<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Redis入门指南：掌握常见数据类型 | 跟着小康学编程</title><meta name="author" content="小康"><meta name="copyright" content="小康"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前言: 每次你在游戏中看到玩家排行榜，或者在音乐应用中浏览热门歌单，有没有想过这个排行榜是如何做到实时更新的？当然，依靠 Redis 即可做到。 在技术领域，我们经常听到「键值存储」 这个词。但在 Redis 的世界里，这只是冰山一角。Redis 的对象，不仅仅是简单的数据，它们是为各种任务量身定制的超能工具。 接下来，让我们走进 Redis 的对象世界，Redis 5.0版本就已经支持了下面的">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis入门指南：掌握常见数据类型">
<meta property="og:url" content="http://example.com/RedisObject/index.html">
<meta property="og:site_name" content="跟着小康学编程">
<meta property="og:description" content="前言: 每次你在游戏中看到玩家排行榜，或者在音乐应用中浏览热门歌单，有没有想过这个排行榜是如何做到实时更新的？当然，依靠 Redis 即可做到。 在技术领域，我们经常听到「键值存储」 这个词。但在 Redis 的世界里，这只是冰山一角。Redis 的对象，不仅仅是简单的数据，它们是为各种任务量身定制的超能工具。 接下来，让我们走进 Redis 的对象世界，Redis 5.0版本就已经支持了下面的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/me.jpg">
<meta property="article:published_time" content="2024-04-30T01:51:28.581Z">
<meta property="article:modified_time" content="2024-05-01T01:09:20.207Z">
<meta property="article:author" content="小康">
<meta property="article:tag" content="Redis基础">
<meta property="article:tag" content="Redis数据类型">
<meta property="article:tag" content="Redis案例">
<meta property="article:tag" content="键值存储">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/me.jpg"><link rel="shortcut icon" href="/img/me.jpg"><link rel="canonical" href="http://example.com/RedisObject/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 小康","link":"链接: ","source":"来源: 跟着小康学编程","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Redis入门指南：掌握常见数据类型',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-05-01 09:09:20'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/iconfont/iconfont.css"><meta name="generator" content="Hexo 7.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/me.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">49</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">18</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/category_img.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="跟着小康学编程"><span class="site-name">跟着小康学编程</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Redis入门指南：掌握常见数据类型</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-04-30T01:51:28.581Z" title="发表于 2024-04-30 09:51:28">2024-04-30</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-05-01T01:09:20.207Z" title="更新于 2024-05-01 09:09:20">2024-05-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93/">NoSQL数据库</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF/">数据库技术</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF/Redis%E6%95%99%E7%A8%8B/">Redis教程</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">18k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>66分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Redis入门指南：掌握常见数据类型"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><strong>前言:</strong></p>
<p>每次你在游戏中看到玩家排行榜，或者在音乐应用中浏览热门歌单，有没有想过这个排行榜是如何做到实时更新的？当然，依靠 Redis 即可做到。</p>
<p>在技术领域，我们经常听到<strong>「键值存储」</strong> 这个词。但在 Redis 的世界里，这只是冰山一角。Redis 的对象，不仅仅是简单的数据，它们是为各种任务量身定制的超能工具。</p>
<p>接下来，让我们走进 Redis 的对象世界，Redis 5.0版本就已经支持了下面的 9 种类型，分别是 ：<strong>字符串对象、列表对象、哈希对象、集合对象、有序集合对象、Bitmaps 对象、HyperLogLog 对象、Geospatial 对象、Stream对象。</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/RedisObject/1.png"></p>
<h1 id="Redis-对象："><a href="#Redis-对象：" class="headerlink" title="Redis 对象："></a><strong>Redis 对象：</strong></h1><p>首先，我们要知道，<strong>Redis</strong> 中保存的数据是以<strong>键值对</strong>的形式存在的。</p>
<h2 id="对象的类型与编码"><a href="#对象的类型与编码" class="headerlink" title="对象的类型与编码"></a><strong>对象的类型与编码</strong></h2><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a><strong>类型</strong></h3><p>在 <strong>Redis</strong> 的大家庭中，每个键值对都有两个重要的“<strong>身份证</strong>”。那就是<strong>键的类型</strong>和<strong>值的类型</strong>。就好像我们的名字和职业，其中名字（键）总是一个字符串，而职业（值）则可以是各种各样：可以是字符串、列表、哈希、集合，甚至是有序集合。这就是我们所说的对象类型，五彩斑斓，各有特色。</p>
<h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a><strong>编码</strong></h3><p>我们都知道超级英雄有着不同的超能力，蜘蛛侠(Spider-Man) 有蜘蛛感应，钢铁侠(Iron Man)有高科技装备。同样，Redis 中的每个对象都有一种称为“编码”的隐藏能力。这是什么呢？</p>
<p>简单说，编码是对象的“内部魔法”。它决定了对象在 Redis 内部的存储方式。就好像手机里的照片可以是 JPEG 或 PNG 格式，Redis 对象也可以有不同的编码格式。</p>
<p>但为什么这很重要呢？因为不同的编码方式意味着不同的存储效率和性能。Redis 非常聪明，它会选择最佳的编码方式，为我们节省空间和提高性能。</p>
<p>我们先来看下 <strong>Redis 对象结构体</strong>声明</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct redisObject &#123;</span><br><span class="line">    unsigned type:4;       # 数据类型，使用了4位来表示</span><br><span class="line">    unsigned encoding:4;   # 编码方式 </span><br><span class="line">    void *ptr;             # 指向底层数据结构的指针</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>

<p><strong>Redis</strong> 中的每个对象都是由 <strong>redisObject</strong> 结构表示，其中的 <strong>encoding</strong> 成员记录了对象所使用的编码，<strong>encoding</strong> 的取值不同，对象内部使用的数据结构也会有所不同。关于 redis 对象的各个数据结构的讲解，本篇不涉及，后续会补上。</p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a><strong>分类</strong></h2><h3 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a><strong>字符串对象</strong></h3><h4 id="基本概念："><a href="#基本概念：" class="headerlink" title="基本概念："></a><strong>基本概念：</strong></h4><p>字符串对象是最简单的类型，也是二进制安全的，意味着可以存储任何形式的数据，例如 JPEG 图片、序列化的对象或者纯文本。</p>
<h4 id="简单图解"><a href="#简单图解" class="headerlink" title="简单图解:"></a><strong>简单图解:</strong></h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/RedisObject/2.png"></p>
<p><strong>value 可以存储任何类型的数据：包括普通字符串，数值类型(int,float) 等</strong></p>
<h4 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a><strong>内部实现</strong></h4><p>Redis 的 String 对象使用一种称为 简单动态字符串<strong>SDS（Simple Dynamic String）</strong> 的结构来存储数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">对象结构体声明:</span><br><span class="line">typedef struct redisObject &#123;</span><br><span class="line">    unsigned type:4;      # 数据类型，使用了4位来表示 </span><br><span class="line">    unsigned encoding:4;  # 编码方式</span><br><span class="line">    void *ptr;            # 指向底层数据结构的指针 </span><br><span class="line">&#125; robj;</span><br><span class="line"></span><br><span class="line">SDS 结构体声明:</span><br><span class="line">struct sdshdr &#123;</span><br><span class="line">    size_t len;           # 记录buf数组中已使用字节的数量。</span><br><span class="line">    size_t alloc;         # 记录buf数组的总容量。</span><br><span class="line">    char buf[];           # 字节数组，用于保存字符串。</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="String-对象的编码"><a href="#String-对象的编码" class="headerlink" title="String 对象的编码"></a><strong>String 对象的编码</strong></h4><p>String 对象的编码有三种: <strong>int、embstr、raw</strong> 。</p>
<ul>
<li>int 编码 ：对象 robj 的 ptr 成员指向的是 long 类型的整数</li>
<li>embstr 和 raw 编码 : 对象 robj 的 ptr 成员指向的是 sdshdr 结构体，值存储在 buf 中。</li>
</ul>
<p><strong>使用限制:</strong> 单个 <strong>String</strong> 对象的值可以存储的数据大小上限为 <strong>512MB</strong></p>
<h4 id="常见命令："><a href="#常见命令：" class="headerlink" title="常见命令："></a><strong>常见命令：</strong></h4><p><strong>基本操作</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SET key value : 设置键的值</span><br><span class="line">GET key       : 获取键的值</span><br><span class="line">DEL key       : 删除键</span><br><span class="line"></span><br><span class="line">&gt; SET username &quot;xiaokang&quot;</span><br><span class="line">OK</span><br><span class="line">&gt; GET username</span><br><span class="line">&quot;xiaokang&quot;</span><br><span class="line">&gt; DEL username</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>

<p><strong>字符串操作</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">APPEND key value           : 向字符串尾部追加</span><br><span class="line">STRLEN key                 : 获取字符串的长度</span><br><span class="line">SETRANGE key offset value  : 覆盖部分内容</span><br><span class="line">GETRANGE key start end     : 获取子字符串</span><br><span class="line"># 上面命令的参数 offset、start、end 都指的是下标(从0开始)</span><br><span class="line"></span><br><span class="line"># 初始键值对 : SET username &quot;xiaokang&quot;</span><br><span class="line">&gt; APPEND username 1998</span><br><span class="line">(integer) 12</span><br><span class="line">&gt; GET username</span><br><span class="line">&quot;xiaokang1998&quot;</span><br><span class="line">&gt; STRLEN username</span><br><span class="line">(integer) 12</span><br><span class="line">&gt; SETRANGE username 0 kang</span><br><span class="line">(integer) 12</span><br><span class="line">&gt; GET username</span><br><span class="line">&quot;kangkang1998&quot;</span><br><span class="line">&gt; GETRANGE username 8 -1  # -1代表的是值的结尾</span><br><span class="line">&quot;1998&quot;</span><br></pre></td></tr></table></figure>

<p><strong>数值操作</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">INCR/DECY key                 : 自增1或自减1</span><br><span class="line">INCRBY/DECRBY key increment   : 自增或自减整数，步长为 increment 必须为整数，可正可负</span><br><span class="line">INCRBYFLOAT key increment     : 自增、自减浮点数，increment 推荐使用浮点数，代表你是在操作浮点数，可正可负</span><br><span class="line"># redis 中没有提供 DECRBYFLOAT，所以要想递减浮点数，increment 为负即可</span><br><span class="line"></span><br><span class="line">&gt; set count 2</span><br><span class="line">OK</span><br><span class="line">&gt; INCR count</span><br><span class="line">(integer) 3</span><br><span class="line">&gt; DECR count</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; INCRBY count 3</span><br><span class="line">(integer) 5</span><br><span class="line">127.0.0.1:6379&gt; DECRBY count 3</span><br><span class="line">(integer) 2</span><br><span class="line">&gt; SET float_count 5.5</span><br><span class="line">OK</span><br><span class="line">&gt; INCRBYFLOAT float_count 2.5</span><br><span class="line">&quot;8&quot;</span><br><span class="line">&gt; INCRBYFLOAT float_count -3.5</span><br><span class="line">&quot;4.5&quot;</span><br></pre></td></tr></table></figure>

<p><strong>批量操作</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MSET key1 value1 key2 value2 : 批量设置键值</span><br><span class="line">MGET key1 key2               : 批量获取键值</span><br><span class="line"></span><br><span class="line">&gt; MSET username xiaokang age 25</span><br><span class="line">OK</span><br><span class="line">&gt; GET username</span><br><span class="line">&quot;xiaokang&quot;</span><br><span class="line">&gt; MGET username age</span><br><span class="line">1) &quot;xiaokang&quot;</span><br><span class="line">2) &quot;25&quot;</span><br></pre></td></tr></table></figure>

<p><strong>条件设置</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SETNX key value                   : 仅当键不存在时设置值,键存在则不会执行任何操作</span><br><span class="line">MSETNX key value [key value ...]  : 批量设置</span><br><span class="line"></span><br><span class="line">&gt; SETNX career programmer</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; MSETNX sex man hobby swim</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>

<p><strong>带有过期时间的设置</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SETEX key seconds value : 为键值设置过期时间</span><br><span class="line"></span><br><span class="line"># 10s 后 redis 会自动删除这个 key</span><br><span class="line">&gt; SETEX username 10 xiaokang</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<h4 id="应用案例"><a href="#应用案例" class="headerlink" title="应用案例"></a><strong>应用案例</strong></h4><p><strong>计数器</strong></p>
<p><strong>描述</strong>: 利用 Redis 追踪某些事物的数量。</p>
<p><strong>具体应用 :</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">1. 文章访问计数：文章的阅读次数</span><br><span class="line">#当某篇文章被访问时，递增该文章的阅读计数器。</span><br><span class="line">INCR article:12345:views</span><br><span class="line">#获取某篇文章的阅读次数。</span><br><span class="line">GET article:12345:views</span><br><span class="line"></span><br><span class="line">2. 社交媒体互动计数 ：点赞数</span><br><span class="line">#当某个帖子被点赞时，递增该帖子的点赞计数器。</span><br><span class="line">INCR post:67890:likes</span><br><span class="line">#检查某个帖子的点赞数。</span><br><span class="line">GET post:67890:likes</span><br><span class="line"></span><br><span class="line">3. 实时统计 ：例如，一个电商网站可以使用 Redis 来跟踪网站上当前的在线用户数量</span><br><span class="line">#当用户在线时，递增在线用户计数器。</span><br><span class="line">INCR website:online_users</span><br><span class="line">#检查当前在线的用户数量。</span><br><span class="line">GET website:online_users</span><br><span class="line"></span><br><span class="line">4. 限流: 例如，你可能想限制一个 API 在一定时间内的调用次数。</span><br><span class="line"># 设置一个 API 的调用次数限制。这里以 60 秒内最多调用 10 次为例。</span><br><span class="line">SETEX api:call_limit:client_ip 60 10</span><br><span class="line"># 当 API 被调用时，递减调用计数器。如果值小于或等于 0，则表示已达到限流。</span><br><span class="line">DECRBY api:call_limit:client_ip 1</span><br><span class="line"># 检查某个 API 的剩余调用次数。</span><br><span class="line">GET api:call_limit:client_ip</span><br></pre></td></tr></table></figure>

<p><strong>分布式锁 : 超越传统的锁机制</strong></p>
<p>想象一下，一个电商网站正在进行一次秒杀活动，该活动只有100个商品库存。当活动开始时，数万用户同时尝试购买这些商品。</p>
<p>如果秒杀系统只部署在一个服务器上，那么我们可以使用<strong>普通锁</strong>来保证库存不会被超卖。但是，现在的大型电商平台的抢购系统都是部署在多个服务器上的，所以单个服务器上的普通锁并不能保证整个系统的<strong>数据一致性</strong>。</p>
<p>这时候，我们需要一个更强大的锁：<strong>分布式锁</strong>， 那什么是分布式锁呢？分布式锁，顾名思义，是能在多个系统或多台机器之间都起到限制访问的“锁”。</p>
<p>在秒杀活动这个场景中，分布式锁确保了即便是数万用户在多个服务器上同时尝试购买，系统也能正确、有序地处理每一个购买请求，确保不会出现超卖的情况。</p>
<p><strong>基本概念：</strong></p>
<p>分布式锁是一种能够在多个计算机、服务器或节点之间确保任何时候只有一个进程在执行的机制。它是在复杂的分布式环境中维持顺序和一致性的关键工具。</p>
<p><strong>实现方式：</strong></p>
<p>使用 Redis 实现分布式锁一般步骤：</p>
<ol>
<li>加锁：SET lock_key unique_id EX expire_time NX</li>
</ol>
<ul>
<li>lock_key    ：分布式锁名</li>
<li>unique_id   ：唯一标识符</li>
<li>EX     ：设置过期时间</li>
<li>NX     ：当 lock_key 不存在时命令才会成功</li>
</ul>
<ol>
<li>操作共享资源</li>
<li>释放锁：通过 Lua 脚本来释放锁，先 GET 判断锁是否归属自己，再 DEL 释放锁</li>
</ol>
<p><strong>Lua 脚本 : 用来保证释放锁操作的原子性</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">判断锁是自己的，才释放</span><br><span class="line">if redis.call(&quot;GET&quot;,KEYS[1]) == ARGV[1]</span><br><span class="line">then</span><br><span class="line">    return redis.call(&quot;DEL&quot;,KEYS[1])</span><br><span class="line">else</span><br><span class="line">    return 0</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p><strong>上面实现方式存在一个问题：分布式锁的过期时间如何确定？</strong></p>
<p>如果客户端预期的操作时间超过锁的过期时间，这该怎么办？锁的超时时间设置过长过短都不好。一个合理的方案就是采用自动续期。</p>
<p><strong>续期具体做法：</strong></p>
<p>加锁时，我们设定一个到期时间，启动一个<strong>「守护线程」</strong> 定时查看锁的状态。如果锁即将到期且任务未完成，我们自动「<strong>续期」</strong> 这个锁，重新设置其到期时间。如果续期失败，为避免并发问题，客户端应立刻停止操作。</p>
<p>然而幸运的是，一些编程语言已经实现了专门的客户端库，如 Java 的 Redisson和 Go 的 redsync，它们提供了简化的分布式锁实现。这些库已内置了自动续期等关键功能，避免开发者手动构建这些逻辑。</p>
<p><strong>注意：</strong></p>
<p>以上只是实现了一个单机版的分布式锁，而 Redis 在实际生产环境中都会采用主从集群 + 哨兵的模式部署，这样当主库异常宕机时，哨兵可以实现「故障自动切换」，把从库提升为主库，继续提供服务，以此保证可用性。</p>
<p><strong>我们来考虑一个问题：当「主从发生切换」时，这个分布锁会依旧安全吗？</strong></p>
<p>关于这个问题我这里不做深入探讨，感兴趣的可以参考这篇文章：<strong>「链接地址在文章末尾」</strong></p>
<p><strong>缓存</strong></p>
<p><strong>描述</strong>：利用 Redis 缓存 MYSQL 等关系型数据库查询结果，从而减少关系型数据库的压力。</p>
<p><strong>具体实现:</strong></p>
<p>当用户请求某个数据时，首先检查 Redis 是否有这个数据。如果有，直接从 Redis 返回，这样可以避免查询数据库。如果 Redis 中没有，那么查询关系型数据库，获取数据后，存入 Redis，并设置一个适当的过期时间。</p>
<p><strong>简单示例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func getUserInfo(rdb *redis.Client, userID string) string &#123;</span><br><span class="line"> // 尝试从 Redis 中获取用户信息</span><br><span class="line"> val, err := rdb.Get(ctx, userID).Result()</span><br><span class="line"> if err == redis.nil&#123;</span><br><span class="line">     userData := queryDatabase(userID) #在这里模拟一个数据库查询</span><br><span class="line">     rdb.Set(ctx, userID, userData, time.Hour)  # 缓存结果1小时 </span><br><span class="line">     return userData</span><br><span class="line"> &#125;</span><br><span class="line"> return val</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func queryDatabase(userID string) string &#123;</span><br><span class="line">    //查询数据库</span><br><span class="line">    // ...</span><br><span class="line">   return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Session 存储</strong></p>
<p><strong>Session 是什么：</strong></p>
<p>每次你在网上购物时，在浏览、选择商品、加入购物车，网站都能“记得”你的选择，这是因为它使用了”Session”。简单来说，Session 是服务器给你的一个小“记忆空间”。</p>
<p>在日常的网页浏览中，每当一个用户的请求到达服务器，例如页面访问、API调用，为了维持用户状态或提供个性化的服务，系统通常需要读取该用户的 session 数据。</p>
<p><strong>具体实现：</strong></p>
<p>当用户登录到一个系统时，后端通常会为该用户生成一个唯一的 session ID 。这个 ID 会被传回给客户端，通常存储在 cookie 中。随后，每次客户端发出请求时，都会携带这个 session ID，允许服务器识别出该用户。</p>
<p>为了应对这种频繁的数据读取需求，我们可以将这个 session ID 和 session 数据分别作为键值存储到 redis 中。session 数据包括 : 用户 ID、用户名等。使用 Redis 来存储 session 数据不仅提供了高速的读取效率，还让用户体验更为流畅。</p>
<p><strong>使用示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 在设置 session 存储时，一般会设置过期时间的。</span><br><span class="line">SET session:userId expired_time &quot;user_data_in_json_or_serialized_format&quot;</span><br><span class="line">GET session:userId</span><br></pre></td></tr></table></figure>

<h3 id="列表对象"><a href="#列表对象" class="headerlink" title="列表对象"></a>列表对象</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>Redis 的列表对象是一个有序的字符串集合，这里的有序指的是<strong>添加元素有先后顺序</strong>的，可以被看作是一个双向链表。在 Redis 中，每个列表可以包含超过 4 亿个元素。</p>
<h4 id="简单图解-1"><a href="#简单图解-1" class="headerlink" title="简单图解"></a>简单图解</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/RedisObject/3.png"></p>
<h4 id="内部实现-1"><a href="#内部实现-1" class="headerlink" title="内部实现"></a>内部实现</h4><ul>
<li><strong>压缩列表</strong> <strong>(Ziplist)</strong>: 当列表对象保存的所有字符串元素的长度都小于 64 字节并且列表对象保存的元素数量小于 512 个，列表对象会使用压缩列表(ziplist)作为其底层实现。</li>
<li><strong>双向链表(Linkedlist)</strong>:不满足上述两个条件之一的, 列表对象会使用双向链表(Linkedlist) 作为其底层实现。</li>
</ul>
<h4 id="常见命令：-1"><a href="#常见命令：-1" class="headerlink" title="常见命令："></a><strong>常见命令：</strong></h4><p><strong>查找元素</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">LRANGE key start stop  : 获取列表指定范围内的元素</span><br><span class="line">LINDEX key index       : 通过索引获取列表中的元素</span><br><span class="line">LLEN key               : 返回列表的长度</span><br><span class="line"></span><br><span class="line"># 查看列表对象的所有元素，-1 代表列表对象的最后一个元素</span><br><span class="line">&gt; LRANGE myList 0 -1</span><br><span class="line">1) &quot;grape&quot;</span><br><span class="line">2) &quot;banana&quot;</span><br><span class="line">3) &quot;apple&quot;</span><br><span class="line">4) &quot;orange&quot;</span><br><span class="line">&gt; LINDEX myList 1</span><br><span class="line">&quot;banana&quot;</span><br><span class="line">&gt; LLEN myList</span><br><span class="line">(integer) 4</span><br></pre></td></tr></table></figure>

<p><strong>插入元素 :</strong></p>
<ul>
<li>普通插入</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">LPUSH key element [element ...]   : 将一个或多个值插入到列表头部</span><br><span class="line">RPUSH key element [element ...]   : 将一个或多个值插入到列表尾部</span><br><span class="line"></span><br><span class="line">&gt; LPUSH myList &quot;apple&quot; &quot;banana&quot;</span><br><span class="line">(integer) 2</span><br><span class="line">&gt; LRANGE myList 0 -1</span><br><span class="line">1) &quot;banana&quot;</span><br><span class="line">2) &quot;apple&quot;</span><br><span class="line">&gt; RPUSH myList &quot;orange&quot; &quot;pear&quot;</span><br><span class="line">(integer) 4</span><br><span class="line">&gt; LRANGE myList 0 -1</span><br><span class="line">1) &quot;banana&quot;</span><br><span class="line">2) &quot;apple&quot;</span><br><span class="line">3) &quot;orange&quot;</span><br><span class="line">4) &quot;pear&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>条件插入</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">LPUSHX key element  [element ...] : 只有当列表存在时，将值插入到列表的头部，如果列表不存在，则什么也不做</span><br><span class="line">RPUSHX key element  [element ...] : 只有当列表存在时，将值插入到列表的尾部，如果列表不存在，则什么也不做</span><br><span class="line"></span><br><span class="line">&gt; LPUSHX myList &quot;grape&quot;</span><br><span class="line">(integer) 5</span><br><span class="line">&gt; LRANGE myList 0 -1</span><br><span class="line">1) &quot;grape&quot;</span><br><span class="line">2) &quot;banana&quot;</span><br><span class="line">3) &quot;apple&quot;</span><br><span class="line">4) &quot;orange&quot;</span><br><span class="line">5) &quot;pear&quot;</span><br><span class="line">&gt; LPUSHX noExistList &quot;peach&quot;</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure>

<p><strong>删除元素:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">LPOP key [count]      : 移除并返回列表的前 count 个元素</span><br><span class="line">RPOP key [count]      : 移除并返回列表的最后 count 个元素</span><br><span class="line">LREM key count value  : 移除列表中与参数 value 相等的 count 个元素</span><br><span class="line"></span><br><span class="line"># 先查看列表中的元素</span><br><span class="line">&gt; LRANGE myList 0 -1</span><br><span class="line">1) &quot;grape&quot;</span><br><span class="line">2) &quot;banana&quot;</span><br><span class="line">3) &quot;apple&quot;</span><br><span class="line">4) &quot;orange&quot;</span><br><span class="line">5) &quot;pear&quot;</span><br><span class="line">&gt; LPOP myList</span><br><span class="line">&quot;grape&quot;</span><br><span class="line">&gt; LRANGE myList 0 -1</span><br><span class="line">1) &quot;banana&quot;</span><br><span class="line">2) &quot;apple&quot;</span><br><span class="line">3) &quot;orange&quot;</span><br><span class="line">4) &quot;pear&quot;</span><br><span class="line">&gt; RPOP myList</span><br><span class="line">&quot;pear&quot;</span><br><span class="line">&gt; LRANGE myList 0 -1</span><br><span class="line">1) &quot;banana&quot;</span><br><span class="line">2) &quot;apple&quot;</span><br><span class="line">3) &quot;orange&quot;</span><br></pre></td></tr></table></figure>

<p><strong>修改元素：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">LSET key index value : 通过索引来设置元素的值</span><br><span class="line">LTRIM key start stop ：裁剪列表</span><br><span class="line"># 先查看列表中的元素</span><br><span class="line">&gt; LRANGE myList 0 -1</span><br><span class="line">1) &quot;grape&quot;</span><br><span class="line">2) &quot;banana&quot;</span><br><span class="line">3) &quot;apple&quot;</span><br><span class="line">4) &quot;orange&quot;</span><br><span class="line">&gt; LSET myList 0 &quot;peach&quot;</span><br><span class="line">OK</span><br><span class="line">&gt; LRANGE myList 0 -1</span><br><span class="line">1) &quot;peach&quot;</span><br><span class="line">2) &quot;banana&quot;</span><br><span class="line">3) &quot;apple&quot;</span><br><span class="line">4) &quot;orange&quot;</span><br><span class="line">&gt; LTRIM myList 0 2</span><br><span class="line">OK</span><br><span class="line">&gt; LRANGE myList 0 -1</span><br><span class="line">1) &quot;peach&quot;</span><br><span class="line">2) &quot;banana&quot;</span><br><span class="line">3) &quot;apple&quot;</span><br></pre></td></tr></table></figure>

<p><strong>元素转移:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RPOPLPUSH source destination: 将 source 列表的最后一个元素弹出，并将该元素添加到 destination 列表的头部，同时返回该元素，如果 destination 列表不存在，redis 会自动创建 destination 列表</span><br><span class="line"></span><br><span class="line">&gt; LRANGE myList 0 -1</span><br><span class="line">1) &quot;banana&quot;</span><br><span class="line">2) &quot;apple&quot;</span><br><span class="line">&gt; RPOPLPUSH myList destList</span><br><span class="line">&quot;apple&quot;</span><br><span class="line">&gt; LRANGE destList 0 -1</span><br><span class="line">1) &quot;apple&quot;</span><br></pre></td></tr></table></figure>

<p>要注意的是列表对象并不存在 LPOPRPUSH 命令，可以通过组合 LPOP 和 RPUSH 命令来实现类似效果。</p>
<p><strong>阻塞操作:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">BLPOP key [key ...] timeout            : 移除并获取列表的第一个元素，或阻塞直到有一个可用</span><br><span class="line">BRPOP key [key ...] timeout            : 移除并获取列表的最后一个元素，或阻塞直到有一个可用</span><br><span class="line">BRPOPLPUSH source destination timeout  : 将 source 列表的最后一个元素弹出，并将该元素添加到 destination 列表的头部，同时返回该元素</span><br><span class="line"></span><br><span class="line"># 先查看列表中的元素</span><br><span class="line">&gt; LRANGE myList 0 -1</span><br><span class="line">1) &quot;peach&quot;</span><br><span class="line">2) &quot;banana&quot;</span><br><span class="line">3) &quot;apple&quot;</span><br><span class="line">4) &quot;orange&quot;</span><br><span class="line">&gt;  LRANGE noExistList 0 -1</span><br><span class="line">(empty array)</span><br><span class="line">&gt; BLPOP myList noExistList 10</span><br><span class="line">1) &quot;myList&quot;</span><br><span class="line">2) &quot;peach&quot;</span><br><span class="line">&gt; LRANGE myList 0 -1</span><br><span class="line">1) &quot;banana&quot;</span><br><span class="line">2) &quot;apple&quot;</span><br><span class="line">3) &quot;orange&quot;</span><br><span class="line">&gt; BRPOP myList noExistList 10</span><br><span class="line">1) &quot;myList&quot;</span><br><span class="line">2) &quot;orange&quot;</span><br><span class="line"># 先查看列表的初识元素</span><br><span class="line">&gt; LRANGE myList 0 -1</span><br><span class="line">1) &quot;banana&quot;</span><br><span class="line">&gt; LRANGE destList 0 -1</span><br><span class="line">1) &quot;apple&quot;</span><br><span class="line">&gt; BRPOPLPUSH myList destList 10</span><br><span class="line">&quot;banana&quot;</span><br><span class="line">&gt; LRANGE myList 0 -1</span><br><span class="line">(empty array)</span><br><span class="line">&gt; LRANGE destList 0 -1</span><br><span class="line">1) &quot;banana&quot;</span><br><span class="line">2) &quot;apple&quot;</span><br></pre></td></tr></table></figure>

<h4 id="应用案例："><a href="#应用案例：" class="headerlink" title="应用案例："></a><strong>应用案例：</strong></h4><p>1.<strong>消息队列</strong> ：</p>
<p>当用户在网上购物下订单后，为了不让他们等待各种后续处理（如检查库存、处理付款、发货），我们直接把订单放入一个消息队列，然后由后台进程从队列中获取并处理订单。</p>
<p><strong>实现步骤：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 生产者（下订单的用户）        </span><br><span class="line">LPUSH orders_queue order_id</span><br><span class="line">2. 消费者服务获取订单（ 消费者：后台处理订单的服务）   </span><br><span class="line">BRPOP orders_queue 5</span><br><span class="line">3. 处理订单 :                   </span><br><span class="line">一旦消费者从队列中获取了一个新订单，它可以开始进行必要的处理，</span><br><span class="line">例如检查库存、处理付款等。</span><br></pre></td></tr></table></figure>

<p>2.<strong>栈和队列</strong> ：</p>
<p><strong>栈：</strong> 想象一个浏览器的返回功能。用户访问了几个页面，你希望能够提供一个[返回] 按钮让用户回到他们之前浏览的页面。</p>
<p><strong>实现步骤：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 添加元素</span><br><span class="line">LPUSH browser_history &quot;page1&quot;</span><br><span class="line">LPUSH browser_history &quot;page2&quot;</span><br><span class="line">LPUSH browser_history &quot;page3&quot;</span><br><span class="line"></span><br><span class="line">2.当用户点击返回按钮时:</span><br><span class="line">LPOP browser_history  # Fetches &quot;page3&quot;, the most recently visited</span><br></pre></td></tr></table></figure>

<p><strong>队列：</strong></p>
<p>当我们在电商网站上浏览商品、点击广告或执行其他操作时，这些行为都可以被捕获为一个”事件”。每个事件通常都包含一些基本信息，如用户ID、商品ID、点击时间、页面URL等。</p>
<p><strong>实现步骤：</strong></p>
<ul>
<li>用户点击事件捕获</li>
</ul>
<p>假设一个用户点击了一个商品。此时，我们可以创建一个 JSON 对象来存储这次点击的详细信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$json = &#123;</span><br><span class="line">    &quot;user_id&quot;: &quot;12345&quot;,</span><br><span class="line">    &quot;product_id&quot;: &quot;98765&quot;,</span><br><span class="line">    &quot;timestamp&quot;: &quot;2023-09-01T12:00:00Z&quot;,</span><br><span class="line">    &quot;page_url&quot;: &quot;/products/98765&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>发送事件到队列</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LPUSH click_events $json</span><br></pre></td></tr></table></figure>

<ul>
<li>消费者进程获取事件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RPOP click_events</span><br></pre></td></tr></table></figure>

<p>当消费者进程从队列中获取事件后，可以进一步解析这个JSON对象，并进行所需的处理，例如更新商品的点击率等，以便将该商品推荐给更多的用户。</p>
<p>3.<strong>历史追踪</strong>：</p>
<p>可以使用 Redis 列表来跟踪最近的历史记录，例如最近访问的网页或其他活动。</p>
<p><strong>以最近访问的网页举例说明:</strong> 在一个网站上，你可能希望追踪用户最近访问了哪些页面。每当用户访问一个新页面时，你可以使用 LPUSH 将这个页面 URL 添加到一个列表中，并使用 LTRIM 确保列表只保存最近 N 次访问。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LPUSH user_recent_pages &quot;/home&quot;</span><br><span class="line">LPUSH user_recent_pages &quot;/product/1&quot;</span><br><span class="line">LTRIM user_recent_pages 0 9  # 保留最近10个访问的页面</span><br></pre></td></tr></table></figure>

<p>使用 Redis 列表来跟踪最近的历史记录能够高效地保存和查询用户的近期活动，从而为用户提供个性化的推荐。</p>
<h3 id="哈希对象"><a href="#哈希对象" class="headerlink" title="哈希对象"></a><strong>哈希对象</strong></h3><h4 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a><strong>基本概念</strong></h4><p>Redis 哈希对象也是一种用于存储键值对集合的数据结构，它允许你将多个键值对存储在一个 Redis 键中。</p>
<p>我们一般会使用 Redis 的 Hash 对象来存储对象信息，比如用户信息，用户的名字、年龄、爱好、电子邮箱、密码等。与使用普通的 key-value 存储方式相比 , 哈希对象的存储方式更为高效和节省空间，特别是当我们要存储大量小对象时。</p>
<h4 id="简单图解："><a href="#简单图解：" class="headerlink" title="简单图解："></a>简单图解：</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/RedisObject/4.png"></p>
<p><strong>简单说明：</strong></p>
<p>假设你有一把大钥匙，这把钥匙可以打开一个特定的箱子。这箱子里面有很多物品，每个物品都有标签来描述它。</p>
<ul>
<li>大钥匙 就是我们的 key</li>
<li>箱子 就代表一个 哈希对象</li>
<li>箱子里的物品与其标签 就是 field-value 键值对</li>
</ul>
<h4 id="内部实现-2"><a href="#内部实现-2" class="headerlink" title="内部实现"></a><strong>内部实现</strong></h4><ul>
<li><strong>压缩列表(ziplist)</strong> ：当哈希对象保存的所有键值对的键和值的字符串长度都小于64字节并且哈希对象保存的键值对的数量小于 512 个，哈希对象会采用压缩列表作为其底层实现。</li>
<li><strong>字典(基于哈希表实现)</strong> ：当不能满足上述条件之一时，哈希对象则会采用字典作为其底层实现。</li>
</ul>
<h4 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a><strong>常见命令</strong></h4><p><strong>设置值</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HSET key field value [field value ...] : 设置哈希的 Field-Value 对,可以设置多个</span><br><span class="line">HSETNX key field value                 : 只有在字段 field 不存在时，才设置对应的 value 值，否则什么也不做。</span><br><span class="line"></span><br><span class="line">&gt; HSET userInfo username xiaokang age 25 hobby swim</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure>

<p><strong>获取值</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">HGET key field              : 获取哈希指定字段的值</span><br><span class="line">HMGET key field [field ...] : 获取哈希多个字段的值 # 批量获取</span><br><span class="line">HGETALL key                 : 获取哈希表中的所有字段和值</span><br><span class="line">HKEYS key                   : 获取哈希中所有的字段名(field)</span><br><span class="line">HVALS key                   : 获取哈希中所有的字段值(value)</span><br><span class="line"></span><br><span class="line">&gt; HGET userInfo username</span><br><span class="line">&quot;xiaokang&quot;</span><br><span class="line">&gt; HMGET userInfo &quot;username&quot; &quot;age&quot;</span><br><span class="line">1) &quot;xiaokang&quot;</span><br><span class="line">2) &quot;25&quot;</span><br><span class="line">&gt; HGETALL userInfo</span><br><span class="line">1) &quot;username&quot;</span><br><span class="line">2) &quot;xiaokang&quot;</span><br><span class="line">3) &quot;age&quot;</span><br><span class="line">4) &quot;25&quot;</span><br><span class="line">5) &quot;hobby&quot;</span><br><span class="line">6) &quot;swim&quot;</span><br><span class="line">&gt; HKEYS userInfo</span><br><span class="line">1) &quot;username&quot;</span><br><span class="line">2) &quot;age&quot;</span><br><span class="line">3) &quot;hobby&quot;</span><br><span class="line">&gt; HVALS userInfo</span><br><span class="line">1) &quot;xiaokang&quot;</span><br><span class="line">2) &quot;25&quot;</span><br><span class="line">3) &quot;swim&quot;</span><br></pre></td></tr></table></figure>

<p><strong>自增操作</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">HINCRBY key field increment       : 为哈希字段的整数值加上增量 # increment 可正可负</span><br><span class="line">HINCRBYFLOAT key field increment  : 为哈希字段的浮点数值加上增量 # increment 可正可负</span><br><span class="line"></span><br><span class="line">&gt; HGET userInfo age</span><br><span class="line">&quot;25&quot;</span><br><span class="line">&gt; HINCRBY userInfo age 1</span><br><span class="line">(integer) 26</span><br><span class="line">&gt; HGET userInfo age</span><br><span class="line">&quot;26&quot;</span><br><span class="line"></span><br><span class="line"># HINCRBYFLOAT 命令类似，increment 既可以是整数也可以是浮点数，可正可负</span><br></pre></td></tr></table></figure>

<p><strong>删除操作</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">HDEL key field [field ...] : 删除一个或多个哈希表字段</span><br><span class="line"></span><br><span class="line"># 先查看 hash 字段的所有字段和值</span><br><span class="line">&gt; HGETALL userInfo</span><br><span class="line">1) &quot;username&quot;</span><br><span class="line">2) &quot;xiaokang&quot;</span><br><span class="line">3) &quot;age&quot;</span><br><span class="line">4) &quot;25&quot;</span><br><span class="line">5) &quot;hobby&quot;</span><br><span class="line">6) &quot;swim&quot;</span><br><span class="line">&gt; HDEL userInfo &quot;hobby&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; HGETALL userInfo</span><br><span class="line">1) &quot;username&quot;</span><br><span class="line">2) &quot;xiaokang&quot;</span><br><span class="line">3) &quot;age&quot;</span><br><span class="line">4) &quot;25&quot;</span><br></pre></td></tr></table></figure>

<p><strong>其他操作</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">HEXISTS key field     : 检查哈希对象中是否存在给定的字段</span><br><span class="line">HLEN key              : 获取哈希中字段的数量</span><br><span class="line">HSTRLEN key field     : 获取哈希字段的字符串长度</span><br><span class="line"></span><br><span class="line"># 先查看哈希的所有字段和值</span><br><span class="line">&gt; HGETALL userInfo</span><br><span class="line">1) &quot;username&quot;</span><br><span class="line">2) &quot;xiaokang&quot;</span><br><span class="line">3) &quot;age&quot;</span><br><span class="line">4) &quot;25&quot;</span><br><span class="line">&gt; HLEN userInfo</span><br><span class="line">(integer) 2</span><br><span class="line">&gt; HSTRLEN userInfo &quot;username&quot;</span><br><span class="line">(integer) 8</span><br></pre></td></tr></table></figure>

<p><strong>注意事项</strong></p>
<ul>
<li><strong>小哈希优化：</strong> Redis 对于哈希对象的内存布局进行了优化。小哈希（即哈希对象字段数量很少且字段值大小较小）的内存使用会更加高效。</li>
<li><strong>避免大量删除：</strong> 使用 HDEL 一次删除大量字段可能会影响性能，建议分批进行。</li>
<li><strong>使用哈希而非多个键：</strong> 当需要存储有关特定对象的多个相关字段时，使用单个哈希键比使用多个独立的 Redis 键更为高效。</li>
</ul>
<h4 id="应用案例-1"><a href="#应用案例-1" class="headerlink" title="应用案例"></a><strong>应用案例</strong></h4><ul>
<li><strong>对象存储 :</strong></li>
</ul>
<p>主要是指将某种实体或数据（如用户信息）持久性地保存在 Redis 中，如 ：用户的用户名、邮箱、密码等信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">保存用户信息：</span><br><span class="line">HSET user:1234 name &quot;John Doe&quot; email &quot;john.doe@example.com&quot; age 30</span><br><span class="line">获取用户的邮箱：</span><br><span class="line">HGET user:1234 email</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>对象缓存：</strong></li>
</ul>
<p>这是指当数据原本存储在其他存储系统（如关系型数据库）中，但由于频繁访问或读取，我们决定在 Redis 中缓存该数据的一份副本，以减少对原始数据源的访问压力并提高读取速度。</p>
<p><strong>场景描述：</strong></p>
<p>假设你有一个博客网站，用户可以阅读和评论各种博客文章。每当用户点击一个博客标题，系统都会从关系型数据库中获取该文章的详细内容进行显示。但是，由于某些热门文章被大量用户频繁访问，直接从数据库中获取文章可能会对数据库造成很大的压力，从而影响网站的性能。</p>
<p><strong>具体实现：</strong></p>
<p><strong>伪代码展示 :</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">    &quot;github.com/go-redis/redis/v8&quot;</span><br><span class="line">    &quot;context&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var ctx = context.Background()</span><br><span class="line">options := &amp;redis.Options&#123;</span><br><span class="line">    Addr: &quot;localhost:6379&quot;,  // Redis服务器地址</span><br><span class="line">&#125;</span><br><span class="line">// 初始化Redis客户端：</span><br><span class="line">rdb := redis.NewClient(options)</span><br><span class="line"></span><br><span class="line">// 检查缓存：当用户请求一篇文章时，首先检查Redis缓存中是否存在该文章的数据。</span><br><span class="line">exists, err := rdb.HExists(ctx, &quot;article:ID&quot;, &quot;title&quot;).Result()</span><br><span class="line">if err != nil &#123;</span><br><span class="line">    // Handle error</span><br><span class="line">&#125;</span><br><span class="line">//从缓存中获取数据：如果文章存在于Redis中，则直接从Redis的哈希对象中获取所有相关字段，并显示给用户。</span><br><span class="line">if exists &#123;</span><br><span class="line">    articleData, err := rdb.HGetAll(ctx, &quot;article:ID&quot;).Result()</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        // Handle error</span><br><span class="line">    &#125;</span><br><span class="line">    display(articleData)</span><br><span class="line">&#125;</span><br><span class="line">//从数据库中获取数据：如果文章不在Redis缓存中，则从关系型数据库中获取数据保存到 Redis 缓存中，并且设置超时。</span><br><span class="line">if !exists &#123;</span><br><span class="line">    articleData := Database.fetchArticleByID(&quot;article:ID&quot;)</span><br><span class="line">    _, err := rdb.HMSet(ctx, &quot;article:ID&quot;, map[string]interface&#123;&#125;&#123;</span><br><span class="line">        &quot;title&quot;:   articleData.Title,</span><br><span class="line">        &quot;author&quot;:  articleData.Author,</span><br><span class="line">        &quot;content&quot;: articleData.Content,</span><br><span class="line">    &#125;).Result()</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        // Handle error</span><br><span class="line">    &#125;</span><br><span class="line">    rdb.Expire(ctx, &quot;article:ID&quot;, time.Hour) // 设置1小时的过期时间</span><br><span class="line">    // 显示给用户</span><br><span class="line">    display(articleData)</span><br><span class="line">&#125;</span><br><span class="line">//显示给用户的函数</span><br><span class="line">func display(articleData map[string]string) &#123;</span><br><span class="line">    // ... 你的显示逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>实时统计 ：</strong></li>
</ul>
<p>为了跟踪网站的实时活动，我们可以使用哈希来保存当前在线用户、页面浏览量和API 请求次数等。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">增加在线用户数：</span><br><span class="line">HINCRBY website:stats online_users 1</span><br><span class="line">减少在线用户数：</span><br><span class="line">HINCRBY website:stats online_users -1</span><br><span class="line">记录每个页面的访问次数：</span><br><span class="line">HINCRBY pageviews:20230901 &quot;/home&quot; 1</span><br></pre></td></tr></table></figure>

<h3 id="集合对象"><a href="#集合对象" class="headerlink" title="集合对象"></a>集合对象</h3><h4 id="基本概念：-1"><a href="#基本概念：-1" class="headerlink" title="基本概念："></a>基本概念：</h4><p>集合对象（Set）是一种存储多个唯一元素的无序集合数据结构，它提供了丰富的操作使得集合对象成为非常强大和灵活的工具。集合对象特别适用于存储不允许重复的数据项，例如标签、社交网络中的好友列表或者任何需要快速判断某个元素是否存在的场景。</p>
<h4 id="简单图解-2"><a href="#简单图解-2" class="headerlink" title="简单图解"></a>简单图解</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/RedisObject/5.png"></p>
<h4 id="内部实现-3"><a href="#内部实现-3" class="headerlink" title="内部实现"></a>内部实现</h4><ul>
<li><strong>整数集合（intset） :</strong> 当集合对象保存的所有元素都是整数或者集合对象保存的整数个数不超过512个时，集合对象采用 intset 作为其底层实现。</li>
<li><strong>字典（基于哈希表实现）：</strong> 不满足上面的两个条件之一，则采用字典作为其底层实现。</li>
</ul>
<h4 id="常见命令-1"><a href="#常见命令-1" class="headerlink" title="常见命令"></a>常见命令</h4><p><strong>基本操作:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">SADD key member [member ...] ：向集合添加一个或多个成员</span><br><span class="line">SMEMBERS key                 ：获取集合中的所有成员</span><br><span class="line">SCARD key                    ：获取集合的成员数量</span><br><span class="line">SISMEMBER key member         ：判断 member 元素是否是集合 key 的成员</span><br><span class="line">SREM key member [member ...] ：移除集合中的一个或多个成员</span><br><span class="line"></span><br><span class="line">&gt; SADD mySet &quot;apple&quot; &quot;banana&quot; &quot;peach&quot;</span><br><span class="line">(integer) 3</span><br><span class="line">&gt; SMEMBERS mySet</span><br><span class="line">1) &quot;peach&quot;</span><br><span class="line">2) &quot;banana&quot;</span><br><span class="line">3) &quot;apple&quot;</span><br><span class="line">&gt; SCARD mySet</span><br><span class="line">(integer) 3</span><br><span class="line">&gt; SISMEMBER mySet &quot;peach&quot;   # 成员存在返回 1</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; SISMEMBER mySet &quot;pear&quot;    # 成员不存在返回 0</span><br><span class="line">(integer) 0</span><br><span class="line">&gt; SREM mySet &quot;peach&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; SMEMBERS mySet</span><br><span class="line">1) &quot;banana&quot;</span><br><span class="line">2) &quot;apple&quot;</span><br></pre></td></tr></table></figure>

<p><strong>集合运算:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">SINTER key [key ...]                  ：返回所有给定集合的交集</span><br><span class="line">SINTERSTORE destination key [key ...] ：交集存储在 destination 集合中</span><br><span class="line">SUNION key [key ...]                  ：返回所有给定集合的并集</span><br><span class="line">SUNIONSTORE destination key [key ...] ：并集存储在 destination 集合中</span><br><span class="line">SDIFF key [key ...]                   ：返回第一个集合与其他集合之间的差集</span><br><span class="line">SDIFFSTORE destination key [key ...]  ：差集存储在 destination 集合中</span><br><span class="line"></span><br><span class="line">&gt; SMEMBERS mySet</span><br><span class="line">1) &quot;pear&quot;</span><br><span class="line">2) &quot;banana&quot;</span><br><span class="line">3) &quot;apple&quot;</span><br><span class="line">&gt; SMEMBERS yourSet</span><br><span class="line">1) &quot;peach&quot;</span><br><span class="line">2) &quot;banana&quot;</span><br><span class="line">3) &quot;apple&quot;</span><br><span class="line">&gt; SINTER mySet yourSet</span><br><span class="line">1) &quot;banana&quot;</span><br><span class="line">2) &quot;apple&quot;</span><br><span class="line">&gt; SINTERSTORE resultSet mySet yourSet</span><br><span class="line">(integer) 2</span><br><span class="line">&gt; SMEMBERS resultSet</span><br><span class="line">1) &quot;banana&quot;</span><br><span class="line">2) &quot;apple&quot;</span><br><span class="line"># 并集我这里不提了，和交集操作类似</span><br><span class="line">&gt; SDIFF mySet yourSet</span><br><span class="line">1) &quot;pear&quot;</span><br><span class="line">&gt; SDIFFSTORE result mySet yourSet</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; SMEMBERS result</span><br><span class="line">1) &quot;pear&quot;</span><br></pre></td></tr></table></figure>

<p><strong>随机操作：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">SRANDMEMBER key [count]               ：随机返回集合中的一个或多个成员</span><br><span class="line">SPOP key [count]                      ：随机移除并返回集合中的一个或多个成员</span><br><span class="line"></span><br><span class="line">&gt; SMEMBERS mySet</span><br><span class="line">1) &quot;pear&quot;</span><br><span class="line">2) &quot;banana&quot;</span><br><span class="line">3) &quot;apple&quot;</span><br><span class="line"># 可以看到每次返回的成员都不一样</span><br><span class="line">&gt; SRANDMEMBER mySet</span><br><span class="line">&quot;pear&quot;</span><br><span class="line">&gt; SRANDMEMBER mySet</span><br><span class="line">&quot;apple&quot;</span><br><span class="line">&gt; SPOP mySet</span><br><span class="line">&quot;pear&quot;</span><br><span class="line">&gt; SMEMBERS mySet</span><br><span class="line">1) &quot;banana&quot;</span><br><span class="line">2) &quot;apple&quot;</span><br></pre></td></tr></table></figure>

<p><strong>其他操作:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">SMOVE source destination member       : 将 member 成员从 source 集合移动到 destination 集合</span><br><span class="line"></span><br><span class="line">&gt; SMEMBERS mySet</span><br><span class="line">1) &quot;pear&quot;</span><br><span class="line">2) &quot;banana&quot;</span><br><span class="line">3) &quot;apple&quot;</span><br><span class="line">&gt; SMEMBERS yourSet</span><br><span class="line">1) &quot;peach&quot;</span><br><span class="line">2) &quot;banana&quot;</span><br><span class="line">3) &quot;apple&quot;</span><br><span class="line">&gt; SMOVE mySet yourSet &quot;pear&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; SMEMBERS mySet</span><br><span class="line">1) &quot;banana&quot;</span><br><span class="line">2) &quot;apple&quot;</span><br><span class="line">&gt; SMEMBERS yourSet</span><br><span class="line">1) &quot;peach&quot;</span><br><span class="line">2) &quot;pear&quot;</span><br><span class="line">3) &quot;banana&quot;</span><br><span class="line">4) &quot;apple&quot;</span><br></pre></td></tr></table></figure>

<h4 id="应用案例-2"><a href="#应用案例-2" class="headerlink" title="应用案例"></a><strong>应用案例</strong></h4><ul>
<li><strong>社交网站的好友与关注系统</strong></li>
</ul>
<p>利用集合来存储每个用户的朋友或关注者列表。例如，我们可以为每个用户维护一个集合，其中包含他们的所有朋友或关注者。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SADD &quot;alice:friends&quot; &quot;bob&quot;     # Alice 关注了 Bob</span><br><span class="line">SADD &quot;bob:friends&quot; &quot;charlie&quot;   # Bob 关注了 Charlie</span><br><span class="line">SISMEMBER &quot;alice:friends&quot;, &quot;bob&quot; # 判断 Bob 是否是 Alice 的朋友</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>标签系统</strong></li>
</ul>
<p>可以为内容（如文章、图片等）添加标签，并利用集合存储这些标签。</p>
<p><strong>场景描述：</strong>假设你正在运行一个博客平台，你希望为每篇文章添加一组标签，使用户可以更容易地根据主题或兴趣查找相关文章。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1.为文章添加标签：</span><br><span class="line"># 当你发布文章&quot;Redis入门指南&quot;，其ID为1001，你为它添加了标签&quot;technology&quot;, &quot;tutorial&quot;,和&quot;redis&quot;。</span><br><span class="line">SADD tag:technology 1001</span><br><span class="line">SADD tag:tutorial 1001</span><br><span class="line">SADD tag:redis 1001</span><br><span class="line"></span><br><span class="line">2.查找具有特定标签的文章</span><br><span class="line"># 如果用户想要查看所有与&quot;redis&quot;相关的文章：</span><br><span class="line">SMEMBERS tag:redis   # 输出 1001 ：这表示文章ID为1001的文章带有&quot;redis&quot;标签。</span><br><span class="line"></span><br><span class="line">3.获取文章的所有标签</span><br><span class="line"># 每当你需要查看某篇文章的标签，你可以为其创建一个集合。以文章ID为1001为例：</span><br><span class="line">SADD article:1001:tags &quot;technology&quot;</span><br><span class="line">SADD article:1001:tags &quot;tutorial&quot;</span><br><span class="line">SADD article:1001:tags &quot;redis&quot;</span><br><span class="line"></span><br><span class="line"># 要查看文章1001的所有标签：</span><br><span class="line">SMEMBERS article:1001:tags</span><br><span class="line"># 输出：</span><br><span class="line">1) &quot;technology&quot;</span><br><span class="line">2) &quot;tutorial&quot;</span><br><span class="line">3) &quot;redis&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>唯一计数</strong></li>
</ul>
<p>例如，记录网站的独立访客数。集合可以帮助我们做到这一点，因为它们只存储唯一的元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.存储当天登录的所有用户ID：</span><br><span class="line">SADD visitors:2023-09-20 user12345</span><br><span class="line">SADD visitors:2023-09-20 user67890</span><br><span class="line">2.获得当天登录的独立用户数</span><br><span class="line">SCARD visitors:2023-09-20</span><br></pre></td></tr></table></figure>

<h3 id="有序集合对象"><a href="#有序集合对象" class="headerlink" title="有序集合对象"></a>有序集合对象</h3><h4 id="基本概念：-2"><a href="#基本概念：-2" class="headerlink" title="基本概念："></a>基本概念：</h4><p>Redis 有序集合（Sorted Set）对象是一种存储非重复元素集合的数据结构，每个元素都关联一个双精度浮点数分数（score），用于维护元素之间的排序顺序。有序集合支持高效的元素插入和删除操作，同时保持元素按分数排序，使其非常适合于需要按照排序顺序访问元素的场景，如排行榜、带权重的任务队列等。</p>
<h4 id="简单图解-3"><a href="#简单图解-3" class="headerlink" title="简单图解:"></a>简单图解:</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/RedisObject/6.png"></p>
<h4 id="内部实现-4"><a href="#内部实现-4" class="headerlink" title="内部实现"></a>内部实现</h4><ul>
<li>压缩列表（ziplist）:  当有序集合保存的元素数量小于 128 个 并且有序集合保存的所有元素成员的长度小于 64 字节，有序集合对象会采用 ziplist 作为其底层实现。</li>
<li>跳表(skiplist )：不满足以上2个条件之一的采用 skiplist 作为其底层实现。</li>
</ul>
<h4 id="常见命令-2"><a href="#常见命令-2" class="headerlink" title="常见命令"></a>常见命令</h4><p><strong>添加与更新成员</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ZADD key score member [score member ...] : 添加一个或多个成员到有序集合，或者更新已存在成员的分数</span><br><span class="line">ZINCRBY key increment member             : 增加有序集合中指定成员的分数</span><br><span class="line"></span><br><span class="line">&gt; ZADD myZSet 10 member1 20 member2</span><br><span class="line">(integer) 2</span><br><span class="line"># 获取有序集合中的所有成员及其分数</span><br><span class="line">&gt; ZRANGE myZSet 0 -1 WITHSCORES</span><br><span class="line">1) &quot;member1&quot;</span><br><span class="line">2) &quot;10&quot;</span><br><span class="line">3) &quot;member2&quot;</span><br><span class="line">4) &quot;20&quot;</span><br><span class="line">&gt; ZINCRBY myZSet 5 &quot;member1&quot;</span><br><span class="line">&quot;15&quot;</span><br><span class="line">&gt; ZRANGE myZSet 0 -1 WITHSCORES</span><br><span class="line">1) &quot;member1&quot;</span><br><span class="line">2) &quot;15&quot;</span><br><span class="line">3) &quot;member2&quot;</span><br><span class="line">4) &quot;20&quot;</span><br></pre></td></tr></table></figure>

<p><strong>查询操作</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">ZCARD key            : 获取有序集合的成员数量</span><br><span class="line">ZSCORE key member    : 获取指定成员的分数值</span><br><span class="line">ZRANK key member     : 返回有序集合中指定成员的排名，排名依次是 0，1，2 ...</span><br><span class="line">ZREVRANK key member  : 返回有序集合中指定成员的排名，成员按分数值递减排列</span><br><span class="line">&gt; ZCARD myZSet</span><br><span class="line">(integer) 2</span><br><span class="line">&gt; ZSCORE myZSet &quot;member2&quot;</span><br><span class="line">&quot;20&quot;</span><br><span class="line">&gt; ZRANK myZSet &quot;member1&quot;</span><br><span class="line">(integer) 0</span><br><span class="line">&gt; ZRANK myZSet &quot;member2&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; ZREVRANK myZSet &quot;member2&quot;</span><br><span class="line">(integer) 0</span><br><span class="line">&gt; ZREVRANK myZSet &quot;member1&quot;</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">ZRANGE key min max [WITHSCORES]        : 返回有序集中指定区间内的成员  # min 和 max 是要获取的排名范围（排名可以理解为索引，从0开始，其中0是分数最低的成员），可选的 [WITHSCORES] 参数表示除了返回成员名外，还要返回它们的分数</span><br><span class="line">ZREVRANGE key start stop [WITHSCORES]  : 返回有序集中指定区间内的成员，成员按分数递减排列</span><br><span class="line"></span><br><span class="line">&gt; ZRANGE myZSet 0 1</span><br><span class="line">1) &quot;member1&quot;</span><br><span class="line">2) &quot;member2&quot;</span><br><span class="line">&gt; ZRANGE myZSet 0 1 WITHSCORES</span><br><span class="line">1) &quot;member1&quot;</span><br><span class="line">2) &quot;15&quot;</span><br><span class="line">3) &quot;member2&quot;</span><br><span class="line">4) &quot;20&quot;</span><br><span class="line">&gt; ZREVRANGE myZSet 0 1</span><br><span class="line">1) &quot;member2&quot;</span><br><span class="line">2) &quot;member1&quot;</span><br><span class="line">&gt; ZREVRANGE myZSet 0 1 WITHSCORES</span><br><span class="line">1) &quot;member2&quot;</span><br><span class="line">2) &quot;20&quot;</span><br><span class="line">3) &quot;member1&quot;</span><br><span class="line">4) &quot;15&quot;</span><br><span class="line"></span><br><span class="line">ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]                                        : 获取分数在指定区间的所有成员，建议：max &gt;= min</span><br><span class="line">ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]: 获取分数在指定区间的所有成员，成员按分数递减排列; 建议：max &gt;= min</span><br><span class="line">#[LIMIT offset count]  这是一个限制返回的成员数量的可选项。其中，offset 是开始返回的起始位置（基于0的索引），count 是返回的成员总数。例如，LIMIT 1 3 会返回从下标为1开始的3个成员</span><br><span class="line"></span><br><span class="line">&gt; ZRANGEBYSCORE myZSet 16 22</span><br><span class="line">1) &quot;member2&quot;</span><br><span class="line">&gt; ZRANGEBYSCORE myZSet 16 22 WITHSCORES</span><br><span class="line">1) &quot;member2&quot;</span><br><span class="line">2) &quot;20&quot;</span><br><span class="line">&gt; ZRANGEBYSCORE myZSet 15 22 WITHSCORES LIMIT 0 2</span><br><span class="line">1) &quot;member1&quot;</span><br><span class="line">2) &quot;15&quot;</span><br><span class="line">3) &quot;member2&quot;</span><br><span class="line">4) &quot;20&quot;</span><br><span class="line">&gt; ZREVRANGEBYSCORE myZSet 22 15 WITHSCORES</span><br><span class="line">1) &quot;member2&quot;</span><br><span class="line">2) &quot;20&quot;</span><br><span class="line">3) &quot;member1&quot;</span><br><span class="line">4) &quot;15&quot;</span><br><span class="line"></span><br><span class="line">ZCOUNT key min max: 计算在有序集合中指定区间分数的成员数</span><br><span class="line">ZLEXCOUNT key min max: 用于计算基于成员名称的字典序位于指定区间内的成员数量 # 对于 min和 max，要使用方括号 [ 或 ( 来指示范围的边界是否包含在计数中。方括号 [ 表示该值是包含的，而小括号 ( 表示该值是不包含的。</span><br><span class="line"></span><br><span class="line">&gt; ZCOUNT myZSet 15 20</span><br><span class="line">(integer) 2</span><br><span class="line">&gt; ZLEXCOUNT myZSet [a [z</span><br><span class="line">(integer) 2</span><br><span class="line">&gt; ZLEXCOUNT myZSet [a [b</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">ZSCAN key cursor [MATCH pattern] [COUNT count]: 迭代Redis的有序集合（ZSET）的元素，包括它的成员和分数。是一种渐进地遍历有序集的方法，而不是一次返回所有结果，这对于大型数据集尤为有用，因为它不会因为要返回大量的结果而阻塞服务器。</span><br><span class="line"># cursor: 用于迭代的游标。初次调用时，通常设置为&quot;0&quot;，之后的调用将使用上次返回的游标值。</span><br><span class="line">MATCH pattern (可选): 一个可选的匹配模式，用于筛选具有特定模式的元素。</span><br><span class="line">COUNT count (可选): 提示服务器每次迭代应返回多少元素。实际数目可能会稍多或稍少。</span><br><span class="line"></span><br><span class="line">&gt; ZSCAN myZSet  0</span><br><span class="line">1) &quot;0&quot;</span><br><span class="line">2) 1) &quot;member1&quot;</span><br><span class="line">   2) &quot;15&quot;</span><br><span class="line">   3) &quot;member2&quot;</span><br><span class="line">   4) &quot;20&quot;</span><br><span class="line">&gt; ZSCAN myZSet  0 MATCH  mem*</span><br><span class="line">1) &quot;0&quot;</span><br><span class="line">2) 1) &quot;member1&quot;</span><br><span class="line">   2) &quot;15&quot;</span><br><span class="line">   3) &quot;member2&quot;</span><br><span class="line">   4) &quot;20&quot;</span><br><span class="line">&gt; ZSCAN myZSet  0 COUNT 1</span><br><span class="line">1) &quot;0&quot;</span><br><span class="line">2) 1) &quot;member1&quot;</span><br><span class="line">   2) &quot;15&quot;</span><br><span class="line">   3) &quot;member2&quot;</span><br><span class="line">   4) &quot;20&quot;</span><br></pre></td></tr></table></figure>

<p><strong>删除操作</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">ZREM key member [member ...]    : 移除有序集合中的一个或多个成员</span><br><span class="line"># 先查看有序集合中的成员及分数</span><br><span class="line">&gt; ZRANGE myZSet 0 -1 WITHSCORES</span><br><span class="line">1) &quot;member1&quot;</span><br><span class="line">2) &quot;15&quot;</span><br><span class="line">3) &quot;member2&quot;</span><br><span class="line">4) &quot;20&quot;</span><br><span class="line">&gt; ZREM myZSet &quot;member1&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; ZRANGE myZSet 0 -1 WITHSCORES</span><br><span class="line">1) &quot;member2&quot;</span><br><span class="line">2) &quot;20&quot;</span><br><span class="line"></span><br><span class="line">ZPOPMAX key [count]             : 移除并返回有序集合中的最大的一些成员</span><br><span class="line">&gt; ZADD myZSet 15 &quot;member1&quot; 30 &quot;member3&quot; 55 &quot;member5&quot; 40 &quot;member4&quot;</span><br><span class="line">(integer) 4</span><br><span class="line">&gt; ZRANGE myZSet 0 -1 WITHSCORES</span><br><span class="line"> 1) &quot;member1&quot;</span><br><span class="line"> 2) &quot;15&quot;</span><br><span class="line"> 3) &quot;member2&quot;</span><br><span class="line"> 4) &quot;20&quot;</span><br><span class="line"> 5) &quot;member3&quot;</span><br><span class="line"> 6) &quot;30&quot;</span><br><span class="line"> 7) &quot;member4&quot;</span><br><span class="line"> 8) &quot;40&quot;</span><br><span class="line"> 9) &quot;member5&quot;</span><br><span class="line">10) &quot;55&quot;</span><br><span class="line">&gt; ZPOPMAX myZSet 2</span><br><span class="line">1) &quot;member5&quot;</span><br><span class="line">2) &quot;55&quot;</span><br><span class="line">3) &quot;member4&quot;</span><br><span class="line">4) &quot;40&quot;</span><br><span class="line">&gt; ZRANGE myZSet 0 -1 WITHSCORES</span><br><span class="line">1) &quot;member1&quot;</span><br><span class="line">2) &quot;15&quot;</span><br><span class="line">3) &quot;member2&quot;</span><br><span class="line">4) &quot;20&quot;</span><br><span class="line">5) &quot;member3&quot;</span><br><span class="line">6) &quot;30&quot;</span><br><span class="line"></span><br><span class="line">ZPOPMIN key [count]             : 移除并返回有序集合中的最小的一些成员</span><br><span class="line"># ZPOPMIN 我这里就不举例了，和 ZPOPMAX 类似</span><br><span class="line"></span><br><span class="line">ZREMRANGEBYRANK key start stop  : 移除有序集合中给定的排名区间的所有成员</span><br><span class="line">ZREMRANGEBYSCORE key min max    : 移除有序集合中给定的分数区间的所有成员</span><br><span class="line">ZREMRANGEBYLEX key min max      : 移除有序集合中给定的成员名字典区间的所有成员</span><br><span class="line"></span><br><span class="line">&gt; ZREMRANGEBYSCORE myZSet 20 30</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; ZRANGE myZSet 0 -1 WITHSCORES</span><br><span class="line">(empty array)</span><br><span class="line">&gt;  ZADD myZSet 15 &quot;member1&quot; 30 &quot;member3&quot; 55 &quot;member5&quot; 40 &quot;member4&quot;</span><br><span class="line">(integer) 4</span><br><span class="line">&gt; ZRANGE myZSet 0 -1 WITHSCORES</span><br><span class="line">1) &quot;member1&quot;</span><br><span class="line">2) &quot;15&quot;</span><br><span class="line">3) &quot;member3&quot;</span><br><span class="line">4) &quot;30&quot;</span><br><span class="line">5) &quot;member4&quot;</span><br><span class="line">6) &quot;40&quot;</span><br><span class="line">7) &quot;member5&quot;</span><br><span class="line">8) &quot;55&quot;</span><br><span class="line">&gt; ZREMRANGEBYLEX myZSet [&quot;member1&quot; [&quot;member4&quot;</span><br><span class="line">(integer) 3</span><br><span class="line">&gt; ZRANGE myZSet 0 -1 WITHSCORES</span><br><span class="line">1) &quot;member5&quot;</span><br><span class="line">2) &quot;55&quot;</span><br></pre></td></tr></table></figure>

<p><strong>集合操作</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">ZUNIONSTORE destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]    : 计算给定的一个或多个有序集的并集，并存储在新的 destination 中</span><br><span class="line">ZINTERSTORE destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]    : 计算给定的一个或多个有序集的交集，并存储在新的 destination 中</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line">destination   - 新的有序集合的名字，用于存放结果。</span><br><span class="line">numkeys       - 指定将要合并的有序集合的数量。</span><br><span class="line">key [key ...] - 需要合并的有序集合的名字。</span><br><span class="line">WEIGHTS       - 可选参数，用于为每一个输入的有序集分配一个乘法因子。例如，如果某个集合的 WEIGHT 是2，那么在计算并集时，该集合中的每个元素的分数都会乘以2。</span><br><span class="line">AGGREGATE     - 可选参数，它决定了当多个有序集合中存在相同元素时，如何处理这些元素的分数。有三个选项：SUM（默认）、MIN和MAX。SUM将相同元素的分数加起来，MIN 使用最小分数，而 MAX 使用最大分数。</span><br><span class="line"></span><br><span class="line">&gt; ZADD set1 1 &quot;one&quot; 2 &quot;two&quot;</span><br><span class="line">(integer) 2</span><br><span class="line">&gt; ZADD set2 1 &quot;one&quot; 3 &quot;three&quot;</span><br><span class="line">(integer) 2</span><br><span class="line">&gt; ZRANGE set1 0 -1 WITHSCORES</span><br><span class="line">1) &quot;one&quot;</span><br><span class="line">2) &quot;1&quot;</span><br><span class="line">3) &quot;two&quot;</span><br><span class="line">4) &quot;2&quot;</span><br><span class="line">&gt; ZRANGE set2 0 -1 WITHSCORES</span><br><span class="line">1) &quot;one&quot;</span><br><span class="line">2) &quot;1&quot;</span><br><span class="line">3) &quot;three&quot;</span><br><span class="line">4) &quot;3&quot;</span><br><span class="line">&gt; ZUNIONSTORE result 2 set1 set2</span><br><span class="line">(integer) 3</span><br><span class="line">&gt; ZRANGE result 0 -1 WITHSCORES</span><br><span class="line">1) &quot;one&quot;</span><br><span class="line">2) &quot;2&quot;</span><br><span class="line">3) &quot;two&quot;</span><br><span class="line">4) &quot;2&quot;</span><br><span class="line">5) &quot;three&quot;</span><br><span class="line">6) &quot;3&quot;</span><br><span class="line"># 当然，你可以使用 WEIGHTS 和 AGGREGATE 参数来调整结果的计算方式。例如，如果你想要为 set1 的每个成员加倍其分数，然后和 set2 求并集，并取每个成员的最大值作为结果：</span><br><span class="line"></span><br><span class="line"># set1 set2 两个集合的初始值没变，还是上面的数据</span><br><span class="line">&gt; ZUNIONSTORE result 2 set1 set2  WEIGHTS 2 1 AGGREGATE MAX</span><br><span class="line">(integer) 3</span><br><span class="line">&gt; ZRANGE result 0 -1 WITHSCORES</span><br><span class="line">1) &quot;one&quot;</span><br><span class="line">2) &quot;2&quot;</span><br><span class="line">3) &quot;three&quot;</span><br><span class="line">4) &quot;3&quot;</span><br><span class="line">5) &quot;two&quot;</span><br><span class="line">6) &quot;4&quot;</span><br></pre></td></tr></table></figure>

<h4 id="应用案例-3"><a href="#应用案例-3" class="headerlink" title="应用案例"></a>应用案例</h4><p><strong>实时排行榜</strong></p>
<ul>
<li><strong>游戏排行榜</strong></li>
</ul>
<p>在线游戏的实时排行榜，玩家或用户的得分可以即时更新，并按分数进行排序。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 添加或更新分数</span><br><span class="line">ZADD leaderboard 1500 &quot;player1&quot;</span><br><span class="line">ZADD leaderboard 2200 &quot;player2&quot;</span><br><span class="line">ZADD leaderboard 1800 &quot;player3&quot;</span><br><span class="line">#查询前3名玩家</span><br><span class="line">ZREVRANGE leaderboard 0 2 WITHSCORES</span><br><span class="line"># 获取某个玩家的排名</span><br><span class="line">ZREVRANK leaderboard &quot;player1&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>网站文章或视频的热门排行</li>
</ul>
<p>网站可能希望展示其上点击量最高的文章或视频。每次有用户点击时，相关内容的计数就会增加，然后可以使用有序集合实时显示热门内容。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 文章被点击：</span><br><span class="line">ZINCRBY article_views 1 &quot;article123&quot;</span><br><span class="line">#获取最热门的 3 篇文章</span><br><span class="line">ZREVRANGE article_views 0 2 WITHSCORES</span><br></pre></td></tr></table></figure>

<ul>
<li>电商平台的热门产品排行</li>
</ul>
<p>电商平台可能希望展示最受欢迎的产品。每当产品被购买，其热度都会增加。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#产品被购买：</span><br><span class="line">ZINCRBY product_sales 1 &quot;product123&quot;</span><br><span class="line">#获取最受欢迎的10个产品</span><br><span class="line">ZREVRANGE product_sales 0 9 WITHSCORES</span><br></pre></td></tr></table></figure>

<p><strong>时间线事件记录</strong></p>
<p><strong>场景描述：</strong>假设我们正在为一个社交网络网站设计功能，用户每次登录、发帖或评论都会在其时间线上生成一个事件。我们希望可以跟踪这些事件并能够检索特定时间范围内的事件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#用户在某个时间点登录了网站</span><br><span class="line">ZADD user123:timeline 1631498200 &quot;Logged in&quot;</span><br><span class="line">#该用户稍后发表了一篇文章</span><br><span class="line">ZADD user123:timeline 1631498300 &quot;Posted an article about Redis&quot;</span><br><span class="line">#查询该用户在指定的时间范围内的所有事件</span><br><span class="line">ZRANGEBYSCORE user123:timeline 1631498200 1631498400</span><br></pre></td></tr></table></figure>

<p><strong>延迟任务队列</strong></p>
<p><strong>场景描述：</strong>用户订阅了一个在线服务，比如说一个<strong>音乐服务</strong>，它提供了<strong>一个月</strong>的免费试用。为了提醒用户及时续费或者保存他们的歌单数据，服务提供商可以在试用期结束前的几天，发送一个“您的试用即将结束，请及时续费”的提醒。这个提醒任务就可以放入延迟队列。</p>
<p><strong>具体实现步骤：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 用户注册: 当用户开始他们的免费试用时，你会将这个用户和他们试用结束时间的时间戳（减去3天，这样在结束前3天提醒他们）加入到一个有序集合中。</span><br><span class="line">ZADD trial_end_reminders (start_timestamp + trial_period - few_days) user_id  # 一般时间戳是以秒为单位的，对于这个例子，trial_period = 24*86400，few_days = 3 * 86400。</span><br><span class="line">#后台任务：后台任务每天定期检查这个有序集合，查看哪些用户需要在今天被提醒。</span><br><span class="line">ZRANGEBYSCORE trial_end_reminders (current_timestamp) (current_timestamp + 86400)</span><br><span class="line"></span><br><span class="line">#发送提醒：对于上面命令返回的每一个用户，你的系统会发送一个提醒邮件或者应用内通知，告诉他们试用即将结束，并提供一个续订链接。</span><br><span class="line"></span><br><span class="line">#清理：在发送提醒后，你需要从有序集合中移除这些用户，确保他们不会被再次提醒。</span><br><span class="line">ZREM trial_end_reminders user_id_1 user_id_2 ...</span><br></pre></td></tr></table></figure>

<h3 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps"></a><strong>Bitmaps</strong></h3><h4 id="基本概念：-3"><a href="#基本概念：-3" class="headerlink" title="基本概念："></a><strong>基本概念：</strong></h4><p>Redis 的 Bitmaps（位图）是一种特殊的数据结构，用于高效地处理大量的布尔值（true&#x2F;false或者1&#x2F;0）。在 Redis 中，Bitmaps 实际上并不是一种独立的数据类型，而是字符串（String）类型的一种特殊操作方式。通过 <strong>位操作</strong> 命令，Redis 允许用户在一个很大的字节数组中设置和获取位（bit）的值。</p>
<h4 id="简单图解-4"><a href="#简单图解-4" class="headerlink" title="简单图解:"></a><strong>简单图解:</strong></h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/RedisObject/7.png"></p>
<h4 id="内部实现-5"><a href="#内部实现-5" class="headerlink" title="内部实现"></a>内部实现</h4><p><strong>Bitmaps</strong> 实际上就是一个 String，底层采用字节数组来存储数据。</p>
<p>Bitmaps 提供了一系列的命令来操作和查询二进制位。</p>
<h4 id="基本命令："><a href="#基本命令：" class="headerlink" title="基本命令："></a>基本命令：</h4><p><strong>设置和获取位值：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SETBIT key offset value    : 设置或清除操作只需将对应位 置 0 即可指定的位 # 清除操作只需将对应位 置 0 即可， offset只能是非负整数。</span><br><span class="line">GETBIT key offset          : 获取指定位的值</span><br><span class="line"></span><br><span class="line">#  将位于索引7的位设置为1</span><br><span class="line">&gt; SETBIT mymap 7 1</span><br><span class="line">(integer) 0</span><br><span class="line">#  获取位于索引7的位的值</span><br><span class="line">&gt; GETBIT mymap 7</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>

<p><strong>统计和查找：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">BITCOUNT key                 ：计算整个字符串中设置为1的位数</span><br><span class="line">BITCOUNT key [start end]     ：计算在指定范围内设置为1的位数</span><br><span class="line">BITPOS key bit [start] [end] : 找到第一个设置为1或0的位</span><br><span class="line"></span><br><span class="line">其中，start和end是字符串的字节索引（不是bit索引）</span><br><span class="line"></span><br><span class="line">&gt; BITCOUNT mymap  </span><br><span class="line">(integer) 1</span><br><span class="line">&gt; BITCOUNT mymap 0 1  # 计算从字节0到字节1之间设置为1的位数</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; BITPOS mymap 1</span><br><span class="line">(integer) 7</span><br><span class="line">&gt; BITPOS mymap 0</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure>

<p><strong>其他运算</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BITOP operation destkey key [key ...]   ： 对一个或多个bitmaps进行位运算</span><br><span class="line">operation 可能是 AND, OR, XOR, NOT 其中一种</span><br><span class="line">AND:逻辑与 、OR:逻辑或、XOR:逻辑异或、NOT：逻辑非</span><br><span class="line"></span><br><span class="line">&gt; SETBIT yourmap 5 1</span><br><span class="line">(integer) 0</span><br><span class="line">&gt; BITOP AND destMap mymap yourmap</span><br><span class="line">(integer) 1         # 返回 1，表示 destMap 的长度是 1 字节         </span><br></pre></td></tr></table></figure>

<h4 id="应用案列："><a href="#应用案列：" class="headerlink" title="应用案列："></a><strong>应用案列：</strong></h4><p><strong>员工打卡签到：</strong></p>
<p>大家都知道，员工打卡签到系统几乎是每家公司的标配功能。每天上班，员工都需要打卡来记录他们的出勤情况。今天我们来探讨一下，如何利用 Redis 中的 Bitmaps 来高效地实现这个功能。</p>
<p><strong>为什么选择 Bitmaps?</strong></p>
<p>员工打卡签到无非就是两种结果：签到和未签到。这种二元状态正好与Bitmaps的存储方式相契合，每位员工的每天签到状态只需用一个位（0或1）来表示。</p>
<p>每天使用一个特定日期格式的 key（如 user:12345:attendance:2023-09-01）存储Bitmaps。员工的 ID 直接作为位索引，如 ID 为 42 的员工签到，则将sign_2023-09-01的第 42 位设为 1。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#员工打卡签到</span><br><span class="line">SETBIT user:42:attendance:2023-09-01 42 1    # 员工 ID 42 在2023-09-01签到</span><br><span class="line">SETBIT user:42:attendance:2023-09-01 1024 1  # 员工 ID 1024 在2023-09-01签到</span><br><span class="line"></span><br><span class="line">#检查特定用户是否在某天签到</span><br><span class="line">GETBIT user:42:attendance:2023-09-01 42  # 查看员工 ID 42 在2023-09-01是否签到</span><br><span class="line">GETBIT user:42:attendance:2023-09-01 500  # 查看员工 ID 500 在2023-09-01是否签到</span><br><span class="line"></span><br><span class="line">#计算某一天的签到用户数</span><br><span class="line">BITCOUNT user:42:attendance:2023-09-01  # 查看2023-09-01的签到用户数</span><br></pre></td></tr></table></figure>

<p><strong>日活跟踪:</strong></p>
<p>记录特定日期所有活跃用户的信息。例如，我们可以使用一个特定日期的 bitmaps 来跟踪该日期的所有活跃用户。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 用户 ID 为 12345 和 67890 在 2023-09-01 都活跃了</span><br><span class="line">SETBIT active_users:2023-09-01 12345 1</span><br><span class="line">SETBIT active_users:2023-09-01 67890 1</span><br><span class="line"></span><br><span class="line"># 检查用户 ID 为 12345 在 2023-09-01 是否活跃</span><br><span class="line">GETBIT active_users:2023-09-01 12345</span><br><span class="line"></span><br><span class="line">#检查某一天所有的活跃用户数</span><br><span class="line">BITCOUNT user:42:attendance:2023-09-01</span><br></pre></td></tr></table></figure>

<p><strong>用户登录：</strong></p>
<p>可以使用 bitmaps 来跟踪用户的登录状态，例如，确定用户是否已登录。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 用户 ID 为 12345 登录了</span><br><span class="line">SETBIT user:12345:login_status 1</span><br><span class="line"></span><br><span class="line"># 检查用户 ID 为 12345 是否登录</span><br><span class="line">GETBIT user:12345:login_status</span><br></pre></td></tr></table></figure>

<p><strong>这三个应用的关注点区别：</strong></p>
<p><strong>打卡签到：</strong> 主要关注个体用户的连续行为，例如连续签到多少天。</p>
<p><strong>日活跟踪：</strong> 关注整体的用户行为，例如在某一天有多少用户活跃了。</p>
<p><strong>用户登录：</strong> 主要跟踪用户的即时状态，例如某用户当前是否在线或已登录。</p>
<h3 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h3><p>在大数据应用中，我们经常需要计算或估算某个集合中不重复元素的数量（<strong>基数</strong>），例如统计网站的独立访客(UV)。但当数据规模非常大时，传统的统计方法会消耗大量的存储和计算资源。这时，Redis 的 HyperLogLog（简称HLL）提供了一个很好的解决方案。</p>
<h4 id="基本概念：-4"><a href="#基本概念：-4" class="headerlink" title="基本概念："></a>基本概念：</h4><p>从广义上说，HyperLogLog 是一个概率性的数据结构，用于估算集合的<strong>基数</strong>（即<strong>不重复元素的数量</strong>）。它不会提供完美准确的计数，但它使用的存储空间非常小（最多使用12KB的内存）。</p>
<p>在 <strong>Redis</strong> 的语境中，我们可以将 HyperLogLog 视为一种特定的数据类型。</p>
<h4 id="简单图解：-1"><a href="#简单图解：-1" class="headerlink" title="简单图解："></a>简单图解：</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/RedisObject/8.png"></p>
<p><strong>步骤说明：</strong></p>
<ul>
<li>输入值通过哈希函数生成固定长度的二进制哈希值。</li>
<li>哈希值的前几位决定了它应该进入数组的位置。</li>
<li>存储值，将给定值的前导零的个数存储在数组的对应位置</li>
<li>数组中的值可能会根据新的哈希值进行更新（新的哈希值的前导零个数大于数组值才会更新）</li>
<li>根据数组元素进行基数估计</li>
</ul>
<h4 id="内部实现-6"><a href="#内部实现-6" class="headerlink" title="内部实现"></a>内部实现</h4><p>Redis 的 HyperLogLog 是一种特殊的数据类型，用来估计一个集合中有多少不同的元素。它不会给出完全准确的答案，但它的估计接近真实值，并且使用的存储空间非常小。它是基于一种名为 ‘HyperLogLog’ 的聪明算法来工作的，这种算法使用概率学的魔法来做估计，而不是真正地数每一个元素。</p>
<h4 id="基本命令：-1"><a href="#基本命令：-1" class="headerlink" title="基本命令："></a><strong>基本命令：</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">PFADD key element [element ...]           :  添加元素</span><br><span class="line">PFCOUNT key [key ...]                     :  查询基数估计值</span><br><span class="line">PFMERGE destkey sourcekey [sourcekey ...] :  合并多个 HyperLogLog 数据集</span><br><span class="line"></span><br><span class="line">&gt; PFADD myhll a b c d e f g</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; PFCOUNT myhll</span><br><span class="line">(integer) 7</span><br><span class="line">&gt; PFADD yourhll a b c d h i j k</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; PFMERGE desthll myhll yourhll</span><br><span class="line">OK</span><br><span class="line">&gt; PFCOUNT desthll</span><br><span class="line">(integer) 11</span><br></pre></td></tr></table></figure>

<h4 id="应用案例：-1"><a href="#应用案例：-1" class="headerlink" title="应用案例："></a><strong>应用案例：</strong></h4><p><strong>网站的 UV（独立访客）统计</strong></p>
<p>当你要统计一个网站的UV（独立访客）时，你的目标是确定有多少独立的用户访问了你的网站，而不是访问的总次数。传统的方法（比如，基于关系型数据库的计数）可能会很耗资源，特别是当访客量非常大时。</p>
<p>而 Redis 的 HyperLogLog 提供了一个空间效率非常高的方式来进行这样的估算。每当有用户访问网站时，你可以记录其 IP 地址或者某个与用户相关的唯一标识符（sessionID），然后使用 PFADD 命令将其加入到 HyperLogLog 中。</p>
<p><strong>具体实现：</strong></p>
<p><strong>为每个独立的访客生成唯一标识：</strong></p>
<p>现在大部分网站都会采用 cookie 技术。每当用户访问网站时，服务器都会为这位新访客生成一个唯一的 ID 并将其存储在 cookie 中。这个唯一的 ID 用于在后续的访问中识别该用户，从而跟踪其在网站上的行为和偏好。</p>
<p>我们使用 <strong>user_cookie_12345</strong> ，<strong>user_cookie_12346</strong> 等来标识不同的cookie</p>
<p><strong>添加 Cookie 到 HyperLogLog:</strong></p>
<p>为了跟踪一天的 UV，可以为每天创建一个 HyperLogLog。当用户访问你的网站时，使用PFADD命令将他们的唯一标识添加到 HyperLogLog 中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; PFADD uv_2023_09_01 user_cookie_12345 </span><br><span class="line">&gt; PFADD uv_2023_09_01 user_cookie_12346 </span><br><span class="line">&gt; PFADD uv_2023_09_01 user_cookie_12347 </span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><strong>估算该日的UV：</strong></p>
<p>使用 PFCOUNT 命令来获取估算的UV值。</p>
<p>该命令会返回一个估算的独立访客数量。请注意，这是一个估算值，但其精度在大多数情况下是足够的。</p>
<p><strong>存储历史数据：</strong></p>
<p>如果你想跟踪UV的历史数据，可以为每天保留一个 HyperLogLog。例如：uv_2023_09_01、uv_2023_09_02等。</p>
<p><strong>合并多日数据：</strong></p>
<p>如果你想要一个时间范围内的估算 UV（例如一个月），你可以使用 PFMERGE 命令合并多个 HyperLogLog。</p>
<p>以上就是使用 Redis 的 HyperLogLog 进行网站UV统计的基本方法。使用这种方法，你可以用非常少的空间（每个 HyperLogLog 只需要12KB）来跟踪大量的独立访客。</p>
<h3 id="Geospatial"><a href="#Geospatial" class="headerlink" title="Geospatial"></a>Geospatial</h3><p><strong>简介：</strong></p>
<p>Redis支持一个称为 Geospatial 的地理空间索引功能。这一功能在许多需要地理定位数据的应用中都有着广泛应用，如找到某个位置附近的餐厅或商店等。</p>
<h4 id="基本概念：-5"><a href="#基本概念：-5" class="headerlink" title="基本概念："></a>基本概念：</h4><p>“Geo” 来源于希腊语，意为“地球”，而 “spatial” 则表示“与空间有关”。结合起来，Geospatial 主要关注地球上的空间位置或地域。在 Redis 中，这意味着我们可以使用坐标系统（如经纬度）来存储和查询地理位置的数据。</p>
<h4 id="简单图解-5"><a href="#简单图解-5" class="headerlink" title="简单图解:"></a>简单图解:</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/RedisObject/9.png"></p>
<h4 id="内部实现-7"><a href="#内部实现-7" class="headerlink" title="内部实现:"></a>内部实现:</h4><p><strong>地图到数字：</strong></p>
<p>想象一下，我们的地球是一个巨大的地图。如果我们要在这张地图上标记一个位置，通常会使用经纬度来描述它。但计算机更擅长处理数字而不是这样的坐标。因此，Redis 使用了一种叫做 Geohash 的技巧，它可以把这些坐标（比如经纬度）转换成一个数字。</p>
<p><strong>把位置存进列表：</strong></p>
<p>Redis 有一种特殊的列表叫做 zset（有序集合）。在 Geospatial 中，位置的名字（比如”北京”）作为元素，而转换得到的数字（Geohash）作为这个元素的“分数”。</p>
<p><strong>查找附近的地方：</strong></p>
<p>当我们想知道某个位置附近的其他地方时，Redis 会先找出这个位置的数字（Geohash），然后在 zset 中查找分数接近的其他元素。这样就可以快速地找出附近的位置。</p>
<p><strong>注意：</strong></p>
<p>使用 Geohash 的方法可能不是百分之百精确的，因为它是一种近似的方法。但在实际应用中，这种小小的误差通常不会导致太大的问题，而它让存储和查找变得非常迅速。</p>
<h4 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a><strong>基本命令</strong></h4><p><strong>添加操作：</strong></p>
<p>向指定的键中添加地理空间位置（经度、纬度、名称）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GEOADD key longitude latitude member [longitude latitude member ...]                    : 向指定的键中添加地理空间位置（经度、纬度、名称）</span><br><span class="line"></span><br><span class="line">&gt; GEOADD china:city 114.085947 22.547 shenzhen 113.280637 23.125178 guangzhou</span><br><span class="line">(integer) 2</span><br><span class="line">&gt; GEOADD china:city 121.472644 31.231706 shanghai 116.405285 39.904989 beijing</span><br><span class="line">(integer) 2</span><br><span class="line">&gt; GEOADD china:city 108.948024 34.263161 xian 106.504962 29.533155 chongqing</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure>

<p><strong>获取操作：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">GEOPOS key member [member ...]                      : 获取一个或多个位置元素的经纬度</span><br><span class="line">GEODIST key member1 member2 [m|km|ft|mi]            : 获取两个地点之间的距离    # [m|km|ft|mi]:  分别是：米，千米，英尺，英里</span><br><span class="line">GEORADIUS key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [ASC|DESC] [COUNT count]  : 根据给定的经纬度坐标，返回位于给定距离内的位置。</span><br><span class="line"></span><br><span class="line">#参数详解</span><br><span class="line">WITHCOORD    ： 返回查询结果中地理位置的经纬度坐标</span><br><span class="line">WITHDIST     ： 返回每个查询结果地点到给定坐标的距离</span><br><span class="line">WITHHASH     ： 返回位置的 52 位整数表示的 geohash</span><br><span class="line">ASC|DESC     ： 决定了查询结果的排序方式，按距离升序排列、按距离降序排列 </span><br><span class="line">COUNT count  :  限制查询结果的数量。</span><br><span class="line"></span><br><span class="line">&gt; GEOADD china:city 108.948024 34.263161 xian 106.504962 29.533155 chongqing</span><br><span class="line">(integer) 2</span><br><span class="line">&gt; GEOPOS china:city xian chongqing</span><br><span class="line">1) 1) &quot;108.94802302122116089&quot;</span><br><span class="line">   2) &quot;34.2631604414749944&quot;</span><br><span class="line">2) 1) &quot;106.50495976209640503&quot;</span><br><span class="line">   2) &quot;29.53315530684997015&quot;</span><br><span class="line">&gt; GEODIST china:city shenzhen xian km</span><br><span class="line">&quot;1396.1268&quot;</span><br><span class="line">&gt; GEORADIUS china:city 118.767413 32.041544 500 km</span><br><span class="line">1) &quot;shanghai&quot;</span><br><span class="line">&gt; GEORADIUS china:city 118.767413 32.041544 500 km WITHCOORD</span><br><span class="line">1) 1) &quot;shanghai&quot;</span><br><span class="line">   2) 1) &quot;121.47264629602432251&quot;</span><br><span class="line">      2) &quot;31.23170490709807012&quot;</span><br><span class="line">&gt; GEORADIUS china:city 118.767413 32.041544 500 km WITHDIST</span><br><span class="line">1) 1) &quot;shanghai&quot;</span><br><span class="line">   2) &quot;271.5419&quot;</span><br></pre></td></tr></table></figure>

<p><strong>我们来看一个混合使用参数的例子：</strong></p>
<p>查询距离某个位置 1000 公里内的所有地方，并返回其名称、距离、坐标，然后按距离升序排序，只显示前 3 个结果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt; GEORADIUS china:city 118.767413 32.041544 1000 km WITHDIST WITHCOORD ASC COUNT 3</span><br><span class="line">1) 1) &quot;shanghai&quot;</span><br><span class="line">   2) &quot;271.5419&quot;</span><br><span class="line">   3) 1) &quot;121.47264629602432251&quot;</span><br><span class="line">      2) &quot;31.23170490709807012&quot;</span><br><span class="line">2) 1) &quot;beijing&quot;</span><br><span class="line">   2) &quot;899.9931&quot;</span><br><span class="line">   3) 1) &quot;116.40528291463851929&quot;</span><br><span class="line">      2) &quot;39.9049884229125027&quot;</span><br><span class="line">3) 1) &quot;xian&quot;</span><br><span class="line">   2) &quot;946.7395&quot;</span><br><span class="line">   3) 1) &quot;108.94802302122116089&quot;</span><br><span class="line">      2) &quot;34.2631604414749944&quot;</span><br></pre></td></tr></table></figure>

<h4 id="应用案例-4"><a href="#应用案例-4" class="headerlink" title="应用案例"></a><strong>应用案例</strong></h4><p><strong>位置数据存储与查询</strong>：</p>
<ul>
<li><strong>社交应用</strong>：用户可以查找附近的朋友或兴趣点。例如，一个社交网络应用可以允许用户查看附近的其他用户或活动。</li>
<li><strong>出行与导航</strong>：用于存储和查询地理位置数据，如共享单车或共享汽车的当前位置，以及用户附近的可用车辆。</li>
</ul>
<h3 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a><strong>Stream</strong></h3><h4 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a><strong>基本概念</strong></h4><p>Redis Stream 是 Redis 5.0 中引入的新数据类型，设计用来存储和查询日志数据结构。Stream 是 Redis 对“日志”数据结构的实现，这种结构在各种场景中都很有用，如<strong>消息队列</strong>和<strong>事件日志</strong>。</p>
<p>与简单的 List 不同，Stream 能够更好地支持多用户并发操作，同时还提供了复杂的消息确认和消费机制。</p>
<h4 id="Stream-基本组件介绍"><a href="#Stream-基本组件介绍" class="headerlink" title="Stream 基本组件介绍"></a>Stream 基本组件介绍</h4><p><strong>Stream：</strong>一个Stream是一个按时间顺序排列的消息列表。每个消息都有一个唯一的ID和键值对组成的数据。</p>
<p><strong>Consumer：</strong>这是一个从 Stream 读取消息的客户端。每个 Consumer 都有一个唯一的名字。</p>
<p><strong>Consumer Group：</strong>一个 Consumer Group 包含一组 Consumer，它们共同读取一个 Stream。这样做是为了并行处理消息。</p>
<h4 id="简单图解-6"><a href="#简单图解-6" class="headerlink" title="简单图解"></a>简单图解</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/RedisObject/10.png"></p>
<h4 id="内部实现-8"><a href="#内部实现-8" class="headerlink" title="内部实现:"></a>内部实现:</h4><p><strong>ListPack :</strong> Redis 中的 Stream 的底层用的是一种名为 ListPack 的数据结构，它非常紧凑并且效率高。</p>
<p><strong>唯一ID :</strong> 每个消息都有一个由时间戳和序列号组成的唯一ID，确保消息的全局唯一性。</p>
<h4 id="基本命令-1"><a href="#基本命令-1" class="headerlink" title="基本命令:"></a><strong>基本命令:</strong></h4><p><strong>基础操作</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">添加操作：</span><br><span class="line">XADD key  *|ID field value [field value ...]  :   </span><br><span class="line"># *|ID: 消息的 ID。使用 * 会自动生成一个ID，或者你可以指定一个</span><br><span class="line"></span><br><span class="line">&gt; XADD mystream * name xiaokang age 25</span><br><span class="line">&quot;1695020949856-0&quot;</span><br><span class="line">&gt; XADD mystream * hobby swim job programmer</span><br><span class="line">&quot;1695029970290-0&quot;</span><br><span class="line"></span><br><span class="line">查询操作:</span><br><span class="line">XRANGE key start end [COUNT count]      ：  查询指定ID范围内的消息</span><br><span class="line">XREVRANGE key end start [COUNT count]   :   反向查询指定ID范围内的消息</span><br><span class="line"></span><br><span class="line">#  参数说明：</span><br><span class="line">key            : 表示你要检索的 Stream 的名字</span><br><span class="line">[COUNT count]  : 可选参数，用于限制返回的消息数量</span><br><span class="line">对于 XRANGE 命令，参数 start 和 end 的含义：</span><br><span class="line">start          : 检索的起始消息 ID</span><br><span class="line">end            : 检索的结束消息 ID</span><br><span class="line"></span><br><span class="line">对于 XRANGE 命令，参数 start 和 end 的含义： </span><br><span class="line">start          : 反向检索的起始消息 ID</span><br><span class="line">end            : 反向检索的结束消息 ID</span><br><span class="line"></span><br><span class="line">特殊符号解释:</span><br><span class="line">参数 start 取 &#x27;-&#x27; ， 表示最早的消息，取 + 表示最新的消息</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 检索所有消息</span><br><span class="line">&gt; XRANGE mystream - +</span><br><span class="line">1) 1) &quot;1695020949856-0&quot;</span><br><span class="line">   2) 1) &quot;name&quot;</span><br><span class="line">      2) &quot;xiaokang&quot;</span><br><span class="line">      3) &quot;age&quot;</span><br><span class="line">      4) &quot;25&quot;</span><br><span class="line">2) 1) &quot;1695029970290-0&quot;</span><br><span class="line">   2) 1) &quot;hobby&quot;</span><br><span class="line">      2) &quot;swim&quot;</span><br><span class="line">      3) &quot;job&quot;</span><br><span class="line">      4) &quot;programmer&quot;</span><br><span class="line">#  反向检索所有消息</span><br><span class="line">&gt; XREVRANGE  mystream +  -</span><br><span class="line">1) 1) &quot;1695029970290-0&quot;</span><br><span class="line">   2) 1) &quot;hobby&quot;</span><br><span class="line">      2) &quot;swim&quot;</span><br><span class="line">      3) &quot;job&quot;</span><br><span class="line">      4) &quot;programmer&quot;</span><br><span class="line">2) 1) &quot;1695020949856-0&quot;</span><br><span class="line">   2) 1) &quot;name&quot;</span><br><span class="line">      2) &quot;xiaokang&quot;</span><br><span class="line">      3) &quot;age&quot;</span><br><span class="line">      4) &quot;25&quot;</span><br><span class="line"></span><br><span class="line">获取长度：</span><br><span class="line">XLEN key                   ：获取Stream中的消息数量</span><br><span class="line"></span><br><span class="line">&gt; XLEN mystream</span><br><span class="line">(integer) 2</span><br><span class="line"></span><br><span class="line">裁剪操作：</span><br><span class="line">XTRIM key MAXLEN|MINID [=|~] threshold [LIMIT count]  ：裁减Stream 的长度，控制其大小</span><br><span class="line"># 参数说明</span><br><span class="line">MAXLEN|MINID  : 裁减策略选择。</span><br><span class="line">MAXLEN        ：使 Stream 最多保持指定数量的消息。</span><br><span class="line">MINID         ：删除所有小于指定ID的消息。</span><br><span class="line"></span><br><span class="line">[=|~]: 这是一个可选的修饰符，与上面的 MAXLEN 或 MINID 一起使用。</span><br><span class="line"></span><br><span class="line">=：这意味着长度或ID应该精确匹配。对于 MAXLEN，它确保Stream的长度恰好等于指定的长度（删除任何额外的消息）；对于 MINID，它确保删除的所有消息的ID值都小于等于给定值。</span><br><span class="line">~：这意味着长度或ID是一个近似值。这可能会导致更快的裁减操作，但Stream的实际长度可会略微超过或低于指定的值。</span><br><span class="line">[LIMIT count]  : 这是一个可选的参数，它限制了在一个操作中可以删除的消息数</span><br><span class="line"></span><br><span class="line">&gt; XTRIM mystream MAXLEN = 1</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; XRANGE mystream - +</span><br><span class="line">1) 1) &quot;1695029970290-0&quot;</span><br><span class="line">   2) 1) &quot;hobby&quot;</span><br><span class="line">      2) &quot;swim&quot;</span><br><span class="line">      3) &quot;job&quot;</span><br><span class="line">      4) &quot;programmer&quot;</span><br><span class="line">      </span><br><span class="line">删除操作：</span><br><span class="line">XDEL key ID [ID ...]       ： 从Stream中删除指定的消息</span><br><span class="line"></span><br><span class="line">&gt; XDEL mystream &quot;1695029970290-0&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; XRANGE mystream - +</span><br><span class="line"></span><br><span class="line">读取消息操作:</span><br><span class="line"></span><br><span class="line">XREAD [COUNT count] [BLOCK milliseconds] STREAMS key [key ...] ID [ID ...]                    : 用于从一个或多个流中读取消息</span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line">COUNT count                  :可选参数，指定要从每个流中读取的最大消息数。</span><br><span class="line">BLOCK milliseconds           :可选参数，阻塞操作的时间（以毫秒为单位）。该命令会等待指定的时间，直到有新的消息可用。 在给定的时间内没有新消息，则命令会返回一个空响应</span><br><span class="line">STREAMS                      :指示后面要列出要从中读取的流的名称。这是一个固定的关键字。</span><br><span class="line">key [key ...]                :要从中读取的流的名称列表</span><br><span class="line">ID [ID ...]                  :为每个指定的流提供一个消息 ID，从该 ID 之后（不包括该 ID）开始读取消息。</span><br><span class="line">特殊 ID $                     :表示只读取新的消息，也就是那些在发出此 XREAD 命令之后添加到流中的消息。</span><br></pre></td></tr></table></figure>

<p><strong>消费者和消费者组操作</strong></p>
<p>XGROUP：用于创建、修改或删除消费者组。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 参数说明:</span><br><span class="line">CREATE : 创建一个新的消费者组。</span><br><span class="line">XGROUP CREATE key groupname ID|$ [MKSTREAM]</span><br><span class="line"></span><br><span class="line">key        : Stream 的名称。</span><br><span class="line">groupname  : 消费者组的名称。</span><br><span class="line">ID         : 从哪个消息 ID 开始消费。如果选择 $，则只会消费新添加到 Stream 的消息。</span><br><span class="line">MKSTREAM   : 可选参数。如果 Stream 不存在，它会创建一个新的空 Stream。</span><br><span class="line"></span><br><span class="line">SETID  :  设置消费者组的开始消费消息的 ID。</span><br><span class="line">XGROUP SETID key groupname ID|$</span><br><span class="line">key        : Stream 的名称。</span><br><span class="line">groupname  : 消费者组的名称。</span><br><span class="line">ID         : 从哪个消息 ID 开始消费。如果选择 $，则只会消费新添加到 Stream 的消息。</span><br><span class="line"></span><br><span class="line">DESTROY  :  删除一个消费者组。</span><br><span class="line">XGROUP DESTROY key groupname</span><br><span class="line">key        : Stream 的名称。</span><br><span class="line">groupname  : 消费者组的名称。</span><br><span class="line"></span><br><span class="line">CREATECONSUMER  :  在给定的消费者组中显式地创建一个消费者。</span><br><span class="line">XGROUP CREATECONSUMER key groupname consumername</span><br><span class="line">key          : Stream 的名称。</span><br><span class="line">groupname    : 消费者组的名称。</span><br><span class="line">consumername : 新创建的消费者的名称。</span><br></pre></td></tr></table></figure>

<p>XREADGROUP：使用消费者组从Stream中读取消息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [key ...] ID [ID ...] </span><br><span class="line"># 参数说明：</span><br><span class="line">group               : 指的是你想读取消息的消费者组的名称。</span><br><span class="line">consumer            : 是该消费者组内的消费者名称。每次使用 XREADGROUP，都需要指定消费者名称。</span><br><span class="line">COUNT count         : 可选参数，指定从每个流中读取的最大消息数量。</span><br><span class="line">NOACK               : 消息在被读取时不会被标记为“未确认”。因此，不需要（也不能）对它们进行确认。默认情况下，当消费者读取消息后，是需要对消息进行确认的。</span><br><span class="line">ID [ID ...]         : 为每个指定的流提供一个消息 ID，从该 ID 之后（不包括该 ID）开始读取消息。</span><br><span class="line">特殊 ID &gt;            : 表示从上次读取的位置继续读取（只在使用 XREADGROUP 时有效）。</span><br></pre></td></tr></table></figure>

<p>XACK   : 用来确认消费者已成功处理的特定消息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">XACK key group ID [ID ...] </span><br><span class="line"></span><br><span class="line"># 参数解释 </span><br><span class="line">key            : 这是你要确认消息的 Stream 的名字。</span><br><span class="line">group          : 这是消息所属的消费者组的名称。</span><br><span class="line">ID [ID ...]    : 一个或多个你想确认的消息的 ID。</span><br></pre></td></tr></table></figure>

<p>XPENDING  ：用于查询消费者组中待处理（已发送但未确认）的消息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">XPENDING key group [[IDLE min-idle-time] start end count [consumer]]</span><br><span class="line">key                           : 你要查询的 Stream 的名称。</span><br><span class="line">group: 你要查询的消费者组的名称。</span><br><span class="line">IDLE min-idle-time            : 这是一个可选的参数，它允许你只查询那些已经空闲或未确认超过指定毫秒数的消息。</span><br><span class="line">start                         : 起始消息 ID。</span><br><span class="line">end                           : 结束消息 ID。</span><br><span class="line">count                         : 你要返回的消息的最大数量。</span><br><span class="line">consumer                      : 这是一个可选的参数，它允许你只查询特定消费者的待处理消息。</span><br></pre></td></tr></table></figure>

<p>XCLAIM ：允许一个消费者重新认领消费者组中的挂起消息，通常用于处理由失效消费者未完成的消息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">XCLAIM key group consumer min-idle-time ID [ID ...] [IDLE ms] [TIME ms-unix-time] [RETRYCOUNT count] [force] [justid] </span><br><span class="line"></span><br><span class="line">key                        : 指定的 Stream 名称。</span><br><span class="line">group                      : 你想要操作的消费者组名称。</span><br><span class="line">consumer                   : 这是尝试认领消息的消费者的名字。</span><br><span class="line">min-idle-time              : 以毫秒为单位的时间，仅当消息的闲置时间超过此值时，消费者才能认领该消息。</span><br><span class="line">ID [ID ...]                : 你想要认领的消息的 ID 列表。</span><br><span class="line">IDLE ms                    : 设置消息的新的闲置时间（自从最后一次被消费以来的时间）。</span><br><span class="line">TIME ms-unix-time          : 修改消息的最后一次被读取的时间为给定的 Unix 时间</span><br><span class="line">RETRYCOUNT count           : 设置消息的投递计数（即这条消息已经被送达的次数）。</span><br><span class="line">force                      : 这个选项允许你不考虑 min-idle-time 条件，直接强制认领消息。</span><br><span class="line">justid                     : 如果设置这个选项，命令只返回消息 ID，不返回消息的内容。</span><br></pre></td></tr></table></figure>

<p>接下来，我通过一个示例来演示如何使用Redis Stream中的命令进行消息的添加、消费和确认。</p>
<p><strong>场景：</strong></p>
<p>以一个在线订单系统为例，当一个用户下单时，订单详细信息被添加到一个名为“orders”的stream中。有一个消费者组叫做“order-processors”，里面有两个消费者：“processor1”和“processor2”。它们的任务是处理这些订单，例如更新库存、发送确认邮件等。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">1. 添加订单</span><br><span class="line">XADD orders * order_id 123 item_id A1 count 2  # 用户A下了一个订单，订单编号为123,买了 2件</span><br><span class="line">&quot;1695103666038-0&quot;</span><br><span class="line">2.创建消费者组</span><br><span class="line">XGROUP CREATE orders order-processors $ MKSTREAM            # 创建一个名为“order-processors”的消费者组，从                    stream 的开始处监听新的订单。</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">3.读取和处理订单</span><br><span class="line"># processor1读取了订单123并开始处理它</span><br><span class="line">XREADGROUP GROUP order-processors processor1 COUNT 1 STREAMS orders &gt;</span><br><span class="line"># 同时，另一个用户B下了一个订单，编号为124</span><br><span class="line">XADD orders * order_id 124 item_id A2 quantity 1</span><br><span class="line"># 然后，processor2 开始读取订单：</span><br><span class="line">XREADGROUP GROUP order-processors processor2 COUNT 1 STREAMS orders &gt;</span><br><span class="line"></span><br><span class="line">4.确认订单已处理</span><br><span class="line"># 当processor1成功处理订单123时，它会确认处理完成：</span><br><span class="line">XACK orders order-processors messageID1</span><br><span class="line"># 注意：messageID1是processor1从Stream读取到的订单123的ID。</span><br><span class="line"></span><br><span class="line">5.查看未处理的订单</span><br><span class="line">XPENDING orders order-processors</span><br><span class="line"># 假设processor2由于某种原因暂时不能处理订单124，这时我们会看到订单124尚未被处理。</span><br><span class="line"></span><br><span class="line">6.重新处理失败的订单</span><br><span class="line"># 如果processor2出现故障，processor1可以认领并处理订单124：</span><br><span class="line">XCLAIM orders order-processors processor1 3600000 messageID2</span><br></pre></td></tr></table></figure>

<p>这个简单的在线订购系统例子展示了如何使用Redis Streams进行实时订单处理。这种模式可以确保即使某个消费者失败，订单也能被其他消费者接手并顺利处理。</p>
<h4 id="应用案例-5"><a href="#应用案例-5" class="headerlink" title="应用案例:"></a><strong>应用案例:</strong></h4><p><strong>消息队列</strong></p>
<p>消息队列是一种应用程序之间传递数据的方式。它允许应用程序异步地发送和接收消息，这意味着发送消息的应用程序和接收消息的应用程序无需同时运行。</p>
<p><strong>以在线购物系统的订单处理为例进行说明：</strong></p>
<p>考虑一个在线购物系统。当用户下单时，系统不应该让用户等待直到所有的后端处理（例如库存检查、付款处理、通知仓库等）都完成。相反，一旦订单提交，系统应该立即给用户一个响应，而后端的处理可以稍后进行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#1. 添加订单到队列：</span><br><span class="line">#用户下单后，我们将订单数据添加到名为orders的Redis Stream中。</span><br><span class="line">XADD orders * order_id 101 product_id P01 quantity 3</span><br><span class="line"></span><br><span class="line">#2.处理订单：</span><br><span class="line"># 后台有多个workers（进程），它们不断地监听新的订单，并进行处理。这些worke 可以是分布在多台机器上的多个进程。</span><br><span class="line"></span><br><span class="line">首先，我们创建一个消费者组：</span><br><span class="line">XGROUP CREATE orders order-processors $ MKSTREAM</span><br><span class="line"></span><br><span class="line">接着，一个worker可以开始读取并处理订单：</span><br><span class="line">XREADGROUP GROUP order-processors worker1 COUNT 1 STREAMS orders &gt;</span><br><span class="line"># 这里，worker1是处理订单的消费者名称。&gt;意味着从最新的消息开始读取。</span><br><span class="line"></span><br><span class="line">确认订单处理完成：</span><br><span class="line">一旦worker1处理完订单，它需要确认该订单已被处理：</span><br><span class="line">XACK orders order-processors &lt;messageID&gt;    # 其中，&lt;messageID&gt;是在步骤1中Redis生成的订单ID。 </span><br></pre></td></tr></table></figure>

<p>通过此例子，我们展示了如何使用 Redis Stream 作为消息队列，来异步处理在线购物系统中的订单。这种结构确保了用户下单后能够迅速得到响应，同时订单处理也能在后台高效地进行。</p>
<p><strong>事件日志</strong></p>
<p>事件日志就是记录系统或应用中发生的各种事件，如用户操作、系统异常等。</p>
<p><strong>事件日志的常见应用是在电商平台中记录用户的购物行为。</strong></p>
<p>假设你运营一个电商平台，每当用户浏览、搜索、点击、购买或者评论商品时，都会产生一个事件。你可以使用Redis Streams来记录这些事件。<strong>基于这些事件，可以做一些实时分析，比如：分析用户的购物模式和偏好，为他们提供更相关的商品推荐。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1.浏览商品:</span><br><span class="line">事件：商品浏览</span><br><span class="line">数据：用户ID，商品ID，浏览时间，来源页面等。</span><br><span class="line">XADD user-activity * event &quot;商品浏览&quot; userID &quot;12345&quot; productID &quot;abcd&quot; timestamp &quot;1632067200&quot; source &quot;主页&quot;</span><br><span class="line">2.搜索商品:</span><br><span class="line">事件：商品搜索</span><br><span class="line">数据：用户ID，搜索关键词，搜索时间，搜索结果数等。</span><br><span class="line">XADD user-activity * event &quot;商品搜索&quot; userID &quot;12345&quot; keyword &quot;运动鞋&quot; timestamp &quot;1632067250&quot; results &quot;50&quot;</span><br><span class="line">3.点击商品:</span><br><span class="line">事件：商品点击</span><br><span class="line">数据：用户ID，商品ID，点击时间。</span><br><span class="line">XADD user-activity * event &quot;商品点击&quot; userID &quot;12345&quot; productID &quot;abcd&quot; timestamp &quot;1632067300&quot;</span><br><span class="line">4.购买商品:</span><br><span class="line">事件：商品购买</span><br><span class="line">数据：用户ID，商品ID，购买数量，总价，购买时间。</span><br><span class="line">XADD user-activity * event &quot;商品购买&quot; userID &quot;12345&quot; productID &quot;abcd&quot; quantity &quot;2&quot; total &quot;200&quot; timestamp &quot;1632067400&quot;</span><br><span class="line">5.商品评价:</span><br><span class="line">事件：商品评价</span><br><span class="line">数据：用户ID，商品ID，评分，评论内容，评价时间。</span><br><span class="line">XADD user-activity * event &quot;商品评价&quot; userID &quot;12345&quot; productID &quot;abcd&quot; rating &quot;5&quot; review &quot;非常满意&quot; timestamp &quot;1632067500&quot;</span><br></pre></td></tr></table></figure>

<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a><strong>总结：</strong></h2><p>在上文，我们深入探讨了 Redis 的九种对象类型，包括字符串(String)、列表(List)、哈希(Hash)、集合(Set)、有序集合(Sorted Set)、Bitmaps、HyperLogLog、Geospatial 和 Stream。</p>
<p><strong>这里简单总结下各种数据结构的使用场景：</strong></p>
<ul>
<li><strong>字符串对象</strong>是最简单的数据类型，适用于缓存、临时存储等场景。</li>
<li><strong>列表对象</strong>提供了队列的实现，非常适合消息队列和栈的应用。</li>
<li><strong>哈希对象</strong>是存储对象属性的理想选择，适用于存储和访问对象。</li>
<li><strong>集合对象和有序集合对象</strong>适用于存储不重复元素，其中有序集合还可以进行排名和范围查询。</li>
<li><strong>Bitmaps和 HyperLogLog</strong> 提供了高效的计数和统计功能。</li>
<li><strong>Geospatial</strong> 允许进行地理位置的存储和查询。</li>
<li><strong>Stream</strong> 为构建复杂的消息传递提供了基础。</li>
</ul>
<p>Redis 作为一个高性能的键值数据库，已经成为现代应用开发不可或缺的组成部分。通过深入了解 Redis 的各种对象及其编码方式，我们不仅可以更加高效地利用其提供的功能，还能针对不同的应用场景选择最适合的对象类型，从而优化我们的应用性能和资源使用。</p>
<p>本篇文章旨在为大家提供一个关于 Redis 各个对象的全面指南，从基本概念到内部实现，再到实际应用案例。不管您是刚开始接触 Redis 还是已经有很多经验，希望本文都能为您带来新的启示。</p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a><strong>最后</strong></h3><p>如果你对 Linux C&#x2F;C++ 编程，Redis 等后端技术感兴趣或者想学习计算机原理相关的知识，不妨关注我的公众号「跟着小康学编程」**。这里不仅有丰富的学习资源，还有持续更新的简单易懂的技术文章。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p>
<p>另外，小康最近创建了一个技术交流群，专门用来探讨技术相关或者解答读者的问题。大家在阅读这篇文章的时候，如果觉得有问题的或者有不理解的知识点，欢迎大家加群或者评论区询问。我能够解决的，尽量给大家回复。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h3><p>[1]Redis分布式锁到底安全吗？: <em><a target="_blank" rel="noopener" href="http://kaito-kidd.com/2021/06/08/is-redis-distributed-lock-really-safe/">http://kaito-kidd.com/2021/06/08/is-redis-distributed-lock-really-safe/</a></em></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">小康</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/RedisObject/">http://example.com/RedisObject/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">跟着小康学编程</a>！</span></div></div><!-- 添加赞赏二维码--><div class="reward-container" style="text-align: center; margin-top: 20px;"><div class="reward-item" style="display: inline-block; margin: 10px;"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/wechat.jpg" alt="请作者喝咖啡" style="width: 150px; height: 150px;"><div>请作者喝咖啡</div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Redis%E5%9F%BA%E7%A1%80/">Redis基础</a><a class="post-meta__tags" href="/tags/Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">Redis数据类型</a><a class="post-meta__tags" href="/tags/Redis%E6%A1%88%E4%BE%8B/">Redis案例</a><a class="post-meta__tags" href="/tags/%E9%94%AE%E5%80%BC%E5%AD%98%E5%82%A8/">键值存储</a></div><div class="post_share"><div class="social-share" data-image="/img/me.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/RedisPersistence/" title="全面解析 Redis 持久化：RDB、AOF与混合持久化"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">全面解析 Redis 持久化：RDB、AOF与混合持久化</div></div></a></div><div class="next-post pull-right"><a href="/LinuxCmd/" title="Linux 命令入门指南：快速掌握基础命令"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Linux 命令入门指南：快速掌握基础命令</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/me.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">小康</div><div class="author-info__description">程序猿一枚，也是一名编程狂热者</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">49</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">18</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://xiaokang2024.github.io/xiaokangvx/"><i class="fab fa-weixin"></i><span>关注跟着小康学编程</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/xiaokang2024" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="https://www.zhihu.com/people/jkhenryer" target="_blank" title="&quot;知乎&quot;"><i class="iconfont icon-zhihu" style="color: #0084ff;"></i></a><a class="social-icon" href="https://xiaokang2024.github.io/images/xiaokang-weixin.png" target="_blank" title="&quot;WeChat&quot;"><i class="iconfont icon-weixin" style="color: #1aad19;"></i></a><a class="social-icon" href="https://xiaokang2024.github.io/images/xiaokanggzh.png" target="_blank" title="&quot;微信公众号&quot;"><i class="iconfont icon-weixingongzhonghao" style="color: #07C160;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎访问我的编程学习网站！关注我的微信公众号「跟着小康学编程」，不错过任何更新和独家内容！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis-%E5%AF%B9%E8%B1%A1%EF%BC%9A"><span class="toc-number">1.</span> <span class="toc-text">Redis 对象：</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%BC%96%E7%A0%81"><span class="toc-number">1.1.</span> <span class="toc-text">对象的类型与编码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.1.</span> <span class="toc-text">类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A0%81"><span class="toc-number">1.1.2.</span> <span class="toc-text">编码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E7%B1%BB"><span class="toc-number">1.2.</span> <span class="toc-text">分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.2.1.</span> <span class="toc-text">字符串对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%EF%BC%9A"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">基本概念：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%9B%BE%E8%A7%A3"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">简单图解:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">内部实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String-%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BC%96%E7%A0%81"><span class="toc-number">1.2.1.4.</span> <span class="toc-text">String 对象的编码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4%EF%BC%9A"><span class="toc-number">1.2.1.5.</span> <span class="toc-text">常见命令：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B"><span class="toc-number">1.2.1.6.</span> <span class="toc-text">应用案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.2.2.</span> <span class="toc-text">列表对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%9B%BE%E8%A7%A3-1"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">简单图解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">内部实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4%EF%BC%9A-1"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">常见命令：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B%EF%BC%9A"><span class="toc-number">1.2.2.5.</span> <span class="toc-text">应用案例：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.2.3.</span> <span class="toc-text">哈希对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-1"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%9B%BE%E8%A7%A3%EF%BC%9A"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">简单图解：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0-2"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">内部实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4"><span class="toc-number">1.2.3.4.</span> <span class="toc-text">常见命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B-1"><span class="toc-number">1.2.3.5.</span> <span class="toc-text">应用案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.2.4.</span> <span class="toc-text">集合对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%EF%BC%9A-1"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">基本概念：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%9B%BE%E8%A7%A3-2"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">简单图解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0-3"><span class="toc-number">1.2.4.3.</span> <span class="toc-text">内部实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4-1"><span class="toc-number">1.2.4.4.</span> <span class="toc-text">常见命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B-2"><span class="toc-number">1.2.4.5.</span> <span class="toc-text">应用案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.2.5.</span> <span class="toc-text">有序集合对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%EF%BC%9A-2"><span class="toc-number">1.2.5.1.</span> <span class="toc-text">基本概念：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%9B%BE%E8%A7%A3-3"><span class="toc-number">1.2.5.2.</span> <span class="toc-text">简单图解:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0-4"><span class="toc-number">1.2.5.3.</span> <span class="toc-text">内部实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4-2"><span class="toc-number">1.2.5.4.</span> <span class="toc-text">常见命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B-3"><span class="toc-number">1.2.5.5.</span> <span class="toc-text">应用案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bitmaps"><span class="toc-number">1.2.6.</span> <span class="toc-text">Bitmaps</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%EF%BC%9A-3"><span class="toc-number">1.2.6.1.</span> <span class="toc-text">基本概念：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%9B%BE%E8%A7%A3-4"><span class="toc-number">1.2.6.2.</span> <span class="toc-text">简单图解:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0-5"><span class="toc-number">1.2.6.3.</span> <span class="toc-text">内部实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%EF%BC%9A"><span class="toc-number">1.2.6.4.</span> <span class="toc-text">基本命令：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E6%A1%88%E5%88%97%EF%BC%9A"><span class="toc-number">1.2.6.5.</span> <span class="toc-text">应用案列：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HyperLogLog"><span class="toc-number">1.2.7.</span> <span class="toc-text">HyperLogLog</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%EF%BC%9A-4"><span class="toc-number">1.2.7.1.</span> <span class="toc-text">基本概念：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%9B%BE%E8%A7%A3%EF%BC%9A-1"><span class="toc-number">1.2.7.2.</span> <span class="toc-text">简单图解：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0-6"><span class="toc-number">1.2.7.3.</span> <span class="toc-text">内部实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%EF%BC%9A-1"><span class="toc-number">1.2.7.4.</span> <span class="toc-text">基本命令：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B%EF%BC%9A-1"><span class="toc-number">1.2.7.5.</span> <span class="toc-text">应用案例：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Geospatial"><span class="toc-number">1.2.8.</span> <span class="toc-text">Geospatial</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%EF%BC%9A-5"><span class="toc-number">1.2.8.1.</span> <span class="toc-text">基本概念：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%9B%BE%E8%A7%A3-5"><span class="toc-number">1.2.8.2.</span> <span class="toc-text">简单图解:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0-7"><span class="toc-number">1.2.8.3.</span> <span class="toc-text">内部实现:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4"><span class="toc-number">1.2.8.4.</span> <span class="toc-text">基本命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B-4"><span class="toc-number">1.2.8.5.</span> <span class="toc-text">应用案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Stream"><span class="toc-number">1.2.9.</span> <span class="toc-text">Stream</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-2"><span class="toc-number">1.2.9.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Stream-%E5%9F%BA%E6%9C%AC%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.2.9.2.</span> <span class="toc-text">Stream 基本组件介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%9B%BE%E8%A7%A3-6"><span class="toc-number">1.2.9.3.</span> <span class="toc-text">简单图解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0-8"><span class="toc-number">1.2.9.4.</span> <span class="toc-text">内部实现:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4-1"><span class="toc-number">1.2.9.5.</span> <span class="toc-text">基本命令:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B-5"><span class="toc-number">1.2.9.6.</span> <span class="toc-text">应用案例:</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-number">1.3.</span> <span class="toc-text">总结：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%90%8E"><span class="toc-number">1.3.1.</span> <span class="toc-text">最后</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">1.3.2.</span> <span class="toc-text">参考资料</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/RedisCluster/" title="Redis 架构解析：从主从复制到哨兵和集群模式">Redis 架构解析：从主从复制到哨兵和集群模式</a><time datetime="2024-04-30T06:29:21.248Z" title="发表于 2024-04-30 14:29:21">2024-04-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/RedisPersistence/" title="全面解析 Redis 持久化：RDB、AOF与混合持久化">全面解析 Redis 持久化：RDB、AOF与混合持久化</a><time datetime="2024-04-30T03:34:53.707Z" title="发表于 2024-04-30 11:34:53">2024-04-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/RedisObject/" title="Redis入门指南：掌握常见数据类型">Redis入门指南：掌握常见数据类型</a><time datetime="2024-04-30T01:51:28.581Z" title="发表于 2024-04-30 09:51:28">2024-04-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/LinuxCmd/" title="Linux 命令入门指南：快速掌握基础命令">Linux 命令入门指南：快速掌握基础命令</a><time datetime="2024-04-29T03:16:29.040Z" title="发表于 2024-04-29 11:16:29">2024-04-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/techbooks/" title="必读：2024年度最佳计算机编程书籍推荐">必读：2024年度最佳计算机编程书籍推荐</a><time datetime="2024-04-28T10:04:54.216Z" title="发表于 2024-04-28 18:04:54">2024-04-28</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 小康</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.8.8/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'yNXYnuxkePack1IfO9FTTxA9-gzGzoHsz',
      appKey: 'bs6gdkXWDYvN826BUX5Xl53U',
      avatar: 'monsterid',
      serverURLs: 'https://ynxynuxk.lc-cn-n1-shared.com',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: true
    }, null))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await getScript('https://cdn.jsdelivr.net/npm/valine@1.5.1/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Valine' === 'Valine' || !true) {
    if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script></div><script src="/js/wechat.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>