<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>IP 面试题 — 对称加密与非对称加密的区别？</title>
      <link href="/encryption-differences/"/>
      <url>/encryption-differences/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康。</p><p>今天给大家分享一个 IP 面试题 ：<strong>对称加密与非对称加密的区别？</strong></p><blockquote><p><strong>小技巧</strong>：在面试中，可以参考下面的<strong>示例回答</strong>，这样回答简洁明了。<strong>详细介绍</strong>部分则是为了帮助大家系统学习，以便应对面试官深入提问。</p></blockquote><h3 id="示例回答"><a href="#示例回答" class="headerlink" title="示例回答"></a>示例回答</h3><p>对称加密使用同一个密钥进行加密和解密，速度快但密钥管理复杂；非对称加密使用一对公钥和私钥，公钥加密，私钥解密，密钥管理简单但速度较慢。在HTTPS中，非对称加密用于交换对称加密的密钥，然后用对称加密进行实际数据传输。</p><hr><h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><h4 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h4><p>对称加密是最传统的加密方式，它使用同一个密钥对数据进行加密和解密。常见的对称加密算法有AES、DES等。</p><ol><li><strong>密钥相同</strong>：</li></ol><ul><li>加密和解密使用同一个密钥。</li></ul><ol start="2"><li><strong>速度快</strong>：</li></ol><ul><li>对称加密算法计算简单，处理速度快，适合大数据量的加密。</li></ul><ol start="3"><li><strong>密钥管理复杂</strong>：</li></ol><ul><li>因为加密和解密都使用同一个密钥，密钥需要在通信双方之间安全地传输和存储。一旦密钥泄露，数据安全就无法保证。</li></ul><h4 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h4><p>非对称加密，也称公钥加密，它使用一对密钥：公钥和私钥。常见的非对称加密算法有RSA、ECC等。</p><ol><li><strong>密钥不同</strong>：</li></ol><ul><li>加密和解密使用不同的密钥：公钥加密，私钥解密。</li></ul><ol start="2"><li><strong>密钥管理简单</strong>：</li></ol><ul><li>公钥可以公开，私钥需保密。因为公钥不能解密数据，所以即使公钥泄露，数据安全也能保证。</li></ul><ol start="3"><li><strong>速度较慢</strong>：</li></ol><ul><li>非对称加密算法计算复杂，处理速度较慢，通常用于加密小数据量或对称加密的密钥。</li></ul><h4 id="在HTTPS中的应用"><a href="#在HTTPS中的应用" class="headerlink" title="在HTTPS中的应用"></a>在HTTPS中的应用</h4><p>HTTPS（HyperText Transfer Protocol Secure）结合了对称加密和非对称加密的优点，确保数据在网络上传输时的安全性。</p><ol><li><strong>非对称加密</strong>：</li></ol><ul><li>在HTTPS连接建立初期，客户端（浏览器）和服务器使用非对称加密进行密钥交换。<ul><li>服务器向客户端发送其公钥，客户端生成一个对称密钥，用服务器的公钥加密后发送给服务器。</li></ul></li></ul><ol start="2"><li><strong>对称加密</strong>：</li></ol><ul><li>一旦对称密钥被安全交换，接下来的数据传输就使用对称加密进行。这是因为对称加密速度快，适合大数据量的加密。</li></ul><ol start="3"><li><strong>数据安全</strong>：</li></ol><ul><li>非对称加密确保密钥交换的安全性，对称加密确保数据传输的效率和安全性。两者结合，使HTTPS既安全又高效。</li></ul><h4 id="举例说明："><a href="#举例说明：" class="headerlink" title="举例说明："></a>举例说明：</h4><p>假设你在浏览器中访问一个HTTPS网站：</p><ol><li><strong>非对称加密</strong>：浏览器与服务器建立连接，服务器发送公钥给浏览器。浏览器生成一个对称密钥，用服务器的公钥加密后发送给服务器。</li><li><strong>对称加密</strong>：服务器用私钥解密获得对称密钥，然后双方使用这个对称密钥加密和解密传输的数据。</li></ol><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>对称加密和非对称加密的主要区别在于密钥的使用和管理方式。对称加密速度快但密钥管理复杂，非对称加密密钥管理简单但速度较慢。在HTTPS中，非对称加密用于安全地交换对称加密的密钥，然后用对称加密进行高效的数据传输。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h2><p>欢迎大家关注我的微信公众号「<strong>跟着小康学编程</strong>」！本号致力于分享<strong>C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习、计算机基础原理、Linux 编程、数据库、微服务、容器技术</strong> 等内容。文章力求通俗易懂，并配有代码示例，方便初学者理解。如果您对这些内容感兴趣，欢迎关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p>后续，我还会陆续分享各个方向的编程面试题，包括<strong>C&#x2F;C++、Java、Go，以及操作系统、计算机网络、数据结构、数据库和微服务</strong>等领域，为大家的面试提供帮助。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络面试 </tag>
            
            <tag> IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IP 面试题 — IP路由是如何决定数据包的传输路径的？</title>
      <link href="/how-ip-routing-decides-packet-paths/"/>
      <url>/how-ip-routing-decides-packet-paths/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康。</p><p>今天给大家分享一个 IP 面试题 ：<strong>IP路由是如何决定数据包的传输路径的？</strong></p><blockquote><p><strong>小技巧</strong>：在面试中，可以参考下面的<strong>示例回答</strong>，这样回答简洁明了。<strong>详细介绍</strong>部分则是为了帮助大家系统学习，以便应对面试官深入提问。</p></blockquote><h3 id="示例回答"><a href="#示例回答" class="headerlink" title="示例回答"></a>示例回答</h3><p>IP路由通过路由表决定数据包的传输路径。路由器检查数据包的目标IP地址，与路由表中的条目进行匹配，然后将数据包转发到下一跳路由器或最终目的地。</p><hr><h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><h4 id="IP路由的工作原理"><a href="#IP路由的工作原理" class="headerlink" title="IP路由的工作原理"></a>IP路由的工作原理</h4><p>IP路由决定数据包传输路径的过程主要依赖于路由器和路由表。路由表是路由器中存储的一组规则，用于确定如何将数据包转发到其最终目的地。</p><ol><li><strong>检查目标IP地址</strong>：</li></ol><ul><li>当一个数据包到达路由器时，路由器首先查看数据包的目标IP地址。</li></ul><ol start="2"><li><strong>查找路由表</strong>：</li></ol><ul><li>路由器将目标IP地址与路由表中的条目进行匹配。路由表中的每个条目包含一个目标网络前缀和一个下一跳地址。</li><li>路由表还可能包含不同的条目，如直接连接的网络、静态路由和动态路由协议学习到的路由。</li></ul><ol start="3"><li><strong>选择最佳路径</strong>：</li></ol><ul><li>路由器根据最长前缀匹配原则选择最佳路径。最长前缀匹配是指路由表中与目标IP地址匹配的条目中，网络前缀最长的条目优先。</li><li>例如，如果目标IP地址是192.168.1.10，路由表中有两个条目：192.168.1.0&#x2F;24和192.168.0.0&#x2F;16，路由器会选择192.168.1.0&#x2F;24，因为它的前缀更长，更具体。</li></ul><ol start="4"><li><strong>转发数据包</strong>：</li></ol><ul><li>根据选定的路由条目，路由器将数据包转发到下一跳路由器或直接到达最终目的地。</li><li>下一跳路由器会重复上述步骤，直到数据包到达最终目的地。</li></ul><h4 id="示例说明"><a href="#示例说明" class="headerlink" title="示例说明"></a>示例说明</h4><p>假设你在家里的电脑上访问一个远程服务器：</p><ol><li><strong>目标IP地址检查</strong>：</li></ol><ul><li>你的电脑生成一个数据包，目标IP地址是远程服务器的IP地址，比如203.0.113.10。</li></ul><ol start="2"><li><strong>查找路由表</strong>：</li></ol><ul><li>家里的路由器接收到这个数据包后，会检查它的路由表，看哪个条目最匹配203.0.113.10。</li></ul><ol start="3"><li><strong>选择最佳路径</strong>：</li></ol><ul><li>假设路由表中有两个条目：203.0.113.0&#x2F;24和0.0.0.0&#x2F;0（默认路由），路由器会选择203.0.113.0&#x2F;24，因为它更具体。</li></ul><ol start="4"><li><strong>转发数据包</strong>：</li></ol><ul><li>路由器根据匹配的条目，将数据包转发到下一跳，比如你的ISP的路由器。</li><li>ISP的路由器接收到数据包后，重复同样的过程，直到数据包到达目标服务器。</li></ul><h4 id="形象比喻"><a href="#形象比喻" class="headerlink" title="形象比喻"></a>形象比喻</h4><p>可以将IP路由比作导航系统：</p><ul><li><strong>检查目标地址</strong>：就像你输入导航目的地地址。</li><li><strong>查找最佳路线</strong>：导航系统查看地图数据库，找到最匹配的路径。</li><li><strong>选择最佳路径</strong>：选择最优路线，例如高速公路。</li><li><strong>转发数据包</strong>：按照选择的路线行驶，途中可能经过多个出口（路由器），最终到达目的地。</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>IP路由通过路由表决定数据包的传输路径，确保数据包按照最优路径从源设备到达目标设备。理解IP路由的工作原理，有助于理解网络数据传输的效率和可靠性。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h2><p>欢迎大家关注我的微信公众号「<strong>跟着小康学编程</strong>」！本号致力于分享<strong>C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习、计算机基础原理、Linux 编程、数据库、微服务、容器技术</strong> 等内容。文章力求通俗易懂，并配有代码示例，方便初学者理解。如果您对这些内容感兴趣，欢迎关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p>后续，我还会陆续分享各个方向的编程面试题，包括<strong>C&#x2F;C++、Java、Go，以及操作系统、计算机网络、数据结构、数据库和微服务</strong>等领域，为大家的面试提供帮助。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络面试 </tag>
            
            <tag> IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IP 面试题 — TCP分段和IP分片有何不同？TCP分段丢失或者IP分片数据丢失的话，重传的是整个数据还只是分段数据？</title>
      <link href="/tcp-segmentation-and-ip-fragmentation-detail/"/>
      <url>/tcp-segmentation-and-ip-fragmentation-detail/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康。</p><p>今天给大家分享一个 IP 面试题 ：<strong>TCP分段和IP分片有何不同？TCP分段丢失或者IP分片数据丢失的话，重传的是整个数据还只是分段数据？</strong></p><blockquote><p><strong>小技巧</strong>：在面试中，可以参考下面的<strong>示例回答</strong>，这样回答简洁明了。<strong>详细介绍</strong>部分则是为了帮助大家系统学习，以便应对面试官深入提问。</p></blockquote><h3 id="示例回答"><a href="#示例回答" class="headerlink" title="示例回答"></a>示例回答</h3><p>TCP 分段和 IP 分片的区别在于层次和目的。TCP 分段在传输层进行，目的是将数据流分成可管理的段，每个段都有序列号。IP 分片在网络层进行，当数据包大小超过路径上的 MTU 时，将其分成更小的片段。TCP 分段丢失时，只需重传丢失的段；而 IP 分片丢失时，需要重传整个数据包。</p><hr><h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><h4 id="TCP-分段和-IP-分片的区别"><a href="#TCP-分段和-IP-分片的区别" class="headerlink" title="TCP 分段和 IP 分片的区别"></a>TCP 分段和 IP 分片的区别</h4><ol><li><strong>层次和目的</strong>：</li></ol><ul><li><strong>TCP 分段</strong>：在传输层进行，目的是将数据流分成多个段，每个段都有一个序列号。这样接收端可以按照序列号将段重组为原始数据流。每个段的大小由 MSS（最大报文段长度）决定，这是在连接建立时由双方协商的。</li><li><strong>IP 分片</strong>：在网络层进行，当数据包的大小超过路径上的 MTU（最大传输单元）时，将其分成更小的片段。每个片段都有自己的 IP 头部信息，包括标识符、片段偏移量和更多片段标志，以便接收端重新组装原始数据包。</li></ul><ol start="2"><li><strong>重传机制</strong>：</li></ol><ul><li><strong>TCP 分段丢失</strong>：如果一个 TCP 段在传输过程中丢失，TCP 协议会通过重传机制仅重传丢失的段。这是因为 TCP 提供可靠的传输服务，能够检测到丢失的段并请求发送端重传。</li><li><strong>IP 分片丢失</strong>：如果一个 IP 片段在传输过程中丢失，整个数据包都需要重传。这是因为 IP 层本身不具备可靠性，无法单独重传丢失的片段。接收端在检测到片段丢失后，会丢弃整个数据包，并依靠传输层（如 TCP）来处理重传。</li></ul><h4 id="形象比喻"><a href="#形象比喻" class="headerlink" title="形象比喻"></a>形象比喻</h4><p>可以将 TCP 分段和 IP 分片比作邮寄大件物品：</p><ul><li><strong>TCP 分段</strong>：相当于将大件物品分成多个包裹，每个包裹都有标识和顺序信息。如果某个包裹丢失，只需重新邮寄丢失的包裹。</li><li><strong>IP 分片</strong>：如果这些包裹在运输过程中需要经过狭窄的街道，需要进一步将包裹拆成更小的包裹。如果某个小包裹丢失，收件人无法组装完整的物品，需要重新邮寄整个物品。</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>真正理解 TCP 分段和 IP 分片的求职者应该能够清楚地解释以下几点：</p><ol><li><strong>层次和目的</strong>：TCP 分段在传输层进行，将数据流分成可管理的段；IP 分片在网络层进行，确保数据包能够通过网络链路。</li><li><strong>重传机制</strong>：TCP 分段丢失时，仅重传丢失的段；IP 分片丢失时，需要重传整个数据包。</li></ol><h2 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h2><p>欢迎大家关注我的微信公众号「<strong>跟着小康学编程</strong>」！本号致力于分享<strong>C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习、计算机基础原理、Linux 编程、数据库、微服务、容器技术</strong> 等内容。文章力求通俗易懂，并配有代码示例，方便初学者理解。如果您对这些内容感兴趣，欢迎关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p>后续，我还会陆续分享各个方向的编程面试题，包括<strong>C&#x2F;C++、Java、Go，以及操作系统、计算机网络、数据结构、数据库和微服务</strong>等领域，为大家的面试提供帮助。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络面试 </tag>
            
            <tag> IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IP 面试题 — MTU（最大传输单元）是什么？为什么它很重要？</title>
      <link href="/what-mtu/"/>
      <url>/what-mtu/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康。</p><p>今天给大家分享一个 IP 面试题 ：<strong>MTU（最大传输单元）是什么？为什么它很重要？</strong></p><blockquote><p><strong>小技巧</strong>：在面试中，可以参考下面的<strong>示例回答</strong>，这样回答简洁明了。<strong>详细介绍</strong>部分则是为了帮助大家系统学习，以便应对面试官深入提问。</p></blockquote><h3 id="示例回答"><a href="#示例回答" class="headerlink" title="示例回答"></a>示例回答</h3><p>MTU（最大传输单元）是指网络链路上能够传输的最大数据包大小。它很重要，因为如果数据包超过了MTU，就需要进行分片，这会增加开销和延迟。</p><hr><h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><h4 id="什么是-MTU？"><a href="#什么是-MTU？" class="headerlink" title="什么是 MTU？"></a>什么是 MTU？</h4><p>MTU（Maximum Transmission Unit）是指在网络链路上传输的单个数据包的最大字节大小。不同的网络链路和设备有不同的 MTU 值，常见的以太网 MTU 是 1500 字节。</p><h4 id="为什么-MTU-很重要？"><a href="#为什么-MTU-很重要？" class="headerlink" title="为什么 MTU 很重要？"></a>为什么 MTU 很重要？</h4><ol><li><strong>避免分片</strong>：</li></ol><ul><li><strong>分片开销</strong>：如果数据包的大小超过了路径上某个链路的 MTU，数据包就需要进行分片。每个片段都需要额外的 IP 头部信息，这增加了网络开销。</li><li><strong>性能影响</strong>：分片增加了传输的复杂性和延迟。如果一个片段丢失，需要重新发送整个数据包，影响传输效率。</li></ul><ol start="2"><li><strong>提高传输效率</strong>：</li></ol><ul><li><strong>优化传输</strong>：选择合适的 MTU 可以优化数据传输效率，减少开销和延迟。在 MTU 范围内传输的数据包可以更快地通过网络，而不需要分片和重组。</li><li><strong>避免丢包</strong>：适当设置 MTU 可以减少因数据包过大而导致的丢包现象，从而提高传输的可靠性。</li></ul><ol start="3"><li><strong>网络协议的设计</strong>：</li></ol><ul><li><strong>协议适配</strong>：许多网络协议在设计时都会考虑 MTU 的大小。例如，TCP 协议会根据路径 MTU（PMTU）来调整数据包的大小，避免数据包被分片。</li><li><strong>一致性</strong>：确保网络路径上的所有设备都能处理特定大小的数据包，避免因 MTU 不一致导致的数据包丢失或延迟。</li></ul><h4 id="形象比喻"><a href="#形象比喻" class="headerlink" title="形象比喻"></a>形象比喻</h4><p>可以将 MTU 比作公路上的限高杆：</p><ul><li><strong>限高杆</strong>：就像 MTU，决定了车辆（数据包）能够通过的最大高度（大小）。</li><li><strong>车辆高度</strong>：如果车辆高度超过了限高杆，需要卸货（分片）才能通过。</li><li><strong>优化运输</strong>：选择适当的车辆高度，确保顺利通过限高杆，避免卸货带来的额外时间和成本。</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>理解 MTU 的重要性需要掌握以下几点：</p><ol><li><strong>定义</strong>：MTU 是网络链路上能够传输的最大数据包大小。</li><li><strong>避免分片</strong>：如果数据包大小超过 MTU 需要进行分片，这会增加开销和延迟。</li><li><strong>提高效率</strong>：适当的 MTU 设置可以优化传输效率，减少丢包，提高传输可靠性。</li><li><strong>网络协议适配</strong>：许多网络协议会根据 MTU 来调整数据包大小，确保传输顺利。</li></ol><h2 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h2><p>欢迎大家关注我的微信公众号「<strong>跟着小康学编程</strong>」！本号致力于分享<strong>C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习、计算机基础原理、Linux 编程、数据库、微服务、容器技术</strong> 等内容。文章力求通俗易懂，并配有代码示例，方便初学者理解。如果您对这些内容感兴趣，欢迎关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p>后续，我还会陆续分享各个方向的编程面试题，包括<strong>C&#x2F;C++、Java、Go，以及操作系统、计算机网络、数据结构、数据库和微服务</strong>等领域，为大家的面试提供帮助。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络面试 </tag>
            
            <tag> IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IP 面试题 — TCP层已经进行了分段，IP层还会进行分片吗？</title>
      <link href="/tcp-segmentation-and-ip-fragmentation/"/>
      <url>/tcp-segmentation-and-ip-fragmentation/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康。</p><p>今天给大家分享一个 IP 面试题 ：<strong>TCP层已经进行了分段，IP层还会进行分片吗？</strong></p><blockquote><p><strong>小技巧</strong>：在面试中，可以参考下面的<strong>示例回答</strong>，这样回答简洁明了。<strong>详细介绍</strong>部分则是为了帮助大家系统学习，以便应对面试官深入提问。</p></blockquote><h3 id="示例回答"><a href="#示例回答" class="headerlink" title="示例回答"></a>示例回答</h3><p>是的，尽管 TCP 层已经进行了分段，但 IP 层仍可能需要分片。如果 TCP 分段后的数据包仍然大于路径上的 MTU（最大传输单元），IP 层会将这些数据包进一步分片，以确保它们能够通过网络传输。</p><hr><h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><h4 id="TCP-分段和-IP-分片的区别"><a href="#TCP-分段和-IP-分片的区别" class="headerlink" title="TCP 分段和 IP 分片的区别"></a>TCP 分段和 IP 分片的区别</h4><ul><li><strong>TCP 分段</strong>：在传输层，TCP 协议将数据流分成多个段，每个段都有一个序列号，用于确保数据能按正确顺序重组。每个段的大小由 MSS（最大报文段长度）决定，这是在连接建立时由双方协商的。</li><li><strong>IP 分片</strong>：在网络层，IP 协议根据网络路径上的 MTU 限制，将超出 MTU 的数据包分成更小的片段。这是为了确保数据包能够通过所有网络链路，因为不同的网络设备和链路有不同的 MTU 值，通常为 1500 字节。</li></ul><h4 id="为什么-IP-层仍需要分片？"><a href="#为什么-IP-层仍需要分片？" class="headerlink" title="为什么 IP 层仍需要分片？"></a>为什么 IP 层仍需要分片？</h4><ol><li><strong>MTU 限制</strong>：</li></ol><ul><li><strong>MTU（最大传输单元）</strong>：每个网络链路和设备都有一个 MTU 值，表示可以传输的最大数据包大小。如果数据包的大小超过了某个链路的 MTU，数据包将无法通过该链路。</li><li><strong>解决方案</strong>：当 TCP 分段后的数据包大小仍然超过某个链路的 MTU 时，IP 层会将这些数据包进一步分片，以确保数据能够顺利传输。</li></ul><ol start="2"><li><strong>网络层的职责</strong>：</li></ol><ul><li><strong>IP 层独立性</strong>：IP 层独立于传输层工作，负责确保数据包能够在不同的网络环境中传输。即使 TCP 层已经进行了分段，IP 层仍可能需要根据网络路径上的 MTU 进行分片。</li><li><strong>路由器处理</strong>：当数据包在路由器之间传输时，如果发现数据包大小超过了某个链路的 MTU，路由器会对数据包进行分片。</li></ul><h4 id="形象比喻"><a href="#形象比喻" class="headerlink" title="形象比喻"></a>形象比喻</h4><p>可以将 TCP 分段和 IP 分片比作邮寄大件物品：</p><ul><li><strong>TCP 分段</strong>：相当于将一个大物品分成多个包裹，每个包裹都有标识和顺序信息，以便接收方能够按正确顺序重组。</li><li><strong>IP 分片</strong>：如果这些包裹仍然太大，不能通过某些运输渠道（如狭窄的街道），需要进一步将包裹再拆分成更小的包裹，以便通过所有运输渠道。</li></ul><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>理解 TCP 分段和 IP 分片的关键在于以下几点：</p><ol><li><strong>TCP 分段</strong>：在传输层进行，将数据流分成多个段，每个段都有序列号。</li><li><strong>IP 分片</strong>：在网络层进行，当数据包超过路径上的 MTU 时，将数据包分成更小的片段。</li><li><strong>MTU 限制</strong>：不同网络链路有不同的 MTU 值，IP 分片确保数据包能通过所有链路。</li></ol><h2 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h2><p>欢迎大家关注我的微信公众号「<strong>跟着小康学编程</strong>」！本号致力于分享<strong>C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习、计算机基础原理、Linux 编程、数据库、微服务、容器技术</strong> 等内容。文章力求通俗易懂，并配有代码示例，方便初学者理解。如果您对这些内容感兴趣，欢迎关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p>后续，我还会陆续分享各个方向的编程面试题，包括<strong>C&#x2F;C++、Java、Go，以及操作系统、计算机网络、数据结构、数据库和微服务</strong>等领域，为大家的面试提供帮助。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络面试 </tag>
            
            <tag> IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IP 面试题 — 什么是多播（Multicast）？它如何工作？</title>
      <link href="/how-multicast-works/"/>
      <url>/how-multicast-works/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康。</p><p>今天给大家分享一个 IP 面试题 ：<strong>什么是多播（Multicast）？它如何工作？</strong></p><blockquote><p><strong>小技巧</strong>：在面试中，可以参考下面的<strong>示例回答</strong>，这样回答简洁明了。<strong>详细介绍</strong>部分则是为了帮助大家系统学习，以便应对面试官深入提问。</p></blockquote><h3 id="示例回答"><a href="#示例回答" class="headerlink" title="示例回答"></a>示例回答</h3><p>多播（Multicast）是一种网络通信方式，允许一个发送方将数据同时传输给多个接收方。它通过特定的多播地址和路由机制，确保数据仅在需要的网络部分传播，提高传输效率。</p><hr><h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><h4 id="什么是多播（Multicast）？"><a href="#什么是多播（Multicast）？" class="headerlink" title="什么是多播（Multicast）？"></a>什么是多播（Multicast）？</h4><p>多播（Multicast）是一种网络通信方式，用于在IP网络中进行一对多或多对多的传输。与单播（Unicast）一对一和广播（Broadcast）一对所有不同，多播允许数据仅发送给特定的一组接收者。这种方式节省了网络带宽，提高了效率。</p><h4 id="多播的工作原理"><a href="#多播的工作原理" class="headerlink" title="多播的工作原理"></a><strong>多播的工作原理</strong></h4><ol><li><strong>多播地址</strong>：</li></ol><ul><li>多播使用特定的IP地址范围，通常在224.0.0.0到239.255.255.255之间。这些地址用于标识多播组。</li><li>任何希望接收多播数据的设备必须加入这个多播组，类似于调到一个特定的频道。</li></ul><ol start="2"><li><strong>加入多播组</strong>：</li></ol><ul><li>设备通过互联网组管理协议（IGMP）向网络上的路由器发送请求，表示要加入或离开一个多播组。</li><li>路由器会维护一个列表，记录有哪些设备加入了哪些多播组。</li></ul><ol start="3"><li><strong>数据传输</strong>：</li></ol><ul><li>当一个发送方（源）发送多播数据包时，这个数据包会被标记为发往特定的多播组地址。</li><li>多播路由器接收到这个数据包后，会查看路由表，确定哪些网络部分需要接收这个数据包，然后将其转发到这些部分。</li><li>这避免了数据包被发送到不需要的网络部分，提高了网络效率。</li></ul><ol start="4"><li><strong>多播路由协议</strong>：</li></ol><ul><li>多播路由协议（如PIM-SM，PIM-DM）帮助路由器建立和维护多播路径，确保数据有效传输到所有接收者。</li><li>这些协议根据网络拓扑和组成员情况，动态调整数据包的传输路径。</li></ul><h4 id="形象比喻："><a href="#形象比喻：" class="headerlink" title="形象比喻："></a>形象比喻：</h4><p>可以将多播比作学校广播系统：</p><ul><li><strong>多播地址</strong>：就像学校的广播频道，只有调到这个频道的教室才能接收到广播内容。</li><li><strong>加入多播组</strong>：学生（设备）通过告知老师（路由器）来决定是否收听广播（加入或离开多播组）。</li><li><strong>数据传输</strong>：广播室（源设备）将消息发送给所有调到这个频道的教室，确保消息只传到需要听的地方，而不打扰其他地方。</li></ul><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>多播是一种高效的网络通信方式，通过使用特定的多播地址和路由机制，使数据仅发送给订阅的接收者，从而节省带宽和资源。理解多播的工作原理，包括多播地址、加入多播组和数据传输过程，能帮助我们更好地利用这种技术，提高网络通信的效率。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h2><p>欢迎大家关注我的微信公众号「<strong>跟着小康学编程</strong>」！本号致力于分享<strong>C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习、计算机基础原理、Linux 编程、数据库、微服务、容器技术</strong> 等内容。文章力求通俗易懂，并配有代码示例，方便初学者理解。如果您对这些内容感兴趣，欢迎关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p>后续，我还会陆续分享各个方向的编程面试题，包括<strong>C&#x2F;C++、Java、Go，以及操作系统、计算机网络、数据结构、数据库和微服务</strong>等领域，为大家的面试提供帮助。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络面试 </tag>
            
            <tag> IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IP 面试题 — CIDR（无类别域间路由）是什么？它如何改进IP寻址？</title>
      <link href="/what-CIDR/"/>
      <url>/what-CIDR/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康。</p><p>今天给大家分享一个 IP 面试题 ：<strong>CIDR（无类别域间路由）是什么？它如何改进IP寻址？</strong></p><blockquote><p><strong>小技巧</strong>：在面试中，可以参考下面的<strong>示例回答</strong>，这样回答简洁明了。<strong>详细介绍</strong>部分则是为了帮助大家系统学习，以便应对面试官深入提问。</p></blockquote><h3 id="示例回答"><a href="#示例回答" class="headerlink" title="示例回答"></a>示例回答</h3><p>CIDR（无类别域间路由）是一种用于IP地址分配和路由的方式。它通过使用可变长度子网掩码代替传统的A、B、C类网络，改进了IP寻址的效率，减少了地址浪费，并简化了路由表。</p><hr><h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><h4 id="CIDR-的定义"><a href="#CIDR-的定义" class="headerlink" title="CIDR 的定义"></a>CIDR 的定义</h4><p>CIDR（Classless Inter-Domain Routing，无类别域间路由）是一种IP地址分配方法，它使用可变长度子网掩码（VLSM），允许更灵活和高效的IP地址分配。CIDR 于1993年引入，以解决传统A、B、C类IP地址分配的局限性。</p><h4 id="CIDR-如何改进-IP-寻址？"><a href="#CIDR-如何改进-IP-寻址？" class="headerlink" title="CIDR 如何改进 IP 寻址？"></a>CIDR 如何改进 IP 寻址？</h4><p><strong>1、更高效的地址分配</strong>：</p><ul><li><strong>传统分类方法</strong>：A类、B类和C类网络的固定子网掩码导致了地址浪费。例如，B类网络有65,536个地址，即使一个网络只需要几百个地址，其余的也不能用于其他目的。</li><li><strong>CIDR 方法</strong>：CIDR 允许使用可变长度子网掩码，可以根据实际需求分配地址。例如，&#x2F;24 表示一个网络有256个地址，而 &#x2F;28 表示一个网络有16个地址。这种灵活性减少了IP地址浪费。</li></ul><p><strong>2、简化路由表</strong>：</p><ul><li><strong>聚合路由</strong>：CIDR 支持路由聚合，即将多个连续的IP地址块合并成一个路由条目。例如，多个 &#x2F;24 网络可以聚合为一个 &#x2F;16 路由条目。这大大减少了路由器需要存储和处理的路由条目数量，提升了路由效率。</li><li><strong>例子</strong>：假设有以下三个网络：192.168.0.0&#x2F;24、192.168.1.0&#x2F;24 和 192.168.2.0&#x2F;24。传统方法需要三个路由条目，而 CIDR 允许将它们合并为一个 192.168.0.0&#x2F;22 路由条目。</li></ul><p><strong>3、网络划分更灵活</strong>：</p><ul><li><strong>VLSM 支持</strong>：CIDR 支持可变长度子网掩码，允许在同一网络中使用不同大小的子网。这样，一个大网络可以根据需要进一步划分为更小的子网，适应不同规模的子网需求。</li><li><strong>例子</strong>：一个 &#x2F;24 网络可以划分为两个 &#x2F;25 网络，或者四个 &#x2F;26 网络，以便更灵活地分配地址。</li></ul><h4 id="形象比喻"><a href="#形象比喻" class="headerlink" title="形象比喻"></a>形象比喻</h4><p>可以将传统的A、B、C类网络比作固定大小的房子，而 CIDR 比作根据需求建造的房子：</p><ul><li><strong>传统分类方法</strong>：像是拥有固定大小的房子，不论你有多少人居住，都必须使用特定大小的房子，导致空间浪费或不足。</li><li><strong>CIDR 方法</strong>：像是根据家庭成员数量建造不同大小的房子，更灵活、更节省资源。</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>真正理解 CIDR 的求职者应该能够解释以下几点：</p><ol><li><strong>CIDR 的定义</strong>：使用可变长度子网掩码进行IP地址分配和路由。</li><li><strong>改进的方面</strong>：更高效的地址分配，简化路由表，提供网络划分的灵活性。</li></ol><h2 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h2><p>欢迎大家关注我的微信公众号「<strong>跟着小康学编程</strong>」！本号致力于分享<strong>C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习、计算机基础原理、Linux 编程、数据库、微服务、容器技术</strong> 等内容。文章力求通俗易懂，并配有代码示例，方便初学者理解。如果您对这些内容感兴趣，欢迎关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p>后续，我还会陆续分享各个方向的编程面试题，包括<strong>C&#x2F;C++、Java、Go，以及操作系统、计算机网络、数据结构、数据库和微服务</strong>等领域，为大家的面试提供帮助。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络面试 </tag>
            
            <tag> IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IP 面试题 — 说说 IP 报文首部的格式？首部有哪些重要的字段？</title>
      <link href="/ip-header/"/>
      <url>/ip-header/</url>
      
        <content type="html"><![CDATA[<p>🚀大家好，我是小康。</p><p>今天给大家分享一个 IP 面试题 ：<strong>说说 IP 报文首部的格式？首部有哪些重要的字段？</strong></p><blockquote><p><strong>小技巧</strong>：在面试中，可以参考下面的<strong>示例回答</strong>，这样回答简洁明了。<strong>详细介绍</strong>部分则是为了帮助大家系统学习，以便应对面试官深入提问。</p></blockquote><h3 id="示例回答"><a href="#示例回答" class="headerlink" title="示例回答"></a>示例回答</h3><p>IP报文首部是IP数据包的头部信息，包含控制和路由数据。重要字段包括版本、首部长度、总长度、标识、标志、片偏移、生存时间、协议、首部校验和、源地址和目的地址。</p><hr><h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><h4 id="IP报文首部的格式如下图："><a href="#IP报文首部的格式如下图：" class="headerlink" title="IP报文首部的格式如下图："></a>IP报文首部的格式如下图：</h4><p>IP报文首部（Header）是IP数据包的重要组成部分，包含了各种控制和路由信息，使数据包能够正确地传输和处理。IPv4的首部通常为20字节，具体如下：</p><ol><li><strong>版本（Version）</strong>：</li></ol><ul><li>占4位，表示IP协议的版本。IPv4报文的版本字段值为4。</li></ul><ol start="2"><li><strong>首部长度（IHL，Internet Header Length）</strong>：</li></ol><ul><li>占4位，表示IP首部的长度，以4字节为单位。最小值为5，表示最小首部长度为20字节。</li></ul><ol start="3"><li><strong>服务类型（Type of Service，TOS）</strong>：</li></ol><ul><li>占8位，用于指定数据包的优先级和服务质量。</li></ul><ol start="4"><li><strong>总长度（Total Length）</strong>：</li></ol><ul><li>占16位，表示整个IP数据包（首部和数据）的总长度，以字节为单位。最大长度为65535字节。</li></ul><ol start="5"><li><strong>标识（Identification）</strong>：</li></ol><ul><li>占16位，用于唯一标识数据包的ID，主要用于数据包分片时的重组。</li></ul><ol start="6"><li><strong>标志（Flags）</strong>：</li></ol><ul><li>占3位，控制和标记分片的选项。包括不分片位（DF）和更多分片位（MF）。</li></ul><ol start="7"><li><strong>片偏移（Fragment Offset）</strong>：</li></ol><ul><li>占13位，指示每个片段相对于原始数据包的起始位置。</li></ul><ol start="8"><li><strong>生存时间（TTL，Time to Live）</strong>：</li></ol><ul><li>占8位，指定数据包可以经过的最大路由器数量，防止数据包在网络中无限循环。</li></ul><ol start="9"><li><strong>协议（Protocol）</strong>：</li></ol><ul><li>占8位，表示传输层协议的类型，如TCP（6）或UDP（17）。</li></ul><ol start="10"><li><strong>首部校验和（Header Checksum）</strong>：</li></ol><ul><li>占16位，用于检验首部数据的完整性。</li></ul><ol start="11"><li><strong>源地址（Source Address）</strong>：</li></ol><ul><li>占32位，表示发送数据包的设备的IP地址。</li></ul><ol start="12"><li><strong>目的地址（Destination Address）</strong>：</li></ol><ul><li>占32位，表示接收数据包的设备的IP地址。</li></ul><ol start="13"><li><strong>选项和填充（Options and Padding）</strong>：</li></ol><ul><li>可变长度，提供扩展功能，但一般情况下不使用。</li></ul><h4 id="示例说明"><a href="#示例说明" class="headerlink" title="示例说明"></a>示例说明</h4><p>假设你要发送一个IP数据包，首先要创建IP报文首部，包含上述所有字段。</p><ul><li><strong>版本和首部长度</strong>：设置版本为4，首部长度为5（即20字节）。</li><li><strong>服务类型</strong>：指定数据包的优先级。</li><li><strong>总长度</strong>：计算首部和数据的总长度，例如1500字节。</li><li><strong>标识</strong>：给数据包分配一个唯一的ID。</li><li><strong>标志和片偏移</strong>：如果数据包需要分片，设置相应的标志和片偏移。</li><li><strong>生存时间</strong>：例如设置为64，表示数据包可以经过64个路由器。</li><li><strong>协议</strong>：如果是TCP数据包，协议字段设置为6。</li><li><strong>首部校验和</strong>：计算并填入校验和值，确保数据包完整。</li><li><strong>源地址和目的地址</strong>：填入发送方和接收方的IP地址。</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>IP报文首部包含了多个关键字段，用于控制和路由数据包。这些字段帮助数据包找到正确的路径并确保其完整传输。理解这些字段及其作用，有助于掌握网络数据传输的基本原理，并能在网络管理和故障排除中应用。  </p><h2 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h2><p>欢迎大家关注我的微信公众号「<strong>跟着小康学编程</strong>」！本号致力于分享<strong>C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习、计算机基础原理、Linux 编程、数据库、微服务、容器技术</strong> 等内容。文章力求通俗易懂，并配有代码示例，方便初学者理解。如果您对这些内容感兴趣，欢迎关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p>后续，我还会陆续分享各个方向的编程面试题，包括<strong>C&#x2F;C++、Java、Go，以及操作系统、计算机网络、数据结构、数据库和微服务</strong>等领域，为大家的面试提供帮助。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络面试 </tag>
            
            <tag> IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IP 面试题 — IPv6 与 IPv4 的主要区别是什么？</title>
      <link href="/differences-between-ipv6-and-ipv4/"/>
      <url>/differences-between-ipv6-and-ipv4/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康。</p><p>今天给大家分享一个 IP 面试题 ：<strong>IPv6 与 IPv4 的主要区别是什么？</strong></p><blockquote><p><strong>小技巧</strong>：在面试中，可以参考下面的<strong>示例回答</strong>，这样回答简洁明了。<strong>详细介绍</strong>部分则是为了帮助大家系统学习，以便应对面试官深入提问。</p></blockquote><h3 id="示例回答"><a href="#示例回答" class="headerlink" title="示例回答"></a>示例回答</h3><p>IPv6 和 IPv4 的主要区别在于地址长度、地址数量、配置方式和安全性。IPv6 使用 128 位地址，提供了更多的 IP 地址，支持自动配置，内置了更强的安全性。</p><hr><h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><h4 id="1-地址长度和数量"><a href="#1-地址长度和数量" class="headerlink" title="1. 地址长度和数量"></a>1. 地址长度和数量</h4><ul><li><strong>IPv4</strong>：使用 32 位地址，总共可以提供约 43 亿个唯一的 IP 地址。格式通常是四个十进制数（如：192.168.1.1）。</li><li><strong>IPv6</strong>：使用 128 位地址，总共可以提供约 3.4 x 10^38 个唯一的 IP 地址。格式通常是八组十六进制数（如：2001:0db8:85a3:0000:0000:8a2e:0370:7334）。</li></ul><h4 id="2-地址配置"><a href="#2-地址配置" class="headerlink" title="2. 地址配置"></a>2. 地址配置</h4><ul><li><strong>IPv4</strong>：主要依靠手动配置或 DHCP（动态主机配置协议）进行地址分配。</li><li><strong>IPv6</strong>：支持无状态地址自动配置（SLAAC），设备可以自动生成自己的地址，大大简化了配置过程。同时也支持 DHCPv6。</li></ul><h4 id="3-安全性"><a href="#3-安全性" class="headerlink" title="3. 安全性"></a>3. 安全性</h4><ul><li><strong>IPv4</strong>：安全性依赖于应用层协议（如 SSL&#x2F;TLS）和外部机制（如防火墙）。</li><li><strong>IPv6</strong>：内置 IPsec（IP 安全协议），提供端到端加密和数据完整性检查，增强了安全性。</li></ul><h4 id="4-路由效率"><a href="#4-路由效率" class="headerlink" title="4. 路由效率"></a>4. 路由效率</h4><ul><li><strong>IPv4</strong>：由于地址耗尽，需要使用 NAT（网络地址转换）等技术，增加了网络复杂性和延迟。</li><li><strong>IPv6</strong>：报头结构更简洁，消除了 NAT 的需求，提供更高效的路由和数据包处理。</li></ul><h4 id="5-扩展性和未来"><a href="#5-扩展性和未来" class="headerlink" title="5. 扩展性和未来"></a>5. 扩展性和未来</h4><ul><li><strong>IPv4</strong>：地址空间有限，已经接近耗尽，无法满足未来大量设备的连接需求。</li><li><strong>IPv6</strong>：提供几乎无限的地址空间，足以应对未来互联网的发展和物联网（IoT）的需求。</li></ul><h4 id="形象比喻"><a href="#形象比喻" class="headerlink" title="形象比喻"></a>形象比喻</h4><p>可以将 IPv4 和 IPv6 的区别比作城市街道系统的扩展：</p><ul><li><strong>IPv4</strong>：像是一个老旧的城市，街道数量有限，地址快要用完了，需要各种补丁（如公寓合租）来解决住址问题。</li><li><strong>IPv6</strong>：像是新规划的城市，有大量新的街道和地址，不需要担心地址不够用，而且规划更合理，交通（数据传输）更高效。</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>理解 IPv6 和 IPv4 的主要区别需要掌握以下几点：</p><ol><li><strong>地址长度和数量</strong>：IPv6 使用 128 位地址，比 IPv4 的 32 位地址提供了更多的 IP 地址。</li><li><strong>地址配置</strong>：IPv6 支持自动配置，简化了网络设置。</li><li><strong>安全性</strong>：IPv6 内置了 IPsec，增强了网络安全。</li><li><strong>路由效率</strong>：IPv6 结构简洁，提高了路由和数据包处理效率。</li><li><strong>扩展性</strong>：IPv6 提供几乎无限的地址空间，满足未来需求。</li></ol><h2 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h2><p>欢迎大家关注我的微信公众号「<strong>跟着小康学编程</strong>」！本号致力于分享<strong>C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习、计算机基础原理、Linux 编程、数据库、微服务、容器技术</strong> 等内容。文章力求通俗易懂，并配有代码示例，方便初学者理解。如果您对这些内容感兴趣，欢迎关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p>后续，我还会陆续分享各个方向的编程面试题，包括<strong>C&#x2F;C++、Java、Go，以及操作系统、计算机网络、数据结构、数据库和微服务</strong>等领域，为大家的面试提供帮助。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络面试 </tag>
            
            <tag> IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IP 面试题 — IPV4 地址不够如何解决？</title>
      <link href="/solving-ipv4-shortage/"/>
      <url>/solving-ipv4-shortage/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康。</p><p>今天给大家分享一个 IP 面试题 ：<strong>IPV4 地址不够如何解决？</strong></p><blockquote><p><strong>小技巧</strong>：在面试中，可以参考下面的<strong>示例回答</strong>，这样回答简洁明了。<strong>详细介绍</strong>部分则是为了帮助大家系统学习，以便应对面试官深入提问。</p></blockquote><h3 id="示例回答"><a href="#示例回答" class="headerlink" title="示例回答"></a>示例回答</h3><p>IPv4 地址不够的问题主要通过三种方法解决：使用 NAT 技术、引入私有 IP 地址和推广 IPv6。NAT 技术让多个设备共享一个公共 IP 地址，私有 IP 地址用于内部网络，而 IPv6 提供了更大范围的地址空间。</p><hr><h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><h4 id="1-NAT-技术（网络地址转换）"><a href="#1-NAT-技术（网络地址转换）" class="headerlink" title="1. NAT 技术（网络地址转换）"></a>1. NAT 技术（网络地址转换）</h4><p>NAT（Network Address Translation）技术允许多个设备共享一个公共 IP 地址。这是通过将内部私有 IP 地址映射到一个或多个公共 IP 地址来实现的。NAT 常见于家庭路由器和公司防火墙中。</p><ul><li><strong>工作原理</strong>：当一个设备（如电脑或手机）在内部网络中发送数据包到外部网络时，NAT 会将数据包的源 IP 地址替换为公共 IP 地址。当响应数据包返回时，NAT 会将公共 IP 地址替换回内部私有 IP 地址，并将数据包转发到原始设备。</li><li><strong>优点</strong>：减少了公共 IP 地址的需求，同时增强了网络安全，因为内部网络的结构对外部不可见。</li></ul><h4 id="2-私有-IP-地址"><a href="#2-私有-IP-地址" class="headerlink" title="2. 私有 IP 地址"></a>2. 私有 IP 地址</h4><p>私有 IP 地址用于内部网络，不在互联网上使用。这些地址由 IANA（Internet Assigned Numbers Authority）保留，用于局域网（LAN）和内部网络。<br><strong>私有 IP 地址范围</strong>：</p><ul><li>10.0.0.0 - 10.255.255.255</li><li>172.16.0.0 - 172.31.255.255</li><li>192.168.0.0 - 192.168.255.255</li></ul><p><strong>优点</strong>：可以在内部网络中重复使用相同的私有 IP 地址，不会耗尽公共 IP 地址。</p><h4 id="3-IPv6"><a href="#3-IPv6" class="headerlink" title="3. IPv6"></a>3. IPv6</h4><p>IPv6（Internet Protocol version 6）是为了解决 IPv4 地址耗尽问题而设计的。IPv6 使用 128 位地址，能够提供几乎无限数量的 IP 地址。</p><ul><li><strong>IPv6 地址示例</strong>：格式通常是八组十六进制数，如：2001:0db8:85a3:0000:0000:8a2e:0370:7334 。  </li><li><strong>优点</strong>：除了提供更大的地址空间外，IPv6 还引入了更高效的路由和配置功能，增强了安全性和移动性支持。</li></ul><h4 id="形象比喻"><a href="#形象比喻" class="headerlink" title="形象比喻"></a>形象比喻</h4><p>可以将这三种方法比作解决城市住房紧张的措施：</p><ul><li><strong>NAT 技术</strong>：像多人合租一套公寓，共享公共资源。</li><li><strong>私有 IP 地址</strong>：像在城市内建造多个小区，每个小区内的地址（门牌号）可以重复使用。</li><li><strong>IPv6</strong>：像开辟一个新城市，有足够多的房子，几乎可以满足所有人的需求。</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>理解 IPv4 地址耗尽的解决方法需要了解 NAT 技术、私有 IP 地址和 IPv6 的基本概念和工作原理。掌握这些内容的人应该能够清楚地解释每种方法的优点和工作机制。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h2><p>欢迎大家关注我的微信公众号「<strong>跟着小康学编程</strong>」！本号致力于分享<strong>C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习、计算机基础原理、Linux 编程、数据库、微服务、容器技术</strong> 等内容。文章力求通俗易懂，并配有代码示例，方便初学者理解。如果您对这些内容感兴趣，欢迎关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p>后续，我还会陆续分享各个方向的编程面试题，包括<strong>C&#x2F;C++、Java、Go，以及操作系统、计算机网络、数据结构、数据库和微服务</strong>等领域，为大家的面试提供帮助。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络面试 </tag>
            
            <tag> IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IP 面试题 — 什么是IP分片？为什么需要IP分片？</title>
      <link href="/ip-fragmentation-explained/"/>
      <url>/ip-fragmentation-explained/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康。</p><p>今天给大家分享一个 IP 面试题 ：<strong>什么是IP分片？为什么需要IP分片？</strong></p><blockquote><p><strong>小技巧</strong>：在面试中，可以参考下面的<strong>示例回答</strong>，这样回答简洁明了。<strong>详细介绍</strong>部分则是为了帮助大家系统学习，以便应对面试官深入提问。</p></blockquote><h3 id="示例回答"><a href="#示例回答" class="headerlink" title="示例回答"></a>示例回答</h3><p>IP 分片是指将过大的 IP 数据包拆分成更小的片段进行传输的过程，因为某些网络设备和链路对数据包的大小有限制。分片可以确保数据包能够顺利通过这些限制并到达目的地。</p><hr><h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><h4 id="什么是-IP-分片？"><a href="#什么是-IP-分片？" class="headerlink" title="什么是 IP 分片？"></a>什么是 IP 分片？</h4><p>IP 分片（IP Fragmentation）是将一个过大的 IP 数据包拆分成多个较小片段的过程，以便在网络中传输。分片是在发送端或路由器上进行的(在网络层进行的)，当数据包大小超过路径上某一网络的最大传输单元（MTU）时，就会发生分片。</p><h4 id="为什么需要-IP-分片？"><a href="#为什么需要-IP-分片？" class="headerlink" title="为什么需要 IP 分片？"></a><strong>为什么需要 IP 分片？</strong></h4><ol><li><strong>MTU 限制</strong>：</li></ol><ul><li><strong>MTU（最大传输单元）</strong>：是网络链路上能够传输的最大数据包大小。不同的网络链路和设备有不同的 MTU 值，通常为 1500 字节。</li><li><strong>问题</strong>：如果数据包的大小超过了某个链路的 MTU，数据包将无法通过该链路。因此，需要将数据包分片成更小的片段，以便通过所有网络链路。</li></ul><ol start="2"><li><strong>确保数据传输顺利</strong>：</li></ol><ul><li><strong>分片传输</strong>：通过将大数据包分片成更小的片段，可以确保数据包能够通过不同的网络设备和链路，不会因为过大而被丢弃。</li><li><strong>完整性</strong>：尽管数据包被分成多个片段，但在到达目的地后，这些片段会被重新组装成原始数据包，确保数据的完整性。</li></ul><h4 id="IP-分片的工作原理"><a href="#IP-分片的工作原理" class="headerlink" title="IP 分片的工作原理"></a>IP 分片的工作原理</h4><ol><li><strong>分片过程</strong>：</li></ol><ul><li>当数据包的大小超过路径上某一链路的 MTU 时，发送端或中间的路由器会将数据包分成多个片段。</li><li>每个片段都有自己的 IP 头部信息，包括标识符、片段偏移量和更多片段标志。</li></ul><ol start="2"><li><strong>传输过程</strong>：</li></ol><ul><li>这些片段作为独立的数据包在网络中传输，可能经过不同的路径。</li><li>每个片段都携带相同的标识符，使接收端能够识别并重组它们。</li></ul><ol start="3"><li><strong>重组过程</strong>：</li></ol><ul><li>片段到达目的地后，接收端根据片段的标识符和偏移量将它们重新组装成原始数据包。</li><li>如果有片段丢失，接收端的 IP 层会丢弃整个数据包。</li></ul><h4 id="形象比喻"><a href="#形象比喻" class="headerlink" title="形象比喻"></a>形象比喻</h4><p>可以将 IP 分片比作邮寄一件大物品：</p><ul><li><strong>大物品</strong>：相当于原始数据包，可能超大，邮局不接受。</li><li><strong>分拆成小包裹</strong>：将大物品拆分成多个小包裹，每个包裹都有标识信息。</li><li><strong>邮寄过程</strong>：每个小包裹独立运输，可能经过不同的路线。</li><li><strong>最终组装</strong>：收件人收到所有小包裹后，根据标识信息重新组装成大物品。</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>真正理解 IP 分片的求职者应该能够清楚地解释以下几点：</p><ol><li><strong>什么是 IP 分片</strong>：将过大的数据包拆分成更小的片段进行传输。</li><li><strong>为什么需要 IP 分片</strong>：解决不同网络设备和链路的 MTU 限制，确保数据包能够顺利传输到目的地。</li><li><strong>IP 分片的工作原理</strong>：包括分片、传输和重组的过程。</li></ol><h2 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h2><p>欢迎大家关注我的微信公众号「<strong>跟着小康学编程</strong>」！本号致力于分享<strong>C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习、计算机基础原理、Linux 编程、数据库、微服务、容器技术</strong> 等内容。文章力求通俗易懂，并配有代码示例，方便初学者理解。如果您对这些内容感兴趣，欢迎关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p>后续，我还会陆续分享各个方向的编程面试题，包括<strong>C&#x2F;C++、Java、Go，以及操作系统、计算机网络、数据结构、数据库和微服务</strong>等领域，为大家的面试提供帮助。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络面试 </tag>
            
            <tag> IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IP 面试题 — 什么是NAT（网络地址转换）？它有哪些类型？</title>
      <link href="/what-nat/"/>
      <url>/what-nat/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康。</p><p>今天给大家分享一个 IP 面试题 ：<strong>什么是NAT（网络地址转换）？它有哪些类型？</strong></p><blockquote><p><strong>小技巧</strong>：在面试中，可以参考下面的<strong>示例回答</strong>，这样回答简洁明了。<strong>详细介绍</strong>部分则是为了帮助大家系统学习，以便应对面试官深入提问。</p></blockquote><h3 id="示例回答"><a href="#示例回答" class="headerlink" title="示例回答"></a>示例回答</h3><p>NAT（网络地址转换）是一种技术，用于将私有IP地址转换为公有IP地址，以便多个设备共享一个公共IP地址上网。NAT有三种主要类型：静态NAT、动态NAT和端口地址转换（PAT）。</p><hr><h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><h4 id="NAT-的三种类型"><a href="#NAT-的三种类型" class="headerlink" title="NAT 的三种类型"></a><strong>NAT 的三种类型</strong></h4><p>NAT（网络地址转换）有三种主要类型：静态NAT、动态NAT和端口地址转换（PAT），它们的工作原理相似。当内部设备访问外部网络时，NAT设备将私有IP地址转换为公有IP地址，发送请求到互联网，外部网络的响应返回到公有IP地址后，NAT设备再将其转换回原始的私有IP地址。而当外部网络访问内部设备时，NAT设备接收发到公有IP地址的请求，并根据配置将其转发到内部网络中的特定私有IP地址，实现双向数据流动。</p><h4 id="具体分类："><a href="#具体分类：" class="headerlink" title="具体分类："></a>具体分类：</h4><p>1、<strong>静态 NAT</strong></p><ul><li><strong>定义</strong>：静态 NAT 是将一个特定的私有IP地址永久映射到一个特定的公有IP地址。每次这个私有IP地址发送数据包到互联网时，都会使用相同的公有IP地址。</li><li><strong>用途</strong>：适用于需要从外部网络直接访问内部网络中特定设备的情况，例如公司服务器需要一个固定的公有IP地址，以便外部用户可以通过这个公有IP地址访问服务器。</li><li><strong>双向访问</strong>：静态 NAT 支持双向访问。外部用户可以通过固定的公有IP地址访问内部设备，同时内部设备通过相同的公有IP地址访问外部网络。</li><li><strong>例子</strong>：假设你有一台内部服务器，IP地址是192.168.1.10，通过静态 NAT 将其映射到公有IP地址203.0.113.10。无论何时访问这个公有IP地址，都能找到这台服务器。同时，服务器访问互联网时，显示的也是这个公有IP地址。</li></ul><p>2、<strong>动态 NAT</strong></p><ul><li><strong>定义</strong>：动态 NAT 使用一个私有IP地址池和一个公有IP地址池。每当内部设备需要访问互联网时，动态 NAT 会从公有IP地址池中选择一个未使用的公有IP地址进行映射。</li><li><strong>用途</strong>：适用于内部网络中的多个设备需要访问外部网络，但每次连接时不需要使用固定的公有IP地址。这样可以更有效地利用有限的公有IP地址资源。</li><li><strong>双向访问</strong>：动态 NAT 主要用于内部设备访问外部网络，不适合外部设备主动访问内部设备。</li><li><strong>例子</strong>：家里的多台设备使用192.168.1.0&#x2F;24地址段，每次访问互联网时，动态 NAT 会从ISP提供的公有IP地址池中分配一个未使用的地址，例如今天是203.0.113.11，明天可能是203.0.113.12。</li></ul><p>3、 <strong>端口地址转换（PAT）</strong></p><ul><li><strong>定义</strong>：端口地址转换（PAT）也称为“多对一 NAT”或“网络地址端口转换（NAPT）”，是将多个私有IP地址通过一个单一的公有IP地址进行映射，并使用不同的端口号进行区分。每个内部设备的流量都被分配一个唯一的端口号。</li><li><strong>用途</strong>：PAT 是最常见的 NAT 类型，适用于家庭和小型企业网络，允许多个内部设备同时共享一个公有IP地址访问互联网。这样，可以大大节省公有IP地址的使用。</li><li><strong>双向访问</strong>：PAT 支持内部设备访问外部网络，但外部网络访问内部设备时需要特定的端口转发规则。</li><li><strong>例子</strong>：你家里的所有设备通过同一个公有IP地址203.0.113.10上网，但每个设备会分配一个不同的端口号来区分，比如电脑1使用端口10001，电脑2使用端口10002。当返回数据时，路由器会根据端口号将数据发送到正确的设备。</li></ul><h4 id="形象比喻"><a href="#形象比喻" class="headerlink" title="形象比喻"></a>形象比喻</h4><p>可以将 NAT 比作一个大楼前台接收包裹的过程：</p><ul><li><strong>静态 NAT</strong>：就像大楼的每个住户都有一个固定的邮箱，所有包裹都会被送到固定的邮箱，并且住户也可以通过这个邮箱寄出包裹。</li><li><strong>动态 NAT</strong>：就像大楼的住户每次寄包裹时，前台随机分配一个可用的邮箱号码。这个邮箱只用于寄包裹，不能接收外部的包裹。</li><li><strong>端口地址转换（PAT）</strong>：就像大楼所有住户都用一个公共邮箱，但每个包裹上都有不同的房间号，前台根据房间号把包裹分发给正确的住户。同时，住户也可以通过这个公共邮箱寄出包裹。</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>真正掌握 NAT 的求职者应该能够：</p><ol><li><strong>定义 NAT</strong>：理解 NAT 是一种将私有IP地址转换为公有IP地址的技术，用于解决IPv4地址不足的问题。</li><li><strong>解释 NAT 类型</strong>：清楚地理解静态 NAT、动态 NAT 和端口地址转换（PAT）的定义和用途。</li><li><strong>双向访问</strong>：说明哪种类型的 NAT 支持双向访问，并举例说明每种 NAT 类型的双向访问特性。</li></ol><h2 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h2><p>欢迎大家关注我的微信公众号「<strong>跟着小康学编程</strong>」！本号致力于分享<strong>C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习、计算机基础原理、Linux 编程、数据库、微服务、容器技术</strong> 等内容。文章力求通俗易懂，并配有代码示例，方便初学者理解。如果您对这些内容感兴趣，欢迎关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p>后续，我还会陆续分享各个方向的编程面试题，包括<strong>C&#x2F;C++、Java、Go，以及操作系统、计算机网络、数据结构、数据库和微服务</strong>等领域，为大家的面试提供帮助。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络面试 </tag>
            
            <tag> IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IP 面试题 — 说下 ARP 协议的工作过程？</title>
      <link href="/arp-protocol-operation/"/>
      <url>/arp-protocol-operation/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康。</p><p>今天给大家分享一个 IP 面试题 ：<strong>说下 ARP 协议的工作过程？</strong></p><blockquote><p><strong>小技巧</strong>：在面试中，可以参考下面的<strong>示例回答</strong>，这样回答简洁明了。<strong>详细介绍</strong>部分则是为了帮助大家系统学习，以便应对面试官深入提问。</p></blockquote><h3 id="示例回答"><a href="#示例回答" class="headerlink" title="示例回答"></a>示例回答</h3><p>ARP协议用于将IP地址转换为MAC地址。设备发送ARP请求广播，询问谁拥有某个IP地址。目标设备回复其MAC地址，发送设备将这个映射关系存储在ARP缓存中，以后通信时直接使用。</p><hr><h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><h4 id="ARP-协议的工作过程"><a href="#ARP-协议的工作过程" class="headerlink" title="ARP 协议的工作过程"></a>ARP 协议的工作过程</h4><ol><li><strong>发送ARP请求</strong>：</li></ol><ul><li>当一台设备需要和同一网络中的另一台设备通信时，它需要知道对方的MAC地址。假设设备A想与设备B通信，但只知道设备B的IP地址。</li><li>设备A会发送一个ARP请求，这是一个广播消息，包含设备A的IP地址和它想要找的设备B的IP地址。这个请求会发送到网络中的所有设备，询问“谁是这个IP地址？”</li></ul><ol start="2"><li><strong>接收ARP请求</strong>：</li></ol><ul><li>网络中的所有设备都会接收到这个ARP请求，但只有拥有请求中目标IP地址的设备B会回应。</li><li>设备B会发送一个ARP回复消息，包含它的MAC地址。这个消息是直接发送给设备A的，而不是广播。</li></ul><ol start="3"><li><strong>更新ARP缓存</strong>：</li></ol><ul><li>设备A收到设备B的ARP回复后，将设备B的IP地址和MAC地址的映射关系存储在ARP缓存中。</li><li>这样，当设备A再次需要与设备B通信时，就可以直接使用这个缓存中的MAC地址，而不需要再次发送ARP请求。</li></ul><ol start="4"><li><strong>通信开始</strong>：</li></ol><ul><li>现在，设备A可以使用设备B的MAC地址来封装数据包，进行通信。</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>ARP协议通过广播ARP请求来获取目标设备的MAC地址，并将这个映射关系存储在ARP缓存中，以加速后续通信。通过理解ARP的工作过程，可以看出它在局域网中确保设备间通信的关键作用。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h2><p>欢迎大家关注我的微信公众号「<strong>跟着小康学编程</strong>」！本号致力于分享<strong>C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习、计算机基础原理、Linux 编程、数据库、微服务、容器技术</strong> 等内容。文章力求通俗易懂，并配有代码示例，方便初学者理解。如果您对这些内容感兴趣，欢迎关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p>后续，我还会陆续分享各个方向的编程面试题，包括<strong>C&#x2F;C++、Java、Go，以及操作系统、计算机网络、数据结构、数据库和微服务</strong>等领域，为大家的面试提供帮助。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络面试 </tag>
            
            <tag> IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IP 面试题 — IP 寻址如何工作？</title>
      <link href="/how-ip-addressing-works/"/>
      <url>/how-ip-addressing-works/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康。</p><p>今天给大家分享一个 IP 面试题 ：<strong>IP 寻址如何工作？</strong></p><blockquote><p><strong>小技巧</strong>：在面试中，可以参考下面的<strong>示例回答</strong>，这样回答简洁明了。<strong>详细介绍</strong>部分则是为了帮助大家系统学习，以便应对面试官深入提问。</p></blockquote><h3 id="示例回答"><a href="#示例回答" class="headerlink" title="示例回答"></a>示例回答</h3><p>IP 寻址是通过 IP 地址在网络中定位和识别设备的过程。每个设备有一个唯一的 IP 地址，数据包通过路由器转发，根据目标 IP 地址找到最终目的地。</p><hr><h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><h4 id="IP-寻址的基本原理"><a href="#IP-寻址的基本原理" class="headerlink" title="IP 寻址的基本原理"></a>IP 寻址的基本原理</h4><ol><li><strong>IP 地址的结构</strong>：</li></ol><ul><li>IP 地址是一个 32 位（IPv4）或 128 位（IPv6）的数值，用于标识网络中的设备。IPv4 地址通常表示为四个十进制数（如 192.168.1.1），每个数在 0 到 255 之间。</li><li>IP 地址分为网络部分和主机部分。网络部分用于识别子网络，主机部分用于识别子网络中的具体设备。子网掩码用于确定网络部分和主机部分。</li></ul><ol start="2"><li><strong>数据包的构建和传输</strong>：</li></ol><ul><li>数据在网络中传输时被封装成数据包。每个数据包包含源 IP 地址和目标 IP 地址。</li><li>当一个设备发送数据时，它会将数据包发送到本地路由器。</li></ul><ol start="3"><li><strong>路由器的工作原理</strong>：</li></ol><ul><li>路由器是负责在不同网络之间转发数据包的设备。它根据数据包的目标 IP 地址决定下一步将数据包发送到哪里。</li><li>路由器有一张路由表，记录了网络到达路径的信息。当一个数据包到达路由器时，路由器会查找路由表，确定数据包的下一跳。</li></ul><ol start="4"><li><strong>数据包的转发</strong>：</li></ol><ul><li>数据包从源设备发送，经过一个或多个路由器，最终到达目标设备。</li><li>每个路由器根据目标 IP 地址和自己的路由表决定将数据包转发到下一个路由器或直接发送到目标设备。</li></ul><h4 id="形象比喻："><a href="#形象比喻：" class="headerlink" title="形象比喻："></a>形象比喻：</h4><p>可以将 IP 寻址和数据包传输比作邮寄系统：</p><ul><li><strong>IP 地址</strong>：像邮政地址，确定了邮件的目的地。</li><li><strong>路由器</strong>：像邮局，每个邮局根据邮政编码（IP 地址）将邮件转发到下一个邮局或最终目的地。</li><li><strong>数据包</strong>：像信件，包含发件人地址（源 IP 地址）和收件人地址（目标 IP 地址）。</li></ul><p>当你寄一封信时，信件会从一个邮局传到下一个邮局，直到到达收件人手中。类似地，数据包在网络中被路由器逐步转发，直到到达目标设备。</p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>真正理解 IP 寻址的人，应该能够解释 IP 地址的结构和作用，理解数据包在网络中的传输过程，以及路由器如何根据路由表决定数据包的转发路径。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h2><p>欢迎大家关注我的微信公众号「<strong>跟着小康学编程</strong>」！本号致力于分享<strong>C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习、计算机基础原理、Linux 编程、数据库、微服务、容器技术</strong> 等内容。文章力求通俗易懂，并配有代码示例，方便初学者理解。如果您对这些内容感兴趣，欢迎关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p>后续，我还会陆续分享各个方向的编程面试题，包括<strong>C&#x2F;C++、Java、Go，以及操作系统、计算机网络、数据结构、数据库和微服务</strong>等领域，为大家的面试提供帮助。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络面试 </tag>
            
            <tag> IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IP 面试题 — ARP缓存是什么？</title>
      <link href="/what-arp/"/>
      <url>/what-arp/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康。</p><p>今天给大家分享一个 IP 面试题 ：<strong>ARP缓存是什么？</strong></p><blockquote><p><strong>小技巧</strong>：在面试中，可以参考下面的<strong>示例回答</strong>，这样回答简洁明了。<strong>详细介绍</strong>部分则是为了帮助大家系统学习，以便应对面试官深入提问。</p></blockquote><h3 id="示例回答"><a href="#示例回答" class="headerlink" title="示例回答"></a>示例回答</h3><p>ARP缓存是存储IP地址和对应MAC地址映射关系的表格，用于加速网络通信。它能减少网络延迟，因为设备可以直接从缓存中获取MAC地址，而不用每次都发送ARP请求。</p><hr><h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><h4 id="什么是-ARP-缓存？"><a href="#什么是-ARP-缓存？" class="headerlink" title="什么是 ARP 缓存？"></a>什么是 ARP 缓存？</h4><p>ARP（地址解析协议）缓存是一种存储IP地址与对应MAC地址映射关系的临时表格。每个设备在本地维护一个这样的表格，用于快速查找网络中设备的物理地址。</p><h4 id="ARP-缓存的工作原理"><a href="#ARP-缓存的工作原理" class="headerlink" title="ARP 缓存的工作原理"></a>ARP 缓存的工作原理</h4><ol><li><strong>发送ARP请求</strong>：</li></ol><ul><li>当一台设备需要和另一台设备通信时，它需要知道对方的MAC地址。</li><li>如果ARP缓存中没有这个IP地址的对应MAC地址，该设备会广播一个ARP请求，询问“谁是这个IP地址？”</li></ul><ol start="2"><li><strong>接收ARP回复</strong>：</li></ol><ul><li>拥有该IP地址的设备会回复其MAC地址。</li><li>发送设备将这个映射关系（IP地址和MAC地址）存储在ARP缓存中。</li></ul><ol start="3"><li><strong>缓存使用</strong>：</li></ol><ul><li>当再次需要通信时，设备会首先检查ARP缓存，如果缓存中有对应关系，则直接使用MAC地址进行通信。</li><li>这样就避免了每次通信都发送ARP请求，减少了网络延迟和流量。</li></ul><h4 id="ARP缓存的作用"><a href="#ARP缓存的作用" class="headerlink" title="ARP缓存的作用"></a>ARP缓存的作用</h4><ul><li><strong>加速通信</strong>：通过缓存IP地址和MAC地址的映射关系，设备可以快速找到目标设备的物理地址，加速数据包的发送。</li><li><strong>减少网络流量</strong>：缓存减少了网络上ARP请求的广播数量，减轻了网络负担。</li></ul><h4 id="举例说明："><a href="#举例说明：" class="headerlink" title="举例说明："></a>举例说明：</h4><p>假设你在公司内部网络中，有一台打印机IP地址为192.168.1.100：</p><ol><li><strong>初次通信</strong>：你的电脑要向打印机发送数据。电脑首先查看ARP缓存中是否有192.168.1.100的MAC地址。如果没有，电脑会发送ARP请求。</li><li><strong>回复并缓存</strong>：打印机回复其MAC地址，比如00:1A:2B:3C:4D:5E。你的电脑将这个IP-MAC映射关系存储在ARP缓存中。</li><li><strong>后续通信</strong>：下一次你的电脑需要和打印机通信时，会直接从ARP缓存中获取MAC地址，快速发送数据，而无需再次发送ARP请求。</li></ol><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>ARP缓存是一种用于存储IP地址和MAC地址映射关系的表格，能够加速网络通信，减少延迟和广播流量。通过理解ARP缓存的作用和工作原理，可以看出它在提高网络效率方面的重要性。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h2><p>欢迎大家关注我的微信公众号「<strong>跟着小康学编程</strong>」！本号致力于分享<strong>C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习、计算机基础原理、Linux 编程、数据库、微服务、容器技术</strong> 等内容。文章力求通俗易懂，并配有代码示例，方便初学者理解。如果您对这些内容感兴趣，欢迎关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p>后续，我还会陆续分享各个方向的编程面试题，包括<strong>C&#x2F;C++、Java、Go，以及操作系统、计算机网络、数据结构、数据库和微服务</strong>等领域，为大家的面试提供帮助。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络面试 </tag>
            
            <tag> IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IP 面试题 — 说下 ping 的原理？</title>
      <link href="/what-ping/"/>
      <url>/what-ping/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康。</p><p>今天给大家分享一个 IP 面试题 ：<strong>说下 ping 的原理？</strong></p><blockquote><p><strong>小技巧</strong>：在面试中，可以参考下面的<strong>示例回答</strong>，这样回答简洁明了。<strong>详细介绍</strong>部分则是为了帮助大家系统学习，以便应对面试官深入提问。</p></blockquote><h3 id="示例回答"><a href="#示例回答" class="headerlink" title="示例回答"></a>示例回答</h3><p>Ping 的原理是通过发送 ICMP 回显请求消息并接收回显应答消息来测试目标主机是否在线以及响应时间。</p><hr><h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><h4 id="Ping-的工作原理"><a href="#Ping-的工作原理" class="headerlink" title="Ping 的工作原理"></a>Ping 的工作原理</h4><ol><li><strong>发送ICMP请求</strong>：</li></ol><ul><li>当你在命令行输入 <code>ping</code> 命令时，电脑会向目标主机发送一个 ICMP 回显请求（Echo Request）消息。这个消息包含了发送方的 IP 地址和一个序列号，用来标识和跟踪这个请求。</li></ul><ol start="2"><li><strong>接收ICMP回复</strong>：</li></ol><ul><li>目标主机收到 ICMP 回显请求后，会发送一个 ICMP 回显应答（Echo Reply）消息。这个应答消息包含了发送方的 IP 地址和序列号，确保回复能够正确匹配请求。</li></ul><ol start="3"><li><strong>计算响应时间</strong>：</li></ol><ul><li>发送方收到回显应答后，会记录从发送请求到接收到回复所花费的时间。这就是响应时间或延迟（Latency）。</li></ul><ol start="4"><li><strong>输出结果</strong>：</li></ol><ul><li>Ping 命令会显示每次请求的响应时间以及成功接收回复的次数。如果目标主机不可达，Ping 命令会显示超时或无回复。</li></ul><h4 id="举例说明："><a href="#举例说明：" class="headerlink" title="举例说明："></a>举例说明：</h4><p>假设你在命令行输入 <code>ping www.google.com</code>，具体步骤如下：</p><ol><li>你的电脑向 Google 服务器发送一个 ICMP 回显请求消息。</li><li>Google 服务器收到请求后，发送一个 ICMP 回显应答消息回到你的电脑。</li><li>你的电脑记录从发送请求到接收到应答所花费的时间，并显示结果。</li></ol><p><strong>示例</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ping www.google.com</span><br><span class="line"></span><br><span class="line">Pinging www.google.com [142.250.190.100] with 32 bytes of data:</span><br><span class="line">Reply from 142.250.190.100: bytes=32 time=20ms TTL=54</span><br><span class="line">Reply from 142.250.190.100: bytes=32 time=19ms TTL=54</span><br><span class="line">Reply from 142.250.190.100: bytes=32 time=21ms TTL=54</span><br><span class="line">Reply from 142.250.190.100: bytes=32 time=22ms TTL=54</span><br><span class="line"></span><br><span class="line">Ping statistics <span class="keyword">for</span> 142.250.190.100:</span><br><span class="line">    Packets: Sent = 4, Received = 4, Lost = 0 (0% loss),</span><br><span class="line">Approximate round trip <span class="built_in">times</span> <span class="keyword">in</span> milli-seconds:</span><br><span class="line">    Minimum = 19ms, Maximum = 22ms, Average = 20ms</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Ping 的原理是通过发送和接收 ICMP 消息来测试目标主机的可达性和响应时间。了解 Ping 的工作原理有助于理解网络连接状况和诊断网络问题。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h2><p>欢迎大家关注我的微信公众号「<strong>跟着小康学编程</strong>」！本号致力于分享<strong>C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习、计算机基础原理、Linux 编程、数据库、微服务、容器技术</strong> 等内容。文章力求通俗易懂，并配有代码示例，方便初学者理解。如果您对这些内容感兴趣，欢迎关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p>后续，我还会陆续分享各个方向的编程面试题，包括<strong>C&#x2F;C++、Java、Go，以及操作系统、计算机网络、数据结构、数据库和微服务</strong>等领域，为大家的面试提供帮助。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络面试 </tag>
            
            <tag> IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IP 面试题 — ICMP 协议的功能？ 有哪些应用？</title>
      <link href="/functions-of-icmp-protocol/"/>
      <url>/functions-of-icmp-protocol/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康。</p><p>今天给大家分享一个 IP 面试题 ：<strong>ICMP 协议的功能？ 有哪些应用？</strong></p><blockquote><p><strong>小技巧</strong>：在面试中，可以参考下面的<strong>示例回答</strong>，这样回答简洁明了。<strong>详细介绍</strong>部分则是为了帮助大家系统学习，以便应对面试官深入提问。</p></blockquote><h3 id="示例回答"><a href="#示例回答" class="headerlink" title="示例回答"></a>示例回答</h3><p>ICMP协议用于发送网络错误消息和控制信息。常见应用有Ping和Traceroute，Ping用来检查另一台设备是否在线，Traceroute用来显示数据经过的路由路径。  </p><hr><h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><p>ICMP（Internet Control Message Protocol，互联网控制消息协议）是一种网络协议，用于传递网络中的错误消息和控制信息。它帮助设备发现和解决网络问题，确保数据能够顺利传输。  </p><h4 id="ICMP的主要功能包括："><a href="#ICMP的主要功能包括：" class="headerlink" title="ICMP的主要功能包括："></a>ICMP的主要功能包括：</h4><ol><li>报告错误：当数据包无法到达目的地时，ICMP会通知发送方。例如，如果目标主机不可达或超时，ICMP会发送一条错误消息。</li><li>传递控制信息：ICMP还用于网络诊断，提供有关网络状态的信息。</li></ol><h4 id="ICMP的应用"><a href="#ICMP的应用" class="headerlink" title="ICMP的应用"></a>ICMP的应用</h4><ol><li><strong>Ping</strong>：</li></ol><ul><li><strong>功能</strong>：Ping是ICMP的一个重要应用，用于测试目标主机是否可达。</li><li><strong>工作原理</strong>：通过发送ICMP回显请求（Echo Request）消息并等待回显应答（Echo Reply）消息，来确定目标主机的状态。</li><li><strong>例子</strong>：在命令行输入<code>ping www.google.com</code>，如果Google服务器回复ICMP回显应答消息，说明Google服务器是可达的。</li></ul><ol start="2"><li><strong>Traceroute</strong>：</li></ol><ul><li><strong>功能</strong>：Traceroute用于跟踪数据包从源到目标的路径，并显示沿途经过的每个路由器。</li><li><strong>工作原理</strong>：通过发送TTL（生存时间）递增的ICMP回显请求消息，Traceroute能逐跳地发现路径上的路由器。</li><li><strong>例子</strong>：在命令行输入<code>traceroute www.google.com</code>，可以看到数据包从你的电脑到Google服务器所经过的每个路由器的IP地址。</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>ICMP协议用于传递网络层的控制信息和错误消息，确保数据包能够有效传输。常见应用有Ping（测试主机可达性）和Traceroute（跟踪数据包路径）。理解ICMP协议的功能和应用，能够帮助网络管理和故障排除。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h2><p>欢迎大家关注我的微信公众号「<strong>跟着小康学编程</strong>」！本号致力于分享<strong>C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习、计算机基础原理、Linux 编程、数据库、微服务、容器技术</strong> 等内容。文章力求通俗易懂，并配有代码示例，方便初学者理解。如果您对这些内容感兴趣，欢迎关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p>后续，我还会陆续分享各个方向的编程面试题，包括<strong>C&#x2F;C++、Java、Go，以及操作系统、计算机网络、数据结构、数据库和微服务</strong>等领域，为大家的面试提供帮助。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络面试 </tag>
            
            <tag> IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IP 面试题 — DNS 为什么用 UDP？</title>
      <link href="/why-dns-use-udp/"/>
      <url>/why-dns-use-udp/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康。</p><p>今天给大家分享一个 IP 面试题 ：<strong>DNS 为什么用 UDP？</strong></p><blockquote><p><strong>小技巧</strong>：在面试中，可以参考下面的<strong>示例回答</strong>，这样回答简洁明了。<strong>详细介绍</strong>部分则是为了帮助大家系统学习，以便应对面试官深入提问。</p></blockquote><h3 id="示例回答："><a href="#示例回答：" class="headerlink" title="示例回答："></a>示例回答：</h3><p>DNS 用 UDP 因为它速度快、开销小，适合查询小数据量的请求。UDP 不需要建立连接，传输效率高，而且大多数 DNS 查询数据量很小，不需要 TCP 的可靠传输。</p><hr><h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><h4 id="DNS-使用-UDP-的原因："><a href="#DNS-使用-UDP-的原因：" class="headerlink" title="DNS 使用 UDP 的原因："></a>DNS 使用 UDP 的原因：</h4><ol><li><strong>速度快、延迟低</strong>：</li></ol><ul><li><strong>UDP</strong>：UDP（User Datagram Protocol）是无连接协议，不需要像 TCP（Transmission Control Protocol）那样建立和断开连接。因此，UDP 发送数据的延迟更低，速度更快。</li><li><strong>DNS 查询</strong>：DNS 查询的响应时间对网络性能非常重要，使用 UDP 可以确保快速响应，提升用户体验。</li></ul><ol start="2"><li><strong>开销小</strong>：</li></ol><ul><li><strong>UDP</strong>：UDP 头部只有 8 个字节，而 TCP 头部至少有 20 个字节。较小的头部意味着更少的开销。</li><li><strong>DNS 查询</strong>：大多数 DNS 查询的数据量很小，使用 UDP 可以减少网络资源的消耗，提高效率。</li></ul><ol start="3"><li><strong>简化处理</strong>：</li></ol><ul><li><strong>UDP</strong>：由于是无连接协议，服务器不需要维护连接状态，这大大简化了服务器的处理逻辑。</li><li><strong>DNS 查询</strong>：DNS 服务器每天要处理大量的查询请求，使用 UDP 可以减少服务器的负担，提升整体性能。</li></ul><ol start="4"><li><strong>大多数查询数据量小</strong>：</li></ol><ul><li><strong>DNS 查询</strong>：大多数 DNS 查询的数据包都小于 512 字节，可以通过一个 UDP 数据包传输，这对于快速和高效的域名解析非常合适。</li><li><strong>例外情况</strong>：对于少数需要传输较大数据量的 DNS 查询，会使用 TCP，但这种情况比较少见。</li></ul><blockquote><p><strong>另外</strong>： 要想将DNS 为什么用 UDP 这个问题理解的更加透彻，需要知道 UDP 和 TCP 的区别，关于这两者的区别大家可以参考这篇文章：</p></blockquote><h2 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h2><p>欢迎大家关注我的微信公众号「<strong>跟着小康学编程</strong>」！本号致力于分享<strong>C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习、计算机基础原理、Linux 编程、数据库、微服务、容器技术</strong> 等内容。文章力求通俗易懂，并配有代码示例，方便初学者理解。如果您对这些内容感兴趣，欢迎关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p>后续，我还会陆续分享各个方向的编程面试题，包括<strong>C&#x2F;C++、Java、Go，以及操作系统、计算机网络、数据结构、数据库和微服务</strong>等领域，为大家的面试提供帮助。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络面试 </tag>
            
            <tag> IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IP 面试题 — 域名和 IP 的关系？一个 IP 可以对应多个域名吗？</title>
      <link href="/domainName-and-ip-relationship/"/>
      <url>/domainName-and-ip-relationship/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康。</p><p>今天给大家分享一个 IP 面试题 ：<strong>域名和 IP 的关系？一个 IP 可以对应多个域名吗？</strong></p><blockquote><p><strong>小技巧</strong>：在面试中，可以参考下面的<strong>示例回答</strong>，这样回答简洁明了。<strong>详细介绍</strong>部分则是为了帮助大家系统学习，以便应对面试官深入提问。</p></blockquote><h3 id="示例回答："><a href="#示例回答：" class="headerlink" title="示例回答："></a>示例回答：</h3><p>域名是用来方便人们记忆和访问网站的名称，而 IP 地址是计算机用来在网络上相互通信的数字地址。一个 IP 地址可以对应多个域名，比如多个网站可以共享一个服务器的同一个 IP 地址。</p><hr><h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><h4 id="域名和-IP-地址的关系："><a href="#域名和-IP-地址的关系：" class="headerlink" title="域名和 IP 地址的关系："></a>域名和 IP 地址的关系：</h4><ul><li><strong>域名</strong>：域名是为了便于记忆和使用而创建的，比如<a href="http://www.example.com.域名通过dns(域名系统)解析,转化为计算机可以理解的ip地址./">www.example.com。域名通过DNS（域名系统）解析，转化为计算机可以理解的IP地址。</a></li><li><strong>IP地址</strong>：IP地址是标识网络中设备的数字地址，如192.168.1.1。每个设备在网络中都有一个唯一的IP地址。</li></ul><h4 id="DNS（域名系统）"><a href="#DNS（域名系统）" class="headerlink" title="DNS（域名系统）"></a>DNS（域名系统）</h4><p>DNS就像互联网的电话簿，将域名转换为IP地址。当你在浏览器中输入域名时，DNS服务器会将这个域名解析成对应的IP地址，以便建立连接。</p><h4 id="一个IP可以对应多个域名吗？"><a href="#一个IP可以对应多个域名吗？" class="headerlink" title="一个IP可以对应多个域名吗？"></a>一个IP可以对应多个域名吗？</h4><p>是的，一个IP地址可以对应多个域名。在同一台服务器上，可以托管多个网站，每个网站都有不同的域名，但它们共享同一个IP地址。</p><h4 id="形象比喻："><a href="#形象比喻：" class="headerlink" title="形象比喻："></a>形象比喻：</h4><p>可以把域名和IP地址比作街道地址和门牌号：</p><ul><li><strong>域名</strong>：像是商店的名称，便于人们记住和查找。例如，“开心书店”。</li><li><strong>IP地址</strong>：像是具体的街道地址，标识实际位置。例如，“北京市朝阳区某街某号”。</li></ul><h2 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h2><p>欢迎大家关注我的微信公众号「<strong>跟着小康学编程</strong>」！本号致力于分享<strong>C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习、计算机基础原理、Linux 编程、数据库、微服务、容器技术</strong> 等内容。文章力求通俗易懂，并配有代码示例，方便初学者理解。如果您对这些内容感兴趣，欢迎关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p>后续，我还会陆续分享各个方向的编程面试题，包括<strong>C&#x2F;C++、Java、Go，以及操作系统、计算机网络、数据结构、数据库和微服务</strong>等领域，为大家的面试提供帮助。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络面试 </tag>
            
            <tag> IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IP 面试题 — 子网掩码是什么？它的作用是什么？</title>
      <link href="/what-is-a-subnet-mask/"/>
      <url>/what-is-a-subnet-mask/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康。</p><p>今天给大家分享一个 IP 面试题 ：<strong>子网掩码是什么？它的作用是什么？</strong></p><blockquote><p><strong>小技巧</strong>：在面试中，可以参考下面的<strong>示例回答</strong>，这样回答简洁明了。<strong>详细介绍</strong>部分则是为了帮助大家系统学习，以便应对面试官深入提问。</p></blockquote><h3 id="示例回答"><a href="#示例回答" class="headerlink" title="示例回答"></a>示例回答</h3><p>子网掩码是一种用来划分IP地址的工具，它决定了IP地址的哪一部分是网络部分，哪一部分是主机部分。它的主要作用是帮助在同一网络内进行子网划分，确保数据包能正确路由到目标设备。常见的子网掩码有255.255.255.0。</p><hr><h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><h4 id="什么是子网掩码？"><a href="#什么是子网掩码？" class="headerlink" title="什么是子网掩码？"></a>什么是子网掩码？</h4><p>子网掩码（Subnet Mask）是一种32位的数值，用于将一个IP地址划分为网络部分和主机部分。它与IP地址配合使用，通过“与”（AND）运算确定一个设备的网络地址。子网掩码通常表示为四个十进制数，每个数值在0到255之间，用点分隔开。</p><h4 id="子网掩码的作用："><a href="#子网掩码的作用：" class="headerlink" title="子网掩码的作用："></a>子网掩码的作用：</h4><ol><li><strong>确定网络和主机部分</strong>：</li></ol><ul><li><strong>网络部分</strong>：子网掩码中的1位表示网络部分。所有在同一网络上的设备，这部分的IP地址是相同的。</li><li><strong>主机部分</strong>：子网掩码中的0位表示主机部分。每个设备在同一网络中的这部分是唯一的。</li></ul><ol start="2"><li><strong>划分子网</strong>：</li></ol><ul><li>通过子网掩码，可以将一个大的网络划分成多个较小的子网。这有助于网络管理，提高网络性能和安全性。</li></ul><ol start="3"><li><strong>路由和通信</strong>：</li></ol><ul><li>子网掩码帮助路由器确定目标设备所在的网络，确保数据包能够正确地路由到目标设备。</li></ul><h4 id="常见子网掩码示例："><a href="#常见子网掩码示例：" class="headerlink" title="常见子网掩码示例："></a>常见子网掩码示例：</h4><ul><li><strong>255.0.0.0</strong>：A类地址的默认子网掩码，网络部分为前8位。</li><li><strong>255.255.0.0</strong>：B类地址的默认子网掩码，网络部分为前16位。</li><li><strong>255.255.255.0</strong>：C类地址的默认子网掩码，网络部分为前24位。</li></ul><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>理解子网掩码的关键在于知道它如何将IP地址划分为网络部分和主机部分，以及如何通过子网掩码进行网络划分和数据包路由。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h2><p>欢迎大家关注我的微信公众号「<strong>跟着小康学编程</strong>」！本号致力于分享<strong>C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习、计算机基础原理、Linux 编程、数据库、微服务、容器技术</strong> 等内容。文章力求通俗易懂，并配有代码示例，方便初学者理解。如果您对这些内容感兴趣，欢迎关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p>后续，我还会陆续分享各个方向的编程面试题，包括<strong>C&#x2F;C++、Java、Go，以及操作系统、计算机网络、数据结构、数据库和微服务</strong>等领域，为大家的面试提供帮助。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络面试 </tag>
            
            <tag> IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IP 面试题 — IP 协议的定义和作用？</title>
      <link href="/ip-vs-mac-address-differences/"/>
      <url>/ip-vs-mac-address-differences/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康。</p><p>今天给大家分享一个 IP 面试题 ：<strong>IP 协议的定义和作用？</strong></p><blockquote><p><strong>小技巧</strong>：在面试中，可以参考下面的<strong>示例回答</strong>，这样回答简洁明了。<strong>详细介绍</strong>部分则是为了帮助大家系统学习，以便应对面试官深入提问。</p></blockquote><h3 id="示例回答"><a href="#示例回答" class="headerlink" title="示例回答"></a>示例回答</h3><p>IP 协议，即互联网协议（Internet Protocol），是用于网络通信的基础协议。它的主要作用是提供一种机制，使数据能够从一个设备传送到另一个设备。IP 协议定义了数据包的格式和寻址方式，确保数据包能够在不同的网络之间正确地传输。简单来说，它就像网络世界的邮递员，确保你的数据包从发件人那里顺利送到收件人手中。</p><hr><h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><h4 id="IP-协议的定义"><a href="#IP-协议的定义" class="headerlink" title="IP 协议的定义"></a>IP 协议的定义</h4><p>IP 协议全称是“互联网协议”，它是互联网的核心协议之一。IP 协议负责定义数据包的结构，使数据在网络上传输变得可能。IP 协议主要包含两种版本：IPv4 和 IPv6。</p><ul><li><strong>IPv4</strong>：使用 32 位地址，可以提供大约 43 亿个独特的地址。</li><li><strong>IPv6</strong>：使用 128 位地址，能够提供几乎无限数量的地址，解决了 IPv4 地址耗尽的问题。</li></ul><h4 id="IP-协议的作用"><a href="#IP-协议的作用" class="headerlink" title="IP 协议的作用"></a>IP 协议的作用</h4><ul><li><strong>寻址</strong>：IP 协议定义了全球唯一的地址格式（IP 地址），确保每个连接到网络的设备都有一个唯一的标识。</li><li><strong>数据封装</strong>：IP 协议将数据封装成数据包，包含源地址和目标地址。</li><li><strong>路由选择</strong>：IP 协议通过路由器选择最佳路径，将数据包从源地址发送到目标地址，即使中间经过多个网络</li><li><strong>数据传输</strong>：IP 协议确保数据包能够在不同的网络之间传输，无论它们使用何种底层技术。</li></ul><h4 id="错误处理："><a href="#错误处理：" class="headerlink" title="错误处理："></a>错误处理：</h4><p>IP 协议本身不负责重传丢失的数据包或纠正数据损坏，但它提供了基本的错误检测机制。例如，IP 数据包头部有一个校验和字段，用于验证数据包头部是否在传输过程中出现错误。如果检测到错误，数据包会被丢弃，但 IP 协议不会尝试重传。这种错误处理更多是由上层协议（如 TCP）来完成的。</p><h4 id="形象比喻"><a href="#形象比喻" class="headerlink" title="形象比喻"></a>形象比喻</h4><p>可以把 IP 协议比作网络世界里的邮递员。每个数据包就像一封信，IP 协议负责在信封上写明收件人的地址（目标 IP 地址）和寄件人的地址（源 IP 地址），然后找到最佳的路线把信从一个地方送到另一个地方。即使中途需要转车（通过多个路由器），邮递员也会确保信最终到达目的地。至于信丢失或损坏，邮递员会通知发信人，具体的处理措施由发信人和收信人商定（由上层协议如 TCP 处理）。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h2><p>欢迎大家关注我的微信公众号「<strong>跟着小康学编程</strong>」！本号致力于分享<strong>C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习、计算机基础原理、Linux 编程、数据库、微服务、容器技术</strong> 等内容。文章力求通俗易懂，并配有代码示例，方便初学者理解。如果您对这些内容感兴趣，欢迎关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p>后续，我还会陆续分享各个方向的编程面试题，包括<strong>C&#x2F;C++、Java、Go，以及操作系统、计算机网络、数据结构、数据库和微服务</strong>等领域，为大家的面试提供帮助。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络面试 </tag>
            
            <tag> IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IP 面试题 — 为什么既有IP地址，又有MAC 地址？</title>
      <link href="/why-ip-and-mac-addresses/"/>
      <url>/why-ip-and-mac-addresses/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康。</p><p>今天给大家分享一个 IP 面试题 ：<strong>为什么既有IP地址，又有MAC 地址？</strong></p><blockquote><p><strong>小技巧</strong>：在面试中，可以参考下面的<strong>示例回答</strong>，这样回答简洁明了。<strong>详细介绍</strong>部分则是为了帮助大家系统学习，以便应对面试官深入提问。</p></blockquote><h3 id="示例回答"><a href="#示例回答" class="headerlink" title="示例回答"></a>示例回答</h3><p>IP 地址和 MAC 地址用于不同的通信层次。IP 地址用于网络层，负责设备间的全球定位和通信，而 MAC 地址用于链路层，负责本地网络中设备之间的通信。IP 地址可以变化，适应不同的网络环境，而 MAC 地址是设备的硬件标识，不会变。</p><hr><h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><h4 id="IP-地址"><a href="#IP-地址" class="headerlink" title="IP 地址"></a>IP 地址</h4><p>IP 地址（Internet Protocol Address）是一种逻辑地址，用于标识网络中的设备，确保数据可以在不同网络之间传输。每个连接到网络的设备都会被分配一个唯一的 IP 地址，这个地址可以动态变化，例如当你连接到不同的 Wi-Fi 网络时。</p><h4 id="MAC-地址"><a href="#MAC-地址" class="headerlink" title="MAC 地址"></a>MAC 地址</h4><p>MAC 地址（Media Access Control Address）是一种物理地址，由设备制造商在网卡生产时分配。每个设备的 MAC 地址是唯一的，通常不会改变。MAC 地址用于在同一个局域网内标识设备，确保数据在本地网络中的正确传输。</p><h4 id="为什么既有IP地址，又有MAC-地址？"><a href="#为什么既有IP地址，又有MAC-地址？" class="headerlink" title="为什么既有IP地址，又有MAC 地址？"></a>为什么既有IP地址，又有MAC 地址？</h4><ol><li><strong>层次和功能不同</strong>：</li></ol><ul><li><strong>IP 地址</strong>：工作在网络层，主要用于数据包在不同网络之间的传输。它就像一个邮寄地址，可以在全球范围内定位你的设备。</li><li><strong>MAC 地址</strong>：工作在链路层，主要用于数据包在同一个局域网内的传输。它就像一个设备的硬件身份证，确保在本地网络中的唯一性。</li></ul><ol start="2"><li><strong>可变性和固定性</strong>：</li></ol><ul><li><strong>IP 地址</strong>：是逻辑地址，可以动态分配和更改。例如，你的手机在家和在办公室会获得不同的 IP 地址。</li><li><strong>MAC 地址</strong>：是物理地址，由硬件决定，通常不会改变。</li></ul><ol start="3"><li><strong>数据传输的两步过程</strong>：</li></ol><ul><li>当你访问一个网站时，数据首先通过 IP 地址在互联网中找到你的设备所在的网络，</li><li>然后在你的本地网络中通过 MAC 地址将数据传输到你的设备。</li></ul><h2 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h2><p>欢迎大家关注我的微信公众号「<strong>跟着小康学编程</strong>」！本号致力于分享<strong>C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习、计算机基础原理、Linux 编程、数据库、微服务、容器技术</strong> 等内容。文章力求通俗易懂，并配有代码示例，方便初学者理解。如果您对这些内容感兴趣，欢迎关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p>后续，我还会陆续分享各个方向的编程面试题，包括<strong>C&#x2F;C++、Java、Go，以及操作系统、计算机网络、数据结构、数据库和微服务</strong>等领域，为大家的面试提供帮助。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络面试 </tag>
            
            <tag> IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IP 面试题 — 什么是私有IP地址和公有IP地址？</title>
      <link href="/private-ip-public-ip/"/>
      <url>/private-ip-public-ip/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康。</p><p>今天给大家分享一个 IP 面试题 ：<strong>什么是私有IP地址和公有IP地址？</strong></p><blockquote><p><strong>小技巧</strong>：在面试中，可以参考下面的<strong>示例回答</strong>，这样回答简洁明了。<strong>详细介绍</strong>部分则是为了帮助大家系统学习，以便应对面试官深入提问。</p></blockquote><h3 id="示例回答"><a href="#示例回答" class="headerlink" title="示例回答"></a>示例回答</h3><p>私有 IP 地址是在内部网络中使用的，不会在互联网上传输，常用于家庭和企业网络。公有 IP 地址是全球唯一的，可以在互联网上传输和访问。私有 IP 地址的范围有三段：10.0.0.0&#x2F;8，172.16.0.0&#x2F;12，和 192.168.0.0&#x2F;16，而公有 IP 地址则是其他不在私有地址范围内的地址。</p><hr><h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><h4 id="私有-IP-地址"><a href="#私有-IP-地址" class="headerlink" title="私有 IP 地址"></a>私有 IP 地址</h4><p>私有 IP 地址是专门保留用于内部网络的 IP 地址。这些地址不会在互联网上路由，因此它们在不同的网络中可以重复使用。私有 IP 地址主要用于局域网（LAN）中，如家庭网络、企业内部网络等。<br>私有 IP 地址的范围有三段：</p><ol><li><strong>10.0.0.0 到 10.255.255.255</strong>（10.0.0.0&#x2F;8）</li><li><strong>172.16.0.0 到 172.31.255.255</strong>（172.16.0.0&#x2F;12）</li><li><strong>192.168.0.0 到 192.168.255.255</strong>（192.168.0.0&#x2F;16）</li></ol><p>这些范围内的地址在私有网络中使用，不会与公网上的 IP 地址冲突。</p><h4 id="公有-IP-地址"><a href="#公有-IP-地址" class="headerlink" title="公有 IP 地址"></a>公有 IP 地址</h4><p>公有 IP 地址是可以在互联网上使用和路由的地址。这些地址由互联网服务提供商（ISP）分配，并且每个公有 IP 地址都是全球唯一的。公有 IP 地址使设备可以在全球范围内进行通信。<br><strong>私有 IP 地址和公有 IP 地址的区别：</strong></p><ol><li><strong>可访问性</strong>：</li></ol><ul><li>私有 IP 地址只能在内部网络中使用，不会在互联网上路由。</li><li>公有 IP 地址可以在互联网上使用，并且全球唯一。</li></ul><ol start="2"><li><strong>用途</strong>：</li></ol><ul><li>私有 IP 地址用于内部通信，例如家庭、企业内部网络。</li><li>公有 IP 地址用于设备之间的互联网通信。</li></ul><ol start="3"><li><strong>安全性</strong>：</li></ol><ul><li>私有 IP 地址相对更安全，因为它们不直接暴露在互联网中。</li><li>公有 IP 地址需要采取更多的安全措施，因为它们可以被任何互联网用户访问。</li></ul><h4 id="形象比喻："><a href="#形象比喻：" class="headerlink" title="形象比喻："></a>形象比喻：</h4><p>可以把私有 IP 地址和公有 IP 地址比作公司内部的分机号和外部电话号码：</p><ul><li><strong>私有 IP 地址</strong>：像公司内部的分机号，只能在公司内部使用和拨打。例如，公司内部的不同部门或办公室之间的通话。</li><li><strong>公有 IP 地址</strong>：像公司的外部电话号码，任何人都可以拨打并与公司联系。例如，客户从外部拨打公司电话进行咨询。</li></ul><h2 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h2><p>欢迎大家关注我的微信公众号「<strong>跟着小康学编程</strong>」！本号致力于分享<strong>C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习、计算机基础原理、Linux 编程、数据库、微服务、容器技术</strong> 等内容。文章力求通俗易懂，并配有代码示例，方便初学者理解。如果您对这些内容感兴趣，欢迎关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p>后续，我还会陆续分享各个方向的编程面试题，包括<strong>C&#x2F;C++、Java、Go，以及操作系统、计算机网络、数据结构、数据库和微服务</strong>等领域，为大家的面试提供帮助。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络面试 </tag>
            
            <tag> IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IP 面试题 — IP 地址有哪些分类？</title>
      <link href="/ip-category/"/>
      <url>/ip-category/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康。</p><p>今天给大家分享一个 IP 面试题 ：<strong>IP 地址有哪些分类？</strong></p><blockquote><p><strong>小技巧</strong>：在面试中，可以参考下面的<strong>示例回答</strong>，这样回答简洁明了。<strong>详细介绍</strong>部分则是为了帮助大家系统学习，以便应对面试官深入提问。</p></blockquote><h3 id="示例回答"><a href="#示例回答" class="headerlink" title="示例回答"></a>示例回答</h3><p>IP 地址可以分为五类：A、B、C、D 和 E 类。A、B、C 类用于常规的网络通信，D 类用于组播，E 类保留用于实验。A 类地址范围从 1.0.0.0 到 126.0.0.0，B 类从 128.0.0.0 到 191.255.255.255  ，C 类从 192.0.0.0 到 223.255.255.0，D 类从 224.0.0.0 到 239.255.255.255，E 类从 240.0.0.0 到 255.255.255.255。</p><hr><h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><h4 id="IP-地址分类"><a href="#IP-地址分类" class="headerlink" title="IP 地址分类"></a>IP 地址分类</h4><p>IP 地址是互联网协议地址的简称，是用来标识网络中每一台设备的唯一地址。IP 地址的分类是为了便于网络管理和分配。  IP 地址分为五类：A 类、B 类、C 类、D 类和 E 类。每一类都有其特定的用途和范围。</p><h4 id="A-类地址"><a href="#A-类地址" class="headerlink" title="A 类地址"></a>A 类地址</h4><ul><li><strong>范围</strong>：1.0.0.0 到 126.0.0.0</li><li><strong>特征</strong>：A 类地址用于大型网络。第一个字节（8 位）标识网络部分，剩下的三个字节（24 位）标识主机部分。A 类地址可以提供 16,777,214 个主机地址。</li></ul><h4 id="B-类地址"><a href="#B-类地址" class="headerlink" title="B 类地址"></a>B 类地址</h4><ul><li><strong>范围</strong>： 128.0.0.0 到 191.255.255.255  </li><li><strong>特征</strong>：B 类地址用于中型网络。前两个字节（16 位）标识网络部分，剩下的两个字节（16 位）标识主机部分。B 类地址可以提供 65,534 个主机地址。</li></ul><h4 id="C-类地址"><a href="#C-类地址" class="headerlink" title="C 类地址"></a>C 类地址</h4><ul><li><strong>范围</strong>：192.0.0.0 到 223.255.255.0 </li><li><strong>特征</strong>：C 类地址用于小型网络。前三个字节（24 位）标识网络部分，最后一个字节（8 位）标识主机部分。C 类地址可以提供 254 个主机地址。</li></ul><h4 id="D-类地址"><a href="#D-类地址" class="headerlink" title="D 类地址"></a>D 类地址</h4><ul><li><strong>范围</strong>：224.0.0.0 到 239.255.255.255</li><li><strong>特征</strong>：D 类地址用于组播。组播是一种将数据发送到多个特定接收者的通信方式，而不是像单播那样发送到单个接收者。</li></ul><h4 id="E-类地址"><a href="#E-类地址" class="headerlink" title="E 类地址"></a>E 类地址</h4><ul><li><strong>范围</strong>：240.0.0.0 到 255.255.255.255</li><li><strong>特征</strong>：E 类地址保留用于实验和未来用途。一般不在公共网络中使用。</li></ul><h4 id="形象比喻"><a href="#形象比喻" class="headerlink" title="形象比喻"></a>形象比喻</h4><p>可以把 IP 地址分类比作不同的邮政编码区域：</p><ul><li>A 类地址就像大城市的邮政编码区域，覆盖范围广，住户很多。</li><li>B 类地址像中等城市的邮政编码区域，范围适中，住户数量适中。</li><li>C 类地址像小镇或社区的邮政编码区域，范围小，住户少。</li><li>D 类地址像是特定的社区公告板，信息发送给特定的一群人。</li><li>E 类地址就像是预留的特殊区域，可能会有未来的特殊用途。</li></ul><h2 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h2><p>欢迎大家关注我的微信公众号「<strong>跟着小康学编程</strong>」！本号致力于分享<strong>C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习、计算机基础原理、Linux 编程、数据库、微服务、容器技术</strong> 等内容。文章力求通俗易懂，并配有代码示例，方便初学者理解。如果您对这些内容感兴趣，欢迎关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p>后续，我还会陆续分享各个方向的编程面试题，包括<strong>C&#x2F;C++、Java、Go，以及操作系统、计算机网络、数据结构、数据库和微服务</strong>等领域，为大家的面试提供帮助。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络面试 </tag>
            
            <tag> IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IP 面试题 — IP 协议的定义和作用？</title>
      <link href="/what-ip/"/>
      <url>/what-ip/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康。</p><p>今天给大家分享一个 IP 面试题 ：<strong>IP 协议的定义和作用？</strong></p><blockquote><p><strong>小技巧</strong>：在面试中，可以参考下面的<strong>示例回答</strong>，这样回答简洁明了。<strong>详细介绍</strong>部分则是为了帮助大家系统学习，以便应对面试官深入提问。</p></blockquote><h3 id="示例回答"><a href="#示例回答" class="headerlink" title="示例回答"></a>示例回答</h3><p>IP 协议，即互联网协议（Internet Protocol），是用于网络通信的基础协议。它的主要作用是提供一种机制，使数据能够从一个设备传送到另一个设备。IP 协议定义了数据包的格式和寻址方式，确保数据包能够在不同的网络之间正确地传输。简单来说，它就像网络世界的邮递员，确保你的数据包从发件人那里顺利送到收件人手中。</p><hr><h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><h4 id="IP-协议的定义"><a href="#IP-协议的定义" class="headerlink" title="IP 协议的定义"></a>IP 协议的定义</h4><p>IP 协议全称是“互联网协议”，它是互联网的核心协议之一。IP 协议负责定义数据包的结构，使数据在网络上传输变得可能。IP 协议主要包含两种版本：IPv4 和 IPv6。</p><ul><li><strong>IPv4</strong>：使用 32 位地址，可以提供大约 43 亿个独特的地址。</li><li><strong>IPv6</strong>：使用 128 位地址，能够提供几乎无限数量的地址，解决了 IPv4 地址耗尽的问题。</li></ul><h4 id="IP-协议的作用"><a href="#IP-协议的作用" class="headerlink" title="IP 协议的作用"></a>IP 协议的作用</h4><ul><li><strong>寻址</strong>：IP 协议定义了全球唯一的地址格式（IP 地址），确保每个连接到网络的设备都有一个唯一的标识。</li><li><strong>数据封装</strong>：IP 协议将数据封装成数据包，包含源地址和目标地址。</li><li><strong>路由选择</strong>：IP 协议通过路由器选择最佳路径，将数据包从源地址发送到目标地址，即使中间经过多个网络</li><li><strong>数据传输</strong>：IP 协议确保数据包能够在不同的网络之间传输，无论它们使用何种底层技术。</li></ul><h4 id="错误处理："><a href="#错误处理：" class="headerlink" title="错误处理："></a>错误处理：</h4><p>IP 协议本身不负责重传丢失的数据包或纠正数据损坏，但它提供了基本的错误检测机制。例如，IP 数据包头部有一个校验和字段，用于验证数据包头部是否在传输过程中出现错误。如果检测到错误，数据包会被丢弃，但 IP 协议不会尝试重传。这种错误处理更多是由上层协议（如 TCP）来完成的。</p><h4 id="形象比喻"><a href="#形象比喻" class="headerlink" title="形象比喻"></a>形象比喻</h4><p>可以把 IP 协议比作网络世界里的邮递员。每个数据包就像一封信，IP 协议负责在信封上写明收件人的地址（目标 IP 地址）和寄件人的地址（源 IP 地址），然后找到最佳的路线把信从一个地方送到另一个地方。即使中途需要转车（通过多个路由器），邮递员也会确保信最终到达目的地。至于信丢失或损坏，邮递员会通知发信人，具体的处理措施由发信人和收信人商定（由上层协议如 TCP 处理）。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h2><p>欢迎大家关注我的微信公众号「<strong>跟着小康学编程</strong>」！本号致力于分享<strong>C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习、计算机基础原理、Linux 编程、数据库、微服务、容器技术</strong> 等内容。文章力求通俗易懂，并配有代码示例，方便初学者理解。如果您对这些内容感兴趣，欢迎关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p>后续，我还会陆续分享各个方向的编程面试题，包括<strong>C&#x2F;C++、Java、Go，以及操作系统、计算机网络、数据结构、数据库和微服务</strong>等领域，为大家的面试提供帮助。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络面试 </tag>
            
            <tag> IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP 面试题 — TCP 最大连接数限制？</title>
      <link href="/tcp-max-connection-limits/"/>
      <url>/tcp-max-connection-limits/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康。</p><p>今天给大家分享一个 TCP 面试题 ：<strong>TCP 最大连接数限制？</strong></p><blockquote><p><strong>小技巧</strong>：在面试中，可以参考下面的<strong>示例回答</strong>，这样回答简洁明了。<strong>详细介绍</strong>部分则是为了帮助大家系统学习，以便应对面试官深入提问。</p></blockquote><h3 id="示例回答："><a href="#示例回答：" class="headerlink" title="示例回答："></a>示例回答：</h3><p>TCP 最大连接数受到多个因素的限制，包括系统的可用端口数、文件描述符的上限和系统资源等。一般来说，单个 IP 地址的 TCP 连接数限制在 65535 个以内，因为端口号范围是 0 到 65535。</p><hr><h3 id="详细解释："><a href="#详细解释：" class="headerlink" title="详细解释："></a>详细解释：</h3><p>TCP 最大连接数限制是由多个因素综合决定的，包括系统的硬件资源、操作系统配置以及网络协议栈的限制。</p><h4 id="主要限制因素："><a href="#主要限制因素：" class="headerlink" title="主要限制因素："></a>主要限制因素：</h4><ol><li><strong>端口号范围：</strong></li></ol><ul><li><strong>原理：</strong> TCP 连接是由源 IP、源端口、目标 IP 和目标端口四元组唯一标识的。每个 IP 地址的端口号范围是 0 到 65535，其中 0 到 1023 是保留端口，实际可用的端口是 1024 到 65535。</li><li><strong>限制：</strong> 单个 IP 地址的最大连接数理论上限是 65535 个。</li></ul><ol start="2"><li><strong>文件描述符上限：</strong></li></ol><ul><li><strong>原理：</strong> 每个 TCP 连接在操作系统中对应一个文件描述符。操作系统对每个进程能打开的文件描述符数量有限制，这个限制可以通过调整系统配置来修改。</li><li><strong>限制：</strong> 默认情况下，Linux 系统每个进程的文件描述符上限是 1024 个，可以通过修改 &#x2F;etc&#x2F;security&#x2F;limits.conf 文件和使用 ulimit 命令来增加这个上限。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前文件描述符限制</span></span><br><span class="line"><span class="built_in">ulimit</span> -n</span><br><span class="line"></span><br><span class="line"><span class="comment"># 临时增加文件描述符限制</span></span><br><span class="line"><span class="built_in">ulimit</span> -n 65536</span><br><span class="line"></span><br><span class="line"><span class="comment"># 永久增加文件描述符限制（编辑 /etc/security/limits.conf）</span></span><br><span class="line">* soft nofile 65536</span><br><span class="line">* hard nofile 65536</span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li><strong>系统资源：</strong></li></ol><ul><li><strong>原理：</strong> 系统的内存、CPU 和网络带宽等资源也会影响最大连接数。每个连接都会占用一定的系统资源，超过系统资源限制会导致系统性能下降甚至崩溃。</li><li><strong>优化：</strong> 通过优化系统资源管理、增加硬件配置和使用高效的网络编程模型（如多线程、异步 IO 等）可以提高系统的最大连接数。</li></ul><ol start="4"><li><strong>TCP 参数配置：</strong></li></ol><ul><li><strong>原理：</strong> TCP 协议栈中的一些参数配置也会影响最大连接数，例如 net.ipv4.ip_local_port_range、net.core.somaxconn 和 net.ipv4.tcp_max_syn_backlog 等。</li><li><strong>调整：</strong> 可以通过修改 &#x2F;etc&#x2F;sysctl.conf 文件和使用 sysctl 命令来调整这些参数。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前 TCP 参数</span></span><br><span class="line">sysctl -a | grep ip_local_port_range</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改 TCP 参数（编辑 /etc/sysctl.conf）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义本地端口的范围，以增加可用的端口数量</span></span><br><span class="line">net.ipv4.ip_local_port_range = 1024 65535</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义每个端口的最大监听队列长度:(这个队列包含了已经完成三次握手、等待由应用程序接受（accept）的TCP连接。)</span></span><br><span class="line">net.core.somaxconn = 4096</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义 SYN 队列的最大长度:(SYN队列是用于存放处于SYN_RCVD状态的半开连接（half-open connections）)</span></span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 4096</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使修改生效</span></span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure></li></ul><h4 id="实际例子："><a href="#实际例子：" class="headerlink" title="实际例子："></a>实际例子：</h4><ul><li><strong>Web 服务器：</strong> 对于一个高并发的 Web 服务器，通常需要处理成千上万的并发连接。通过增加文件描述符上限、优化系统资源管理和调整 TCP 参数配置，可以显著提高服务器的最大连接数，确保高并发请求的处理能力。</li></ul><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>TCP 最大连接数受到端口号范围、文件描述符上限、系统资源和 TCP 参数配置等多方面的限制。通过合理调整这些因素，可以有效提高系统的最大连接数，满足高并发网络应用的需求。理解这些限制因素及其优化方法，对于设计和维护高性能网络服务器至关重要。</p><p>​</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h2><p>欢迎大家关注我的微信公众号「<strong>跟着小康学编程</strong>」！本号致力于分享<strong>C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习、计算机基础原理、Linux 编程、数据库、微服务、容器技术</strong> 等内容。文章力求通俗易懂，并配有代码示例，方便初学者理解。如果您对这些内容感兴趣，欢迎关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p>后续，我还会陆续分享各个方向的编程面试题，包括<strong>C&#x2F;C++、Java、Go，以及操作系统、计算机网络、数据结构、数据库和微服务</strong>等领域，为大家的面试提供帮助。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络面试 </tag>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP 面试题 — TCP 粘包是怎么产生的？</title>
      <link href="/how-tcp-sticky-packets-occur/"/>
      <url>/how-tcp-sticky-packets-occur/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康。</p><p>今天给大家分享一个 TCP 面试题 ：<strong>TCP 粘包是怎么产生的？</strong></p><blockquote><p><strong>小技巧</strong>：在面试中，可以参考下面的<strong>示例回答</strong>，这样回答简洁明了。<strong>详细介绍</strong>部分则是为了帮助大家系统学习，以便应对面试官深入提问。</p></blockquote><h3 id="示例回答："><a href="#示例回答：" class="headerlink" title="示例回答："></a>示例回答：</h3><p>TCP 粘包是因为发送方连续发送多个小数据包，接收方一次性接收并合并了这些数据包。造成这种情况的原因包括发送端缓冲区满、TCP 协议优化传输效率以及接收方处理数据不及时。</p><hr><h3 id="详细解释："><a href="#详细解释：" class="headerlink" title="详细解释："></a>详细解释：</h3><p>TCP 粘包是网络编程中常见的问题，通常发生在发送方发送多个小数据包，而接收方一次性接收并合并了这些数据包，导致接收方无法正确解析每个独立的数据包。理解粘包现象及其原因对于网络编程非常重要。</p><h4 id="粘包现象的产生原因："><a href="#粘包现象的产生原因：" class="headerlink" title="粘包现象的产生原因："></a>粘包现象的产生原因：</h4><ol><li><strong>TCP 协议的优化机制：</strong></li></ol><ul><li><strong>发送端连续发送多个小数据包</strong>：  当发送方在短时间内发送多个小数据包，TCP 协议为了提高传输效率，可能会将这些小数据包合并成一个大的数据包，再一起发送出去。这种优化机制在减少包头开销和提高网络利用率的同时，会导致粘包现象。</li></ul><ol start="2"><li><strong>接收方处理不及时：</strong></li></ol><ul><li>接收方处理数据的速度较慢，导致接收到的数据积累在接收缓冲区中，当接收方读取数据时，会一次性读取多个数据包，造成粘包现象。</li></ul><h4 id="例子说明："><a href="#例子说明：" class="headerlink" title="例子说明："></a>例子说明：</h4><p>假设有一个聊天应用，用户 A 发送了两条消息“Hello”和“How are you?”。由于发送端在短时间内发送了这两条消息，它们可能被合并成一个数据包发送给接收方 B。接收方 B 在接收时，会一次性接收到“HelloHow are you?”，需要处理粘包问题。</p><h4 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h4><ol><li><strong>固定长度消息：</strong></li></ol><ul><li>每个消息固定长度，接收方按照固定长度读取数据，确保每次读取的都是完整的消息。</li></ul><ol start="2"><li><strong>使用特殊分隔符：</strong></li></ol><ul><li>在每个消息之间使用特殊字符或字符串作为分隔符，接收方根据分隔符拆分数据包。</li></ul><ol start="3"><li><strong>消息头包含长度信息：</strong></li></ol><ul><li>在每个消息前添加消息头，消息头包含该消息的长度信息，接收方根据长度信息读取完整消息。</li></ul><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>TCP 粘包现象是由于发送方连续发送多个小数据包、以及接收方处理数据不及时等原因造成的。理解粘包现象的产生原因及其解决方法，可以有效应对网络编程中的数据传输问题，确保数据的正确解析和处理。通过设计合理的协议和处理机制，可以提高网络通信的稳定性和可靠性。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h2><p>欢迎大家关注我的微信公众号「<strong>跟着小康学编程</strong>」！本号致力于分享<strong>C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习、计算机基础原理、Linux 编程、数据库、微服务、容器技术</strong> 等内容。文章力求通俗易懂，并配有代码示例，方便初学者理解。如果您对这些内容感兴趣，欢迎关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p>后续，我还会陆续分享各个方向的编程面试题，包括<strong>C&#x2F;C++、Java、Go，以及操作系统、计算机网络、数据结构、数据库和微服务</strong>等领域，为大家的面试提供帮助。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络面试 </tag>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP 面试题 — 怎么解决拆包和粘包？</title>
      <link href="/resolve-split-and-sticky-packets/"/>
      <url>/resolve-split-and-sticky-packets/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康。</p><p>今天给大家分享一个 TCP 面试题 ：<strong>怎么解决拆包和粘包？</strong></p><blockquote><p><strong>小技巧</strong>：在面试中，可以参考下面的<strong>示例回答</strong>，这样回答简洁明了。<strong>详细介绍</strong>部分则是为了帮助大家系统学习，以便应对面试官深入提问。</p></blockquote><h3 id="示例回答："><a href="#示例回答：" class="headerlink" title="示例回答："></a>示例回答：</h3><p>解决拆包和粘包的方法主要有三种：使用固定长度消息、使用特殊分隔符、在消息头中包含长度信息。固定长度消息确保每次发送和接收的数据大小一致，特殊分隔符帮助识别消息边界，消息头则告诉接收方消息的具体长度。  </p><hr><h3 id="详细解释："><a href="#详细解释：" class="headerlink" title="详细解释："></a>详细解释：</h3><p>拆包和粘包问题是网络编程中常见的现象，尤其是在使用 TCP 协议进行数据传输时。了解并掌握解决这些问题的方法，对于保证数据传输的准确性和完整性非常重要。</p><h4 id="解决拆包和粘包的方法："><a href="#解决拆包和粘包的方法：" class="headerlink" title="解决拆包和粘包的方法："></a>解决拆包和粘包的方法：</h4><ol><li><strong>固定长度消息：</strong></li></ol><ul><li><strong>原理：</strong> 发送方发送的每个消息都有固定的长度，接收方按照固定的长度来读取数据。这样接收方可以准确地知道每次读取的数据边界，避免了拆包和粘包的问题。</li><li><strong>优点：</strong> 实现简单，容易维护。</li><li><strong>缺点：</strong> 不适合传输变长的数据，可能会导致空间浪费。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例：发送固定长度的消息</span></span><br><span class="line"><span class="type">char</span> message[<span class="number">20</span>] = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">send(sockfd, message, <span class="keyword">sizeof</span>(message), <span class="number">0</span>);</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li><strong>使用特殊分隔符：</strong></li></ol><ul><li><strong>原理：</strong> 在每个消息之间使用特定的分隔符（如换行符、特殊字符或字符串）。接收方接收到数据后，根据分隔符来拆分消息。</li><li><strong>优点：</strong> 适合传输变长的数据，灵活性高。</li><li><strong>缺点：</strong> 如果消息内容中包含分隔符，需要进行转义处理，增加复杂度。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例：使用特殊分隔符</span></span><br><span class="line"><span class="type">char</span> message[] = <span class="string">&quot;Hello, world!|How are you?&quot;</span>;</span><br><span class="line">send(sockfd, message, <span class="keyword">sizeof</span>(message), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收方根据分隔符 &#x27;|&#x27; 拆分消息</span></span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li><strong>消息头包含长度信息：</strong></li></ol><ul><li><strong>原理：</strong> 在每个消息的前面添加一个消息头，消息头包含了该消息的长度信息。接收方首先读取消息头，根据消息头中的长度信息来读取完整的消息。</li><li><strong>优点：</strong> 适合传输变长的数据，效率高。</li><li><strong>缺点：</strong> 需要设计消息头结构，增加了一些实现的复杂性。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例：消息头包含长度信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Message</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">    <span class="type">char</span> data[<span class="number">256</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Message</span> <span class="title">msg</span>;</span></span><br><span class="line">msg.length = <span class="built_in">strlen</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(msg.data, <span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">send(sockfd, &amp;msg, <span class="keyword">sizeof</span>(msg.length) + msg.length, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收方先读取消息头，再根据长度读取数据</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>解决拆包和粘包问题的方法包括固定长度消息、使用特殊分隔符和消息头包含长度信息。固定长度消息简单易用，但不适合变长数据；使用特殊分隔符灵活性高，但需要处理分隔符转义；消息头包含长度信息适合变长数据，效率高，但实现稍复杂。理解并掌握这些方法，可以有效解决拆包和粘包问题，确保数据传输的准确性和完整性。</p><p>​</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h2><p>欢迎大家关注我的微信公众号「<strong>跟着小康学编程</strong>」！本号致力于分享<strong>C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习、计算机基础原理、Linux 编程、数据库、微服务、容器技术</strong> 等内容。文章力求通俗易懂，并配有代码示例，方便初学者理解。如果您对这些内容感兴趣，欢迎关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p>后续，我还会陆续分享各个方向的编程面试题，包括<strong>C&#x2F;C++、Java、Go，以及操作系统、计算机网络、数据结构、数据库和微服务</strong>等领域，为大家的面试提供帮助。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络面试 </tag>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP 面试题 — 说说TCP 的粘包和拆包？</title>
      <link href="/tcp-sticky-and-split-packets/"/>
      <url>/tcp-sticky-and-split-packets/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康。</p><p>今天给大家分享一个 TCP 面试题 ：<strong>说说TCP 的粘包和拆包？</strong></p><blockquote><p><strong>小技巧</strong>：在面试中，可以参考下面的<strong>示例回答</strong>，这样回答简洁明了。<strong>详细介绍</strong>部分则是为了帮助大家系统学习，以便应对面试官深入提问。</p></blockquote><h3 id="示例回答："><a href="#示例回答：" class="headerlink" title="示例回答："></a>示例回答：</h3><p>TCP 粘包和拆包是指数据在传输过程中的一种现象。粘包是多个数据包被合并成一个，拆包是一个数据包被拆成多个。发生这种情况的原因包括发送端缓冲区满、网络传输过程中的数据流控制以及接收端处理不及时等。</p><hr><h3 id="详细解释："><a href="#详细解释：" class="headerlink" title="详细解释："></a>详细解释：</h3><p>TCP 是一种面向连接的、可靠的传输协议。在 TCP 传输过程中，由于其流式传输的特性，可能会出现粘包和拆包的现象。理解这些现象及其处理方法对于网络编程非常重要。</p><h4 id="粘包现象："><a href="#粘包现象：" class="headerlink" title="粘包现象："></a>粘包现象：</h4><ul><li><strong>定义：</strong> 粘包是指多个数据包在传输过程中被合并成一个数据包。接收方在读取数据时，会将多个数据包一起读取，造成数据混乱。</li><li><strong>原因：</strong><ol><li>发送端一次性发送了多个小数据包，发送缓冲区将这些数据包合并。</li><li>网络传输过程中，TCP 协议会根据网络状况进行优化，合并小数据包以提高传输效率。</li><li>接收端处理数据不及时，读取到多个数据包。</li></ol></li><li><strong>解决方法：</strong><ol><li><strong>固定长度消息：</strong> 每个消息固定长度，接收方按照固定长度读取数据。</li><li><strong>特殊分隔符：</strong> 使用特殊字符或字符串作为消息分隔符，接收方根据分隔符拆分数据包。</li><li><strong>消息头：</strong> 在每个消息前加上消息头，消息头包含消息长度信息，接收方根据长度信息读取完整消息。</li></ol></li></ul><h4 id="拆包现象："><a href="#拆包现象：" class="headerlink" title="拆包现象："></a>拆包现象：</h4><ul><li><strong>定义：</strong> 拆包是指一个数据包在传输过程中被拆成多个小数据包，接收方需要多次读取才能获取完整的数据包。</li><li><strong>原因：</strong><ol><li>发送端发送的大数据包超过了网络传输的最大报文段（MSS），被拆分成多个小数据包传输。</li><li>网络传输过程中，数据包被拆分以适应网络传输的限制。</li></ol></li><li><strong>解决方法：</strong><ol><li><strong>流式处理：</strong> 接收方设计成流式处理模式，能够处理分批到达的数据，并将其组合成完整的数据包。</li><li><strong>超时机制：</strong> 接收方设置超时机制，如果在一定时间内未接收到完整数据包，可以采取相应的措施（如重传请求）。</li></ol></li></ul><h4 id="实际例子："><a href="#实际例子：" class="headerlink" title="实际例子："></a>实际例子：</h4><ul><li><strong>场景 1：</strong> 一个聊天应用中，用户 A 发送了两条消息“Hello”和“How are you?”，由于粘包现象，接收方 B 收到的数据可能是“HelloHow are you?”，需要接收方拆分这些数据。</li><li><strong>场景 2：</strong> 文件传输过程中，用户 A 发送一个大文件，由于拆包现象，接收方 B 需要多次读取数据，直到接收到完整的文件数据。</li></ul><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>TCP 粘包和拆包是数据传输过程中常见的现象，由于 TCP 的流式传输特性，这些现象不可避免。理解粘包和拆包的原理及其解决方法，可以有效应对网络编程中的数据传输问题，确保数据传输的准确性和可靠性。通过设计合理的数据传输协议和处理机制，可以提高网络通信的效率和稳定性。</p><p>​</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h2><p>欢迎大家关注我的微信公众号「<strong>跟着小康学编程</strong>」！本号致力于分享<strong>C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习、计算机基础原理、Linux 编程、数据库、微服务、容器技术</strong> 等内容。文章力求通俗易懂，并配有代码示例，方便初学者理解。如果您对这些内容感兴趣，欢迎关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p>后续，我还会陆续分享各个方向的编程面试题，包括<strong>C&#x2F;C++、Java、Go，以及操作系统、计算机网络、数据结构、数据库和微服务</strong>等领域，为大家的面试提供帮助。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络面试 </tag>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP 面试题 — 谈谈你对 ARQ 协议的理解？</title>
      <link href="/arq/"/>
      <url>/arq/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康。</p><p>今天给大家分享一个 TCP 面试题 ：<strong>谈谈你对 ARQ 协议的理解？</strong></p><blockquote><p><strong>小技巧</strong>：在面试中，可以参考下面的<strong>示例回答</strong>，这样回答简洁明了。<strong>详细介绍</strong>部分则是为了帮助大家系统学习，以便应对面试官深入提问。</p></blockquote><h3 id="示例回答："><a href="#示例回答：" class="headerlink" title="示例回答："></a>示例回答：</h3><p>ARQ 协议是一种自动重传请求协议，用于确保数据可靠传输。如果接收方未能正确接收数据，会请求发送方重传。常见的 ARQ 协议包括停止等待 ARQ、连续 ARQ 。</p><hr><h3 id="详细解释："><a href="#详细解释：" class="headerlink" title="详细解释："></a>详细解释：</h3><p>ARQ（Automatic Repeat reQuest，自动重传请求）协议是一种用于可靠数据传输的机制。它通过确认和重传机制确保数据能够正确无误地到达接收方。ARQ 协议有多种实现方式，以下是几种主要的 ARQ 协议：</p><h4 id="停止等待-ARQ（Stop-and-Wait-ARQ）："><a href="#停止等待-ARQ（Stop-and-Wait-ARQ）：" class="headerlink" title="停止等待 ARQ（Stop-and-Wait ARQ）："></a>停止等待 ARQ（Stop-and-Wait ARQ）：</h4><ul><li><strong>工作原理：</strong> 发送方每次发送一个数据包，然后等待接收方的确认（ACK）包。如果在规定时间内未收到确认，发送方会重传该数据包。</li><li><strong>优点：</strong> 实现简单，确保每个数据包都被确认。</li><li><strong>缺点：</strong> 效率较低，因为发送方在等待确认期间不能发送新数据。</li></ul><h4 id="连续-ARQ（Continuous-ARQ）："><a href="#连续-ARQ（Continuous-ARQ）：" class="headerlink" title="连续 ARQ（Continuous ARQ）："></a>连续 ARQ（Continuous ARQ）：</h4><ul><li><strong>工作原理：</strong> 发送方可以连续发送多个数据包，无需等待每个数据包的确认。接收方按顺序接收并确认每个数据包，如果发现丢包或错误，接收方会请求重传丢失的数据包。</li><li><strong>优点：</strong> 提高了数据传输效率，因为发送方可以连续发送数据。</li><li><strong>缺点：</strong> 需要更复杂的序列号管理和重传机制。</li></ul><h4 id="实际例子："><a href="#实际例子：" class="headerlink" title="实际例子："></a>实际例子：</h4><ul><li><strong>场景 1：停止等待 ARQ：</strong> 发送方发送数据包 1，等待接收方的确认。如果接收方没有收到数据包 1 或确认丢失，发送方会在超时后重传数据包 1。</li><li><strong>场景 2：连续 ARQ：</strong> 发送方连续发送数据包 1, 2, 3，接收方依次确认。如果接收方发现数据包 2 丢失，会请求发送方重传数据包 2。</li></ul><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>ARQ 协议通过确认和重传机制，确保数据可靠传输。停止等待 ARQ 简单但效率低，连续 ARQ 提高了效率但复杂度增加。理解这些协议有助于掌握可靠数据传输的基本原理和实现方法，在实际网络通信中应用更为高效的传输方案。</p><p>​</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h2><p>欢迎大家关注我的微信公众号「<strong>跟着小康学编程</strong>」！本号致力于分享<strong>C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习、计算机基础原理、Linux 编程、数据库、微服务、容器技术</strong> 等内容。文章力求通俗易懂，并配有代码示例，方便初学者理解。如果您对这些内容感兴趣，欢迎关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p>后续，我还会陆续分享各个方向的编程面试题，包括<strong>C&#x2F;C++、Java、Go，以及操作系统、计算机网络、数据结构、数据库和微服务</strong>等领域，为大家的面试提供帮助。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络面试 </tag>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP 面试题 — 谈谈你对停止等待协议的理解？</title>
      <link href="/stop-and-wait-protocol/"/>
      <url>/stop-and-wait-protocol/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康。</p><p>今天给大家分享一个 TCP 面试题 ：<strong>谈谈你对停止等待协议的理解？</strong></p><blockquote><p><strong>小技巧</strong>：在面试中，可以参考下面的<strong>示例回答</strong>，这样回答简洁明了。<strong>详细介绍</strong>部分则是为了帮助大家系统学习，以便应对面试官深入提问。</p></blockquote><h3 id="示例回答："><a href="#示例回答：" class="headerlink" title="示例回答："></a>示例回答：</h3><p>停止等待协议是一种简单的数据传输协议。发送方每次发送一个数据包，等待接收方确认（ACK）后再发送下一个。如果超时未收到确认，发送方会重传数据包。它保证了数据的可靠传输，但效率较低。</p><hr><h3 id="详细解释："><a href="#详细解释：" class="headerlink" title="详细解释："></a>详细解释：</h3><p>停止等待协议（Stop-and-Wait Protocol）是最基本的数据传输协议之一，用于保证数据的可靠传输。其工作原理和特点如下：</p><h4 id="基本工作原理："><a href="#基本工作原理：" class="headerlink" title="基本工作原理："></a>基本工作原理：</h4><ul><li><strong>发送数据包：</strong> 发送方每次发送一个数据包，然后进入等待状态，等待接收方的确认（ACK）包。</li><li><strong>接收确认：</strong> 接收方收到数据包后，发送一个确认（ACK）包给发送方，通知其已成功接收数据。</li><li><strong>重传机制：</strong> 如果发送方在指定时间内（超时时间）未收到接收方的确认包，认为数据包丢失或损坏，会重新发送该数据包。</li></ul><h4 id="流程举例："><a href="#流程举例：" class="headerlink" title="流程举例："></a>流程举例：</h4><ul><li>发送方发送数据包1，等待接收方确认。</li><li>接收方收到数据包1，发送确认包 ACK1。</li><li>发送方收到 ACK1，发送数据包2。</li><li>如果发送方发送数据包2后超时未收到 ACK2，则重新发送数据包2。</li></ul><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ul><li><strong>简单可靠：</strong> 停止等待协议通过确认机制和超时重传，确保每个数据包都能被可靠地传输到接收方。</li><li><strong>易于实现：</strong> 由于其简单的操作流程，停止等待协议易于实现和理解，适用于基础的通信场景。</li></ul><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ul><li><strong>效率较低：</strong> 由于发送方必须等待接收方的确认后才能发送下一个数据包，数据传输效率较低，尤其是在高延迟或高带宽的网络环境中。</li><li><strong>网络利用率低：</strong> 在等待确认期间，发送方的链路资源闲置，未被充分利用，导致网络利用率低。</li></ul><h4 id="实际应用："><a href="#实际应用：" class="headerlink" title="实际应用："></a>实际应用：</h4><ul><li>停止等待协议常用于简单的通信场景或带宽和延迟要求不高的环境中。在现代高速网络中，通常会采用更复杂和高效的传输协议，如滑动窗口协议，以提高数据传输效率和网络利用率。</li></ul><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>停止等待协议通过每次发送一个数据包并等待确认的方式，确保了数据传输的可靠性。虽然其简单可靠，但效率较低，适用于带宽和延迟要求不高的场景。在实际应用中，理解其原理有助于掌握更复杂的传输协议，如滑动窗口协议和 TCP 的传输机制。</p><p>​</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h2><p>欢迎大家关注我的微信公众号「<strong>跟着小康学编程</strong>」！本号致力于分享<strong>C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习、计算机基础原理、Linux 编程、数据库、微服务、容器技术</strong> 等内容。文章力求通俗易懂，并配有代码示例，方便初学者理解。如果您对这些内容感兴趣，欢迎关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p>后续，我还会陆续分享各个方向的编程面试题，包括<strong>C&#x2F;C++、Java、Go，以及操作系统、计算机网络、数据结构、数据库和微服务</strong>等领域，为大家的面试提供帮助。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络面试 </tag>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP 面试题 — 说说 TCP 的重传机制？</title>
      <link href="/tcp-retransmission/"/>
      <url>/tcp-retransmission/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康。</p><p>今天给大家分享一个 TCP 面试题 ：<strong>说说 TCP 的重传机制？</strong></p><blockquote><p><strong>小技巧</strong>：在面试中，可以参考下面的<strong>示例回答</strong>，这样回答简洁明了。<strong>详细介绍</strong>部分则是为了帮助大家系统学习，以便应对面试官深入提问。</p></blockquote><h3 id="示例回答："><a href="#示例回答：" class="headerlink" title="示例回答："></a>示例回答：</h3><p>TCP 的重传机制通过超时重传和快速重传来确保数据包到达，使用选择性确认(SACK)优化重传效率。超时重传是发送方在指定时间内未收到 ACK 时重传数据，快速重传是在接收方收到三次重复的 ACK 时立即重传数据。SACK 则允许接收方告知发送方哪些数据包已收到，哪些丢失，从而优化重传效率。 这些机制共同确保丢失的数据包能被及时重传，保证数据传输的可靠性。 </p><hr><h3 id="详细解释："><a href="#详细解释：" class="headerlink" title="详细解释："></a>详细解释：</h3><p>TCP 的重传机制是为了确保数据可靠传输，即使在数据包丢失的情况下也能保证完整性。主要包括以下两种机制：</p><h4 id="超时重传（Timeout-Retransmission）："><a href="#超时重传（Timeout-Retransmission）：" class="headerlink" title="超时重传（Timeout Retransmission）："></a>超时重传（Timeout Retransmission）：</h4><ul><li><strong>工作原理：</strong> 发送方在发送数据包后，会启动一个定时器（重传定时器）。如果在指定时间内（超时时间）没有收到接收方的确认（ACK），发送方会认为该数据包可能丢失或损坏，然后重新发送该数据包。</li><li><strong>关键点：</strong> 超时时间的设定非常重要，过短可能导致不必要的重传，过长则会延迟数据传输。TCP 动态调整超时时间，以适应不同的网络状况。</li></ul><h4 id="快速重传（Fast-Retransmit）："><a href="#快速重传（Fast-Retransmit）：" class="headerlink" title="快速重传（Fast Retransmit）："></a>快速重传（Fast Retransmit）：</h4><ul><li><strong>工作原理：</strong> 接收方在收到失序的数据包时，会发送一个重复的 ACK，通知发送方某个数据包没有按顺序到达。如果发送方连续收到三个或更多相同的重复 ACK，会立即重传被认为丢失的数据包，而无需等待超时。</li><li><strong>优势：</strong> 快速重传机制能够更快地检测到数据包丢失，并进行重传，提高数据传输的效率和可靠性。</li></ul><p><strong>3.选择性确认（SACK，Selective Acknowledgment）：</strong></p><ul><li><strong>工作原理：</strong> SACK 允许接收方在 ACK 报文中携带已成功接收的非连续数据包的范围信息。这样，发送方可以知道具体哪些数据包丢失，只重传这些丢失的数据包，而不是所有未确认的数据包。</li><li><strong>优势：</strong> 选择性确认优化了重传过程，特别是在高丢包率的网络环境下显得尤为重要，减少了不必要的重传，提高了整体传输效率。</li></ul><h4 id="结合实际场景："><a href="#结合实际场景：" class="headerlink" title="结合实际场景："></a>结合实际场景：</h4><ul><li><strong>场景 1：</strong> 假设发送方发送了数据包 1, 2, 3，但只有数据包 1 到达了接收方。接收方会发送 ACK 1，确认收到了数据包 1，但未收到数据包 2 和 3。发送方的定时器超时后，发现没有收到数据包 2 和 3 的 ACK，于是重新发送数据包 2 和 3。这就是超时重传。</li><li><strong>场景 2：</strong> 如果发送方发送了数据包 1, 2, 3, 4，但数据包 2 丢失了。接收方收到数据包 1 后发送 ACK 1，然后收到数据包 3 和 4 后继续发送 ACK 1（因为数据包 2 丢失了）。发送方连续收到三个 ACK 1 后，立即重传数据包 2，而无需等待超时。这就是快速重传。</li><li><strong>场景 3：</strong> 假设发送方发送了数据包 1, 2, 3, 4, 5，但数据包 2 和 4 丢失了。接收方可以通过 SACK 告知发送方已收到数据包 1, 3, 5 和未收到数据包 2, 4。发送方只需重传数据包 2 和 4，提高了重传效率。</li></ul><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>TCP 的重传机制通过超时重传和快速重传来确保数据包的可靠到达。超时重传通过设定定时器来检测丢失的数据包，而快速重传通过重复 ACK 的反馈迅速响应丢包情况，SACK 优化了重传效率。这几种机制相辅相成，确保了 TCP 传输的可靠性和稳定性。通过这些机制，TCP 能够在复杂的网络环境中保持高效的数据传输。</p><p>​</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h2><p>欢迎大家关注我的微信公众号「<strong>跟着小康学编程</strong>」！本号致力于分享<strong>C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习、计算机基础原理、Linux 编程、数据库、微服务、容器技术</strong> 等内容。文章力求通俗易懂，并配有代码示例，方便初学者理解。如果您对这些内容感兴趣，欢迎关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p>后续，我还会陆续分享各个方向的编程面试题，包括<strong>C&#x2F;C++、Java、Go，以及操作系统、计算机网络、数据结构、数据库和微服务</strong>等领域，为大家的面试提供帮助。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络面试 </tag>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP 面试题 — 说说TCP 的拥塞控制？</title>
      <link href="/tcp-congestion-control/"/>
      <url>/tcp-congestion-control/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康。</p><p>今天给大家分享一个 TCP 面试题 ：<strong>说说TCP 的拥塞控制？</strong></p><blockquote><p><strong>小技巧</strong>：在面试中，可以参考下面的<strong>示例回答</strong>，这样回答简洁明了。<strong>详细介绍</strong>部分则是为了帮助大家系统学习，以便应对面试官深入提问。</p></blockquote><h3 id="示例回答："><a href="#示例回答：" class="headerlink" title="示例回答："></a>示例回答：</h3><p>TCP 的拥塞控制通过慢启动、拥塞避免、快速重传和快速恢复这四个阶段来管理网络流量。慢启动从小数据量开始逐步增加；拥塞避免缓慢增加数据量；快速重传和快速恢复在丢包时迅速调整发送速率。这些机制确保了网络不被过载，传输高效且稳定。</p><hr><h3 id="详细解释："><a href="#详细解释：" class="headerlink" title="详细解释："></a>详细解释：</h3><p>TCP 拥塞控制是一套用于防止网络过载的机制，确保数据传输的高效性和稳定性。主要包括以下四个阶段：</p><h4 id="慢启动（Slow-Start）："><a href="#慢启动（Slow-Start）：" class="headerlink" title="慢启动（Slow Start）："></a>慢启动（Slow Start）：</h4><ul><li><strong>工作原理：</strong> 连接建立初期，发送方从小的发送窗口开始，逐步增加数据发送量。每次收到一个 ACK，窗口大小就加倍。这种指数增长方式可以快速找到网络的可用带宽。</li><li><strong>应用场景：</strong> 新连接建立时或重传超时后。</li></ul><h4 id="拥塞避免（Congestion-Avoidance）："><a href="#拥塞避免（Congestion-Avoidance）：" class="headerlink" title="拥塞避免（Congestion Avoidance）："></a>拥塞避免（Congestion Avoidance）：</h4><ul><li><strong>工作原理：</strong> 当窗口大小达到一定阈值（慢启动阈值）后，进入拥塞避免阶段。此时，窗口大小以线性方式增长，每个 RTT（往返时间）增加一个 MSS（最大报文段长度）。这种方式较慢，但能更稳定地探测网络容量。</li><li><strong>应用场景：</strong> 网络状况良好，没有丢包时。</li></ul><h4 id="快速重传（Fast-Retransmit）："><a href="#快速重传（Fast-Retransmit）：" class="headerlink" title="快速重传（Fast Retransmit）："></a>快速重传（Fast Retransmit）：</h4><ul><li><strong>工作原理：</strong> 当接收方收到失序的数据包时，会发送重复的 ACK。发送方收到三个或更多相同的重复 ACK 后，会立即重传丢失的数据包，而无需等待超时。</li><li><strong>优势：</strong> 能更快地检测到丢包并重传，提高了传输效率。</li></ul><h4 id="快速恢复（Fast-Recovery）："><a href="#快速恢复（Fast-Recovery）：" class="headerlink" title="快速恢复（Fast Recovery）："></a>快速恢复（Fast Recovery）：</h4><ul><li><strong>工作原理：</strong> 在快速重传后，发送方认为网络出现轻微拥塞，将拥塞窗口减半（而不是重置为1），然后进入拥塞避免阶段。这种方式避免了过于剧烈的窗口缩减，使得传输速率能更快恢复。</li><li><strong>应用场景：</strong> 丢包后但网络仍能承受部分流量时。</li></ul><h4 id="具体例子："><a href="#具体例子：" class="headerlink" title="具体例子："></a>具体例子：</h4><ul><li><strong>慢启动：</strong> 发送方初始窗口大小为 1，发送一个数据包，收到 ACK 后窗口加倍，变为 2，继续发送两个数据包，再次收到 ACK 后变为 4，依此类推。</li><li><strong>拥塞避免：</strong> 当窗口大小达到慢启动阈值（如 16）时，每个 RTT 增加一个 MSS，而不是指数增长，以避免网络拥塞。</li><li><strong>快速重传和快速恢复：</strong> 如果窗口大小为 16，但发生了丢包，接收方发送重复 ACK，发送方收到三个重复 ACK 后，立即重传丢失的数据包，将窗口减半至 8，然后进入拥塞避免阶段。</li></ul><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>TCP 的拥塞控制通过慢启动、拥塞避免、快速重传和快速恢复四个阶段，动态调整数据发送速率，确保网络不被过载。这些机制共同作用，使得 TCP 能在复杂的网络环境中保持高效、稳定的数据传输。理解这些机制有助于更好地掌握 TCP 协议和网络流量管理。</p><p>​</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h2><p>欢迎大家关注我的微信公众号「<strong>跟着小康学编程</strong>」！本号致力于分享<strong>C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习、计算机基础原理、Linux 编程、数据库、微服务、容器技术</strong> 等内容。文章力求通俗易懂，并配有代码示例，方便初学者理解。如果您对这些内容感兴趣，欢迎关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p>后续，我还会陆续分享各个方向的编程面试题，包括<strong>C&#x2F;C++、Java、Go，以及操作系统、计算机网络、数据结构、数据库和微服务</strong>等领域，为大家的面试提供帮助。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络面试 </tag>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP 面试题 — 了解Nagle 算法和延迟确认吗？</title>
      <link href="/nagle-and-delay-ack/"/>
      <url>/nagle-and-delay-ack/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康。</p><p>今天给大家分享一个 TCP 面试题 ：<strong>了解Nagle 算法和延迟确认吗？</strong></p><blockquote><p><strong>小技巧</strong>：在面试中，可以参考下面的<strong>示例回答</strong>，这样回答简洁明了。<strong>详细介绍</strong>部分则是为了帮助大家系统学习，以便应对面试官深入提问。</p></blockquote><h3 id="示例回答："><a href="#示例回答：" class="headerlink" title="示例回答："></a>示例回答：</h3><p>Nagle 算法和延迟确认是用于优化 TCP 性能的两种机制。Nagle 算法通过将小数据包合并成一个大包发送，减少网络拥塞；延迟确认通过等待一段时间再发送 ACK，减少确认包的数量。这两者结合可以提高网络传输效率，但在某些实时应用中需要慎重使用。</p><h3 id="详细解释："><a href="#详细解释：" class="headerlink" title="详细解释："></a>详细解释：</h3><p>Nagle 算法和延迟确认（Delayed ACK）是 TCP 协议中用于优化数据传输性能的两种机制。</p><h4 id="Nagle-算法："><a href="#Nagle-算法：" class="headerlink" title="Nagle 算法："></a>Nagle 算法：</h4><ul><li><strong>工作原理：</strong> 该算法通过将小数据包合并成一个大包来减少发送的小包数量，从而减少网络拥塞。具体来说，当有小数据包需要发送时，如果之前发送的数据包的确认（ACK）还没有收到，Nagle 算法会将这些小包暂存在发送缓冲区中，直到收到之前数据包的 ACK 或缓冲区满。</li><li><strong>优点：</strong> 减少了小数据包的数量，降低了网络拥塞，提升了网络利用率。</li><li><strong>缺点：</strong> 在某些实时应用（如在线游戏、远程控制）中，可能会增加传输延迟，影响用户体验。</li></ul><h4 id="延迟确认（Delayed-ACK）："><a href="#延迟确认（Delayed-ACK）：" class="headerlink" title="延迟确认（Delayed ACK）："></a>延迟确认（Delayed ACK）：</h4><ul><li><strong>工作原理：</strong> 接收方在收到数据包后不会立即发送确认（ACK），而是等待一段时间（通常 200 毫秒）再发送 ACK。如果在这段时间内有更多数据包到达，接收方可以一次性发送一个 ACK 确认多个数据包。</li><li><strong>优点：</strong> 减少了 ACK 包的数量，降低了网络负载，提高了传输效率。</li><li><strong>缺点：</strong> 可能会增加传输延迟，特别是在需要快速反馈的场景中（如 HTTP 请求-响应）。</li></ul><h4 id="结合使用："><a href="#结合使用：" class="headerlink" title="结合使用："></a>结合使用：</h4><ul><li>当 Nagle 算法和延迟确认一起使用时，可能会出现“捉迷藏效应”（Silly Window Syndrome）。发送方等 ACK 发送大包，接收方等更多数据包一起确认，导致数据传输延迟。为了避免这种情况，在需要快速交互的应用中，可以禁用 Nagle 算法（通过设置 TCP_NODELAY 选项）和延迟确认。</li><li><strong>如何禁用？</strong><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 禁用 Nagle 算法</span></span><br><span class="line"><span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line">setsockopt(sockfd, IPPROTO_TCP, TCP_NODELAY, (<span class="type">char</span> *)&amp;flag, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 禁用延迟确认</span></span><br><span class="line"><span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line">setsockopt(sockfd, IPPROTO_TCP, TCP_QUICKACK, (<span class="type">char</span> *)&amp;flag, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h4 id="实际场景："><a href="#实际场景：" class="headerlink" title="实际场景："></a>实际场景：</h4><ul><li><strong>Nagle 算法：</strong> 适用于需要减少小包传输的场景，如批量数据传输。</li><li><strong>延迟确认：</strong> 适用于希望减少 ACK 包数量的场景，如流媒体传输。</li></ul><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>Nagle 算法通过合并小数据包减少网络拥塞，延迟确认通过等待一段时间减少 ACK 包的数量。两者结合使用可以提高网络传输效率，但在实时性要求高的应用中需要慎重配置。理解这两种机制的优缺点及其适用场景，可以更好地优化 TCP 数据传输性能。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h2><p>欢迎大家关注我的微信公众号「<strong>跟着小康学编程</strong>」！本号致力于分享<strong>C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习、计算机基础原理、Linux 编程、数据库、微服务、容器技术</strong> 等内容。文章力求通俗易懂，并配有代码示例，方便初学者理解。如果您对这些内容感兴趣，欢迎关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p>后续，我还会陆续分享各个方向的编程面试题，包括<strong>C&#x2F;C++、Java、Go，以及操作系统、计算机网络、数据结构、数据库和微服务</strong>等领域，为大家的面试提供帮助。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络面试 </tag>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP 面试题 — 谈谈你对 TCP 滑动窗口的了解？</title>
      <link href="/TCP-sliding-window/"/>
      <url>/TCP-sliding-window/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康。</p><p>今天给大家分享一个 TCP 面试题 ：<strong>谈谈你对 TCP 滑动窗口的了解？</strong></p><blockquote><p><strong>小技巧</strong>：在面试中，可以参考下面的<strong>示例回答</strong>，这样回答简洁明了。<strong>详细介绍</strong>部分则是为了帮助大家系统学习，以便应对面试官深入提问。</p></blockquote><h3 id="示例回答："><a href="#示例回答：" class="headerlink" title="示例回答："></a>示例回答：</h3><p>TCP 滑动窗口是用来控制数据流动的机制。它通过动态调整窗口大小，让发送方可以连续发送多个数据包，而无需等待每个包的确认。这样提高了传输效率，同时避免了网络拥塞。</p><hr><h3 id="详细解释："><a href="#详细解释：" class="headerlink" title="详细解释："></a>详细解释：</h3><p>TCP 滑动窗口机制是一种流量控制方法，确保数据传输高效且稳定。它的主要特点和功能如下：</p><h4 id="窗口大小（Window-Size）："><a href="#窗口大小（Window-Size）：" class="headerlink" title="窗口大小（Window Size）："></a>窗口大小（Window Size）：</h4><ul><li>窗口大小是指接收方能够接收的最大数据量。接收方通过 ACK 报文告知发送方自己的窗口大小。</li><li>例如，如果窗口大小为 5000 字节，发送方可以在未收到 ACK 的情况下连续发送最多 5000 字节的数据。</li></ul><h4 id="滑动窗口（Sliding-Window）："><a href="#滑动窗口（Sliding-Window）：" class="headerlink" title="滑动窗口（Sliding Window）："></a>滑动窗口（Sliding Window）：</h4><ul><li>滑动窗口指的是窗口大小可以动态调整。每当接收方确认收到一些数据（发送 ACK），窗口就会向前滑动，允许发送方继续发送新的数据。</li><li>例如，如果窗口大小为 5000 字节，发送方发送了 3000 字节的数据并收到确认，那么窗口会向前滑动 3000 字节，允许发送方再发送 3000 字节的新数据。</li></ul><h4 id="提高传输效率："><a href="#提高传输效率：" class="headerlink" title="提高传输效率："></a>提高传输效率：</h4><ul><li>通过滑动窗口机制，发送方不需要每发送一个数据包就等待 ACK，从而可以连续发送多个数据包，提高了传输效率。</li><li>这种机制特别适用于高延迟网络环境，避免了因等待确认而浪费的时间。</li></ul><h4 id="流量控制（Flow-Control）："><a href="#流量控制（Flow-Control）：" class="headerlink" title="流量控制（Flow Control）："></a>流量控制（Flow Control）：</h4><ul><li>滑动窗口机制还用于流量控制，确保发送方不会发送超过接收方处理能力的数据，防止接收方缓冲区溢出。</li><li>接收方通过动态调整窗口大小来控制发送方的数据发送速率。</li></ul><h4 id="拥塞控制（Congestion-Control）："><a href="#拥塞控制（Congestion-Control）：" class="headerlink" title="拥塞控制（Congestion Control）："></a>拥塞控制（Congestion Control）：</h4><ul><li>虽然滑动窗口主要用于流量控制，但它也与拥塞控制机制相结合，通过调整窗口大小来避免网络拥塞，提高传输效率和稳定性。</li></ul><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>TCP 滑动窗口通过动态调整窗口大小，使得发送方能够连续发送多个数据包，提高了传输效率，同时避免网络拥塞和接收方缓冲区溢出。理解滑动窗口的工作原理及其在流量控制和拥塞控制中的作用，对于掌握 TCP 协议的可靠数据传输机制非常重要。</p><p>​</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h2><p>欢迎大家关注我的微信公众号「<strong>跟着小康学编程</strong>」！本号致力于分享<strong>C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习、计算机基础原理、Linux 编程、数据库、微服务、容器技术</strong> 等内容。文章力求通俗易懂，并配有代码示例，方便初学者理解。如果您对这些内容感兴趣，欢迎关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p>后续，我还会陆续分享各个方向的编程面试题，包括<strong>C&#x2F;C++、Java、Go，以及操作系统、计算机网络、数据结构、数据库和微服务</strong>等领域，为大家的面试提供帮助。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络面试 </tag>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP 面试题 — 谈下你对流量控制的理解？</title>
      <link href="/what-tcp-flow-control/"/>
      <url>/what-tcp-flow-control/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康。</p><p>今天给大家分享一个 TCP 面试题 ：<strong>谈下你对流量控制的理解？</strong></p><blockquote><p><strong>小技巧</strong>：在面试中，可以参考下面的<strong>示例回答</strong>，这样回答简洁明了。<strong>详细介绍</strong>部分则是为了帮助大家系统学习，以便应对面试官深入提问。</p></blockquote><h3 id="示例回答："><a href="#示例回答：" class="headerlink" title="示例回答："></a>示例回答：</h3><p>流量控制是为了防止发送方发送数据过快，超过接收方的处理能力。TCP 使用滑动窗口机制，通过接收方通知的窗口大小来控制发送方的数据发送量，确保数据传输稳定、可靠。</p><hr><h3 id="详细解释："><a href="#详细解释：" class="headerlink" title="详细解释："></a>详细解释：</h3><p>流量控制是网络传输中的重要机制，主要用于调节发送方的数据发送速率，防止接收方处理不过来，导致数据丢失或缓冲区溢出。</p><h4 id="流量控制的基本原理："><a href="#流量控制的基本原理：" class="headerlink" title="流量控制的基本原理："></a>流量控制的基本原理：</h4><h4 id="滑动窗口机制："><a href="#滑动窗口机制：" class="headerlink" title="滑动窗口机制："></a>滑动窗口机制：</h4><ul><li><strong>工作原理：</strong> 在 TCP 协议中，流量控制通过滑动窗口机制实现。每个 TCP 连接都有一个发送窗口和接收窗口。发送窗口表示发送方可以发送的最大数据量，而接收窗口表示接收方能够接收和处理的最大数据量。</li><li><strong>窗口大小：</strong> 接收方在每次发送 ACK 报文时，会告知当前的窗口大小（Window Size）。发送方根据接收方提供的窗口大小，决定可以发送的数据量。</li></ul><h4 id="动态调整："><a href="#动态调整：" class="headerlink" title="动态调整："></a>动态调整：</h4><ul><li><strong>动态变化：</strong> 滑动窗口的大小是动态变化的。接收方根据自己的处理能力和缓冲区状况，实时调整窗口大小。如果接收方处理能力下降或缓冲区接近满载，会缩小窗口大小，通知发送方减少数据发送量；如果处理能力提高或缓冲区有空闲，则会增大窗口大小，通知发送方增加数据发送量。</li></ul><h4 id="避免拥塞："><a href="#避免拥塞：" class="headerlink" title="避免拥塞："></a>避免拥塞：</h4><ul><li><strong>目的：</strong> 流量控制的目的是确保接收方有足够的时间处理接收到的数据，避免因处理不过来而导致的数据丢失或网络拥塞。</li><li><strong>传输效率：</strong> 通过流量控制，TCP 可以在不引起网络拥塞的前提下，尽可能高效地传输数据，提高整体网络传输效率。</li></ul><h4 id="实际例子："><a href="#实际例子：" class="headerlink" title="实际例子："></a>实际例子：</h4><ul><li><strong>场景 1：</strong> 假设发送方发送数据的速度非常快，而接收方的处理速度较慢，可能导致接收方的缓冲区很快填满。如果没有流量控制机制，接收方的缓冲区溢出，会导致数据丢失。通过流量控制，接收方可以通知发送方减慢发送速度，等待接收方处理完当前数据。</li><li><strong>场景 2：</strong> 如果接收方的处理能力突然提高，缓冲区有了更多空闲空间，它可以通过滑动窗口通知发送方增大发送数据的速率，提高传输效率。</li></ul><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>流量控制通过滑动窗口机制，动态调整发送方的数据发送速率，确保接收方能够及时处理接收到的数据，避免缓冲区溢出和数据丢失。理解流量控制的原理和机制，对于掌握 TCP 协议和网络传输优化至关重要。通过流量控制，TCP 能够在复杂的网络环境中实现稳定、可靠的高效数据传输。</p><p>​</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h2><p>欢迎大家关注我的微信公众号「<strong>跟着小康学编程</strong>」！本号致力于分享<strong>C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习、计算机基础原理、Linux 编程、数据库、微服务、容器技术</strong> 等内容。文章力求通俗易懂，并配有代码示例，方便初学者理解。如果您对这些内容感兴趣，欢迎关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p>后续，我还会陆续分享各个方向的编程面试题，包括<strong>C&#x2F;C++、Java、Go，以及操作系统、计算机网络、数据结构、数据库和微服务</strong>等领域，为大家的面试提供帮助。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络面试 </tag>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP 面试题 — TCP 是如何保证可靠性的？</title>
      <link href="/tcp-howto-keep-reliable/"/>
      <url>/tcp-howto-keep-reliable/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康。</p><p>今天给大家分享一个 TCP 面试题 ：<strong>TCP 是如何保证可靠性的？</strong></p><blockquote><p><strong>小技巧</strong>：在面试中，可以参考下面的<strong>示例回答</strong>，这样回答简洁明了。<strong>详细介绍</strong>部分则是为了帮助大家系统学习，以便应对面试官深入提问。</p></blockquote><h3 id="示例回答："><a href="#示例回答：" class="headerlink" title="示例回答："></a>示例回答：</h3><p>TCP 通过序列号和确认号来保证数据按顺序传输，通过校验和来检查数据完整性，还通过重传机制来确保丢失的数据包被重新发送。这些机制一起保证了 TCP 的可靠性。</p><hr><h3 id="详细解释："><a href="#详细解释：" class="headerlink" title="详细解释："></a>详细解释：</h3><h4 id="TCP（传输控制协议）通过以下几种机制来保证数据传输的可靠性："><a href="#TCP（传输控制协议）通过以下几种机制来保证数据传输的可靠性：" class="headerlink" title="TCP（传输控制协议）通过以下几种机制来保证数据传输的可靠性："></a>TCP（传输控制协议）通过以下几种机制来保证数据传输的可靠性：</h4><ol><li><strong>序列号（Sequence Number）：</strong></li></ol><ul><li>每个数据包都有一个序列号，接收方可以根据序列号将数据包按顺序排列。如果有数据包丢失或乱序，接收方可以检测到，并要求重传。</li></ul><ol start="2"><li><strong>确认号（Acknowledgment Number）：</strong></li></ol><ul><li>接收方在收到数据包后，会发送一个包含确认号的 ACK 报文，告诉发送方已成功接收哪些数据。如果发送方未收到确认，就会重传相应的数据包。</li></ul><ol start="3"><li><strong>校验和（Checksum）：</strong></li></ol><ul><li>每个数据包都包含一个校验和，用于检验数据在传输过程中是否被损坏。接收方会对收到的数据包进行校验，如果发现数据有误，会丢弃数据包并请求重传。</li></ul><ol start="4"><li><strong>重传机制（Retransmission Mechanism）：</strong></li></ol><ul><li>发送方会启动一个超时重传定时器，如果在一定时间内没有收到 ACK 报文，就会重传未确认的数据包。这确保了丢失的数据包能够被重新发送。</li></ul><ol start="5"><li><strong>流量控制（Flow Control）：</strong></li></ol><ul><li>通过窗口大小字段（Window Size），接收方可以通知发送方自己的接收能力，避免发送方发送过多数据，导致接收方处理不过来。</li></ul><ol start="6"><li><strong>拥塞控制（Congestion Control）：</strong></li></ol><ul><li>TCP 通过算法（如慢启动、拥塞避免、快重传、快恢复等）动态调整发送数据的速率，以避免网络拥塞，提高传输效率。</li></ul><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>TCP 的可靠性通过序列号和确认号确保数据的顺序和完整接收，校验和用于检测数据包是否损坏，重传机制确保丢失的数据包能够被重新发送，流量控制和拥塞控制则保证了数据传输的效率和稳定性。这些机制相互配合，使得 TCP 在网络传输中能够提供可靠的数据传输服务。</p><p>​</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h2><p>欢迎大家关注我的微信公众号「<strong>跟着小康学编程</strong>」！本号致力于分享<strong>C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习、计算机基础原理、Linux 编程、数据库、微服务、容器技术</strong> 等内容。文章力求通俗易懂，并配有代码示例，方便初学者理解。如果您对这些内容感兴趣，欢迎关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p>后续，我还会陆续分享各个方向的编程面试题，包括<strong>C&#x2F;C++、Java、Go，以及操作系统、计算机网络、数据结构、数据库和微服务</strong>等领域，为大家的面试提供帮助。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络面试 </tag>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP 面试题 — 说说 TCP 报文首部的格式？首部有哪些重要的字段？</title>
      <link href="/tcpheader/"/>
      <url>/tcpheader/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康。</p><p>今天给大家分享一个 TCP 面试题 ：<strong>说说 TCP 报文首部的格式？首部有哪些重要的字段？</strong></p><blockquote><p><strong>小技巧</strong>：在面试中，可以参考下面的<strong>示例回答</strong>，这样回答简洁明了。<strong>详细介绍</strong>部分则是为了帮助大家系统学习，以便应对面试官深入提问。</p></blockquote><h3 id="示例回答："><a href="#示例回答：" class="headerlink" title="示例回答："></a>示例回答：</h3><p>TCP 报文首部是 TCP 协议用于传输数据时附加在数据前面的控制信息，有 20 个字节的固定部分，还有可选字段。 首部包含了多个重要字段，如源端口、目标端口、序列号、确认号、标志位、窗口大小、校验和和紧急指针。这些字段用于管理连接、保证数据传输的可靠性和完整性。</p><hr><h3 id="详细解释："><a href="#详细解释：" class="headerlink" title="详细解释："></a>详细解释：</h3><h4 id="TCP-报文首部的格式如下图："><a href="#TCP-报文首部的格式如下图：" class="headerlink" title="TCP 报文首部的格式如下图："></a>TCP 报文首部的格式如下图：</h4><p><img src="/images/TCP/tcpheader.png"></p><h4 id="以下是-TCP-报文首部的主要字段及其作用："><a href="#以下是-TCP-报文首部的主要字段及其作用：" class="headerlink" title="以下是 TCP 报文首部的主要字段及其作用："></a>以下是 TCP 报文首部的主要字段及其作用：</h4><ol><li><strong>源端口（Source Port）：</strong></li></ol><ul><li>表示发送数据的应用程序的端口号，用于标识发送方的通信端口。</li></ul><ol start="2"><li><strong>目标端口（Destination Port）：</strong></li></ol><ul><li>表示接收数据的应用程序的端口号，用于标识接收方的通信端口。</li></ul><ol start="3"><li><strong>序列号（Sequence Number）：</strong></li></ol><ul><li>表示数据段在整个数据流中的位置，用于确保数据包按顺序到达，保证数据的完整性。</li></ul><ol start="4"><li><strong>确认号（Acknowledgment Number）：</strong></li></ol><ul><li>用于确认接收到的数据包，告诉发送方已接收到哪些数据，是可靠传输的重要机制。</li></ul><ol start="5"><li><strong>标志位（Flags）：</strong>包括多个标志位，如 SYN、ACK、FIN、RST、PSH、URG，用于控制连接的建立、维护和终止。</li></ol><ul><li><strong>SYN：</strong> 用于建立连接。</li><li><strong>ACK：</strong> 用于确认收到数据。</li><li><strong>FIN：</strong> 用于断开连接。</li><li><strong>RST：</strong> 用于重置连接。</li><li><strong>PSH：</strong> 用于加快数据传输。</li><li><strong>URG：</strong> 表示紧急数据。</li></ul><ol start="6"><li><strong>窗口大小（Window Size）：</strong></li></ol><ul><li>表示接收方能够接收的最大数据量，用于流量控制，防止发送方发送过多数据导致接收方缓冲区溢出。</li></ul><ol start="7"><li><strong>校验和（Checksum）：</strong></li></ol><ul><li>用于校验数据的完整性，确保数据在传输过程中没有发生错误。</li></ul><ol start="8"><li><strong>紧急指针（Urgent Pointer）：</strong></li></ol><ul><li>用于指示紧急数据的结束位置，配合 URG 标志位使用。</li></ul><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>TCP 报文首部通过这些关键字段，管理数据传输的顺序、确认、流量控制和错误检测，确保数据可靠、顺序地传输。理解这些字段及其作用，对于掌握 TCP 协议和网络通信至关重要。通过这些字段的协调工作，TCP 实现了高效、可靠的数据传输。</p><p>​</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h2><p>欢迎大家关注我的微信公众号「<strong>跟着小康学编程</strong>」！本号致力于分享<strong>C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习、计算机基础原理、Linux 编程、数据库、微服务、容器技术</strong> 等内容。文章力求通俗易懂，并配有代码示例，方便初学者理解。如果您对这些内容感兴趣，欢迎关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p>后续，我还会陆续分享各个方向的编程面试题，包括<strong>C&#x2F;C++、Java、Go，以及操作系统、计算机网络、数据结构、数据库和微服务</strong>等领域，为大家的面试提供帮助。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络面试 </tag>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP 面试题 — 说说半连接队列和 SYN Flood 攻击的关系？</title>
      <link href="/half-Conn-syn-flood/"/>
      <url>/half-Conn-syn-flood/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康。</p><p>今天给大家分享一个 TCP 面试题 ：<strong>说说半连接队列和 SYN Flood 攻击的关系？</strong></p><blockquote><p><strong>小技巧</strong>：在面试中，可以参考下面的<strong>示例回答</strong>，这样回答简洁明了。<strong>详细介绍</strong>部分则是为了帮助大家系统学习，以便应对面试官深入提问。</p></blockquote><h3 id="示例回答"><a href="#示例回答" class="headerlink" title="示例回答"></a>示例回答</h3><p>半连接队列是服务器在接收客户端 SYN 请求后等待客户端确认的队列。SYN Flood 攻击通过发送大量的 SYN 请求，占满半连接队列，使服务器无法处理正常的连接请求。</p><hr><h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><h4 id="半连接队列："><a href="#半连接队列：" class="headerlink" title="半连接队列："></a>半连接队列：</h4><ul><li><p><strong>定义</strong>：在 TCP 三次握手过程中，服务器在接收到客户端的 SYN 请求并回复 SYN-ACK 后，会将连接放入半连接队列，等待客户端的最终 ACK 确认。</p></li><li><p><strong>作用</strong>：半连接队列用于存储那些已经发送 SYN-ACK 但尚未完成三次握手的连接。</p></li></ul><h4 id="SYN-Flood-攻击与半连接队列的关系："><a href="#SYN-Flood-攻击与半连接队列的关系：" class="headerlink" title="SYN Flood 攻击与半连接队列的关系："></a>SYN Flood 攻击与半连接队列的关系：</h4><ul><li><strong>攻击原理</strong>：在 SYN Flood 攻击中，攻击者发送大量伪造的 SYN 请求，这些请求会进入服务器的半连接队列。</li><li><strong>占满队列</strong>：由于这些伪造的请求不会发送最终的 ACK 包，半连接队列中的条目不会被释放，逐渐占满整个队列。</li><li><strong>资源耗尽</strong>：当半连接队列被占满后，服务器无法接收新的 SYN 请求，导致合法用户的连接请求被拒绝，无法建立正常的连接。</li></ul><h4 id="防御措施："><a href="#防御措施：" class="headerlink" title="防御措施："></a>防御措施：</h4><ol><li><strong>SYN Cookies</strong>：使用 SYN cookies 技术，不依赖半连接队列来存储未完成的连接信息，从而减轻队列被占满的风险。</li><li><strong>增加半连接队列大小</strong>：适当增加服务器的半连接队列大小，提高抗攻击能力。</li><li><strong>过滤和检测</strong>：使用防火墙和入侵检测系统，识别并过滤恶意的 SYN 请求。</li></ol><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><ul><li><strong>半连接队列</strong>：用于存储未完成三次握手的连接请求。</li><li><strong>SYN Flood 攻击</strong>：通过大量伪造的 SYN 请求占满半连接队列，导致服务器无法处理正常的连接请求。</li></ul><p>​</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h2><p>欢迎大家关注我的微信公众号「<strong>跟着小康学编程</strong>」！本号致力于分享<strong>C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习、计算机基础原理、Linux 编程、数据库、微服务、容器技术</strong> 等内容。文章力求通俗易懂，并配有代码示例，方便初学者理解。如果您对这些内容感兴趣，欢迎关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p>后续，我还会陆续分享各个方向的编程面试题，包括<strong>C&#x2F;C++、Java、Go，以及操作系统、计算机网络、数据结构、数据库和微服务</strong>等领域，为大家的面试提供帮助。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络面试 </tag>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP 面试题 — 简单说下 SYN FLOOD 是什么？</title>
      <link href="/what-syn-flood/"/>
      <url>/what-syn-flood/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康。</p><p>今天给大家分享一个 TCP 面试题 ：<strong>简单说下 SYN FLOOD 是什么？</strong></p><blockquote><p><strong>小技巧</strong>：在面试中，可以参考下面的<strong>示例回答</strong>，这样回答简洁明了。<strong>详细介绍</strong>部分则是为了帮助大家系统学习，以便应对面试官深入提问。</p></blockquote><h3 id="示例回答"><a href="#示例回答" class="headerlink" title="示例回答:"></a>示例回答:</h3><p>SYN FLOOD 是一种常见的拒绝服务（DoS）攻击，通过发送大量的 SYN 请求，占用服务器资源，导致服务器无法处理正常的请求。</p><blockquote><p><strong>DoS</strong>(Denial of Service)是一种网络攻击，目的是使目标系统无法正常提供服务。攻击者通过发送大量的请求或数据包，耗尽目标系统的资源，使其无法响应合法用户的请求，从而导致服务中断。  </p></blockquote><hr><h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释:"></a>详细解释:</h3><h4 id="SYN-FLOOD-的工作原理："><a href="#SYN-FLOOD-的工作原理：" class="headerlink" title="SYN FLOOD 的工作原理："></a>SYN FLOOD 的工作原理：</h4><ol><li><p><strong>三次握手</strong>：在正常的 TCP 连接中，客户端和服务器需要通过“三次握手”来建立连接。客户端先发送 SYN 包，服务器收到后回复 SYN-ACK 包，客户端再回复一个 ACK 包，连接才建立成功。</p></li><li><p><strong>攻击过程</strong>：在 SYN FLOOD 攻击中，攻击者伪造大量的客户端 IP 地址，向服务器发送大量的 SYN 包。服务器收到 SYN 包后，回复 SYN-ACK 包，并等待客户端的 ACK 包。</p></li><li><p><strong>资源占用</strong>：由于这些伪造的 IP 地址并不存在，服务器一直在等待 ACK 包，导致服务器的半连接队列被占满，无法处理正常的连接请求。</p></li></ol><h4 id="影响："><a href="#影响：" class="headerlink" title="影响："></a>影响：</h4><ul><li><strong>资源耗尽</strong>：服务器的资源被大量无效的 SYN 请求占用，导致无法处理正常用户的请求。</li><li><strong>服务不可用</strong>：合法用户无法建立与服务器的连接，服务变得不可用。</li></ul><h4 id="防御措施："><a href="#防御措施：" class="headerlink" title="防御措施："></a>防御措施：</h4><ol><li><p><strong>使用 SYN cookies：</strong> 通过在 SYN-ACK 报文中嵌入特定信息，而不是直接分配资源，来验证连接请求的合法性。只有在收到真正的 ACK 确认后才分配资源。  防止服务器资源被耗尽。</p></li><li><p><strong>限制 SYN 队列</strong>：限制服务器的 SYN 队列大小，减少被攻击的风险。</p></li><li><p><strong>过滤和检测</strong>：使用防火墙和入侵检测系统过滤恶意流量，检测和阻止 SYN FLOOD 攻击。</p></li></ol><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><ul><li>SYN FLOOD 是一种通过发送大量 SYN 请求来占用服务器资源的拒绝服务攻击。</li><li>防御措施包括使用 SYN cookies、限制 SYN 队列大小以及过滤和检测恶意流量。</li></ul><p>​</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h2><p>欢迎大家关注我的微信公众号「<strong>跟着小康学编程</strong>」！本号致力于分享<strong>C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习、计算机基础原理、Linux 编程、数据库、微服务、容器技术</strong> 等内容。文章力求通俗易懂，并配有代码示例，方便初学者理解。如果您对这些内容感兴趣，欢迎关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p>后续，我还会陆续分享各个方向的编程面试题，包括<strong>C&#x2F;C++、Java、Go，以及操作系统、计算机网络、数据结构、数据库和微服务</strong>等领域，为大家的面试提供帮助。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络面试 </tag>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP 面试题 — forward 和 redirect 的区别？</title>
      <link href="/forward-redirect/"/>
      <url>/forward-redirect/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康。</p><p>今天给大家分享一个 TCP 面试题 ：<strong>forward 和 redirect 的区别？</strong></p><blockquote><p><strong>小技巧</strong>：在面试中，可以参考下面的<strong>示例回答</strong>，这样回答简洁明了。<strong>详细介绍</strong>部分则是为了帮助大家系统学习，以便应对面试官深入提问。</p></blockquote><h3 id="示例回答"><a href="#示例回答" class="headerlink" title="示例回答"></a>示例回答</h3><p>forward 和 redirect 的区别在于，forward 是服务器内部的跳转，用户看不到 URL 变化，而 redirect 是浏览器的重定向，用户会看到 URL 变化。</p><hr><h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><h4 id="forward（转发）："><a href="#forward（转发）：" class="headerlink" title="forward（转发）："></a>forward（转发）：</h4><ul><li><strong>服务器内部跳转</strong>：forward 是服务器内部的跳转，服务器接收到请求后，将请求转发到另一个页面或资源(如 JSP、Servlet)。</li><li><strong>URL 不变</strong>：用户浏览器的地址栏 URL 不会发生变化，因为请求没有离开服务器。</li><li><strong>数据共享</strong>：在转发过程中，原请求中的数据可以直接传递到新页面。</li></ul><p><strong>使用场景</strong>：适用于在服务器内部传递请求，例如在处理表单提交时转发到处理结果页面。<br><strong>示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转发到新的页面 newPage.jsp</span></span><br><span class="line">request.getRequestDispatcher(<span class="string">&quot;/newPage.jsp&quot;</span>).forward(request, response);</span><br></pre></td></tr></table></figure><h4 id="redirect（重定向）："><a href="#redirect（重定向）：" class="headerlink" title="redirect（重定向）："></a>redirect（重定向）：</h4><ul><li><strong>浏览器重定向</strong>：redirect 是服务器告诉浏览器重新请求一个新的 URL，浏览器会向新 URL 发起请求。</li><li><strong>URL 变化</strong>：用户浏览器的地址栏 URL 会变化，因为这是一个新的请求。</li><li><strong>数据不共享</strong>：原请求中的数据不会传递到新页面，新的请求会丢失原有的数据。</li></ul><p><strong>使用场景</strong>：适用于用户操作后需要引导到新页面，例如用户登录成功后跳转到主页。<br><strong>示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务器告诉浏览器重新请求一个新的 URL</span></span><br><span class="line">response.sendRedirect(<span class="string">&quot;newPage.jsp&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>总结</strong>：</p><ul><li><strong>forward</strong>：服务器内部跳转，URL 不变，数据共享。</li><li><strong>redirect</strong>：浏览器重定向，URL 变化，数据不共享。</li></ul><p>​</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h2><p>欢迎大家关注我的微信公众号「<strong>跟着小康学编程</strong>」！本号致力于分享<strong>C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习、计算机基础原理、Linux 编程、数据库、微服务、容器技术</strong> 等内容。文章力求通俗易懂，并配有代码示例，方便初学者理解。如果您对这些内容感兴趣，欢迎关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p>后续，我还会陆续分享各个方向的编程面试题，包括<strong>C&#x2F;C++、Java、Go，以及操作系统、计算机网络、数据结构、数据库和微服务</strong>等领域，为大家的面试提供帮助。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络面试 </tag>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP 面试题 — 保活计时器有什么用？</title>
      <link href="/keepAlive-timer/"/>
      <url>/keepAlive-timer/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康。</p><p>今天给大家分享一个 TCP 面试题 ：<strong>保活计时器有什么用？</strong></p><blockquote><p><strong>小技巧</strong>：在面试中，可以参考下面的<strong>示例回答</strong>，这样回答简洁明了。<strong>详细介绍</strong>部分则是为了帮助大家系统学习，以便应对面试官深入提问。</p></blockquote><h3 id="示例回答："><a href="#示例回答：" class="headerlink" title="示例回答："></a>示例回答：</h3><p>保活计时器的作用是检测空闲连接是否还活着。如果连接一段时间没有数据传输，保活计时器会发送探测包来确认对方是否还在。如果连接失效，可以及时释放资源。 这样可以避免无用的连接占用资源。</p><hr><h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><h4 id="保活计时器的作用："><a href="#保活计时器的作用：" class="headerlink" title="保活计时器的作用："></a>保活计时器的作用：</h4><ul><li><strong>检测连接有效性</strong>：在长时间没有数据传输的情况下，保活计时器会定期发送探测包到对方，确认连接是否仍然有效。</li><li><strong>释放资源</strong>：如果多次探测没有回应，保活计时器会关闭连接并释放相关的系统资源，避免资源浪费。</li></ul><h4 id="具体工作原理："><a href="#具体工作原理：" class="headerlink" title="具体工作原理："></a>具体工作原理：</h4><ol><li><strong>定期探测</strong>：当一个 TCP 连接长时间没有数据传输时，保活计时器会每隔一段时间发送一个探测包（Keep-Alive Probe）。</li><li><strong>等待回应</strong>：如果对方收到探测包，会回复一个 ACK 包，保活计时器会重置计时器，继续监测连接状态。</li><li><strong>判断失效</strong>：如果在多次探测后仍没有收到对方的回应，保活计时器会认为连接已经失效，关闭连接并释放资源。</li></ol><h4 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h4><ul><li><strong>长连接管理</strong>：在需要保持长时间连接的应用中，如远程服务器管理、在线游戏等，保活计时器可以帮助检测和管理连接状态，确保连接有效。</li></ul><h4 id="通俗解释："><a href="#通俗解释：" class="headerlink" title="通俗解释："></a>通俗解释：</h4><p>保活计时器就像你和朋友打电话时，如果对方长时间不说话，你会时不时说“喂，还在吗？”来确认对方还在线。如果对方一直不回应，你就会挂断电话，知道连接已经断了。保活计时器的作用类似，它通过定期检查连接状态，及时关闭失效的连接，释放资源。</p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><ul><li><strong>检测连接有效性</strong>：保活计时器通过定期发送探测包来确认连接是否仍然有效。</li><li><strong>释放资源</strong>：如果连接失效，保活计时器会关闭连接，释放系统资源。</li></ul><p>​</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h2><p>欢迎大家关注我的微信公众号「<strong>跟着小康学编程</strong>」！本号致力于分享<strong>C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习、计算机基础原理、Linux 编程、数据库、微服务、容器技术</strong> 等内容。文章力求通俗易懂，并配有代码示例，方便初学者理解。如果您对这些内容感兴趣，欢迎关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p>后续，我还会陆续分享各个方向的编程面试题，包括<strong>C&#x2F;C++、Java、Go，以及操作系统、计算机网络、数据结构、数据库和微服务</strong>等领域，为大家的面试提供帮助。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络面试 </tag>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP 面试题 — TIME_WAIT 状态过多会导致什么问题？怎么解决？</title>
      <link href="/time-wait-toomany-howto-avoid/"/>
      <url>/time-wait-toomany-howto-avoid/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康。</p><p>今天给大家分享一个 TCP 面试题 ：<strong>TIME_WAIT 状态过多会导致什么问题？怎么解决？</strong></p><blockquote><p><strong>小技巧</strong>：在面试中，可以参考下面的<strong>示例回答</strong>，这样回答简洁明了。<strong>详细介绍</strong>部分则是为了帮助大家系统学习，以便应对面试官深入提问。</p></blockquote><h3 id="示例回答"><a href="#示例回答" class="headerlink" title="示例回答"></a>示例回答</h3><p>TIME_WAIT 状态过多会导致服务器资源被占用( 如文件描述符、内存等 )，端口可能耗尽，可能导致新连接无法建立。解决方法包括减少 TIME_WAIT 时间或启用端口重用。</p><hr><h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><h4 id="TIME-WAIT-状态过多的影响："><a href="#TIME-WAIT-状态过多的影响：" class="headerlink" title="TIME_WAIT 状态过多的影响："></a>TIME_WAIT 状态过多的影响：</h4><ul><li><p><strong>资源占用</strong>：每个 TIME_WAIT 状态的连接都占用系统资源（如文件描述符、内存等），如果有大量连接处于 TIME_WAIT 状态，会消耗大量资源。</p></li><li><p><strong>端口耗尽</strong>：由于 TIME_WAIT 状态需要等待 2MSL 时间，如果有大量连接频繁建立和关闭，系统可能会耗尽可用端口，导致新连接无法建立。</p></li></ul><h4 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h4><p>1、<strong>减少 TIME_WAIT 时间</strong>：通过调整操作系统的参数，缩短 TIME_WAIT 状态的持续时间。例如，在 Linux 系统中，可以调整 tcp_fin_timeout 参数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 30 &gt; /proc/sys/net/ipv4/tcp_fin_timeout</span><br></pre></td></tr></table></figure><p>这个命令将 TIME_WAIT 时间从默认的 60 秒减少到 30 秒。</p><p>2、<strong>启用端口重用</strong>：允许系统在 TIME_WAIT 状态下重用端口。这可以通过设置 SO_REUSEADDR 。例如，在 Linux 系统中，可以在代码中设置 socket 选项：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line">setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="keyword">sizeof</span>(opt));</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：以上的解决方法主要是应对<strong>服务端TIME_WAIT 状态过多</strong>的处理。</p></blockquote><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><ul><li><strong>影响</strong>：TIME_WAIT 状态过多会占用系统资源，导致端口耗尽，无法建立新连接。</li><li><strong>解决方法</strong>：减少 TIME_WAIT 时间和启用端口重用。</li></ul><p>​</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h2><p>欢迎大家关注我的微信公众号「<strong>跟着小康学编程</strong>」！本号致力于分享<strong>C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习、计算机基础原理、Linux 编程、数据库、微服务、容器技术</strong> 等内容。文章力求通俗易懂，并配有代码示例，方便初学者理解。如果您对这些内容感兴趣，欢迎关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p>后续，我还会陆续分享各个方向的编程面试题，包括<strong>C&#x2F;C++、Java、Go，以及操作系统、计算机网络、数据结构、数据库和微服务</strong>等领域，为大家的面试提供帮助。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络面试 </tag>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP 面试题 — CLOSE-WAIT 和 TIME-WAIT 的状态和意义</title>
      <link href="/close-wait-time-wait/"/>
      <url>/close-wait-time-wait/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康。</p><p>今天给大家分享一个 TCP 面试题 ：<strong>CLOSE-WAIT 和 TIME-WAIT 的状态和意义？</strong></p><blockquote><p><strong>小技巧</strong>：在面试中，可以参考下面的<strong>示例回答</strong>，这样回答简洁明了。<strong>详细介绍</strong>部分则是为了帮助大家系统学习，以便应对面试官深入提问。</p></blockquote><h3 id="示例回答"><a href="#示例回答" class="headerlink" title="示例回答"></a>示例回答</h3><p>CLOSE-WAIT 状态表示接收方已经收到对方的关闭请求，但自己还没有关闭连接；TIME-WAIT 状态表示主动关闭方已经确认了对方的关闭请求，等待一段时间确保所有数据包都消失，才彻底关闭连接。</p><hr><h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><h4 id="先来看看-TCP-四次挥手的过程："><a href="#先来看看-TCP-四次挥手的过程：" class="headerlink" title="先来看看 TCP 四次挥手的过程："></a>先来看看 TCP 四次挥手的过程：</h4><p><img src="/images/TCP/tcpfour.png"></p><h4 id="CLOSE-WAIT-状态："><a href="#CLOSE-WAIT-状态：" class="headerlink" title="CLOSE-WAIT 状态："></a>CLOSE-WAIT 状态：</h4><ul><li><p><strong>状态描述</strong>：当一个 TCP 连接的一方（通常是服务器）收到对方（客户端）的 FIN 包时，进入 CLOSE-WAIT 状态。</p></li><li><p><strong>意义</strong>：这意味着接收方知道对方不再发送数据了，但接收方可能还有数据要发送，因此连接还不能立即关闭。接收方在这个状态下需要完成自己的数据发送，之后再发送 FIN 包，进入 LAST-ACK 状态。</p></li><li><p><strong>CLOSE-WAIT</strong> 就像你在电话中听到朋友说“我要挂了”，但你还没说完自己的话，所以你说“好，我知道了”，但继续把自己要说的话说完。这时你就处于 CLOSE-WAIT 状态。</p></li></ul><h4 id="TIME-WAIT-状态："><a href="#TIME-WAIT-状态：" class="headerlink" title="TIME-WAIT 状态："></a>TIME-WAIT 状态：</h4><ul><li><p><strong>状态描述</strong>：当主动关闭连接的一方（通常是客户端）收到对方（服务器）的 FIN 包，并发送 ACK 包后，进入 TIME-WAIT 状态。</p></li><li><p><strong>意义</strong>：在这个状态下，主动关闭方等待 2MSL 时间，确保所有在网络中可能存在的报文段都已经消失，避免旧的报文段影响新的连接。这也确保了被动关闭方能收到 ACK 包，确认连接完全关闭。</p></li></ul><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><ul><li><strong>CLOSE-WAIT</strong> 是为了让接收方有时间完成自己的数据传输。</li><li><strong>TIME-WAIT</strong> 是为了确保连接完全关闭，没有残留数据包干扰新的连接。</li></ul><p>​</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h2><p>欢迎大家关注我的微信公众号「<strong>跟着小康学编程</strong>」！本号致力于分享<strong>C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习、计算机基础原理、Linux 编程、数据库、微服务、容器技术</strong> 等内容。文章力求通俗易懂，并配有代码示例，方便初学者理解。如果您对这些内容感兴趣，欢迎关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p>后续，我还会陆续分享各个方向的编程面试题，包括<strong>C&#x2F;C++、Java、Go，以及操作系统、计算机网络、数据结构、数据库和微服务</strong>等领域，为大家的面试提供帮助。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络面试 </tag>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP 面试题 — TCP 四次挥手过程中，为什么需要等待 2MSL, 才进入 CLOSED 关闭状态？</title>
      <link href="/why-tcp-terminate-wait-2msl/"/>
      <url>/why-tcp-terminate-wait-2msl/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康。</p><p>今天给大家分享一个 TCP 面试题 ：<strong>TCP 四次挥手过程中，为什么需要等待 2MSL, 才进入 CLOSED 关闭状态？</strong></p><blockquote><p><strong>小技巧</strong>：在面试中，可以参考下面的<strong>示例回答</strong>，这样回答简洁明了。<strong>详细介绍</strong>部分则是为了帮助大家系统学习，以便应对面试官深入提问。</p></blockquote><h3 id="示例回答："><a href="#示例回答：" class="headerlink" title="示例回答："></a>示例回答：</h3><p>在 TCP 四次挥手过程中，需要等待 2MSL 才进入 CLOSED 状态，主要是为了两件事：第一，确保最后一个 ACK 报文能被对方收到；第二，防止旧的重复报文影响新的连接。这样做能确保连接真正关闭，数据传输也更可靠。</p><hr><h3 id="详细解释："><a href="#详细解释：" class="headerlink" title="详细解释："></a>详细解释：</h3><h4 id="先来看看-TCP-四次挥手的过程："><a href="#先来看看-TCP-四次挥手的过程：" class="headerlink" title="先来看看 TCP 四次挥手的过程："></a>先来看看 TCP 四次挥手的过程：</h4><p><img src="/images/TCP/tcpthree.png"></p><ol><li><p><strong>第一次挥手（FIN）：</strong> 主动关闭方告诉对方“我没有数据要发送了，我们可以关了”。</p></li><li><p><strong>第二次挥手（ACK）：</strong> 被动关闭方回应“好的，我知道了”。</p></li><li><p><strong>第三次挥手（FIN）：</strong> 被动关闭方也表示“我这边也没有数据了，我们关吧”。</p></li><li><p><strong>第四次挥手（ACK）：</strong> 主动关闭方回应“好的，我们一起关”。</p></li></ol><p>发送完最后一个 ACK 后，主动关闭方需要等待 2MSL（最大报文生存时间的两倍）。这期间，它保持连接的资源，等待一段时间。</p><h4 id="为什么需要等-2MSL-这么久呢？有两个原因："><a href="#为什么需要等-2MSL-这么久呢？有两个原因：" class="headerlink" title="为什么需要等(2MSL)这么久呢？有两个原因："></a>为什么需要等(2MSL)这么久呢？有两个原因：</h4><ol><li><p><strong>确保所有旧包都消失</strong>：MSL 是网络中数据包的最长生存时间。等待 2MSL 可以确保所有旧的、可能还在网络中游荡的数据包都已经过期消失。这样可以防止这些旧包干扰新的连接。例如，旧的 FIN 包或者 ACK 包如果不消失，可能会被新的连接误认为是有效的，从而造成混乱。</p></li><li><p><strong>确保对方收到确认包</strong>：如果服务器在发送 FIN 包后没有收到客户端的 ACK 包，它会重新发送 FIN 包。等待 2MSL 可以确保客户端在需要时还能重发 ACK 包，确保服务器知道连接已经完全关闭，不会再重发 FIN 包。</p></li></ol><h4 id="通俗解释："><a href="#通俗解释：" class="headerlink" title="通俗解释："></a>通俗解释：</h4><p>想象你在和朋友打电话，双方都说完了再见，挂电话前，你得等一下，确认没有回音，确保通话真的结束了。如果你直接挂断，可能朋友还在等你的确认，再次拨回来。这等待的时间就像 2MSL，确保通话（连接）确实彻底结束了，没有任何遗留的声音（数据包）会干扰下一次通话（连接）。</p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>2MSL 等待时间的主要目的是确保连接完全关闭，没有残留的数据包干扰，并且确保对方收到确认信息。这是 TCP 协议为了实现可靠连接关闭而设计的重要机制。</p><p>​</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h2><p>欢迎大家关注我的微信公众号「<strong>跟着小康学编程</strong>」！本号致力于分享<strong>C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习、计算机基础原理、Linux 编程、数据库、微服务、容器技术</strong> 等内容。文章力求通俗易懂，并配有代码示例，方便初学者理解。如果您对这些内容感兴趣，欢迎关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p>后续，我还会陆续分享各个方向的编程面试题，包括<strong>C&#x2F;C++、Java、Go，以及操作系统、计算机网络、数据结构、数据库和微服务</strong>等领域，为大家的面试提供帮助。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络面试 </tag>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP 面试题 — TCP 挥手为什么需要四次呢？三次不行？</title>
      <link href="/why-tcp-four-termination-not-three/"/>
      <url>/why-tcp-four-termination-not-three/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康。</p><p>今天给大家分享一个 TCP 面试题 ：<strong>TCP 挥手为什么需要四次呢？三次不行？</strong></p><blockquote><p><strong>小技巧</strong>：在面试中，可以参考下面的<strong>示例回答</strong>，这样回答简洁明了。<strong>详细介绍</strong>部分则是为了帮助大家系统学习，以便应对面试官深入提问。</p></blockquote><h3 id="示例回答："><a href="#示例回答：" class="headerlink" title="示例回答："></a>示例回答：</h3><p>TCP 挥手需要四次，因为双方需要独立关闭各自的传输方向。三次不行，因为需要双方都确认各自的 FIN 和 ACK。四次挥手确保了连接的完全关闭，避免数据丢失或冲突。</p><hr><h3 id="详细解释："><a href="#详细解释：" class="headerlink" title="详细解释："></a>详细解释：</h3><h4 id="先来看看-TCP-四次挥手的过程："><a href="#先来看看-TCP-四次挥手的过程：" class="headerlink" title="先来看看 TCP 四次挥手的过程："></a>先来看看 TCP 四次挥手的过程：</h4><p><img src="/images/TCP/tcpfour.png"></p><p>TCP 关闭连接通过四次挥手来实现，主要是因为双方需要独立地关闭各自的传输方向。</p><p>具体步骤如下：</p><ol><li><p><strong>第一次挥手（FIN）：</strong> 主动关闭方（比如客户端）发送 FIN 报文，告诉对方（比如服务器）“我没有数据要发了”。</p></li><li><p><strong>第二次挥手（ACK）：</strong> 服务器收到 FIN 报文后，发送一个 ACK 确认，表示“我知道你没有数据了”。</p></li><li><p><strong>第三次挥手（FIN）：</strong> 服务器也发送一个 FIN 报文，告诉客户端“我也没有数据要发了”。</p></li><li><p><strong>第四次挥手（ACK）：</strong> 客户端收到服务器的 FIN 报文后，发送一个 ACK 确认，表示“我知道你也没有数据了”。</p></li></ol><h4 id="为什么三次不行呢？"><a href="#为什么三次不行呢？" class="headerlink" title="为什么三次不行呢？"></a>为什么三次不行呢？</h4><p>原因在于双方需要独立关闭各自的数据传输方向。</p><p>举个例子，如果客户端发送 FIN，服务器收到后直接关闭连接（第二次和第三次挥手合二为一），那么服务器可能还有数据要发送，导致数据丢失。因此，服务器需要在收到 FIN 后先发送 ACK，然后再发送自己的 FIN，客户端再确认收到服务器的 FIN，最终双方都确认彼此的传输方向已经关闭，这样才能保证连接的完整关闭。</p><p>四次挥手确保双方都能安全、完整地关闭连接，避免数据丢失或冲突，是 TCP 协议设计中的一个关键机制。通过这个过程，TCP 实现了可靠的数据传输和连接管理。</p><p>​</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h2><p>欢迎大家关注我的微信公众号「<strong>跟着小康学编程</strong>」！本号致力于分享<strong>C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习、计算机基础原理、Linux 编程、数据库、微服务、容器技术</strong> 等内容。文章力求通俗易懂，并配有代码示例，方便初学者理解。如果您对这些内容感兴趣，欢迎关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p>后续，我还会陆续分享各个方向的编程面试题，包括<strong>C&#x2F;C++、Java、Go，以及操作系统、计算机网络、数据结构、数据库和微服务</strong>等领域，为大家的面试提供帮助。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络面试 </tag>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP 面试题 — 三次握手中每一次没收到报文会发生什么情况？</title>
      <link href="/tcp-three-handshake-detail-2/"/>
      <url>/tcp-three-handshake-detail-2/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康。</p><p>今天给大家分享一个 TCP 面试题 ：<strong>三次握手中每一次没收到报文会发生什么情况？</strong></p><blockquote><p><strong>小技巧</strong>：在面试中，可以参考下面的<strong>示例回答</strong>，这样回答简洁明了。<strong>详细介绍</strong>部分则是为了帮助大家系统学习，以便应对面试官深入提问。</p></blockquote><h3 id="示例回答："><a href="#示例回答：" class="headerlink" title="示例回答："></a>示例回答：</h3><p>如果三次握手中的任何一个报文没有被收到，TCP 将触发超时重传机制。具体来说，如果客户端没收到 SYN-ACK 或 ACK 包，或服务器没收到 SYN 包 或 ACK 包，它们都会重传未确认的报文，直到确认连接建立或放弃。</p><hr><h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><h4 id="三次握手中每一次没收到报文会发生什么情况"><a href="#三次握手中每一次没收到报文会发生什么情况" class="headerlink" title="三次握手中每一次没收到报文会发生什么情况?"></a>三次握手中每一次没收到报文会发生什么情况?</h4><p>先来看下 TCP 三次握手的过程：</p><p><img src="/images/TCP/tcpthree.png"></p><p><strong>第一次握手：客户端发送 SYN 包</strong></p><ul><li><strong>情况</strong>：服务器没收到 SYN 包</li><li><strong>解释</strong>：如果服务器没收到客户端的 SYN 包，客户端会等待一段时间后重传 SYN 包。客户端会继续重传 SYN 包直到收到服务器的 SYN-ACK 包或达到重传次数上限。</li><li><strong>类比</strong>：你向朋友挥手示意，但朋友没看到，你会再次挥手，直到朋友回应或你放弃。</li><li><strong>示例</strong>：客户端发送 SYN 包，等待一段时间没收到回应，再次发送 SYN 包。</li></ul><p><strong>第二次握手：服务器发送 SYN-ACK 包</strong></p><ul><li><strong>情况</strong>：客户端没收到 SYN-ACK 包</li><li><strong>解释</strong>：如果客户端没收到服务器的 SYN-ACK 包，客户端会认为 SYN 包丢失，再次发送 SYN 包。服务器收到重复的 SYN 包后，会重传 SYN-ACK 包，直到客户端收到为止。</li><li><strong>类比</strong>：朋友向你挥手回应，但你没看到，朋友会继续挥手，直到你看到并回应。</li><li><strong>示例</strong>：服务器发送 SYN-ACK 包，客户端没收到，再次发送 SYN 包，服务器重传 SYN-ACK 包。</li></ul><p><strong>第三次握手：客户端发送 ACK 包</strong></p><ul><li><strong>情况</strong>：服务器没收到 ACK 包</li><li><strong>解释</strong>：如果服务器没收到客户端的 ACK 包，服务器会重传 SYN-ACK 包，客户端收到重复的 SYN-ACK 包后，会重传 ACK 包。这个过程会重复，直到服务器收到 ACK 包或达到重传次数上限。</li><li><strong>类比</strong>：你向朋友点头确认，但朋友没看到，他会继续挥手示意，直到你再次点头确认。</li><li><strong>示例</strong>：客户端发送 ACK 包，服务器没收到，服务器重传 SYN-ACK 包，客户端重传 ACK 包。</li></ul><h3 id="关键点总结"><a href="#关键点总结" class="headerlink" title="关键点总结"></a>关键点总结</h3><ul><li><strong>第一次握手（客户端发送 SYN 包）</strong>：如果服务器没收到，客户端重传 SYN 包。</li><li><strong>第二次握手（服务器发送 SYN-ACK 包）</strong>：如果客户端没收到，客户端重传 SYN 包，服务器重传 SYN-ACK 包。</li><li><strong>第三次握手（客户端发送 ACK 包）</strong>：如果服务器没收到，服务器重传 SYN-ACK 包，客户端重传 ACK 包。</li></ul><h2 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h2><p>欢迎大家关注我的微信公众号「<strong>跟着小康学编程</strong>」！本号致力于分享<strong>C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习、计算机基础原理、Linux 编程、数据库、微服务、容器技术</strong> 等内容。文章力求通俗易懂，并配有代码示例，方便初学者理解。如果您对这些内容感兴趣，欢迎关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p>后续，我还会陆续分享各个方向的编程面试题，包括<strong>C&#x2F;C++、Java、Go，以及操作系统、计算机网络、数据结构、数据库和微服务</strong>等领域，为大家的面试提供帮助。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络面试 </tag>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP 面试题 — 说说 TCP 四次挥手的过程？</title>
      <link href="/tcp-four-way-termination/"/>
      <url>/tcp-four-way-termination/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康。</p><p>今天给大家分享一个 TCP 面试题 ：<strong>说说 TCP 四次挥手的过程？</strong></p><blockquote><p><strong>小技巧</strong>：在面试中，可以参考下面的<strong>示例回答</strong>，这样回答简洁明了。<strong>详细介绍</strong>部分则是为了帮助大家系统学习，以便应对面试官深入提问。</p></blockquote><h3 id="示例回答："><a href="#示例回答：" class="headerlink" title="示例回答："></a><strong>示例回答：</strong></h3><p>TCP 四次挥手就像结束一场会议。第一次挥手是主持人宣布“会议结束”（FIN 包），第二次挥手是与会者回应“好的，我知道了”（ACK 包），第三次挥手是与会者说“我也准备离开了”（FIN 包），第四次挥手是主持人确认“好的，大家再见”（ACK 包），然后所有人离开会议室（连接关闭）。</p><hr><h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><h4 id="TCP-四次挥手的过程"><a href="#TCP-四次挥手的过程" class="headerlink" title="TCP 四次挥手的过程"></a>TCP 四次挥手的过程</h4><p><strong>四次挥手的过程如下图</strong>：</p><p><img src="/images/TCP/tcpfour.png"></p><ol><li><strong>第一次挥手：客户端发送 FIN</strong></li></ol><ul><li><strong>过程</strong>：客户端发送一个 FIN（Finish）包，表示它完成了数据传输，请求关闭连接。</li><li><strong>类比</strong>：主持人宣布：“会议结束。”</li><li><strong>状态</strong>：客户端进入 FIN-WAIT-1 状态。</li><li><strong>示例</strong>：客户端发送 FIN 包，序列号为 u。</li></ul><ol start="2"><li><strong>第二次挥手：服务器回复 ACK</strong></li></ol><ul><li><strong>过程</strong>：服务器收到 FIN 包后，回复一个 ACK（Acknowledgment）包，表示它收到了关闭请求，但还未准备好关闭连接。</li><li><strong>类比</strong>：与会者回应：“好的，我知道了。”</li><li><strong>状态</strong>：服务器进入 CLOSE-WAIT 状态，客户端进入 FIN-WAIT-2 状态。</li><li><strong>示例</strong>：服务器发送 ACK 包，序列号为 v，确认号为 u + 1。</li></ul><ol start="3"><li><strong>第三次挥手：服务器发送 FIN</strong></li></ol><ul><li><strong>过程</strong>：当服务器完成数据传输后，发送一个 FIN 包，表示它准备好关闭连接。</li><li><strong>类比</strong>：与会者说：“我也准备离开了。”</li><li><strong>状态</strong>：服务器进入 LAST-ACK 状态。</li><li><strong>示例</strong>：服务器发送 FIN 包，序列号为 w,确认序列号为u+1。</li></ul><ol start="4"><li><strong>第四次挥手：客户端回复 ACK</strong></li></ol><ul><li><strong>过程</strong>：客户端收到 FIN 包后，回复一个 ACK 包，表示确认关闭连接。此时，客户端进入 TIME-WAIT 状态，等待一段时间后关闭，以确保服务器收到 ACK 包。</li><li><strong>类比</strong>：主持人确认：“好的，大家再见。”</li><li><strong>状态</strong>：客户端进入 TIME-WAIT 状态，等待 2MSL（Maximum Segment Lifetime）时间后进入 CLOSED 状态。服务器收到 ACK 确认包进入 CLOSED 状态。</li><li><strong>示例</strong>：客户端发送 ACK 包，确认号为 w + 1，序列号为 u+1。</li></ul><h3 id="关键点总结"><a href="#关键点总结" class="headerlink" title="关键点总结"></a>关键点总结</h3><ul><li><strong>第一次挥手（客户端发送 FIN）</strong>：客户端请求关闭连接（主持人宣布会议结束），进入 FIN-WAIT-1 状态。</li><li><strong>第二次挥手（服务器回复 ACK）</strong>：服务器收到关闭连接请求（与会者确认收到关闭请求），服务器进入 CLOSE-WAIT 状态，客户端进入 FIN-WAIT-2 状态。</li><li><strong>第三次挥手（服务器发送 FIN）</strong>：服务器发送关闭请求（与会者准备离开），进入 LAST-ACK 状态。</li><li><strong>第四次挥手（客户端回复 ACK）</strong>：客户端确认关闭连接(主持人确认所有人可以离开)，客户端进入 TIME-WAIT 状态(客户端需要等待2MSL后才进入CLOSED 状态)，服务器收到确认 ACK 进入 CLOSED 状态。</li></ul><p>​</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h2><p>欢迎大家关注我的微信公众号「<strong>跟着小康学编程</strong>」！本号致力于分享<strong>C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习、计算机基础原理、Linux 编程、数据库、微服务、容器技术</strong> 等内容。文章力求通俗易懂，并配有代码示例，方便初学者理解。如果您对这些内容感兴趣，欢迎关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p>后续，我还会陆续分享各个方向的编程面试题，包括<strong>C&#x2F;C++、Java、Go，以及操作系统、计算机网络、数据结构、数据库和微服务</strong>等领域，为大家的面试提供帮助。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络面试 </tag>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP 面试题 — 第3次握手可以携带数据吗？</title>
      <link href="/tcp-three-handshake-detail-1/"/>
      <url>/tcp-three-handshake-detail-1/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康。</p><p>今天给大家分享一个 TCP 面试题 ：<strong>第3次握手可以携带数据吗？</strong></p><blockquote><p><strong>小技巧</strong>：在面试中，可以参考下面的<strong>示例回答</strong>，这样回答简洁明了。<strong>详细介绍</strong>部分则是为了帮助大家系统学习，以便应对面试官深入提问。</p></blockquote><h3 id="示例回答："><a href="#示例回答：" class="headerlink" title="示例回答："></a>示例回答：</h3><p>第3次握手可以携带数据，但通常不会这样做，因为在连接完全建立之前，携带数据可能会导致数据丢失或重传问题。</p><hr><h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><h4 id="第3次握手携带数据的可能性"><a href="#第3次握手携带数据的可能性" class="headerlink" title="第3次握手携带数据的可能性"></a>第3次握手携带数据的可能性</h4><ol><li><strong>可以携带数据</strong></li></ol><ul><li><strong>解释</strong>：在技术上，TCP 协议允许第3次握手中的 ACK 包携带数据。这是因为在发送 ACK 包的同时，连接已经进入 ESTABLISHED 状态，理论上可以传输数据。</li><li><strong>类比</strong>：就像你在确认见面的最后一次信息中，除了确认信息，还可以附带见面地点的详细说明。</li><li><strong>示例</strong>：客户端在发送 ACK 包时，同时发送一些初始数据。</li></ul><ol start="2"><li><strong>为什么通常不会携带数据</strong></li></ol><ul><li><strong>解释</strong>：尽管技术上可以，实际应用中很少在第3次握手中携带数据。原因是此时连接尚未完全确认，如果 ACK 包丢失，数据也会丢失，需要重传。这会增加复杂性和数据传输的风险。</li><li><strong>类比</strong>：就像在确认见面之前，你发送了见面地点的详细说明，但如果对方没收到确认信息，见面地点的信息也可能丢失。</li><li><strong>示例</strong>：如果客户端在第3次握手中携带数据，但服务器未收到 ACK 包，这些数据将需要重传，增加了复杂性。</li></ul><ol start="3"><li><strong>实际应用中的做法</strong></li></ol><ul><li><strong>解释</strong>：通常在三次握手完全确认连接建立后，再发送数据。这样可以确保连接的可靠性，减少数据丢失和重传的可能性。</li><li><strong>类比</strong>：在确认见面之后，再详细讨论见面地点和时间，确保信息不丢失。</li><li><strong>示例</strong>：客户端在收到服务器的 SYN-ACK 包并发送 ACK 包后，再发送数据。</li></ul><h3 id="关键点总结"><a href="#关键点总结" class="headerlink" title="关键点总结"></a>关键点总结</h3><ul><li><strong>可以携带数据</strong>：第3次握手中的 ACK 包技术上可以携带数据。</li><li><strong>通常不会携带数据</strong>：为了避免数据丢失和重传问题，实际应用中通常在连接完全建立后再发送数据。</li><li><strong>实际应用中的做法</strong>：在三次握手完全确认连接建立后，再进行数据传输，确保可靠性。</li></ul><p>​</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h2><p>欢迎大家关注我的微信公众号「<strong>跟着小康学编程</strong>」！本号致力于分享<strong>C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习、计算机基础原理、Linux 编程、数据库、微服务、容器技术</strong> 等内容。文章力求通俗易懂，并配有代码示例，方便初学者理解。如果您对这些内容感兴趣，欢迎关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p>后续，我还会陆续分享各个方向的编程面试题，包括<strong>C&#x2F;C++、Java、Go，以及操作系统、计算机网络、数据结构、数据库和微服务</strong>等领域，为大家的面试提供帮助。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络面试 </tag>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP 面试题 — 第二次握手传回了 ACK，为什么还要传回 SYN？</title>
      <link href="/tcp-three-handshake-detail/"/>
      <url>/tcp-three-handshake-detail/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康。</p><p>今天给大家分享一个 TCP 面试题 ：<strong>第二次握手传回了 ACK，为什么还要传回 SYN？</strong></p><blockquote><p><strong>小技巧</strong>：在面试中，可以参考下面的<strong>示例回答</strong>，这样回答简洁明了。<strong>详细介绍</strong>部分则是为了帮助大家系统学习，以便应对面试官深入提问。</p></blockquote><h3 id="示例回答："><a href="#示例回答：" class="headerlink" title="示例回答："></a>示例回答：</h3><p>第二次握手不仅要传回 ACK 确认客户端的 SYN，还要传回 SYN 来同步服务器的初始序列号。这确保了双方都能确认彼此的存在和状态，并为数据传输做好准备。</p><hr><h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><h4 id="第二次握手传回了-ACK，为什么还要传回-SYN？"><a href="#第二次握手传回了-ACK，为什么还要传回-SYN？" class="headerlink" title="第二次握手传回了 ACK，为什么还要传回 SYN？"></a>第二次握手传回了 ACK，为什么还要传回 SYN？</h4><ol><li><strong>确认客户端的 SYN</strong></li></ol><ul><li><strong>解释</strong>：第二次握手中的 ACK 是对客户端 SYN 包的确认。这意味着服务器已经收到了客户端的连接请求，并确认了这一请求。</li><li><strong>类比</strong>：就像你和朋友确认见面的计划，你先说：“我们见面吧”，朋友回应：“好的，我收到了你的信息。”</li><li><strong>示例</strong>：服务器发送的 SYN-ACK 包中的 ACK 部分确认了客户端的 SYN。</li></ul><ol start="2"><li><strong>同步服务器的初始序列号</strong></li></ol><ul><li><strong>解释</strong>：第二次握手中的 SYN 是服务器向客户端发送的连接请求。这不仅是对客户端请求的回应，同时也发送了服务器的初始序列号，要求客户端进行确认。</li><li><strong>类比</strong>：在你们确认见面计划时，朋友不仅告诉你他收到了你的信息，还会补充：“我也准备好了，你看到了吗？”</li><li><strong>示例</strong>：服务器发送的 SYN-ACK 包中的 SYN 部分携带了服务器的初始序列号。</li></ul><ol start="3"><li><strong>确保双向通信</strong></li></ol><ul><li><strong>解释</strong>：三次握手的设计是为了确保双方都能确认彼此的存在和状态。第二次握手中包含 ACK 和 SYN 可以确保双向通信的对等性和可靠性。</li><li><strong>类比</strong>：在你和朋友确认见面计划的过程中，你们都需要确保对方已经准备好，并且都能看到对方的回应。</li><li><strong>示例</strong>：第二次握手中的 SYN 和 ACK 包是双向通信的关键，确保双方都能确认连接状态。</li></ul><ol start="4"><li><strong>数据传输准备</strong></li></ol><ul><li><strong>解释</strong>：第二次握手中的 SYN 和 ACK 包为即将到来的数据传输做准备。它们同步了双方的初始序列号，确保数据传输的顺序和完整性。</li><li><strong>类比</strong>：在确认见面计划时，你和朋友不仅要知道彼此的意图，还需要同步时间表，以确保按时见面。</li><li><strong>示例</strong>：服务器和客户端通过 SYN 和 ACK 包同步序列号，为后续的数据传输打好基础。</li></ul><h3 id="关键点总结"><a href="#关键点总结" class="headerlink" title="关键点总结"></a>关键点总结</h3><ul><li><strong>确认客户端的 SYN</strong>：第二次握手中的 ACK 是对客户端 SYN 包的确认。</li><li><strong>同步服务器的初始序列号</strong>：第二次握手中的 SYN 是服务器向客户端发送的连接请求，包含服务器的初始序列号。</li><li><strong>确保双向通信</strong>：三次握手的设计确保双方都能确认彼此的存在和状态。</li><li><strong>数据传输准备</strong>：第二次握手中的 SYN 和 ACK 包为数据传输同步了双方的初始序列号，确保数据传输的顺序和完整性。</li></ul><p>​</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h2><p>欢迎大家关注我的微信公众号「<strong>跟着小康学编程</strong>」！本号致力于分享<strong>C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习、计算机基础原理、Linux 编程、数据库、微服务、容器技术</strong> 等内容。文章力求通俗易懂，并配有代码示例，方便初学者理解。如果您对这些内容感兴趣，欢迎关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p>后续，我还会陆续分享各个方向的编程面试题，包括<strong>C&#x2F;C++、Java、Go，以及操作系统、计算机网络、数据结构、数据库和微服务</strong>等领域，为大家的面试提供帮助。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络面试 </tag>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP 面试题 — TCP 握手为什么是三次，为什么不能是两次？不能是四次？</title>
      <link href="/why-tcp-three-handshake/"/>
      <url>/why-tcp-three-handshake/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康。</p><p>今天给大家分享一个 TCP 面试题 ：<strong>TCP 握手为什么是三次，为什么不能是两次？不能是四次？</strong></p><blockquote><p><strong>小技巧</strong>：在面试中，可以参考下面的<strong>示例回答</strong>，这样回答简洁明了。<strong>详细介绍</strong>部分则是为了帮助大家系统学习，以便应对面试官深入提问。</p></blockquote><h3 id="示例回答："><a href="#示例回答：" class="headerlink" title="示例回答："></a><strong>示例回答：</strong></h3><p>TCP三次握手确保双方准备好通信，防止旧连接误用，同步双方初始序列号，并避免资源浪费。两次握手无法确保双方都准备好，无法防止旧连接的建立，导致序列号不同步和资源浪费，而四次握手则增加了不必要的复杂性和延迟。三次握手在确保连接可靠性的同时，也保持了高效性。 </p><hr><h2 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h2><h3 id="为什么是三次握手？"><a href="#为什么是三次握手？" class="headerlink" title="为什么是三次握手？"></a>为什么是三次握手？</h3><h4 id="1、确保双方都准备好"><a href="#1、确保双方都准备好" class="headerlink" title="1、确保双方都准备好"></a>1、确保双方都准备好</h4><p><strong>解释</strong>：三次握手通过三步过程确认双方都准备好进行数据传输。客户端发送 SYN 包，服务器回复 SYN-ACK 包，客户端再发送 ACK 包。这样，双方都能确认彼此的存在和状态。</p><p><strong>类比：点头确认</strong></p><p>想象你和朋友要在远处确认是否准备好开始对话，你们用点头来确认彼此的状态。这类似于TCP的三次握手。</p><p><strong>点头确认过程（TCP三次握手）</strong></p><ol><li><strong>第一次握手：你点头</strong></li></ol><ul><li>你朝朋友点头，意思是：“我准备好和你说话了。”（SYN包）</li></ul><ol start="2"><li><strong>第二次握手：朋友点头</strong></li></ol><ul><li>朋友看到你的点头，朝你点头回应：“我也准备好了，你听到了吗？”（SYN-ACK包）</li></ul><ol start="3"><li><strong>第三次握手：你再次点头</strong></li></ol><ul><li>你看到朋友的点头，再次点头回应：“我听到了，我们开始吧。”（ACK包）</li></ul><p>通过这个过程，你和朋友可以确保彼此都准备好，并且都知道对方也准备好。这避免了通信中的混乱和误解。  </p><p>如果通信过程只有两次握手，那这样的通信过程可能会存在一些问题 ：</p><ul><li><strong>你无法确认朋友是否收到了你对他准备好的确认</strong>：在三次握手中，你的最后一次点头（发送ACK包）是告诉朋友你已经收到他的回应，并确认你们两个都明白对方已经准备好开始对话。如果没有这一步，虽然你知道朋友准备好了，但朋友并不知道你是否真的收到了他的准备信号，这可能会导致他在你还没有完全准备好的情况下就开始讲话。</li></ul><p>这就是为什么TCP需要三次握手来建立连接。这确保了双方不仅知道对方已经准备好，而且确认了彼此都收到了对方的准备好的信息，从而有效避免了通信的混乱和误解。</p><h4 id="2、防止重复历史连接的初始化"><a href="#2、防止重复历史连接的初始化" class="headerlink" title="2、防止重复历史连接的初始化"></a>2、防止重复历史连接的初始化</h4><p><strong>解释</strong>：通过三次握手，可以确保当前的连接请求是新的，而不是旧的或重复的请求。这是因为每次握手都有新的序列号，确保了连接的唯一性和正确性。</p><p><strong>场景设定</strong>：<br>想象你和朋友通过传纸条的方式进行通信，每次通信都需要确认对方已经准备好，并且要避免误读之前的旧纸条。</p><p><strong>三次握手过程</strong>：</p><ol><li><strong>第一次握手</strong>：你写了一张纸条给朋友，内容是：“我们开始通信吧。”（SYN包）</li><li><strong>第二次握手</strong>：朋友收到纸条后，回了一张纸条给你，内容是：“好的，我收到你的信息了，我们开始吧。”（SYN-ACK包）</li><li><strong>第三次握手</strong>：你收到朋友的纸条后，再回一张纸条给朋友，内容是：“太好了，那我们正式开始通信。”（ACK包）</li></ol><p><strong>防止重复历史连接</strong>：<br>现在假设一个特殊情况：几天前你曾给朋友发过一张“我们开始通信吧”的纸条（SYN包），但是由于某些原因这张纸条在传递过程中被延误了，朋友没有及时收到。所以你们那次通信并没有成功。<br>几天后，这张旧纸条（SYN包）终于到了朋友手中。如果只有2次握手而没有三次握手的确认机制的话，朋友可能会误以为这是新的通信请求，直接开始通信，这样就会导致混乱，因为他以为你们是在旧的基础上开始的。</p><p><strong>通过三次握手</strong>：</p><ul><li>第一次握手时，你发送请求。</li><li>第二次握手时，朋友收到请求并确认准备开始通信。</li><li>第三次握手时，你确认朋友的准备并正式开始通信。</li></ul><p>这三次确认确保了双方都知道当前的通信请求是新的，而不是基于旧的历史纸条。这就防止了网络中滞留的旧请求包被误认为是新的通信请求。</p><h4 id="3、同步双方的初始序列号"><a href="#3、同步双方的初始序列号" class="headerlink" title="3、同步双方的初始序列号"></a>3、同步双方的初始序列号</h4><p>TCP三次握手的过程中同步双方的初始序列号是非常关键的一步，这对后续数据传输中的顺序控制和数据完整性非常重要。</p><p><strong>先说下序列号的作用</strong>：在TCP连接中，每个字节的数据都会被赋予一个序列号，这有助于接收方正确、有序地重组来自发送方的数据。如果数据包在网络中丢失或到达顺序不正确，接收方可以根据序列号重组原始数据。</p><p><strong>类比实际例子</strong>：</p><p>想象两个朋友A和B在玩一个游戏，他们需要互相发送确认信息来同步游戏进度。</p><h4 id="三次握手过程（TCP连接建立）"><a href="#三次握手过程（TCP连接建立）" class="headerlink" title="三次握手过程（TCP连接建立）"></a>三次握手过程（TCP连接建立）</h4><p><strong>1、第一次握手（A -&gt; B）</strong>：A发送一条信息给B：“我在游戏中的进度是第10关。”（相当于TCP中的SYN报文，包含A的初始序列号）</p><p><strong>2、第二次握手（B -&gt; A）</strong>：B收到信息后，回复A：“我知道了，我在游戏中的进度是第20关。”（相当于TCP中的SYN-ACK报文，包含B的初始序列号，并确认收到A的进度信息）</p><p>如果只进行这两次握手，A无法确认B是否正确收到了他的进度信息。如果B的回复在传输过程中丢失，A会一直等待B的确认，而B则认为A已经收到了他的进度信息。在这种情况下，A和B的游戏进度可能不同步，导致游戏进度出现混乱。</p><h4 id="三次握手的解决方案"><a href="#三次握手的解决方案" class="headerlink" title="三次握手的解决方案"></a>三次握手的解决方案</h4><p>通过三次握手，确保双方的初始序列号同步，避免通信中的不确定性和误解。</p><p><strong>3、第三次握手（A -&gt; B）</strong>：A收到B的进度信息后，回复：“好的，我收到了你的进度信息。”（相当于TCP中的ACK报文，确认收到B的SYN-ACK报文）</p><p>这样，B可以确认A确实收到了他的进度信息，确保双方的游戏进度同步。</p><p><strong>总结</strong>：通过三次握手，TCP协议确保双方的初始序列号同步，避免了只进行两次握手可能导致的序列号不同步问题。这个过程类似于两个朋友互相确认游戏进度的过程，确保双方的信息一致，从而避免通信中的不确定性和误解。</p><h4 id="4、避免资源浪费"><a href="#4、避免资源浪费" class="headerlink" title="4、避免资源浪费"></a>4、避免资源浪费</h4><p><strong>解释</strong>：通过三次握手，服务器在确认客户端已准备好进行通信前不会分配大量资源。这有效避免了资源的浪费。</p><p><strong>类比会议室预订</strong>：<br>想象一下，你想预订一间会议室来举办一个会议。这个预订过程和TCP三次握手很相似：</p><ol><li><strong>提出预订请求（第一次握手）</strong>：</li></ol><ul><li>你给管理会议室的管理员发送一条信息：“我想在明天的上午9点到11点使用会议室。”</li><li>这就像发送一个SYN包，表示你想开始一个连接。</li></ul><ol start="2"><li><strong>管理员确认并提出条件（第二次握手）</strong>：</li></ol><ul><li>管理员回复你：“好的，会议室明天上午9点到11点可用。请确认你会准时到达并使用。”</li><li>这就像服务器发送SYN和ACK，不仅确认了你的请求，还提出了自己的条件（即服务器的初始序列号）。</li></ul><ol start="3"><li><strong>你最终确认（第三次握手）</strong>：</li></ol><ul><li>你回复管理员：“我确认，我会准时到达并使用会议室。”</li><li>这就是你发送ACK，确认管理员的条件，完成连接建立。</li></ul><p><strong>如果只有两次握手会发生什么？</strong>   </p><p><strong>1、预订资源浪费</strong>：</p><ul><li>管理员以为你会使用会议室，但你并没有确认。如果你没有收到管理员的回复而没有去使用会议室，会议室会空置，导致资源浪费。<strong>在TCP中，这会导致服务器预留内存。</strong></li></ul><p><strong>2、重复预订</strong>：</p><ul><li>如果你的请求在网络中延迟，管理员在不知情的情况下收到你的旧请求，可能会重复确认预订，导致混乱和资源浪费。<strong>在TCP中，这会导致服务器为多个无效连接预留内存和连接表空间。</strong></li></ul><p><strong>3、未能成功建立连接</strong>：</p><ul><li>如果你没有收到管理员的确认(第二次握手)，你可能会认为预订未成功，再次发送请求，造成不必要的重复操作和资源消耗。<strong>在TCP中，这会导致服务器浪费处理能力和带宽。</strong></li></ul><p>通过这个比喻，我们可以看到TCP三次握手如同一种精确的确认过程，它确保所有资源（如会议室或网络连接）都是在双方明确同意并准备好的情况下才被使用，有效地防止了资源的浪费。</p><h3 id="TCP为什么不是四次握手？"><a href="#TCP为什么不是四次握手？" class="headerlink" title="TCP为什么不是四次握手？"></a>TCP为什么不是四次握手？</h3><h4 id="增加不必要的复杂性"><a href="#增加不必要的复杂性" class="headerlink" title="增加不必要的复杂性"></a>增加不必要的复杂性</h4><ul><li><strong>解释</strong>：四次握手会增加额外的确认步骤，使连接建立的过程更加复杂。每增加一次握手，都会引入更多的确认和等待步骤，增加协议的复杂性。</li><li><strong>类比</strong>：想象你和朋友确认一起吃晚饭。三次握手类似于：你发短信问（SYN），朋友回复确认（SYN-ACK），你再回复收到（ACK）。如果再增加一次确认（四次握手），就像朋友再发短信确认“我们真的去吗？”，这增加了不必要的沟通步骤。</li><li><strong>示例</strong>：现有的三次握手已经确认双方的存在和状态，增加第四次握手只是对已确认的连接再确认一次，没有实质性可靠性提升。</li></ul><h4 id="延迟问题"><a href="#延迟问题" class="headerlink" title="延迟问题"></a>延迟问题</h4><ul><li><strong>解释</strong>：四次握手会导致连接建立时间增加，影响网络通信的效率。每次额外的握手步骤都需要时间，增加了延迟。</li><li><strong>类比</strong>：每增加一次确认步骤，就像你和朋友确认晚饭计划的时间增加了一倍，不仅浪费时间，还可能造成不必要的等待。</li><li><strong>示例</strong>：在三次握手的基础上增加第四次握手，导致连接建立时间增加，没有显著的可靠性提升，反而增加了延迟。</li></ul><h4 id="三次握手已经足够"><a href="#三次握手已经足够" class="headerlink" title="三次握手已经足够"></a>三次握手已经足够</h4><ul><li><strong>解释</strong>：三次握手通过三步过程已经能够确保双方准备好进行通信，防止旧连接误用，同步初始序列号，并避免资源浪费。三次握手平衡了连接的可靠性和效率，已经足够确保连接的正确性。</li><li><strong>类比</strong>：就像打电话确认晚饭计划，你们三次确认已经足够清楚，没必要再增加一次确认。</li><li><strong>示例</strong>：三次握手通过 SYN、SYN-ACK 和 ACK 包确认双方的状态，确保连接建立和资源分配。</li></ul><p><strong>关键点总结</strong>：</p><ul><li><strong>增加不必要的复杂性</strong>：四次握手增加了额外的确认步骤，使连接建立过程复杂化，没有实质性提升。</li><li><strong>延迟问题</strong>：四次握手导致连接建立时间增加，影响网络通信的效率。</li><li><strong>三次握手已经足够</strong>：三次握手已经平衡了连接的可靠性和效率，确保双方的状态和资源分配。</li></ul><p>​</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h2><p>欢迎大家关注我的微信公众号「<strong>跟着小康学编程</strong>」！本号致力于分享<strong>C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习、计算机基础原理、Linux 编程、数据库、微服务、容器技术</strong> 等内容。文章力求通俗易懂，并配有代码示例，方便初学者理解。如果您对这些内容感兴趣，欢迎关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p>后续，我还会陆续分享各个方向的编程面试题，包括<strong>C&#x2F;C++、Java、Go，以及操作系统、计算机网络、数据结构、数据库和微服务</strong>等领域，为大家的面试提供帮助。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络面试 </tag>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP 面试题 — 详细说一下 TCP 的三次握手机制</title>
      <link href="/tcp-three-handshake/"/>
      <url>/tcp-three-handshake/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康。</p><p>今天给大家分享一个 TCP 面试题 ：<strong>详细说一下 TCP 的三次握手机制</strong></p><blockquote><p><strong>小技巧</strong>：在面试中，可以参考下面的<strong>示例回答</strong>，这样回答简洁明了。<strong>详细介绍</strong>部分则是为了帮助大家系统学习，以便应对面试官深入提问。</p></blockquote><h3 id="示例回答："><a href="#示例回答：" class="headerlink" title="示例回答："></a>示例回答：</h3><p>TCP 的三次握手就像打电话前的确认过程。第一次握手是客户端发起的“拨号请求”（SYN请求包），第二次握手是服务器回应的“嘟声响应”（SYN-ACK响应包），第三次握手是客户端的“喂，你好”（ACK包），然后双方确认可以开始进行正常的数据传输(类似于通话)。</p><hr><h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><h4 id="TCP-的三次握手机制"><a href="#TCP-的三次握手机制" class="headerlink" title="TCP 的三次握手机制"></a>TCP 的三次握手机制</h4><p><strong>三次握手的过程如下图</strong>：</p><p><img src="/images/TCP/tcpthree.png"></p><p>1.<strong>第一次握手：客户端发送 SYN</strong></p><ul><li><strong>过程</strong>：客户端向服务器发送一个 SYN 包，表示请求建立连接。SYN 包中包含客户端的初始序列号（ISN）。</li><li><strong>类比</strong>：就像拨打电话时，客户端发起的“拨号”请求。</li><li><strong>示例</strong>：客户端发送 SYN 包，序列号为 x。</li></ul><p>2.<strong>第二次握手：服务器回应 SYN-ACK</strong></p><ul><li><strong>过程</strong>：服务器收到 SYN 包后，回复一个 SYN-ACK 包。这个包中包含服务器的初始序列号（ISN）和对客户端 SYN 包的确认（ACK）。</li><li><strong>类比</strong>：服务器的回应就像电话接通后的“嘟声”，表示服务器已经准备好。</li><li><strong>示例</strong>：服务器发送 SYN-ACK 包，序列号为 y，确认号为 x + 1。</li></ul><p>3.<strong>第三次握手：客户端发送 ACK</strong></p><ul><li><strong>过程</strong>：客户端收到 SYN-ACK 包后，发送一个 ACK 包，确认服务器的序列号，并表示连接建立。</li><li><strong>类比</strong>：客户端的确认就像“喂，你好”，表示连接建立，双方可以开始通信。</li><li><strong>示例</strong>：客户端发送 ACK 包，确认号为 y + 1，消耗掉一个序列号 x+1。</li></ul><h3 id="关键点总结"><a href="#关键点总结" class="headerlink" title="关键点总结"></a>关键点总结</h3><ul><li><strong>第一次握手：客户端发送 SYN</strong>：客户端发起“拨号”请求，发送初始序列号。</li><li><strong>第二次握手：服务器回应 SYN-ACK</strong>：服务器回应“嘟声”，确认客户端序列号并发送自己的序列号。</li><li><strong>第三次握手：客户端发送 ACK</strong>：客户端确认“喂，你好”，确认服务器序列号，连接建立。</li></ul><p>​</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h2><p>欢迎大家关注我的微信公众号「<strong>跟着小康学编程</strong>」！本号致力于分享<strong>C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习、计算机基础原理、Linux 编程、数据库、微服务、容器技术</strong> 等内容。文章力求通俗易懂，并配有代码示例，方便初学者理解。如果您对这些内容感兴趣，欢迎关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p>后续，我还会陆续分享各个方向的编程面试题，包括<strong>C&#x2F;C++、Java、Go，以及操作系统、计算机网络、数据结构、数据库和微服务</strong>等领域，为大家的面试提供帮助。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络面试 </tag>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UDP 面试题 — UDP协议为什么不可靠？</title>
      <link href="/why-udp-unreliable/"/>
      <url>/why-udp-unreliable/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康。</p><p>今天给大家分享一个 UDP 面试题 ：<strong>UDP协议为什么不可靠？</strong></p><blockquote><p><strong>小技巧</strong>：在面试中，可以参考下面的<strong>示例回答</strong>，这样回答简洁明了。<strong>详细介绍</strong>部分则是为了帮助大家系统学习，以便应对面试官深入提问。</p></blockquote><h3 id="示例回答："><a href="#示例回答：" class="headerlink" title="示例回答："></a><strong>示例回答：</strong></h3><p>UDP 协议不可靠，因为它没有连接建立过程、不保证数据包的顺序和送达、缺乏数据完整性校验机制，也没有流量控制和拥塞控制。由于这些原因，UDP 在数据传输过程中可能会出现数据包丢失、乱序和损坏的情况。  </p><h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><h4 id="为什么-UDP-协议不可靠"><a href="#为什么-UDP-协议不可靠" class="headerlink" title="为什么 UDP 协议不可靠"></a>为什么 UDP 协议不可靠</h4><ol><li><strong>没有连接建立过程</strong></li></ol><ul><li><strong>解释</strong>：UDP 在发送数据前不需要建立连接，数据包直接发送到目标地址。</li><li><strong>详细</strong>：由于没有类似 TCP 的三次握手过程，发送方和接收方之间没有确认连接是否已建立和双方是否准备好进行通信。</li><li><strong>示例</strong>：发送方直接发送数据包，如果接收方未准备好接收，这些数据包可能会丢失。</li></ul><ol start="2"><li><strong>不保证数据包的顺序</strong></li></ol><ul><li><strong>解释</strong>：UDP 不保证数据包按发送顺序接收，数据包可能乱序到达。</li><li><strong>详细</strong>：因为没有顺序编号和重排序机制，数据包可能在传输过程中乱序到达接收方。</li><li><strong>示例</strong>：接收方可能先收到第二个数据包，再收到第一个数据包，应用程序需要自行处理乱序问题。</li></ul><ol start="3"><li><strong>不保证数据包的送达</strong></li></ol><ul><li><strong>解释</strong>：UDP 不提供确认机制，发送方不会知道数据包是否成功到达接收方。</li><li><strong>详细</strong>：由于没有确认和重传机制，数据包可能在传输过程中丢失而无法被检测到。</li><li><strong>示例</strong>：如果数据包在网络中丢失，发送方不会重传丢失的数据包。</li></ul><ol start="4"><li><strong>不保证数据包的完整性</strong></li></ol><ul><li><strong>解释</strong>：UDP 不提供错误校验和纠错机制，无法检测和纠正传输中的数据错误。</li><li><strong>详细</strong>：数据包可能在传输过程中损坏，接收方无法检测到数据包中的错误。</li><li><strong>示例</strong>：传输过程中，数据包可能被篡改或损坏，但接收方无法检测和纠正这些错误。</li></ul><ol start="5"><li><strong>没有流量控制和拥塞控制</strong></li></ol><ul><li><strong>解释</strong>：UDP 不控制发送方的数据传输速率，发送方可以以任意速度发送数据。</li><li><strong>详细</strong>：没有滑动窗口和拥塞控制机制，可能导致网络拥堵和数据丢失。</li><li><strong>示例</strong>：发送方发送大量数据包，导致网络拥堵，增加数据丢失的概率。</li></ul><h3 id="关键点总结"><a href="#关键点总结" class="headerlink" title="关键点总结"></a>关键点总结</h3><ul><li><strong>没有连接建立过程</strong>：数据包直接发送，双方可能未准备好进行通信。</li><li><strong>不保证数据包的顺序</strong>：数据包可能乱序到达，接收方需要处理。</li><li><strong>不保证数据包的送达</strong>：没有确认和重传机制，数据包可能丢失。</li><li><strong>不保证数据包的完整性</strong>：没有校验和纠错功能，数据包可能损坏。</li><li><strong>没有流量控制和拥塞控制</strong>：发送速率不受控制，可能导致网络拥堵。</li></ul><p>​</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h2><p>欢迎大家关注我的微信公众号「<strong>跟着小康学编程</strong>」！本号致力于分享<strong>C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习、计算机基础原理、Linux 编程、数据库、微服务、容器技术</strong> 等内容。文章力求通俗易懂，并配有代码示例，方便初学者理解。如果您对这些内容感兴趣，欢迎关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p>后续，我还会陆续分享各个方向的编程面试题，包括<strong>C&#x2F;C++、Java、Go，以及操作系统、计算机网络、数据结构、数据库和微服务</strong>等领域，为大家的面试提供帮助。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络面试 </tag>
            
            <tag> UDP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UDP 面试题 — 为什么QQ采用UDP协议？</title>
      <link href="/why-qq-by-udp/"/>
      <url>/why-qq-by-udp/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康。</p><p>今天给大家分享一个 UDP 面试题 ：<strong>为什么QQ采用UDP协议？</strong></p><blockquote><p><strong>小技巧</strong>：在面试中，可以参考下面的<strong>示例回答</strong>，这样回答简洁明了。<strong>详细介绍</strong>部分则是为了帮助大家系统学习，以便应对面试官深入提问。</p></blockquote><h3 id="示例回答："><a href="#示例回答：" class="headerlink" title="示例回答："></a>示例回答：</h3><p>QQ 采用 UDP 协议因为它速度快、延迟低、开销小，适合实时性要求高的应用，如语音、视频和文件传输。尽管 UDP 不可靠，但通过应用层的机制可以保证数据传输的可靠性。</p><hr><h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><h4 id="为什么-QQ-采用-UDP-协议"><a href="#为什么-QQ-采用-UDP-协议" class="headerlink" title="为什么 QQ 采用 UDP 协议"></a>为什么 QQ 采用 UDP 协议</h4><ol><li><strong>速度快，延迟低</strong></li></ol><ul><li><strong>定义</strong>：UDP 协议不需要建立连接，数据直接发送，减少了握手和确认的时间。</li><li><strong>示例</strong>：在 QQ 的语音和视频聊天中，快速传输数据是关键，UDP 的低延迟满足了实时通信的需求。</li></ul><ol start="2"><li><strong>开销小</strong></li></ol><ul><li><strong>定义</strong>：UDP 协议没有连接建立、确认和重传机制，传输时的协议开销较小。</li><li><strong>示例</strong>：QQ 在传输小消息或文件时，UDP 可以减少数据包头部的信息量，提高传输效率。</li></ul><ol start="3"><li><strong>实时性要求高</strong></li></ol><ul><li><strong>定义</strong>：QQ 的语音、视频和文件传输需要实时性，UDP 提供了这种能力。</li><li><strong>示例</strong>：在语音通话中，丢失少量数据包不会明显影响通话质量，但等待重传数据包会导致明显的延迟。</li></ul><ol start="4"><li><strong>应用层保证可靠性</strong></li></ol><ul><li><strong>定义</strong>：尽管 UDP 本身不可靠，QQ 可以在应用层实现数据重传和顺序控制来保证传输的可靠性。</li><li><strong>示例</strong>：QQ 可以在应用层检测丢包，并根据需要请求重传丢失的数据包。</li></ul><h3 id="关键点总结"><a href="#关键点总结" class="headerlink" title="关键点总结"></a>关键点总结</h3><ul><li><strong>速度快，延迟低</strong>：UDP 没有连接建立和确认过程，适合实时通信。</li><li><strong>开销小</strong>：UDP 的协议头部信息量少，传输效率高。</li><li><strong>实时性要求高</strong>：适合 QQ 的语音、视频和文件传输等实时应用。</li><li><strong>应用层保证可靠性</strong>：通过应用层机制实现数据重传和顺序控制，确保传输可靠性。</li></ul><p>​</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h2><p>欢迎大家关注我的微信公众号「<strong>跟着小康学编程</strong>」！本号致力于分享<strong>C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习、计算机基础原理、Linux 编程、数据库、微服务、容器技术</strong> 等内容。文章力求通俗易懂，并配有代码示例，方便初学者理解。如果您对这些内容感兴趣，欢迎关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p>后续，我还会陆续分享各个方向的编程面试题，包括<strong>C&#x2F;C++、Java、Go，以及操作系统、计算机网络、数据结构、数据库和微服务</strong>等领域，为大家的面试提供帮助。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络面试 </tag>
            
            <tag> UDP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UDP 面试题 — UDP 的主要特点是什么？</title>
      <link href="/udp/"/>
      <url>/udp/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康。</p><p>今天给大家分享一个 UDP 面试题 ：<strong>UDP 的主要特点是什么？</strong></p><blockquote><p><strong>小技巧</strong>：在面试中，可以参考下面的<strong>示例回答</strong>，这样回答简洁明了。<strong>详细介绍</strong>部分则是为了帮助大家系统学习，以便应对面试官深入提问。</p></blockquote><h3 id="示例回答："><a href="#示例回答：" class="headerlink" title="示例回答："></a>示例回答：</h3><p>UDP 是无连接的协议，提供不可靠的数据传输，没有顺序控制、流量控制和拥塞控制。由于没有连接建立和确认机制，UDP 速度快，开销小，适用于实时性要求高的应用，如视频直播和在线游戏。  </p><h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><h4 id="UDP-的主要特点"><a href="#UDP-的主要特点" class="headerlink" title="UDP 的主要特点"></a>UDP 的主要特点</h4><ol><li><strong>无连接</strong></li></ol><ul><li><strong>定义</strong>：UDP 在传输数据前不需要建立连接，数据直接发送到目标地址。</li><li><strong>示例</strong>：发送方直接将数据报文发送到接收方，无需三次握手等连接建立过程。</li></ul><ol start="2"><li><strong>不可靠传输</strong></li></ol><ul><li><strong>定义</strong>：UDP 不保证数据包的送达，也不提供重传机制，数据包可能会丢失、重复或乱序。</li><li><strong>示例</strong>：发送的数据包可能在传输过程中丢失，但 UDP 不负责重传。</li></ul><ol start="3"><li><strong>无顺序控制</strong></li></ol><ul><li><strong>定义</strong>：UDP 不保证数据包按发送顺序接收，数据包可能乱序到达。</li><li><strong>示例</strong>：接收方收到的数据包可能顺序错乱，需要应用层自行处理顺序。</li></ul><ol start="4"><li><strong>无流量控制</strong></li></ol><ul><li><strong>定义</strong>：UDP 不控制发送方的数据传输速率，发送方可以以任意速度发送数据。</li><li><strong>示例</strong>：发送方可以连续发送大量数据包，而无需考虑接收方的处理能力。</li></ul><ol start="5"><li><strong>无拥塞控制</strong></li></ol><ul><li><strong>定义</strong>：UDP 不进行拥塞控制，不会调整数据传输速率来避免网络拥堵。</li><li><strong>示例</strong>：即使网络拥堵，UDP 也会继续发送数据包，可能导致更多丢包。</li></ul><ol start="6"><li><strong>速度快，开销小</strong></li></ol><ul><li><strong>定义</strong>：由于没有连接建立、确认和重传机制，UDP 传输速度快，通信开销小。</li><li><strong>示例</strong>：适用于实时性要求高的应用，如视频直播、在线游戏等。</li></ul><h3 id="关键点总结"><a href="#关键点总结" class="headerlink" title="关键点总结"></a>关键点总结</h3><ul><li><strong>无连接</strong>：无需建立连接，数据直接发送。</li><li><strong>不可靠传输</strong>：不保证送达，无重传机制。</li><li><strong>无顺序控制</strong>：数据包可能乱序到达。</li><li><strong>无流量控制</strong>：不控制数据传输速率。</li><li><strong>无拥塞控制</strong>：不进行拥塞控制。</li><li><strong>速度快，开销小</strong>：适用于实时应用。</li></ul><p>​</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h2><p>欢迎大家关注我的微信公众号「<strong>跟着小康学编程</strong>」！本号致力于分享<strong>C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习、计算机基础原理、Linux 编程、数据库、微服务、容器技术</strong> 等内容。文章力求通俗易懂，并配有代码示例，方便初学者理解。如果您对这些内容感兴趣，欢迎关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p>后续，我还会陆续分享各个方向的编程面试题，包括<strong>C&#x2F;C++、Java、Go，以及操作系统、计算机网络、数据结构、数据库和微服务</strong>等领域，为大家的面试提供帮助。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络面试 </tag>
            
            <tag> UDP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP 面试题 — TCP 的主要特点是什么？</title>
      <link href="/tcp/"/>
      <url>/tcp/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康。</p><p>今天给大家分享一个 TCP 面试题 ：<strong>TCP 的主要特点是什么？</strong></p><blockquote><p><strong>小技巧</strong>：在面试中，可以参考下面的<strong>示例回答</strong>，这样回答简洁明了。<strong>详细介绍</strong>部分则是为了帮助大家系统学习，以便应对面试官深入提问。</p></blockquote><h3 id="示例回答："><a href="#示例回答：" class="headerlink" title="示例回答："></a>示例回答：</h3><p>TCP 是面向连接的协议，提供可靠的数据传输、顺序控制、流量控制和拥塞控制，确保数据完整性和准确性。它通过三次握手建立连接，使用确认机制和重传机制保证数据传输的可靠性，并通过滑动窗口和拥塞控制算法管理数据传输速率。</p><h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><h4 id="TCP-的主要特点"><a href="#TCP-的主要特点" class="headerlink" title="TCP 的主要特点"></a>TCP 的主要特点</h4><ol><li><strong>面向连接</strong></li></ol><ul><li><strong>定义</strong>：在传输数据前，客户端和服务器必须先建立一个连接，这个过程称为三次握手。</li><li><strong>示例</strong>：客户端发送一个 SYN 请求，服务器回应 SYN-ACK，客户端再回应一个 ACK，连接建立。</li></ul><ol start="2"><li><strong>可靠的数据传输</strong></li></ol><ul><li><strong>定义</strong>：TCP 通过确认机制确保每个数据包都被成功接收，如果接收方未收到数据包，将请求重传。</li><li><strong>示例</strong>：客户端发送数据包，服务器收到后发送确认消息。如果客户端未收到确认消息，会重传数据包。</li></ul><ol start="3"><li><strong>顺序控制</strong></li></ol><ul><li><strong>定义</strong>：TCP 保证数据包按发送顺序接收，即使数据包在传输过程中乱序，接收方也会按顺序组装数据。</li><li><strong>示例</strong>：即使数据包 2 先于数据包 1 到达，接收方也会按顺序组装为包 1 和包 2。</li></ul><ol start="4"><li><strong>流量控制</strong></li></ol><ul><li><strong>定义</strong>：TCP 通过滑动窗口机制控制发送方发送数据的速度，防止接收方因处理不过来而导致丢包。</li><li><strong>示例</strong>：接收方根据自身处理能力调整窗口大小，通知发送方控制数据发送速率。</li></ul><ol start="5"><li><strong>拥塞控制</strong></li></ol><ul><li><strong>定义</strong>：TCP 通过算法（如慢启动、拥塞避免）来控制网络拥塞，调整数据发送速率，避免网络拥堵。</li><li><strong>示例</strong>：在网络开始变得拥塞时，TCP 会减慢数据发送速率，以减少网络负载。</li></ul><h3 id="关键点总结"><a href="#关键点总结" class="headerlink" title="关键点总结"></a>关键点总结</h3><ul><li><strong>面向连接</strong>：通过三次握手建立连接。</li><li><strong>可靠的数据传输</strong>：确认机制和重传机制确保数据传输的可靠性。</li><li><strong>顺序控制</strong>：保证数据按发送顺序接收。</li><li><strong>流量控制</strong>：通过滑动窗口机制控制发送速率。</li><li><strong>拥塞控制</strong>：通过算法调整发送速率，避免网络拥堵。</li></ul><p>​</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h2><p>欢迎大家关注我的微信公众号「<strong>跟着小康学编程</strong>」！本号致力于分享<strong>C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习、计算机基础原理、Linux 编程、数据库、微服务、容器技术</strong> 等内容。文章力求通俗易懂，并配有代码示例，方便初学者理解。如果您对这些内容感兴趣，欢迎关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p>后续，我还会陆续分享各个方向的编程面试题，包括<strong>C&#x2F;C++、Java、Go，以及操作系统、计算机网络、数据结构、数据库和微服务</strong>等领域，为大家的面试提供帮助。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络面试 </tag>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP 面试题 — TCP与UDP有哪些区别？各自的应用场景？</title>
      <link href="/tcp-udp/"/>
      <url>/tcp-udp/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康。</p><p>今天给大家分享一个 TCP 面试题 ：<strong>TCP与UDP有哪些区别？各自的应用场景？</strong></p><blockquote><p><strong>小技巧</strong>：在面试中，可以参考下面的<strong>示例回答</strong>，这样回答简洁明了。<strong>详细介绍</strong>部分则是为了帮助大家系统学习，以便应对面试官深入提问。</p></blockquote><h3 id="示例回答："><a href="#示例回答：" class="headerlink" title="示例回答："></a>示例回答：</h3><p>TCP 是面向连接的协议，提供可靠的数据传输、顺序控制、 流量控制和拥塞控制，适用于文件传输和网页浏览等场景。UDP 是无连接的协议，提供不可靠的快速传输，适用于实时应用，如视频直播和在线游戏。</p><hr><h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><h4 id="TCP-与-UDP-的主要区别"><a href="#TCP-与-UDP-的主要区别" class="headerlink" title="TCP 与 UDP 的主要区别"></a>TCP 与 UDP 的主要区别</h4><p><strong>1、连接方式</strong><br><strong>TCP</strong>：面向连接，需要在传输数据前通过三次握手建立连接。</p><ul><li><strong>示例</strong>：浏览器与服务器之间的网页传输。</li></ul><p><strong>UDP</strong>：无连接，不需要建立连接，直接发送数据。</p><ul><li><strong>示例</strong>：DNS 查询请求。</li></ul><p><strong>2、可靠性</strong><br><strong>TCP</strong>：提供可靠的数据传输，确保数据包按顺序到达且无丢失，通过确认机制和重传机制实现。</p><ul><li><strong>示例</strong>：文件传输协议（FTP），确保文件完整传输。</li></ul><p><strong>UDP</strong>：不保证数据包的送达顺序和完整性，可能丢失、重复或乱序。</p><ul><li><strong>示例</strong>：视频流传输，允许部分数据丢失以保证实时性。</li></ul><p><strong>3、顺序控制</strong><br><strong>TCP</strong>：保证数据包按发送顺序接收，通过顺序编号和重排序机制实现。</p><ul><li><strong>示例</strong>：电子邮件传输，确保邮件内容按顺序接收。</li></ul><p><strong>UDP</strong>：不保证数据包的接收顺序，应用层需自行处理。</p><ul><li><strong>示例</strong>：实时语音通话，部分数据包乱序不会显著影响通话质量。</li></ul><p><strong>4、流量控制和拥塞控制</strong><br><strong>TCP</strong>：提供流量控制和拥塞控制，通过滑动窗口和拥塞控制算法（如慢启动、拥塞避免）管理数据传输速率。</p><ul><li><strong>示例</strong>：网络浏览，适应不同网络状况，调整数据传输速率。</li></ul><p><strong>UDP</strong>：不提供流量控制和拥塞控制，发送方以固定速率发送数据。</p><ul><li><strong>示例</strong>：在线游戏，确保快速数据传输，不因网络拥塞而减速。</li></ul><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p><strong>TCP 应用场景</strong></p><ul><li><strong>文件传输</strong>：如 FTP，需要确保数据完整和可靠传输。</li><li><strong>网页浏览</strong>：如 HTTP&#x2F;HTTPS，要求数据按顺序到达且无丢失。</li><li><strong>电子邮件</strong>：如 SMTP，确保邮件内容完整传输。</li></ul><p><strong>UDP 应用场景</strong></p><ul><li><strong>视频直播</strong>：如 IPTV，允许部分数据丢失以保证实时性。</li><li><strong>在线游戏</strong>：需要快速数据传输，不因丢包而等待重传。</li><li><strong>实时语音通话</strong>：如 VoIP，允许少量数据丢失，不显著影响通话质量。</li><li><strong>DNS 查询</strong>：快速发送查询请求和接收响应，无需建立连接。</li></ul><h3 id="关键点总结"><a href="#关键点总结" class="headerlink" title="关键点总结"></a>关键点总结</h3><ul><li><strong>TCP</strong>：面向连接、可靠传输、顺序控制、流量和拥塞控制，适用于文件传输、网页浏览、电子邮件等场景。</li><li><strong>UDP</strong>：无连接、不可靠传输、无顺序控制、无流量和拥塞控制，适用于视频直播、在线游戏、实时语音通话、DNS 查询等场景。</li></ul><p>​</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h2><p>欢迎大家关注我的微信公众号「<strong>跟着小康学编程</strong>」！本号致力于分享<strong>C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习、计算机基础原理、Linux 编程、数据库、微服务、容器技术</strong> 等内容。文章力求通俗易懂，并配有代码示例，方便初学者理解。如果您对这些内容感兴趣，欢迎关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p>后续，我还会陆续分享各个方向的编程面试题，包括<strong>C&#x2F;C++、Java、Go，以及操作系统、计算机网络、数据结构、数据库和微服务</strong>等领域，为大家的面试提供帮助。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络面试 </tag>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP 面试题 — HTTP/3了解吗？</title>
      <link href="/https3/"/>
      <url>/https3/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康。</p><p>今天给大家分享一个 HTTP 面试题 ：<strong>HTTP&#x2F;3了解吗？</strong></p><blockquote><p><strong>小技巧</strong>：在面试中，可以参考下面的<strong>示例回答</strong>，这样回答简洁明了。<strong>详细介绍</strong>部分则是为了帮助大家系统学习，以便应对面试官深入提问。</p></blockquote><h3 id="示例回答："><a href="#示例回答：" class="headerlink" title="示例回答："></a><strong>示例回答：</strong></h3><p>HTTP&#x2F;3 是最新版本的 HTTP 协议，基于 QUIC 传输协议。它提供更快的连接建立、更好的多路复用和更高的安全性，显著提升了网络性能和用户体验。</p><hr><h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><h4 id="HTTP-3-的关键特性"><a href="#HTTP-3-的关键特性" class="headerlink" title="HTTP&#x2F;3 的关键特性"></a>HTTP&#x2F;3 的关键特性</h4><ol><li><strong>基于 QUIC 传输协议</strong></li></ol><ul><li><strong>步骤</strong>：HTTP&#x2F;3 使用 QUIC（Quick UDP Internet Connections）作为传输协议，取代了 TCP。QUIC 是基于 UDP 的协议，旨在减少连接建立时间和提高传输性能。</li><li><strong>示例</strong>：QUIC 可以在一次往返（1-RTT）内完成连接建立，而传统的 TCP 需要多次往返（3-RTT）。</li></ul><ol start="2"><li><strong>更快的连接建立</strong></li></ol><ul><li><strong>步骤</strong>：QUIC 协议通过1-RTT 连接建立，显著减少了连接建立时间。</li><li><strong>示例</strong>：用户首次访问网站时，QUIC 只需一次往返即可建立连接，比传统的 TCP 快得多。</li></ul><ol start="3"><li><strong>改进的多路复用</strong></li></ol><ul><li><strong>步骤</strong>：HTTP&#x2F;3 改进了多路复用技术，允许在单个连接中同时传输多个请求和响应，避免了 HTTP&#x2F;2 的队头阻塞问题。</li><li><strong>示例</strong>：多个请求可以在同一连接中独立进行，不会因为一个请求的延迟而影响其他请求。</li></ul><ol start="4"><li><strong>更高的安全性</strong></li></ol><ul><li><strong>步骤</strong>：QUIC 协议内置了加密功能，每个连接都使用 TLS 1.3 加密，确保数据传输的安全性和完整性。</li><li><strong>示例</strong>：所有数据传输都是加密的，防止数据被窃听或篡改。</li></ul><ol start="5"><li><strong>抗丢包和快速重传</strong></li></ol><ul><li><strong>步骤</strong>：QUIC 的设计使其对丢包的恢复速度更快，能够迅速重传丢失的数据包。</li><li><strong>示例</strong>：在网络不稳定的情况下，QUIC 可以迅速恢复连接，减少延迟。</li></ul><h3 id="关键点总结"><a href="#关键点总结" class="headerlink" title="关键点总结"></a>关键点总结</h3><ul><li><strong>基于 QUIC</strong>：HTTP&#x2F;3 使用基于 UDP 的 QUIC 协议。</li><li><strong>更快连接建立</strong>：通过 0-RTT 和 1-RTT 快速建立连接。</li><li><strong>改进的多路复用</strong>：避免 HTTP&#x2F;2 的队头阻塞问题。</li><li><strong>更高的安全性</strong>：内置 TLS 1.3 加密，确保数据传输安全。</li><li><strong>抗丢包和快速重传</strong>：快速恢复丢失的数据包，减少延迟。</li></ul><p>​</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h2><p>欢迎大家关注我的微信公众号「<strong>跟着小康学编程</strong>」！本号致力于分享<strong>C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习、计算机基础原理、Linux 编程、数据库、微服务、容器技术</strong> 等内容。文章力求通俗易懂，并配有代码示例，方便初学者理解。如果您对这些内容感兴趣，欢迎关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p>后续，我还会陆续分享各个方向的编程面试题，包括<strong>C&#x2F;C++、Java、Go，以及操作系统、计算机网络、数据结构、数据库和微服务</strong>等领域，为大家的面试提供帮助。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> 计算机网络面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP 面试题 — HTTPS 的工作过程？</title>
      <link href="/https/"/>
      <url>/https/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康。</p><p>今天给大家分享一个 HTTP 面试题 ：<strong>HTTPS 的工作过程？</strong></p><blockquote><p><strong>小技巧</strong>：在面试中，可以参考下面的<strong>示例回答</strong>，这样回答简洁明了。<strong>详细介绍</strong>部分则是为了帮助大家系统学习，以便应对面试官深入提问。</p></blockquote><h3 id="示例回答："><a href="#示例回答：" class="headerlink" title="示例回答："></a><strong>示例回答：</strong></h3><p>HTTPS 通过 SSL&#x2F;TLS 协议确保数据传输的安全性和完整性。工作过程包括客户端发起请求、服务器发送证书、验证证书、生成对称密钥、加密通信和传输数据。</p><hr><h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><h4 id="HTTPS-工作过程"><a href="#HTTPS-工作过程" class="headerlink" title="HTTPS 工作过程"></a>HTTPS 工作过程</h4><p>先来看个图：</p><p><img src="/images/HTTPS/https.png"></p><p><strong>1.客户端发起请求</strong></p><ul><li><strong>步骤</strong>：客户端（如浏览器）向服务器的 443 端口发起 HTTPS 请求，要求建立安全连接。</li><li><strong>示例</strong>：用户在浏览器中输入 <a href="https://www.example.com/">https://www.example.com</a> 并按下回车。</li></ul><p><strong>2.服务器发送证书</strong></p><ul><li><strong>步骤</strong>：服务器收到请求后，向客户端发送包含公钥的数字证书。这个证书由权威的证书颁发机构（CA）签名，包含服务器的公钥。</li><li><strong>示例</strong>：服务器返回 SSL&#x2F;TLS 证书。</li></ul><p><strong>3.客户端验证证书</strong></p><ul><li><strong>步骤</strong>：客户端收到服务器的证书后，验证证书的有效性，包括证书是否由受信任的 CA 签发、证书是否在有效期内以及证书的域名是否与请求的域名匹配。</li><li><strong>示例</strong>：浏览器验证服务器证书的合法性。</li></ul><p><strong>4.生成对称密钥</strong></p><ul><li><strong>步骤</strong>：如果证书验证通过，客户端生成一个随机的对称密钥，并使用服务器的公钥对该密钥进行加密，然后将加密后的密钥发送给服务器。</li><li><strong>示例</strong>：浏览器生成对称密钥并加密发送给服务器。</li></ul><p><strong>5.服务器解密对称密钥</strong></p><ul><li><strong>步骤</strong>：服务器使用自己的私钥解密客户端发送的对称密钥。此时，客户端和服务器都持有相同的对称密钥。</li><li><strong>示例</strong>：服务器解密收到的对称密钥。</li></ul><p><strong>6.加密通信</strong></p><ul><li><strong>步骤</strong>：客户端和服务器使用这个对称密钥进行加密通信，确保数据在传输过程中不会被窃听或篡改。</li><li><strong>示例</strong>：客户端和服务器使用对称密钥加密和解密传输的数据。</li></ul><p><strong>7.传输数据</strong></p><ul><li><strong>步骤</strong>：加密通信建立后，客户端和服务器可以安全地传输数据。所有传输的数据都经过加密处理，确保数据的机密性和完整性。</li><li><strong>示例</strong>：用户与网站之间的所有数据交换都是加密的。</li></ul><h3 id="关键点总结"><a href="#关键点总结" class="headerlink" title="关键点总结"></a>关键点总结</h3><ul><li><strong>客户端发起请求</strong>：浏览器请求 HTTPS 连接。</li><li><strong>服务器发送证书</strong>：服务器提供包含公钥的证书。</li><li><strong>客户端验证证书</strong>：浏览器验证证书的合法性，包括签发机构、有效期和域名匹配。</li><li><strong>生成对称密钥</strong>：客户端生成对称密钥并用服务器的公钥加密。</li><li><strong>服务器解密对称密钥</strong>：服务器使用私钥解密对称密钥。</li><li><strong>加密通信</strong>：使用对称密钥进行加密通信。</li><li><strong>传输数据</strong>：安全传输数据，确保数据的机密性和完整性。</li></ul><h3 id="细节说明："><a href="#细节说明：" class="headerlink" title="细节说明："></a>细节说明：</h3><h4 id="上面-https-工作过程中-第二步和第五步-服务器的公钥和私钥是从哪里来的？"><a href="#上面-https-工作过程中-第二步和第五步-服务器的公钥和私钥是从哪里来的？" class="headerlink" title="上面 https 工作过程中(第二步和第五步)服务器的公钥和私钥是从哪里来的？"></a>上面 https 工作过程中(第二步和第五步)服务器的公钥和私钥是从哪里来的？</h4><p>服务器的私钥和公钥是在设置 HTTPS 服务时生成的，并保存在服务器上。这个过程包括生成公钥和私钥，创建证书签名请求（CSR），然后从证书颁发机构（CA）获取数字证书，并配置在服务器上。</p><h4 id="具体过程如下：-实际配置过程可能略有不同，但是原理类似-："><a href="#具体过程如下：-实际配置过程可能略有不同，但是原理类似-：" class="headerlink" title="具体过程如下：(实际配置过程可能略有不同，但是原理类似)："></a>具体过程如下：(实际配置过程可能略有不同，但是原理类似)：</h4><ol><li><strong>生成密钥对</strong>：</li></ol><ul><li><p>在配置 HTTPS 服务时，服务器管理员使用加密工具（如 OpenSSL）生成一对公钥和私钥。</p></li><li><p><strong>示例命令</strong>：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genpkey -algorithm RSA -out private.key</span><br></pre></td></tr></table></figure></li><li><p><strong>结果</strong>： 生成一个包含公钥和私钥的私钥文件 private.key。</p></li></ul><ol start="2"><li><strong>创建证书签名请求（CSR）</strong>：</li></ol><ul><li><p>使用生成的私钥创建一个 CSR，其中包含公钥和其他信息（如域名）。</p></li><li><p><strong>示例命令</strong>：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -key private.key -out server.csr</span><br></pre></td></tr></table></figure></li><li><p><strong>结果</strong>：生成一个 CSR 文件（server.csr），包含公钥。</p></li></ul><ol start="3"><li><strong>获取数字证书</strong>：</li></ol><ul><li><p>将 CSR 发送给权威的证书颁发机构（CA），由 CA 签名生成服务器的数字证书。</p></li><li><p><strong>示例命令</strong>：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -req -days 365 -in server.csr -signkey private.key -out server.crt</span><br></pre></td></tr></table></figure></li><li><p><strong>结果</strong>：CA 颁发一个数字证书（server.crt），包含服务器的公钥私钥并由 CA 签名。</p></li></ul><ol start="4"><li><strong>配置服务器</strong>：</li></ol><ul><li>服务器管理员将 CA 签名的数字证书和私钥一起配置在服务器上。</li><li><strong>示例配置（Nginx）</strong>：<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line"><span class="code">    listen 443 ssl;</span></span><br><span class="line"><span class="code">    ssl_certificate /path/to/server.crt;</span></span><br><span class="line"><span class="code">    ssl_certificate_key /path/to/private.key;</span></span><br><span class="line"><span class="code">    ...</span></span><br><span class="line"><span class="code">&#125;</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>想要了解更加详细介绍 HTTPS 工作过程的朋友可以参考这篇文章</strong>： <a href="https://segmentfault.com/a/1190000021494676">https://segmentfault.com/a/1190000021494676</a></p><blockquote><p>上面的图来自该链接 <a href="https://segmentfault.com/a/1190000021494676%EF%BC%8C%E5%A6%82%E6%9C%89%E4%BE%B5%E6%9D%83%EF%BC%8C%E8%AF%B7%E5%8F%8A%E6%97%B6%E8%81%94%E7%B3%BB%E6%88%91%EF%BC%8C%E6%88%91%E5%88%A0%E6%8E%89%EF%BC%81">https://segmentfault.com/a/1190000021494676，如有侵权，请及时联系我，我删掉！</a></p></blockquote><h2 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h2><p>欢迎大家关注我的微信公众号「<strong>跟着小康学编程</strong>」！本号致力于分享<strong>C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习、计算机基础原理、Linux 编程、数据库、微服务、容器技术</strong> 等内容。文章力求通俗易懂，并配有代码示例，方便初学者理解。如果您对这些内容感兴趣，欢迎关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p>后续，我还会陆续分享各个方向的编程面试题，包括<strong>C&#x2F;C++、Java、Go，以及操作系统、计算机网络、数据结构、数据库和微服务</strong>等领域，为大家的面试提供帮助。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> 计算机网络面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP 面试题 — 客户端怎么去校验证书的合法性？</title>
      <link href="/verify-certifacate/"/>
      <url>/verify-certifacate/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康。</p><p>今天给大家分享一个 HTTP 面试题 ：<strong>客户端怎么去校验证书的合法性？</strong></p><blockquote><p><strong>小技巧</strong>：在面试中，可以参考下面的<strong>示例回答</strong>，这样回答简洁明了。<strong>详细介绍</strong>部分则是为了帮助大家系统学习，以便应对面试官深入提问。</p></blockquote><h3 id="示例回答："><a href="#示例回答：" class="headerlink" title="示例回答："></a><strong>示例回答：</strong></h3><p>客户端校验证书的合法性包括检查证书链、验证证书是否在有效期内、匹配域名以及确认证书是否被吊销。这些步骤确保证书由受信任的 CA 签发、在有效期内、域名匹配且未被吊销，从而确保连接的安全性。  </p><h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><h4 id="客户端校验证书的步骤"><a href="#客户端校验证书的步骤" class="headerlink" title="客户端校验证书的步骤"></a>客户端校验证书的步骤</h4><ol><li><strong>检查证书链</strong></li></ol><ul><li><strong>步骤</strong>：客户端通过根证书和中间证书验证服务器证书的签名。验证整个证书链是否由受信任的证书颁发机构（CA）签发。</li><li><strong>示例</strong>：浏览器从操作系统或自己的存储中找到根证书，并逐级验证中间证书，直到服务器证书。</li></ul><ol start="2"><li><strong>验证证书是否在有效期内</strong></li></ol><ul><li><strong>步骤</strong>：检查服务器证书的有效期，确保当前日期在证书的有效期内（证书的“Not Before”和“Not After”字段）。</li><li><strong>示例</strong>：浏览器检查服务器证书的有效期，确保证书没有过期或尚未生效。</li></ul><ol start="3"><li><strong>匹配域名</strong></li></ol><ul><li><strong>步骤</strong>：确保服务器证书中的域名（Common Name 或 Subject Alternative Name）与客户端请求的域名匹配。</li><li><strong>示例</strong>：浏览器检查服务器证书中的域名字段，确保它与用户访问的域名（如 <a href="http://www.example.com)匹配./">www.example.com）匹配。</a></li></ul><ol start="4"><li><strong>确认证书是否被吊销</strong></li></ol><ul><li><strong>步骤</strong>：通过在线证书状态协议（OCSP）或证书吊销列表（CRL）检查证书是否被吊销。</li><li><strong>示例</strong>：浏览器使用 OCSP 或下载 CRL，确保服务器证书没有被吊销。</li></ul><h3 id="关键点总结"><a href="#关键点总结" class="headerlink" title="关键点总结"></a>关键点总结</h3><ul><li><strong>检查证书链</strong>：验证证书链的完整性和可信任性。</li><li><strong>验证证书有效期</strong>：确保证书在有效期内。</li><li><strong>匹配域名</strong>：确保证书中的域名与请求的域名匹配。</li><li><strong>确认证书状态</strong>：使用 OCSP 或 CRL 检查证书是否被吊销。</li></ul><p>​</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h2><p>欢迎大家关注我的微信公众号「<strong>跟着小康学编程</strong>」！本号致力于分享<strong>C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习、计算机基础原理、Linux 编程、数据库、微服务、容器技术</strong> 等内容。文章力求通俗易懂，并配有代码示例，方便初学者理解。如果您对这些内容感兴趣，欢迎关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p>后续，我还会陆续分享各个方向的编程面试题，包括<strong>C&#x2F;C++、Java、Go，以及操作系统、计算机网络、数据结构、数据库和微服务</strong>等领域，为大家的面试提供帮助。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> 计算机网络面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP 面试题 — 说一下HTTP的报文结构？</title>
      <link href="/http-request-message/"/>
      <url>/http-request-message/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康。</p><p>今天给大家分享一个 HTTP 面试题 ：<strong>说一下HTTP的报文结构？</strong></p><blockquote><p><strong>小技巧</strong>：在面试中，可以参考下面的<strong>示例回答</strong>，这样回答简洁明了。<strong>详细介绍</strong>部分则是为了帮助大家系统学习，以便应对面试官深入提问。</p></blockquote><h3 id="示例回答："><a href="#示例回答：" class="headerlink" title="示例回答："></a><strong>示例回答：</strong></h3><p>HTTP 报文包括起始行、头部字段、空行和消息主体。请求报文的起始行是请求行，响应报文的起始行为状态行。头部字段提供元数据，消息主体承载实际数据。</p><hr><h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><p>HTTP报文有两种，分别是HTTP请求报文和HTTP响应报文：</p><h4 id="HTTP-请求报文结构"><a href="#HTTP-请求报文结构" class="headerlink" title="HTTP 请求报文结构"></a>HTTP 请求报文结构</h4><p><strong>1、请求行</strong>：</p><ul><li><strong>方法</strong>：表示请求类型，如 GET、POST、PUT、DELETE 等。</li><li><strong>URL</strong>：请求资源的地址。</li><li><strong>HTTP 版本</strong>：协议版本，如 HTTP&#x2F;1.1。</li></ul><p><strong>示例</strong>：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/index.html</span> <span class="meta">HTTP/1.1</span></span><br></pre></td></tr></table></figure><p><strong>2、请求头部字段</strong>：</p><ul><li><strong>头部字段名称</strong>：头部字段提供请求的元数据，如 Host、User-Agent、Accept 等。</li></ul><p><strong>示例</strong>：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.example.com</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html</span><br></pre></td></tr></table></figure><p><strong>3、空行</strong>：空行用于分隔头部和消息主体。<br><strong>4、消息主体</strong>（可选）：包含实际的数据，如 POST 请求中的表单数据。<br><strong>示例</strong>（带消息主体的 POST 请求）：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#请求行</span><br><span class="line"><span class="keyword">POST</span> <span class="string">/submit-form</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"># 请求头部字段</span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.example.com</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/x-www-form-urlencoded</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>27</span><br><span class="line"># 空行</span><br><span class="line"></span><br><span class="line"><span class="language-ini"><span class="comment"># 消息主体</span></span></span><br><span class="line"><span class="language-ini"><span class="attr">name</span>=JohnDoe&amp;age=<span class="number">25</span>  </span></span><br></pre></td></tr></table></figure><h4 id="HTTP-响应报文结构"><a href="#HTTP-响应报文结构" class="headerlink" title="HTTP 响应报文结构"></a>HTTP 响应报文结构</h4><p><strong>1、状态行</strong>：</p><ul><li><strong>HTTP 版本</strong>：协议版本，如 HTTP&#x2F;1.1。</li><li><strong>状态码</strong>：表示响应结果的数字代码，如 200、404、500 等。</li><li><strong>状态描述</strong>：对状态码的简要描述。</li></ul><p><strong>示例</strong>：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br></pre></td></tr></table></figure><p><strong>2、响应头部字段</strong>：</p><ul><li><strong>头部字段名称</strong>：头部字段提供响应的元数据，如 Content-Type、Content-Length、Set-Cookie 等。</li></ul><p><strong>示例</strong>：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>1234</span><br><span class="line"><span class="attribute">Set-Cookie</span><span class="punctuation">: </span>sessionId=abc123</span><br></pre></td></tr></table></figure><p><strong>3、空行</strong>：空行用于分隔头部和消息主体。<br><strong>4、消息主体</strong>：包含实际的响应数据，如 HTML 文档、图片、JSON 数据等。<br><strong>示例</strong>（带消息主体的响应）：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 状态行</span><br><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"># 响应头部字段</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>1234</span><br><span class="line">#空行</span><br><span class="line"></span><br><span class="line"><span class="language-gherkin"><span class="comment">#消息主体</span></span></span><br><span class="line"><span class="language-gherkin"><span class="variable">&lt;html&gt;</span></span></span><br><span class="line"><span class="language-gherkin"><span class="variable">&lt;body&gt;</span></span></span><br><span class="line"><span class="language-gherkin"><span class="variable">&lt;h1&gt;</span>Hello, World!<span class="variable">&lt;/h1&gt;</span></span></span><br><span class="line"><span class="language-gherkin"><span class="variable">&lt;/body&gt;</span></span></span><br><span class="line"><span class="language-gherkin"><span class="variable">&lt;/html&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h2><p>欢迎大家关注我的微信公众号「<strong>跟着小康学编程</strong>」！本号致力于分享<strong>C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习、计算机基础原理、Linux 编程、数据库、微服务、容器技术</strong> 等内容。文章力求通俗易懂，并配有代码示例，方便初学者理解。如果您对这些内容感兴趣，欢迎关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p>后续，我还会陆续分享各个方向的编程面试题，包括<strong>C&#x2F;C++、Java、Go，以及操作系统、计算机网络、数据结构、数据库和微服务</strong>等领域，为大家的面试提供帮助。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> 计算机网络面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP 面试题 — HTTP 请求的过程与原理？</title>
      <link href="/http-request/"/>
      <url>/http-request/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康。</p><p>今天给大家分享一个 HTTP 面试题 ：<strong>HTTP 请求的过程与原理？</strong></p><blockquote><p><strong>小技巧</strong>：在面试中，可以参考下面的<strong>示例回答</strong>，这样回答简洁明了。<strong>详细介绍</strong>部分则是为了帮助大家系统学习，以便应对面试官深入提问。</p></blockquote><h3 id="示例回答："><a href="#示例回答：" class="headerlink" title="示例回答："></a><strong>示例回答：</strong></h3><p>HTTP 请求过程包括建立连接、发送请求、服务器处理请求、返回响应、断开连接。浏览器通过 URL 生成 HTTP 请求，并与服务器建立 TCP 连接。服务器处理请求后返回响应，浏览器解析并显示内容。</p><hr><h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><h4 id="1-建立连接"><a href="#1-建立连接" class="headerlink" title="1. 建立连接"></a>1. 建立连接</h4><p><strong>步骤</strong>：客户端（通常是浏览器）向服务器发送请求前，首先需要通过 TCP 三次握手建立连接。<br><strong>三次握手过程</strong>：</p><ul><li><strong>SYN</strong>：客户端发送一个 SYN 包（同步序列号）给服务器，表示请求建立连接。</li><li><strong>SYN-ACK</strong>：服务器收到后，回复一个 SYN-ACK 包（同步-确认序列号），表示同意连接。</li><li><strong>ACK</strong>：客户端收到后，发送一个 ACK 包（确认序列号），连接建立。</li></ul><h4 id="2-发送请求"><a href="#2-发送请求" class="headerlink" title="2. 发送请求"></a>2. 发送请求</h4><p><strong>步骤</strong>：建立连接后，客户端向服务器发送 HTTP 请求。<br><strong>HTTP 请求报文结构包含</strong>：</p><ul><li><strong>请求行</strong>：包括请求方法（如 GET、POST）、请求 URL 和 HTTP 版本。</li><li><strong>请求头</strong>：包含请求的相关信息，如 Host、User-Agent、Accept 等。</li><li><strong>请求体</strong>：在 POST 请求中，包含提交的数据。</li></ul><p><strong>HTTP请求示例</strong>：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/index.html</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.example.com</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html</span><br></pre></td></tr></table></figure><h4 id="3-服务器处理请求"><a href="#3-服务器处理请求" class="headerlink" title="3. 服务器处理请求"></a>3. 服务器处理请求</h4><p><strong>步骤</strong>：服务器接收到 HTTP 请求后，解析请求内容，处理请求并生成响应。<br><strong>具体过程</strong>：</p><ul><li><strong>解析请求行和请求头</strong>：确定请求的资源、客户端信息等。</li><li><strong>处理请求</strong>：根据请求的方法（如读取文件、查询数据库）处理请求。</li><li><strong>生成响应</strong>：生成响应头和响应体，准备返回给客户端。</li></ul><h4 id="4-返回响应"><a href="#4-返回响应" class="headerlink" title="4. 返回响应"></a>4. 返回响应</h4><p><strong>步骤</strong>：服务器将处理结果封装成 HTTP 响应，发送回客户端。<br><strong>HTTP 响应报文结构包含</strong>：</p><ul><li><strong>状态行</strong>：包含 HTTP 版本、状态码和状态描述。</li><li><strong>响应头</strong>：包含响应的相关信息，如 Content-Type、Content-Length 等。</li><li><strong>响应体</strong>：包含实际的返回数据，如 HTML 页面、JSON 数据等。</li></ul><p><strong>HTTP响应示例</strong>：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>1234</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, World!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="5-断开连接"><a href="#5-断开连接" class="headerlink" title="5. 断开连接"></a>5. 断开连接</h4><p><strong>步骤</strong>：完成数据传输后，服务器和客户端通过 TCP 四次挥手断开连接。<br><strong>四次挥手过程</strong>：</p><ol><li><strong>FIN</strong>：客户端发送一个 FIN 包（终止序列号），表示完成数据发送。</li><li><strong>ACK</strong>：服务器收到后，回复一个 ACK 包（确认序列号），表示确认收到。</li><li><strong>FIN</strong>：服务器发送一个 FIN 包，表示完成数据发送。</li><li><strong>ACK</strong>：客户端收到后，回复一个 ACK 包，连接断开。</li></ol><h4 id="6-浏览器解析并显示内容"><a href="#6-浏览器解析并显示内容" class="headerlink" title="6. 浏览器解析并显示内容"></a>6. 浏览器解析并显示内容</h4><p><strong>步骤</strong>：客户端接收到响应后，解析 HTML 内容，构建 DOM 树，加载 CSS、JavaScript 等资源，并渲染页面。</p><h3 id="示例流程"><a href="#示例流程" class="headerlink" title="示例流程"></a>示例流程</h3><ol><li><strong>输入 URL</strong>：用户在浏览器地址栏输入 <a href="http://www.example.com/index.html">http://www.example.com/index.html</a> 并按下回车。</li><li><strong>DNS 解析</strong>：浏览器通过 DNS 解析获取 <a href="http://www.example.com/">www.example.com</a> 的 IP 地址。</li><li><strong>建立连接</strong>：浏览器与服务器的 IP 地址建立 TCP 连接。</li><li><strong>发送请求</strong>：浏览器发送 HTTP GET 请求到服务器。</li><li><strong>接收响应</strong>：服务器处理请求并返回 HTTP 响应。</li><li><strong>解析渲染</strong>：浏览器解析 HTML，加载资源，渲染页面。</li><li><strong>显示内容</strong>：页面内容显示在用户屏幕上。</li></ol><p>​</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h2><p>欢迎大家关注我的微信公众号「<strong>跟着小康学编程</strong>」！本号致力于分享<strong>C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习、计算机基础原理、Linux 编程、数据库、微服务、容器技术</strong> 等内容。文章力求通俗易懂，并配有代码示例，方便初学者理解。如果您对这些内容感兴趣，欢迎关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p>后续，我还会陆续分享各个方向的编程面试题，包括<strong>C&#x2F;C++、Java、Go，以及操作系统、计算机网络、数据结构、数据库和微服务</strong>等领域，为大家的面试提供帮助。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> 计算机网络面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP 面试题 — 谈谈你对域名缓存的了解？</title>
      <link href="/DNS-Cache/"/>
      <url>/DNS-Cache/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康。</p><p>今天给大家分享一个 HTTP 面试题 ：<strong>谈谈你对域名缓存的了解？</strong></p><blockquote><p><strong>小技巧</strong>：在面试中，可以参考下面的<strong>示例回答</strong>，这样回答简洁明了。<strong>详细介绍</strong>部分则是为了帮助大家系统学习，以便应对面试官深入提问。</p></blockquote><h3 id="示例回答："><a href="#示例回答：" class="headerlink" title="示例回答："></a><strong>示例回答：</strong></h3><p>域名缓存是为了加快域名解析速度，减少重复查询带来的网络开销。它可以在本地浏览器缓存、本地操作系统缓存和 DNS 服务器缓存中进行保存。每个缓存条目都有一个 TTL（生存时间），在 TTL 过期后需要重新查询。  </p><hr><h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><h4 id="1-域名缓存的定义"><a href="#1-域名缓存的定义" class="headerlink" title="1. 域名缓存的定义"></a>1. 域名缓存的定义</h4><ul><li><strong>域名缓存</strong>：存储域名解析结果（域名到 IP 地址的映射）的临时存储机制，旨在加快后续相同域名的解析速度。</li></ul><h4 id="2-域名缓存的类型"><a href="#2-域名缓存的类型" class="headerlink" title="2. 域名缓存的类型"></a>2. 域名缓存的类型</h4><p><strong>浏览器缓存</strong>：缓存最近访问的域名和 IP 地址，减少重复解析。</p><ul><li><strong>示例</strong>：用户访问 <a href="http://www.example.com/">www.example.com</a> 后，浏览器会缓存该域名的 IP 地址，后续访问时直接使用缓存。</li></ul><p><strong>操作系统缓存</strong>：操作系统层面的缓存，供所有应用程序使用。</p><ul><li><strong>示例</strong>：所有通过操作系统发出的 DNS 查询请求都会首先检查本地缓存。</li></ul><p><strong>DNS 服务器缓存</strong>：本地 DNS 服务器缓存从其他 DNS 服务器获取的解析结果。</p><ul><li><strong>示例</strong>：本地 DNS 服务器会优先检查缓存，避免重复查询根、顶级域名和权威 DNS 服务器。</li></ul><h4 id="3-TTL（生存时间）"><a href="#3-TTL（生存时间）" class="headerlink" title="3. TTL（生存时间）"></a>3. TTL（生存时间）</h4><ul><li><strong>定义</strong>：TTL（Time to Live）是缓存条目的生存时间，表示缓存条目在过期前可被重复使用的时间长度。</li><li><strong>设置</strong>：TTL 通常由域名的权威 DNS 服务器设置，单位为秒。例如，TTL 为 3600 秒（1 小时）表示缓存条目在 1 小时内有效。</li></ul><h4 id="4-域名缓存的优点"><a href="#4-域名缓存的优点" class="headerlink" title="4. 域名缓存的优点"></a>4. 域名缓存的优点</h4><ul><li><strong>提高解析速度</strong>：减少 DNS 查询时间，加快网页加载速度。</li><li><strong>减少网络负荷</strong>：降低对 DNS 服务器的重复查询，减少网络负荷和服务器压力。</li><li><strong>提高用户体验</strong>：更快的域名解析速度，使用户在访问网站时感受到更快的响应时间。</li></ul><h4 id="5-域名缓存的缺点"><a href="#5-域名缓存的缺点" class="headerlink" title="5. 域名缓存的缺点"></a>5. 域名缓存的缺点</h4><ul><li><strong>缓存过期</strong>：TTL 过期后需要重新查询，可能会导致解析延迟。</li><li><strong>数据不一致</strong>：缓存可能会导致域名解析结果在短时间内无法反映最新的 IP 地址变更。</li></ul><p>​</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h2><p>欢迎大家关注我的微信公众号「<strong>跟着小康学编程</strong>」！本号致力于分享<strong>C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习、计算机基础原理、Linux 编程、数据库、微服务、容器技术</strong> 等内容。文章力求通俗易懂，并配有代码示例，方便初学者理解。如果您对这些内容感兴趣，欢迎关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p>后续，我还会陆续分享各个方向的编程面试题，包括<strong>C&#x2F;C++、Java、Go，以及操作系统、计算机网络、数据结构、数据库和微服务</strong>等领域，为大家的面试提供帮助。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> 计算机网络面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP 面试题 — DNS 的解析过程？</title>
      <link href="/dns/"/>
      <url>/dns/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康。</p><p>今天给大家分享一个 HTTP 面试题 ：<strong>DNS 的解析过程？</strong></p><blockquote><p><strong>小技巧</strong>：在面试中，可以参考下面的<strong>示例回答</strong>，这样回答简洁明了。<strong>详细介绍</strong>部分则是为了帮助大家系统学习，以便应对面试官深入提问。</p></blockquote><h3 id="示例回答："><a href="#示例回答：" class="headerlink" title="示例回答："></a><strong>示例回答：</strong></h3><p>DNS 解析是将域名转换为 IP 地址的过程。浏览器先查找本地缓存，然后向 DNS 服务器发送查询请求。若本地 DNS 服务器无法解析，则逐级查询根 DNS 服务器、顶级域名服务器和权威 DNS 服务器，最终返回 IP 地址。</p><hr><h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><h4 id="DNS-解析过程的具体步骤："><a href="#DNS-解析过程的具体步骤：" class="headerlink" title="DNS 解析过程的具体步骤："></a>DNS 解析过程的具体步骤：</h4><ol><li><strong>用户输入域名</strong>：用户在浏览器中输入 <a href="http://www.example.com./">www.example.com。</a></li><li><strong>本地缓存查询</strong>：浏览器检查本地缓存和操作系统缓存中是否有 <a href="http://www.example.com/">www.example.com</a> 的 IP 地址。</li><li><strong>查询本地 DNS 服务器</strong>：如果本地缓存中没有，浏览器向本地 DNS 服务器（ISP 提供）发送查询请求。</li><li><strong>递归查询过程</strong>：</li></ol><ul><li><strong>根 DNS 服务器</strong>：本地 DNS 服务器向根 DNS 服务器查询，根服务器返回 .com 顶级域名服务器的地址。</li><li><strong>顶级域名服务器</strong>：本地 DNS 服务器向 .com 顶级域名服务器查询，顶级域名服务器返回 example.com 权威 DNS 服务器的地址。</li><li><strong>权威 DNS 服务器</strong>：本地 DNS 服务器向 example.com 权威 DNS 服务器查询，权威服务器返回 <a href="http://www.example.com/">www.example.com</a> 的 IP 地址。</li></ul><ol start="5"><li><strong>返回结果并缓存</strong>：本地 DNS 服务器将 IP 地址返回给浏览器，并缓存查询结果以备下次查询使用。</li><li><strong>访问目标服务器</strong>：浏览器使用返回的 IP 地址访问 <a href="http://www.example.com/">www.example.com</a> 的目标服务器，建立连接并请求资源。</li></ol><p>​</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h2><p>欢迎大家关注我的微信公众号「<strong>跟着小康学编程</strong>」！本号致力于分享<strong>C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习、计算机基础原理、Linux 编程、数据库、微服务、容器技术</strong> 等内容。文章力求通俗易懂，并配有代码示例，方便初学者理解。如果您对这些内容感兴趣，欢迎关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p>后续，我还会陆续分享各个方向的编程面试题，包括<strong>C&#x2F;C++、Java、Go，以及操作系统、计算机网络、数据结构、数据库和微服务</strong>等领域，为大家的面试提供帮助。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> 计算机网络面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP 面试题 — 域名是什么？</title>
      <link href="/what-domain/"/>
      <url>/what-domain/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康。</p><p>今天给大家分享一个 HTTP 面试题 ：<strong>域名是什么？</strong></p><blockquote><p><strong>小技巧</strong>：在面试中，可以参考下面的<strong>示例回答</strong>，这样回答简洁明了。<strong>详细介绍</strong>部分则是为了帮助大家系统学习，以便应对面试官深入提问。</p></blockquote><h3 id="示例回答："><a href="#示例回答：" class="headerlink" title="示例回答："></a><strong>示例回答：</strong></h3><p>域名是用于标识和定位计算机资源的易记名称，如 <a href="http://www.example.com.它对应一个或多个/">www.example.com。它对应一个或多个</a> IP 地址，通过 DNS 解析将人类易读的名称转换为计算机可识别的数字地址。</p><hr><h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><h4 id="1-域名的定义"><a href="#1-域名的定义" class="headerlink" title="1. 域名的定义"></a>1. 域名的定义</h4><ul><li><strong>域名</strong>：域名是互联网中用于标识和定位计算机资源的易记名称。它由一串字符组成，通过点号分隔为多个部分，如 <a href="http://www.example.com./">www.example.com。</a></li></ul><h4 id="2-域名的结构"><a href="#2-域名的结构" class="headerlink" title="2. 域名的结构"></a>2. 域名的结构</h4><ul><li><strong>顶级域名（TLD）</strong>：域名的最后一部分，如 .com、.org、.net。TLD 包括通用顶级域名（gTLD）和国家代码顶级域名（ccTLD）。</li><li><strong>二级域名</strong>：位于 TLD 之前的部分，如 example 是 example.com 的二级域名。</li><li><strong>子域名</strong>：位于二级域名之前的部分，如 www 是 <a href="http://www.example.com/">www.example.com</a> 的子域名。</li></ul><h4 id="3-域名的功能"><a href="#3-域名的功能" class="headerlink" title="3. 域名的功能"></a>3. 域名的功能</h4><ul><li><strong>易记性</strong>：域名比 IP 地址更容易记住和使用，便于用户访问网站。</li><li><strong>标识资源</strong>：域名唯一地标识互联网资源，确保用户可以准确访问目标网站。</li><li><strong>DNS 解析</strong>：域名通过域名系统（DNS）解析，将人类易读的名称转换为计算机可识别的 IP 地址。</li></ul><h4 id="4-域名的作用"><a href="#4-域名的作用" class="headerlink" title="4. 域名的作用"></a>4. 域名的作用</h4><ul><li><strong>便于访问</strong>：用户可以通过域名方便地访问网站，而不需要记住复杂的 IP 地址。</li><li><strong>品牌识别</strong>：企业和个人可以使用域名建立和推广品牌，如 google.com 和 amazon.com。</li><li><strong>资源管理</strong>：通过域名，可以方便地管理和组织互联网资源，如创建子域名来区分不同服务或部门。</li></ul><p>​</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h2><p>欢迎大家关注我的微信公众号「<strong>跟着小康学编程</strong>」！本号致力于分享<strong>C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习、计算机基础原理、Linux 编程、数据库、微服务、容器技术</strong> 等内容。文章力求通俗易懂，并配有代码示例，方便初学者理解。如果您对这些内容感兴趣，欢迎关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p>后续，我还会陆续分享各个方向的编程面试题，包括<strong>C&#x2F;C++、Java、Go，以及操作系统、计算机网络、数据结构、数据库和微服务</strong>等领域，为大家的面试提供帮助。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> 计算机网络面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP 面试题 — 在浏览器中输入 URL 地址到显示主页的过程？</title>
      <link href="/visit-url/"/>
      <url>/visit-url/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康。</p><p>今天给大家分享一个 HTTP 面试题 ：<strong>在浏览器中输入 URL 地址到显示主页的过程？</strong></p><blockquote><p><strong>小技巧</strong>：在面试中，可以参考下面的<strong>示例回答</strong>，这样回答简洁明了。<strong>详细介绍</strong>部分则是为了帮助大家系统学习，以便应对面试官深入提问。</p></blockquote><h3 id="示例回答："><a href="#示例回答：" class="headerlink" title="示例回答："></a><strong>示例回答：</strong></h3><p>当在浏览器中输入 URL 并按下回车后，浏览器会进行 DNS 解析获取服务器 IP 地址，然后与服务器建立 TCP 连接，发送 HTTP 请求。服务器处理请求并返回响应，浏览器解析 HTML 并渲染页面，最终显示主页。</p><hr><h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><h4 id="1-DNS-解析"><a href="#1-DNS-解析" class="headerlink" title="1. DNS 解析"></a>1. DNS 解析</h4><ul><li><strong>步骤</strong>：浏览器首先检查本地缓存是否有对应的 IP 地址。如果没有，则向 DNS 服务器发送请求，获取 URL 对应的 IP 地址。</li></ul><h4 id="2-建立-TCP-连接"><a href="#2-建立-TCP-连接" class="headerlink" title="2. 建立 TCP 连接"></a>2. 建立 TCP 连接</h4><ul><li><strong>步骤</strong>：使用获取的 IP 地址，通过三次握手过程与服务器建立 TCP 连接。具体过程如下：<ol><li>客户端发送 SYN 包（同步序列号）到服务器。</li><li>服务器收到后，回复 SYN-ACK 包（同步-确认序列号）。</li><li>客户端收到后，发送 ACK 包（确认序列号），连接建立。</li></ol></li></ul><h4 id="3-发送-HTTP-请求"><a href="#3-发送-HTTP-请求" class="headerlink" title="3. 发送 HTTP 请求"></a>3. 发送 HTTP 请求</h4><ul><li><strong>步骤</strong>：建立连接后，浏览器发送 HTTP 请求到服务器，包括请求方法（如 GET）、URL 和请求头信息。</li></ul><h4 id="4-服务器处理请求并返回响应"><a href="#4-服务器处理请求并返回响应" class="headerlink" title="4. 服务器处理请求并返回响应"></a>4. 服务器处理请求并返回响应</h4><ul><li><strong>步骤</strong>：服务器收到请求后，处理请求，生成响应并返回给浏览器。响应包括状态码（如 200）、响应头信息和 HTML 内容。</li></ul><h4 id="5-浏览器解析并渲染页面"><a href="#5-浏览器解析并渲染页面" class="headerlink" title="5. 浏览器解析并渲染页面"></a>5. 浏览器解析并渲染页面</h4><ul><li><strong>步骤</strong>：浏览器接收到响应后，解析 HTML 内容，构建 DOM 树，解析 CSS 和 JavaScript，构建渲染树。然后，浏览器绘制页面，显示给用户。</li></ul><h4 id="6-处理资源请求"><a href="#6-处理资源请求" class="headerlink" title="6. 处理资源请求"></a>6. 处理资源请求</h4><ul><li><strong>步骤</strong>：如果 HTML 内容中有引用其他资源（如 CSS、JavaScript、图片），浏览器会发送额外的 HTTP 请求获取这些资源，并在获取后继续渲染页面。</li></ul><h3 id="示例流程"><a href="#示例流程" class="headerlink" title="示例流程"></a>示例流程</h3><ol><li><strong>输入 URL</strong>：用户在浏览器地址栏输入 <a href="http://www.example.com/">http://www.example.com</a> 并按下回车。</li><li><strong>DNS 解析</strong>：浏览器查找 <a href="http://www.example.com/">www.example.com</a> 的 IP 地址。</li><li><strong>建立连接</strong>：浏览器与服务器的 IP 地址建立 TCP 连接。</li><li><strong>发送请求</strong>：浏览器发送 HTTP GET 请求到服务器。</li><li><strong>接收响应</strong>：服务器返回 HTML 响应。</li><li><strong>解析渲染</strong>：浏览器解析 HTML，加载资源，渲染页面。</li><li><strong>显示主页</strong>：主页显示在用户屏幕上。</li></ol><p>​</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h2><p>欢迎大家关注我的微信公众号「<strong>跟着小康学编程</strong>」！本号致力于分享<strong>C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习、计算机基础原理、Linux 编程、数据库、微服务、容器技术</strong> 等内容。文章力求通俗易懂，并配有代码示例，方便初学者理解。如果您对这些内容感兴趣，欢迎关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p>后续，我还会陆续分享各个方向的编程面试题，包括<strong>C&#x2F;C++、Java、Go，以及操作系统、计算机网络、数据结构、数据库和微服务</strong>等领域，为大家的面试提供帮助。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> 计算机网络面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP 面试题 — 在交互过程中如果数据传送完了，还不想断开连接怎么办，怎么维持？</title>
      <link href="/keep-alive/"/>
      <url>/keep-alive/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康。</p><p>今天给大家分享一个 HTTP 面试题 ：<strong>在交互过程中如果数据传送完了，还不想断开连接怎么办，怎么维持？</strong></p><blockquote><p><strong>小技巧</strong>：在面试中，可以参考下面的<strong>示例回答</strong>，这样回答简洁明了。<strong>详细介绍</strong>部分则是为了帮助大家系统学习，以便应对面试官深入提问。</p></blockquote><h3 id="示例回答："><a href="#示例回答：" class="headerlink" title="示例回答："></a>示例回答：</h3><p>在 HTTP&#x2F;1.1 中，可以使用 Connection: keep-alive 头部来维持连接，确保数据传送完毕后连接不会立即关闭。服务器和客户端都需要支持和配置保持连接的机制。  </p><h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><p>更加详细的介绍可以参考这篇文章：<a href="https://xiaokang2024.github.io/http-how-to-keep-alive/">https://xiaokang2024.github.io/http-how-to-keep-alive/</a></p><p>​</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h2><p>欢迎大家关注我的微信公众号「<strong>跟着小康学编程</strong>」！本号致力于分享<strong>C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习、计算机基础原理、Linux 编程、数据库、微服务、容器技术</strong> 等内容。文章力求通俗易懂，并配有代码示例，方便初学者理解。如果您对这些内容感兴趣，欢迎关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p>后续，我还会陆续分享各个方向的编程面试题，包括<strong>C&#x2F;C++、Java、Go，以及操作系统、计算机网络、数据结构、数据库和微服务</strong>等领域，为大家的面试提供帮助。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> 计算机网络面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP 面试题 — 谈下你对 HTTP 长连接和短连接的理解？分别应用于哪些场景？</title>
      <link href="/http-long-short-Conn/"/>
      <url>/http-long-short-Conn/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康。</p><p>今天给大家分享一个 HTTP 面试题 ：<strong>谈下你对 HTTP 长连接和短连接的理解？分别应用于哪些场景？</strong></p><blockquote><p><strong>小技巧</strong>：在面试中，可以参考下面的<strong>示例回答</strong>，这样回答简洁明了。<strong>详细介绍</strong>部分则是为了帮助大家系统学习，以便应对面试官深入提问。</p></blockquote><h3 id="示例回答："><a href="#示例回答：" class="headerlink" title="示例回答："></a><strong>示例回答：</strong></h3><p>HTTP 长连接使用 Connection: keep-alive 头部，允许在一个 TCP 连接上处理多个请求和响应，减少连接建立和关闭的开销，适用于需要频繁请求的场景。HTTP 短连接是每个请求都会建立和关闭一个连接，适用于请求频率低或一次性请求的场景。</p><hr><h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><h4 id="1-HTTP-长连接"><a href="#1-HTTP-长连接" class="headerlink" title="1. HTTP 长连接"></a>1. HTTP 长连接</h4><p><strong>定义</strong>：HTTP 长连接（persistent connection）使用 Connection: keep-alive 头部，保持一个 TCP 连接打开，允许在该连接上处理多个请求和响应。<br><strong>实现方式</strong>：</p><ul><li><strong>请求头</strong>：客户端在请求头中添加 Connection: keep-alive，表示希望保持连接。</li><li><strong>响应头</strong>：服务器在响应头中添加 Connection: keep-alive，表示同意保持连接。</li></ul><p><strong>优点</strong>：</p><ul><li><strong>减少开销</strong>：长连接减少了频繁建立和关闭连接的开销，提高了传输效率。</li><li><strong>提高性能</strong>：复用连接可以加快页面加载速度和数据传输效率。</li></ul><p><strong>应用场景</strong>：</p><ul><li><strong>网页加载</strong>：浏览器加载网页时，可以快速加载多个资源（如 HTML、CSS、JS 文件）。</li><li><strong>API 调用</strong>：RESTful API 的多次调用，减少了每次请求的连接开销。</li><li><strong>实时通信</strong>：如在线聊天，保持长连接以确保消息能够及时传递。</li></ul><h4 id="2-HTTP-短连接"><a href="#2-HTTP-短连接" class="headerlink" title="2. HTTP 短连接"></a>2. HTTP 短连接</h4><p><strong>定义</strong>：HTTP 短连接（non-persistent connection）每个请求都会建立一个新的 TCP 连接，请求完成后立即关闭连接。<br><strong>实现方式</strong>：</p><ul><li><strong>默认行为</strong>：在 HTTP&#x2F;1.0 中，默认是短连接，除非指定 Connection: keep-alive。</li><li><strong>连接关闭</strong>：每次请求结束后，连接立即关闭。</li></ul><p><strong>优点</strong>：</p><ul><li><strong>简单实现</strong>：短连接实现简单，不需要管理连接的状态。</li><li><strong>资源释放</strong>：每次请求完成后立即释放资源，适用于一次性请求。</li></ul><p><strong>应用场景</strong>：</p><ul><li><strong>简单请求</strong>：不需要频繁请求的场景，如静态文件的简单下载。</li><li><strong>资源受限</strong>：服务器资源有限，需要尽快释放连接的场景。</li></ul><p>​</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h2><p>欢迎大家关注我的微信公众号「<strong>跟着小康学编程</strong>」！本号致力于分享<strong>C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习、计算机基础原理、Linux 编程、数据库、微服务、容器技术</strong> 等内容。文章力求通俗易懂，并配有代码示例，方便初学者理解。如果您对这些内容感兴趣，欢迎关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p>后续，我还会陆续分享各个方向的编程面试题，包括<strong>C&#x2F;C++、Java、Go，以及操作系统、计算机网络、数据结构、数据库和微服务</strong>等领域，为大家的面试提供帮助。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> 计算机网络面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP 面试题 — HTTP 如何实现长连接？在什么时候会超时？</title>
      <link href="/http-how-to-keep-alive/"/>
      <url>/http-how-to-keep-alive/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康。</p><p>今天给大家分享一个 HTTP 面试题 ：<strong>HTTP 如何实现长连接？在什么时候会超时？</strong></p><blockquote><p><strong>小技巧</strong>：在面试中，可以参考下面的<strong>示例回答</strong>，这样回答简洁明了。<strong>详细介绍</strong>部分则是为了帮助大家系统学习，以便应对面试官深入提问。</p></blockquote><h3 id="示例回答："><a href="#示例回答：" class="headerlink" title="示例回答："></a>示例回答：</h3><p> HTTP 通过 Connection: keep-alive 头部实现长连接，使多个请求和响应复用一个 TCP 连接。长连接会在空闲一定时间后超时，超时时间由服务器配置决定。</p><hr><h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><h4 id="1-HTTP-如何实现长连接"><a href="#1-HTTP-如何实现长连接" class="headerlink" title="1. HTTP 如何实现长连接"></a>1. HTTP 如何实现长连接</h4><p><strong>Connection 头部</strong>：HTTP&#x2F;1.1 通过在请求和响应头部使用 Connection: keep-alive 实现长连接，这表示客户端希望保持连接打开，以便复用同一个 TCP 连接处理多个请求和响应。</p><ul><li><p><strong>请求示例</strong>：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.example.com</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br></pre></td></tr></table></figure></li><li><p><strong>响应示例</strong>：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>123</span><br></pre></td></tr></table></figure></li></ul><p><strong>持久连接</strong>：在长连接模式下，TCP 连接在一个请求&#x2F;响应完成后不会立即关闭，而是保持一段时间以处理后续的请求。这减少了频繁建立和关闭连接的开销，提高了传输效率。</p><h4 id="2-什么时候会超时"><a href="#2-什么时候会超时" class="headerlink" title="2. 什么时候会超时"></a>2. 什么时候会超时</h4><ul><li><strong>服务器配置</strong>：长连接的超时时间通常由服务器配置决定。服务器在配置文件中设置一个最大空闲时间，超过这个时间，服务器会关闭连接。</li><li><strong>客户端配置</strong>：有时客户端也会有一个超时时间设置，如果服务器在此时间内没有响应，客户端会主动关闭连接。</li><li><strong>常见超时时间</strong>：默认超时时间因服务器不同而异，通常在 30 秒到几分钟之间。可以通过修改服务器配置文件（如 Apache 的 KeepAliveTimeout 或 Nginx 的 keepalive_timeout）来调整。</li></ul><h3 id="示例应用"><a href="#示例应用" class="headerlink" title="示例应用"></a>示例应用</h3><ul><li><strong>网页浏览</strong>：在用户浏览网页时，浏览器与服务器保持长连接，可以快速加载多个资源（如 HTML、CSS、JS 文件），提高页面加载速度。</li><li><strong>API 调用</strong>：在调用 RESTful API 时，保持长连接可以减少连接建立的开销，提高数据传输效率。</li></ul><p>​</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h2><p>欢迎大家关注我的微信公众号「<strong>跟着小康学编程</strong>」！本号致力于分享<strong>C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习、计算机基础原理、Linux 编程、数据库、微服务、容器技术</strong> 等内容。文章力求通俗易懂，并配有代码示例，方便初学者理解。如果您对这些内容感兴趣，欢迎关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p>后续，我还会陆续分享各个方向的编程面试题，包括<strong>C&#x2F;C++、Java、Go，以及操作系统、计算机网络、数据结构、数据库和微服务</strong>等领域，为大家的面试提供帮助。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> 计算机网络面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP 面试题 — 为什么要用HTTPS？解决了哪些问题？</title>
      <link href="/https-used-todo/"/>
      <url>/https-used-todo/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康。</p><p>今天给大家分享一个 HTTP 面试题 ：<strong>为什么要用HTTPS？解决了哪些问题？</strong></p><blockquote><p><strong>小技巧</strong>：在面试中，可以参考下面的<strong>示例回答</strong>，这样回答简洁明了。<strong>详细介绍</strong>部分则是为了帮助大家系统学习，以便应对面试官深入提问。</p></blockquote><h3 id="示例回答："><a href="#示例回答：" class="headerlink" title="示例回答："></a>示例回答：</h3><p>HTTPS 确保数据传输的安全性，通过使用 SSL&#x2F;TLS 协议加密数据，防止被窃听和篡改。此外，HTTPS 还验证服务器身份，防止钓鱼网站。它解决了 HTTP 数据明文传输带来的安全问题，提供了数据机密性、完整性和身份验证。</p><hr><h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><h4 id="1-为什么要用-HTTPS"><a href="#1-为什么要用-HTTPS" class="headerlink" title="1. 为什么要用 HTTPS"></a>1. 为什么要用 HTTPS</h4><ul><li><strong>数据加密</strong>：HTTPS 使用 SSL&#x2F;TLS 协议对数据进行加密，确保数据在传输过程中不会被窃听或截取。即使数据被拦截，也无法直接读取内容。</li><li><strong>数据完整性</strong>：通过加密和校验机制，HTTPS 确保数据在传输过程中不会被篡改，接收方能验证数据的完整性。</li><li><strong>身份验证</strong>：HTTPS 使用数字证书验证服务器的身份，确保客户端连接到的是真正的服务器，防止钓鱼网站和中间人攻击。</li><li><strong>信任和排名</strong>：现代浏览器会标记未使用 HTTPS 的网站为“不安全”，影响用户信任度。此外，搜索引擎（如 Google）在排名中也优先考虑使用 HTTPS 的网站。</li></ul><h4 id="2-解决的问题"><a href="#2-解决的问题" class="headerlink" title="2. 解决的问题"></a>2. 解决的问题</h4><ul><li><strong>防窃听</strong>：HTTP 传输的数据是明文的，容易被第三方窃听。HTTPS 通过加密防止数据被非法获取。</li><li><strong>防篡改</strong>：HTTP 数据在传输过程中可能被篡改，HTTPS 通过完整性校验防止数据被修改。</li><li><strong>防钓鱼</strong>：HTTP 不能验证服务器身份，容易被钓鱼网站冒充。HTTPS 使用数字证书验证服务器身份，确保连接的合法性。</li><li><strong>用户信任</strong>：HTTPS 增加了用户对网站的信任度，浏览器对未使用 HTTPS 的网站进行“不安全”警告，HTTPS 提升了用户体验和信任度。</li></ul><h3 id="示例应用"><a href="#示例应用" class="headerlink" title="示例应用"></a>示例应用</h3><ul><li><strong>在线购物</strong>：在电子商务网站中，HTTPS 保护用户的支付信息，如信用卡号和个人信息，确保交易安全。</li><li><strong>在线银行</strong>：银行网站使用 HTTPS 确保客户的账户信息和交易记录不被窃听和篡改。</li><li><strong>登录页面</strong>：社交媒体、电子邮件等网站的登录页面使用 HTTPS 保护用户的用户名和密码，防止被窃取。</li></ul><p>​</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h2><p>欢迎大家关注我的微信公众号「<strong>跟着小康学编程</strong>」！本号致力于分享<strong>C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习、计算机基础原理、Linux 编程、数据库、微服务、容器技术</strong> 等内容。文章力求通俗易懂，并配有代码示例，方便初学者理解。如果您对这些内容感兴趣，欢迎关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p>后续，我还会陆续分享各个方向的编程面试题，包括<strong>C&#x2F;C++、Java、Go，以及操作系统、计算机网络、数据结构、数据库和微服务</strong>等领域，为大家的面试提供帮助。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> 计算机网络面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP 面试题 — HTTPS 的优缺点？</title>
      <link href="/https-goodbad/"/>
      <url>/https-goodbad/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康。</p><p>今天给大家分享一个 HTTP 面试题 ：<strong>HTTPS 的优缺点？</strong></p><blockquote><p><strong>小技巧</strong>：在面试中，可以参考下面的<strong>示例回答</strong>，这样回答简洁明了。<strong>详细介绍</strong>部分则是为了帮助大家系统学习，以便应对面试官深入提问。</p></blockquote><p><strong>示例回答：</strong><br>HTTPS 提供数据加密和服务器身份验证，确保传输的安全性和完整性，提升用户信任。但其实现复杂，性能略低于 HTTP，有额外的加密开销。</p><hr><h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><h4 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h4><ul><li><strong>数据加密</strong>：HTTPS 使用 SSL&#x2F;TLS 协议对数据进行加密，防止数据在传输过程中被窃听。</li><li><strong>身份验证</strong>：通过数字证书验证服务器的身份，确保客户端连接到的是真正的服务器，防止钓鱼和中间人攻击。</li><li><strong>数据完整性</strong>：HTTPS 确保数据在传输过程中不会被篡改，接收方可以验证数据的完整性。</li><li><strong>提升用户信任</strong>：使用 HTTPS 的网站在浏览器中显示为“安全”，增加了用户对网站的信任度。</li><li><strong>搜索引擎优化</strong>：搜索引擎（如 Google）会优先考虑使用 HTTPS 的网站，提高排名。</li></ul><h4 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h4><ul><li><strong>实现复杂</strong>：相比 HTTP，HTTPS 的实现更加复杂，需要配置数字证书和加密算法。</li><li><strong>性能开销</strong>：由于需要进行加密和解密操作，HTTPS 的性能略低于 HTTP，可能增加服务器和客户端的计算负担。</li><li><strong>证书成本</strong>：获取和续订 SSL&#x2F;TLS 证书需要费用，尤其是高信任度的证书。</li></ul><p>​</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h2><p>欢迎大家关注我的微信公众号「<strong>跟着小康学编程</strong>」！本号致力于分享<strong>C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习、计算机基础原理、Linux 编程、数据库、微服务、容器技术</strong> 等内容。文章力求通俗易懂，并配有代码示例，方便初学者理解。如果您对这些内容感兴趣，欢迎关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p>后续，我还会陆续分享各个方向的编程面试题，包括<strong>C&#x2F;C++、Java、Go，以及操作系统、计算机网络、数据结构、数据库和微服务</strong>等领域，为大家的面试提供帮助。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> 计算机网络面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP 面试题 — HTTP 和 HTTPS 的区别？</title>
      <link href="/http-https/"/>
      <url>/http-https/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康。</p><p>今天给大家分享一个 HTTP 面试题 ：<strong>HTTP 和 HTTPS 的区别？</strong></p><blockquote><p><strong>小技巧</strong>：在面试中，可以参考下面的<strong>示例回答</strong>，这样回答简洁明了。<strong>详细介绍</strong>部分则是为了帮助大家系统学习，以便应对面试官深入提问。</p></blockquote><h3 id="示例回答："><a href="#示例回答：" class="headerlink" title="示例回答："></a>示例回答：</h3><p>HTTP 是不加密的协议，数据在传输过程中是明文的，容易被窃听和篡改，默认使用端口 80。适用于如普通信息浏览等对安全性要求不高的场景。HTTPS 是加密的 HTTP，使用 SSL&#x2F;TLS 协议对数据进行加密，确保数据的安全性和完整性，默认使用端口 443。适用于如在线支付、敏感信息传输等对安全性要求高的场景。</p><hr><h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><h4 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h4><p><strong>定义</strong>：HTTP（Hypertext Transfer Protocol）是超文本传输协议，用于在 Web 浏览器和服务器之间传输数据。<br><strong>特点</strong>：</p><ul><li><strong>明文传输</strong>：数据在传输过程中不进行加密，容易被第三方窃听和篡改。</li><li><strong>端口</strong>：默认使用端口 80。</li><li><strong>安全性低</strong>：由于数据是明文传输，敏感信息（如用户名、密码）容易被截获。</li></ul><p><strong>优缺点</strong>：</p><ul><li><strong>优点</strong>：实现简单，效率较高，适用于对安全性要求不高的场景。</li><li><strong>缺点</strong>：缺乏安全性，数据易被窃听和篡改。</li></ul><h4 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h4><p><strong>定义</strong>：HTTPS（Hypertext Transfer Protocol Secure）是安全的超文本传输协议，通过 SSL&#x2F;TLS 协议对数据进行加密，确保数据的安全性和完整性。<br><strong>特点</strong>：</p><ul><li><strong>加密传输</strong>：使用 SSL&#x2F;TLS 协议对数据进行加密，保护数据的机密性。</li><li><strong>身份验证</strong>：通过数字证书验证服务器的身份，防止钓鱼网站。</li><li><strong>数据完整性</strong>：确保数据在传输过程中不被篡改。</li><li><strong>端口</strong>：默认使用端口 443。</li></ul><p><strong>优缺点</strong>：</p><ul><li><strong>优点</strong>：提供了数据的加密传输、身份验证和数据完整性，适用于对安全性要求高的场景。</li><li><strong>缺点</strong>：实现复杂，性能略低于 HTTP，有额外的加密开销。</li></ul><h4 id="主要区别"><a href="#主要区别" class="headerlink" title="主要区别"></a>主要区别</h4><p><strong>安全性</strong>：</p><ul><li><strong>HTTP</strong>：数据明文传输，无加密，安全性低。</li><li><strong>HTTPS</strong>：数据加密传输，使用 SSL&#x2F;TLS 协议，安全性高。</li></ul><p><strong>端口</strong>：</p><ul><li><strong>HTTP</strong>：默认使用端口 80。</li><li><strong>HTTPS</strong>：默认使用端口 443。</li></ul><p><strong>性能</strong>：</p><ul><li><strong>HTTP</strong>：没有加密开销，性能较高。</li><li><strong>HTTPS</strong>：有加密和解密的开销，性能略低于 HTTP，但现代硬件和优化技术已使性能差异减少。</li></ul><p><strong>应用场景</strong>：</p><ul><li><strong>HTTP</strong>：适用于对安全性要求不高的场景，如普通信息浏览。</li><li><strong>HTTPS</strong>：适用于对安全性要求高的场景，如登录页面、在线支付、敏感信息传输等。</li></ul><p>​</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h2><p>欢迎大家关注我的微信公众号「<strong>跟着小康学编程</strong>」！本号致力于分享<strong>C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习、计算机基础原理、Linux 编程、数据库、微服务、容器技术</strong> 等内容。文章力求通俗易懂，并配有代码示例，方便初学者理解。如果您对这些内容感兴趣，欢迎关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p>后续，我还会陆续分享各个方向的编程面试题，包括<strong>C&#x2F;C++、Java、Go，以及操作系统、计算机网络、数据结构、数据库和微服务</strong>等领域，为大家的面试提供帮助。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> 计算机网络面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP 面试题 — HTTP1.0，1.1，2.0 的版本区别？</title>
      <link href="/http-Version/"/>
      <url>/http-Version/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康。</p><p>今天给大家分享一个 HTTP 面试题 ：<strong>HTTP1.0，1.1，2.0 的版本区别？</strong></p><blockquote><p><strong>小技巧</strong>：在面试中，可以参考下面的<strong>示例回答</strong>，这样回答简洁明了。<strong>详细介绍</strong>部分则是为了帮助大家系统学习，以便应对面试官深入提问。</p></blockquote><h3 id="示例回答："><a href="#示例回答：" class="headerlink" title="示例回答："></a>示例回答：</h3><p>HTTP&#x2F;1.0 每个请求都要建立一个新的连接，效率较低。HTTP&#x2F;1.1 支持持久连接（keep-alive）和管道化，显著提高了传输效率。HTTP&#x2F;2.0 引入二进制分帧和多路复用，允许多个请求在同一连接上同时进行，提高了性能。  </p><h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><h4 id="1-HTTP-1-0"><a href="#1-HTTP-1-0" class="headerlink" title="1. HTTP&#x2F;1.0"></a>1. HTTP&#x2F;1.0</h4><p><strong>定义</strong>：HTTP&#x2F;1.0 是 HTTP 协议的第一个广泛使用的版本。<br><strong>特点</strong>：</p><ul><li><strong>每个请求都建立一个连接</strong>：每次请求-响应都会建立和关闭一个 TCP 连接，效率较低。</li><li><strong>缺乏持久连接</strong>：没有机制保持连接的持续存在。</li><li><strong>缓存控制</strong>： HTTP&#x2F;1.0 使用 Expires 头部字段进行简单的缓存控制，通过指定资源的过期时间来决定缓存的有效期。这种机制较为基础，灵活性有限。  </li><li><strong>简单协议</strong>：只支持基本的 GET、POST 和 HEAD 请求。</li></ul><p><strong>优缺点</strong>：</p><ul><li><strong>优点</strong>： 实现简单，适合早期的网络环境。  </li><li><strong>缺点</strong>：效率低下，每个请求都要建立连接，增加了延迟和开销。</li></ul><h4 id="2-HTTP-1-1"><a href="#2-HTTP-1-1" class="headerlink" title="2. HTTP&#x2F;1.1"></a>2. HTTP&#x2F;1.1</h4><p><strong>定义</strong>：HTTP&#x2F;1.1 是对 HTTP&#x2F;1.0 的改进版本，广泛使用于现代 Web。<br><strong>特点</strong>：</p><ul><li><strong>持久连接</strong>：默认开启持久连接（Connection: keep-alive）， 多个请求可以复用同一个连接，减少了连接建立和关闭的开销。  </li><li><strong>管道化</strong>：允许在一个 TCP 连接中发送多个请求而无需等待响应，但浏览器支持有限。</li><li><strong>更多缓存控制</strong>：HTTP&#x2F;1.1 引入了 Cache-Control 头部字段，提供更灵活的缓存策略，如 max-age 和 no-cache，可以更精细地控制缓存行为。这增强了对资源缓存的管理和优化。</li><li><strong>分块传输编码</strong>：支持在响应体中分块传输数据，提高了传输效率。</li><li><strong>更多的 HTTP 方法</strong>：如 PUT、DELETE 等。</li></ul><p><strong>优缺点</strong>：</p><ul><li><strong>优点</strong>：持久连接和管道化提高了效率，缓存控制更灵活。</li><li><strong>缺点</strong>：管道化支持有限，仍然有队头阻塞问题。</li></ul><h4 id="3-HTTP-2-0"><a href="#3-HTTP-2-0" class="headerlink" title="3. HTTP&#x2F;2.0"></a>3. HTTP&#x2F;2.0</h4><p><strong>定义</strong>：HTTP&#x2F;2.0 是对 HTTP&#x2F;1.1 的重大升级，旨在提高 Web 传输性能。<br><strong>特点</strong>：</p><ul><li><p><strong>二进制分帧</strong>：将数据分为更小的帧并通过二进制格式传输，提高了传输效率。</p></li><li><p><strong>多路复用</strong>：在一个 TCP 连接中并行处理多个请求和响应，消除了队头阻塞。</p></li><li><p><strong>头部压缩</strong>：使用 HPACK 算法对头部进行压缩，减少了传输的数据量。</p></li><li><p><strong>服务器推送</strong>：服务器可以主动向客户端推送资源，无需客户端请求。</p></li><li><p><strong>缓存控制</strong> HTTP&#x2F;2.0 继承了 HTTP&#x2F;1.1 的缓存控制机制，但通过头部压缩和多路复用等技术，进一步提升了传输效率和性能，尽管缓存控制本身没有新的变化。<br><strong>优缺点</strong>：</p></li><li><p><strong>优点</strong>：大幅提高了传输效率，减少了延迟，改善了用户体验。</p></li><li><p><strong>缺点</strong>：需要客户端和服务器的支持，部署复杂度略高。</p></li></ul><h3 id="比较总结"><a href="#比较总结" class="headerlink" title="比较总结"></a>比较总结</h3><h4 id="连接管理："><a href="#连接管理：" class="headerlink" title="连接管理："></a>连接管理：</h4><ul><li><strong>HTTP&#x2F;1.0</strong>：每个请求独立连接。</li><li><strong>HTTP&#x2F;1.1</strong>：支持持久连接和管道化。</li><li><strong>HTTP&#x2F;2.0</strong>：多路复用，单连接处理多个请求。</li></ul><h4 id="传输效率："><a href="#传输效率：" class="headerlink" title="传输效率："></a>传输效率：</h4><ul><li><strong>HTTP&#x2F;1.0</strong>：效率最低。</li><li><strong>HTTP&#x2F;1.1</strong>：通过持久连接和管道化提高效率。</li><li><strong>HTTP&#x2F;2.0</strong>：二进制分帧、多路复用和头部压缩，大幅提高效率。</li></ul><h4 id="缓存控制："><a href="#缓存控制：" class="headerlink" title="缓存控制："></a>缓存控制：</h4><ul><li><strong>HTTP&#x2F;1.0</strong>：简单的缓存控制。</li><li><strong>HTTP&#x2F;1.1</strong>：更灵活的缓存策略。</li><li><strong>HTTP&#x2F;2.0</strong>：继承了 HTTP&#x2F;1.1 的缓存机制，并通过改进传输机制提升性能。</li></ul><p>​</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h2><p>欢迎大家关注我的微信公众号「<strong>跟着小康学编程</strong>」！本号致力于分享<strong>C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习、计算机基础原理、Linux 编程、数据库、微服务、容器技术</strong> 等内容。文章力求通俗易懂，并配有代码示例，方便初学者理解。如果您对这些内容感兴趣，欢迎关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p>后续，我还会陆续分享各个方向的编程面试题，包括<strong>C&#x2F;C++、Java、Go，以及操作系统、计算机网络、数据结构、数据库和微服务</strong>等领域，为大家的面试提供帮助。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> 计算机网络面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP 面试题 — 说说 WebSocket 与 Socket 的区别？?</title>
      <link href="/websocket-socket/"/>
      <url>/websocket-socket/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康。</p><p>今天给大家分享一个 HTTP 面试题 ：<strong>说说 WebSocket 与 Socket 的区别？</strong></p><blockquote><p><strong>小技巧</strong>：在面试中，可以参考下面的<strong>示例回答</strong>，这样回答简洁明了。<strong>详细介绍</strong>部分则是为了帮助大家系统学习，以便应对面试官深入提问。</p></blockquote><h3 id="示例回答："><a href="#示例回答：" class="headerlink" title="示例回答："></a>示例回答：</h3><p>Socket 是网络编程的标准接口，包括 IP 地址、端口和协议。WebSocket 是应用层协议，支持持久化连接，允许在单个 TCP 连接上进行全双工通信。Socket 更底层，用于各种网络通信，WebSocket 专注于浏览器和服务器之间的实时双向通信。</p><hr><h3 id="详细介绍"><a href="#详细介绍" class="headerlink" title="详细介绍"></a>详细介绍</h3><h4 id="1-Socket"><a href="#1-Socket" class="headerlink" title="1. Socket"></a>1. Socket</h4><p><strong>定义</strong>：Socket 是网络编程的标准接口，包括 IP 地址、端口和协议。<br><strong>作用</strong>：提供一个抽象层，方便开发者进行网络编程，屏蔽了底层网络通信的细节。<br><strong>组成</strong>：IP 地址 + 端口 + 协议。<br><strong>用途</strong>：广泛用于各种网络通信，如 HTTP、FTP、SMTP 等。<br><strong>工作原理</strong>：</p><ul><li><strong>创建套接字</strong>：通过操作系统的 API 创建一个 Socket。</li><li><strong>连接和通信</strong>：通过指定的 IP 地址和端口进行连接和数据传输。</li></ul><h4 id="2-WebSocket"><a href="#2-WebSocket" class="headerlink" title="2. WebSocket"></a>2. WebSocket</h4><p><strong>定义</strong>：WebSocket 是一个持久化的应用层协议，伴随 HTML5 引入，允许在单个 TCP 连接上进行全双工通信。<br><strong>作用</strong>：允许浏览器和服务器进行实时双向通信。<br><strong>工作原理</strong>：</p><ul><li><strong>连接建立</strong>：通过 HTTP&#x2F;HTTPS 协议的升级请求建立连接。</li><li><strong>持续连接</strong>：一旦连接建立，客户端和服务器可以互相发送消息，直到连接关闭。</li></ul><p><strong>优点</strong>：</p><ul><li><strong>实时性</strong>：支持低延迟的双向通信。</li><li><strong>节省带宽</strong>：避免了每次通信都重新建立连接和传输 HTTP 头部信息。</li></ul><p><strong>用途</strong>：用于需要实时数据更新的应用，如在线聊天、实时通知、在线游戏等。</p><h4 id="3-主要区别"><a href="#3-主要区别" class="headerlink" title="3. 主要区别"></a>3. 主要区别</h4><p><strong>层次</strong>：</p><ul><li><strong>Socket</strong>：底层网络通信接口，支持多种协议（如 TCP、UDP）。</li><li><strong>WebSocket</strong>：应用层协议，建立在 TCP 连接之上，通过 HTTP&#x2F;HTTPS 协议升级。</li></ul><p><strong>用途</strong>：</p><ul><li><strong>Socket</strong>：广泛用于各种网络通信，适用于所有网络应用。包括文件传输、消息传递、任何形式的点对点或客户端到服务器的通信。</li><li><strong>WebSocket</strong>：专用于浏览器和服务器之间的实时双向通信。主要用于Web应用中，如在线聊天、实时通知更新等，以提供快速、连续的数据交换。</li></ul><p><strong>实现方式</strong>：</p><ul><li><strong>Socket</strong>：通过操作系统提供的 API 创建和管理连接。</li><li><strong>WebSocket</strong>：通过 HTTP 协议进行连接升级，然后在单个 TCP 连接上进行持续通信。</li></ul><p>​</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h2><p>欢迎大家关注我的微信公众号「<strong>跟着小康学编程</strong>」！本号致力于分享<strong>C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习、计算机基础原理、Linux 编程、数据库、微服务、容器技术</strong> 等内容。文章力求通俗易懂，并配有代码示例，方便初学者理解。如果您对这些内容感兴趣，欢迎关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p>后续，我还会陆续分享各个方向的编程面试题，包括<strong>C&#x2F;C++、Java、Go，以及操作系统、计算机网络、数据结构、数据库和微服务</strong>等领域，为大家的面试提供帮助。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> 计算机网络面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP 面试题 — 说一下你了解的端口及对应的服务？</title>
      <link href="/port-service/"/>
      <url>/port-service/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康。</p><p>今天给大家分享一个 HTTP 面试题 ：<strong>说一下你了解的端口及对应的服务？</strong></p><blockquote><p><strong>小技巧</strong>：在面试中，可以参考下面的<strong>示例回答</strong>，这样回答简洁明了。<strong>详细介绍</strong>部分则是为了帮助大家系统学习，以便应对面试官深入提问。</p></blockquote><h3 id="示例回答："><a href="#示例回答：" class="headerlink" title="示例回答："></a>示例回答：</h3><p>常见的端口及其对应的服务包括：</p><ul><li>80：HTTP，用于网页访问。</li><li>443：HTTPS，用于加密网页访问。</li><li>22：SSH，用于安全远程登录。</li><li>21：FTP，用于文件传输。</li><li>25：SMTP，用于邮件发送。</li><li>110：POP3，用于邮件接收。</li><li>143：IMAP，用于邮件接收和管理。</li></ul><hr><h3 id="详细介绍："><a href="#详细介绍：" class="headerlink" title="详细介绍："></a>详细介绍：</h3><h4 id="1-HTTP-端口-80"><a href="#1-HTTP-端口-80" class="headerlink" title="1. HTTP (端口 80)"></a>1. HTTP (端口 80)</h4><ul><li><strong>用途</strong>：用于网页访问，未加密的 HTTP 流量。</li><li><strong>典型应用</strong>：用户访问网站时，浏览器通过端口 80 与服务器进行通信。</li><li><strong>示例</strong>：用户在浏览器中输入 <a href="http://example.com/">http://example.com</a> 访问网站。</li></ul><h4 id="2-HTTPS-端口-443"><a href="#2-HTTPS-端口-443" class="headerlink" title="2. HTTPS (端口 443)"></a>2. HTTPS (端口 443)</h4><ul><li><strong>用途</strong>：用于加密网页访问，确保数据在传输过程中安全。</li><li><strong>典型应用</strong>：用户访问安全网站时，浏览器通过端口 443 与服务器进行加密通信。</li><li><strong>示例</strong>：用户在浏览器中输入 <a href="https://example.com/">https://example.com</a> 访问安全网站。</li></ul><h4 id="3-SSH-端口-22"><a href="#3-SSH-端口-22" class="headerlink" title="3. SSH (端口 22)"></a>3. SSH (端口 22)</h4><ul><li><strong>用途</strong>：用于安全远程登录和执行命令。</li><li><strong>典型应用</strong>：系统管理员通过 SSH 连接到远程服务器进行管理和维护。</li><li><strong>示例</strong>：使用 SSH 客户端输入 ssh user@hostname 连接到服务器。</li></ul><h4 id="4-FTP-端口-21"><a href="#4-FTP-端口-21" class="headerlink" title="4. FTP (端口 21)"></a>4. FTP (端口 21)</h4><ul><li><strong>用途</strong>：用于文件传输，未加密的 FTP 流量。</li><li><strong>典型应用</strong>：用户上传或下载文件到 FTP 服务器。</li><li><strong>示例</strong>：使用 FTP 客户端连接到 <a href="ftp://example.com/">ftp://example.com</a> 进行文件传输。</li></ul><h4 id="5-SMTP-端口-25"><a href="#5-SMTP-端口-25" class="headerlink" title="5. SMTP (端口 25)"></a>5. SMTP (端口 25)</h4><ul><li><strong>用途</strong>：用于邮件发送。</li><li><strong>典型应用</strong>：邮件服务器通过 SMTP 协议发送电子邮件。</li><li><strong>示例</strong>：邮件客户端发送邮件时，连接到 SMTP 服务器的端口 25。</li></ul><h4 id="6-POP3-端口-110"><a href="#6-POP3-端口-110" class="headerlink" title="6. POP3 (端口 110)"></a>6. POP3 (端口 110)</h4><ul><li><strong>用途</strong>：用于邮件接收，未加密的 POP3 流量。</li><li><strong>典型应用</strong>：用户通过 POP3 协议从邮件服务器接收电子邮件。</li><li><strong>示例</strong>：邮件客户端连接到 POP3 服务器的端口 110 接收邮件。</li></ul><h4 id="7-IMAP-端口-143"><a href="#7-IMAP-端口-143" class="headerlink" title="7. IMAP (端口 143)"></a>7. IMAP (端口 143)</h4><ul><li><strong>用途</strong>：用于邮件接收和管理。</li><li><strong>典型应用</strong>：用户通过 IMAP 协议在多个设备上管理和同步电子邮件。</li><li><strong>示例</strong>：邮件客户端连接到 IMAP 服务器的端口 143 管理邮件。</li></ul><h3 id="额外端口和服务（如果求职者掌握更多，可以进一步展示）"><a href="#额外端口和服务（如果求职者掌握更多，可以进一步展示）" class="headerlink" title="额外端口和服务（如果求职者掌握更多，可以进一步展示）"></a>额外端口和服务（如果求职者掌握更多，可以进一步展示）</h3><h4 id="8-DNS-端口-53"><a href="#8-DNS-端口-53" class="headerlink" title="8. DNS (端口 53)"></a>8. DNS (端口 53)</h4><ul><li><strong>用途</strong>：用于域名解析，将域名转换为 IP 地址。</li><li><strong>典型应用</strong>：DNS 服务器通过端口 53 接收查询请求并返回相应的 IP 地址。</li><li><strong>示例</strong>：浏览器在访问 example.com 时，通过 DNS 查询获取 IP 地址。</li></ul><h4 id="9-MySQL-端口-3306"><a href="#9-MySQL-端口-3306" class="headerlink" title="9. MySQL (端口 3306)"></a>9. MySQL (端口 3306)</h4><ul><li><strong>用途</strong>：用于 MySQL 数据库服务。</li><li><strong>典型应用</strong>：应用程序连接到 MySQL 数据库服务器进行数据查询和操作。</li><li><strong>示例</strong>：使用数据库客户端连接到 mysql:&#x2F;&#x2F;hostname:3306 进行数据库操作。</li></ul><p>​</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h2><p>欢迎大家关注我的微信公众号「<strong>跟着小康学编程</strong>」！本号致力于分享<strong>C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习、计算机基础原理、Linux 编程、数据库、微服务、容器技术</strong> 等内容。文章力求通俗易懂，并配有代码示例，方便初学者理解。如果您对这些内容感兴趣，欢迎关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p>后续，我还会陆续分享各个方向的编程面试题，包括<strong>C&#x2F;C++、Java、Go，以及操作系统、计算机网络、数据结构、数据库和微服务</strong>等领域，为大家的面试提供帮助。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> 计算机网络面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP 面试题 — 说说Session 和 Cookie 有什么联系和区别?</title>
      <link href="/session-cookie/"/>
      <url>/session-cookie/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康。</p><p>今天给大家分享一个 HTTP 面试题 ：<strong>说说Session 和 Cookie 有什么联系和区别?</strong></p><blockquote><p><strong>小技巧</strong>：在面试中，可以参考下面的<strong>示例回答</strong>，这样回答简洁明了。<strong>详细介绍</strong>部分则是为了帮助大家系统学习，以便应对面试官深入提问。</p></blockquote><h3 id="示例回答："><a href="#示例回答：" class="headerlink" title="示例回答："></a>示例回答：</h3><p>Cookie 存储在客户端，用于保存用户信息。Session 存储在服务器端，用于保存用户会话信息。Cookie 可以用来保存 Session ID，Session 依赖 Cookie 实现用户识别。</p><hr><h3 id="详细介绍"><a href="#详细介绍" class="headerlink" title="详细介绍"></a>详细介绍</h3><h4 id="1-Cookie"><a href="#1-Cookie" class="headerlink" title="1. Cookie"></a>1. Cookie</h4><ul><li><strong>定义</strong>：Cookie 是由服务器发送并存储在客户端（浏览器）上的小数据文件。</li><li><strong>作用</strong>：用于在客户端存储少量数据，通常用于记住用户登录状态、偏好设置等。</li><li><strong>存储位置</strong>：存储在客户端（浏览器）。</li><li><strong>生命周期</strong>：可以设置过期时间，短期或长期存储。</li><li><strong>安全性</strong>：易被盗用或篡改，需通过 HTTPS 传输确保安全。</li><li><strong>示例</strong>：购物车信息、用户登录状态。</li></ul><h4 id="2-Session"><a href="#2-Session" class="headerlink" title="2. Session"></a>2. Session</h4><ul><li><strong>定义</strong>：Session 是服务器端存储的用户会话信息。</li><li><strong>作用</strong>：用于在服务器端保存用户的状态和数据，通常用于跟踪用户会话。</li><li><strong>存储位置</strong>：存储在服务器端，通常通过 Session ID 进行识别。</li><li><strong>生命周期</strong>：一般会话结束或超时后失效。</li><li><strong>安全性</strong>：相对较高，因为数据存储在服务器端。</li><li><strong>示例</strong>：用户登录后的会话信息、购物车数据（更安全）。</li></ul><h4 id="3-联系"><a href="#3-联系" class="headerlink" title="3. 联系"></a>3. 联系</h4><ul><li><strong>Session 依赖 Cookie</strong>：Session ID 通常通过 Cookie 存储在客户端，并在每次请求时发送给服务器，以便服务器识别用户会话。</li><li><strong>信息传递</strong>：服务器通过 Set-Cookie 响应头将 Session ID 发送到客户端，客户端在后续请求中通过 Cookie 发送 Session ID。</li></ul><h4 id="4-区别"><a href="#4-区别" class="headerlink" title="4. 区别"></a>4. 区别</h4><p><strong>存储位置</strong>：</p><ul><li><strong>Cookie</strong>：存储在客户端（浏览器）。</li><li><strong>Session</strong>：存储在服务器端。</li></ul><p><strong>安全性</strong>：</p><ul><li><strong>Cookie</strong>：易被盗用或篡改，需通过 HTTPS 传输。</li><li><strong>Session</strong>：相对较高，数据存储在服务器端。</li></ul><p><strong>生命周期</strong>：</p><ul><li><strong>Cookie</strong>：可设置过期时间，长期或短期存储。</li><li><strong>Session</strong>：一般会话结束或超时后失效。</li></ul><p><strong>用途</strong>：</p><ul><li><strong>Cookie</strong>：适用于存储不敏感的用户偏好设置、登录状态等。</li><li><strong>Session</strong>：适用于存储敏感的会话信息和状态数据。</li></ul><h3 id="示例应用"><a href="#示例应用" class="headerlink" title="示例应用"></a>示例应用</h3><h4 id="Cookie-示例"><a href="#Cookie-示例" class="headerlink" title="Cookie 示例"></a>Cookie 示例</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Set-Cookie</span><span class="punctuation">: </span>sessionId=abc123; Path=/; HttpOnly</span><br></pre></td></tr></table></figure><ul><li><strong>作用</strong>：服务器通过 Set-Cookie 响应头将 Session ID 发送到客户端，客户端在后续请求中通过 Cookie 发送 Session ID。</li></ul><h4 id="Session-示例"><a href="#Session-示例" class="headerlink" title="Session 示例"></a>Session 示例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在服务器端（例如使用 python 的 Flask 框架）</span></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, session</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">app.secret_key = <span class="string">&#x27;supersecretkey&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/login&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">login</span>():</span><br><span class="line">    session[<span class="string">&#x27;user_id&#x27;</span>] = <span class="number">42</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;User logged in&#x27;</span></span><br></pre></td></tr></table></figure><ul><li><strong>作用</strong>：服务器端保存用户的会话信息，例如用户 ID。</li></ul><p>​</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h2><p>欢迎大家关注我的微信公众号「<strong>跟着小康学编程</strong>」！本号致力于分享<strong>C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习、计算机基础原理、Linux 编程、数据库、微服务、容器技术</strong> 等内容。文章力求通俗易懂，并配有代码示例，方便初学者理解。如果您对这些内容感兴趣，欢迎关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p>后续，我还会陆续分享各个方向的编程面试题，包括<strong>C&#x2F;C++、Java、Go，以及操作系统、计算机网络、数据结构、数据库和微服务</strong>等领域，为大家的面试提供帮助。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> 计算机网络面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP 面试题 — GET请求中URL编码的意义？</title>
      <link href="/url-encode/"/>
      <url>/url-encode/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康。</p><p>今天给大家分享一个 HTTP 面试题 ：<strong>GET请求中URL编码的意义？</strong></p><blockquote><p><strong>小技巧</strong>：在面试中，可以参考下面的<strong>示例回答</strong>，这样回答简洁明了。<strong>详细介绍</strong>部分则是为了帮助大家系统学习，以便应对面试官深入提问。</p></blockquote><h3 id="示例回答："><a href="#示例回答：" class="headerlink" title="示例回答："></a>示例回答：</h3><p>URL 编码是为了确保 URL 中的特殊字符能够正确传输，避免引起歧义。它将特殊字符转换为百分号加两位十六进制数字的形式。</p><hr><h3 id="详细介绍："><a href="#详细介绍：" class="headerlink" title="详细介绍："></a>详细介绍：</h3><h4 id="1-什么是-URL-编码"><a href="#1-什么是-URL-编码" class="headerlink" title="1. 什么是 URL 编码"></a>1. 什么是 URL 编码</h4><ul><li><strong>定义</strong>：URL 编码（也称为百分号编码）是将 URL 中的特殊字符转换为百分号（%）加两位十六进制数字的形式。例如，空格编码为 %20。</li></ul><h4 id="2-URL-编码的意义"><a href="#2-URL-编码的意义" class="headerlink" title="2. URL 编码的意义"></a>2. URL 编码的意义</h4><ul><li><strong>避免歧义</strong>：某些字符在 URL 中具有特殊意义，如 ?、&amp;、&#x3D; 等。URL 编码将这些特殊字符转换为安全的形式，以避免歧义。</li><li><strong>安全传输</strong>：确保 URL 在传输过程中不被误解析或破坏，特别是在不同平台和浏览器间传输时。</li></ul><h4 id="3-需要编码的字符"><a href="#3-需要编码的字符" class="headerlink" title="3. 需要编码的字符"></a>3. 需要编码的字符</h4><ul><li><strong>保留字符</strong>：如 :、&#x2F;、?、#、[、]、@、!、$、&amp;、’、(、)、*、+、,、;、&#x3D;。这些字符在 URL 中有特殊意义，需要编码。</li><li><strong>非 ASCII 字符</strong>：如汉字、日文等，需要编码为百分号加十六进制表示形式。</li><li><strong>空格和其他控制字符</strong>：空格在 URL 中不允许，需编码为 %20。</li></ul><h4 id="4-URL-编码的应用场景"><a href="#4-URL-编码的应用场景" class="headerlink" title="4. URL 编码的应用场景"></a>4. URL 编码的应用场景</h4><p><strong>查询参数</strong>：在 GET 请求的查询字符串中包含特殊字符或空格时，需要进行 URL 编码。</p><ul><li>示例：<a href="http://example.com/search?q=hello">http://example.com/search?q=hello</a> world 编码为 <a href="http://example.com/search?q=hello%20world">http://example.com/search?q=hello%20world</a></li></ul><p><strong>路径参数</strong>：在 URL 路径中包含特殊字符或空格时，也需要进行 URL 编码。</p><ul><li>示例：<a href="http://example.com/user/John">http://example.com/user/John</a> Doe 编码为 <a href="http://example.com/user/John%20Doe">http://example.com/user/John%20Doe</a></li></ul><h4 id="5-编码和解码"><a href="#5-编码和解码" class="headerlink" title="5. 编码和解码"></a>5. 编码和解码</h4><p><strong>编码</strong>：将特殊字符转换为百分号加两位十六进制数字的形式。</p><ul><li>示例：hello world 编码为 hello%20world</li></ul><p><strong>解码</strong>：将百分号加两位十六进制数字的形式转换回原始字符。</p><ul><li>示例：hello%20world 解码为 hello world</li></ul><p>​</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h2><p>欢迎大家关注我的微信公众号「<strong>跟着小康学编程</strong>」！本号致力于分享<strong>C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习、计算机基础原理、Linux 编程、数据库、微服务、容器技术</strong> 等内容。文章力求通俗易懂，并配有代码示例，方便初学者理解。如果您对这些内容感兴趣，欢迎关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p>后续，我还会陆续分享各个方向的编程面试题，包括<strong>C&#x2F;C++、Java、Go，以及操作系统、计算机网络、数据结构、数据库和微服务</strong>等领域，为大家的面试提供帮助。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> 计算机网络面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP 面试题 — URI 和 URL 有什么区别?</title>
      <link href="/url-uri/"/>
      <url>/url-uri/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康。</p><p>今天给大家分享一个 HTTP 面试题 ：<strong>URI 和 URL 有什么区别?</strong></p><blockquote><p><strong>小技巧</strong>：在面试中，可以参考下面的<strong>示例回答</strong>，这样回答简洁明了。<strong>详细介绍</strong>部分则是为了帮助大家系统学习，以便应对面试官深入提问。</p></blockquote><h3 id="示例回答："><a href="#示例回答：" class="headerlink" title="示例回答："></a>示例回答：</h3><p>URI 是统一资源标识符，用于标识任何资源。URL 是统一资源定位符，是 URI 的一种，用于提供资源的访问方法。简单来说，所有的 URL 都是 URI，但不是所有的 URI 都是 URL。</p><hr><h3 id="详细介绍："><a href="#详细介绍：" class="headerlink" title="详细介绍："></a>详细介绍：</h3><h4 id="1-URI（Uniform-Resource-Identifier）"><a href="#1-URI（Uniform-Resource-Identifier）" class="headerlink" title="1. URI（Uniform Resource Identifier）"></a>1. URI（Uniform Resource Identifier）</h4><p><strong>定义</strong>：URI 是统一资源标识符，用于标识互联网中的某个资源。<br>URI 可以分为两种类型：</p><ul><li><strong>URL（Uniform Resource Locator）</strong>：统一资源定位符，指定了资源的位置和访问方法。</li><li><strong>URN（Uniform Resource Name）</strong>：统一资源名称，标识资源的名称，具有唯一性，但不指定资源的位置。</li></ul><h4 id="2-URL（Uniform-Resource-Locator）"><a href="#2-URL（Uniform-Resource-Locator）" class="headerlink" title="2. URL（Uniform Resource Locator）"></a>2. URL（Uniform Resource Locator）</h4><p><strong>定义</strong>：URL 是统一资源定位符，是 URI 的一种，提供了资源的访问方法和位置。<br><strong>结构</strong>：通常包括协议（如 http、https）、域名、端口、路径等。</p><ul><li>示例：<a href="http://www.example.com/index.html">http://www.example.com/index.html</a></li><li>解释：这个 URL 指定了使用 HTTP 协议，通过 <a href="http://www.example.com/">www.example.com</a> 域名访问服务器上的 index.html 文件。</li></ul><h4 id="3-主要区别"><a href="#3-主要区别" class="headerlink" title="3. 主要区别"></a>3. 主要区别</h4><p><strong>标识 vs 定位</strong>：</p><ul><li><strong>URI</strong>：侧重于标识资源，包含 URL 和 URN。</li><li><strong>URL</strong>：侧重于定位资源，提供访问资源的方法和位置。</li></ul><p><strong>包含关系</strong>：</p><ul><li><strong>URI 包含 URL</strong>：所有的 URL 都是 URI，因为 URL 提供了资源的标识和访问方法。</li><li><strong>URI 不等于 URL</strong>：URI 可以是 URN，不提供资源的位置。</li></ul><h4 id="4-实际应用"><a href="#4-实际应用" class="headerlink" title="4. 实际应用"></a>4. 实际应用</h4><ul><li><strong>URI</strong>：任何需要唯一标识资源的场景都可以使用 URI，例如：urn:isbn:0451450523（一本书的唯一标识）。</li><li><strong>URL</strong>：任何需要访问资源的场景都使用 URL，例如：<a href="http://www.example.com(访问网站首页)./">http://www.example.com（访问网站首页）。</a></li></ul><p>​</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h2><p>欢迎大家关注我的微信公众号「<strong>跟着小康学编程</strong>」！本号致力于分享<strong>C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习、计算机基础原理、Linux 编程、数据库、微服务、容器技术</strong> 等内容。文章力求通俗易懂，并配有代码示例，方便初学者理解。如果您对这些内容感兴趣，欢迎关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p>后续，我还会陆续分享各个方向的编程面试题，包括<strong>C&#x2F;C++、Java、Go，以及操作系统、计算机网络、数据结构、数据库和微服务</strong>等领域，为大家的面试提供帮助。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> 计算机网络面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP 面试题 — HTTP状态码301和302的区别，都有哪些用途？</title>
      <link href="/httpCode301-302/"/>
      <url>/httpCode301-302/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康。</p><p>今天给大家分享一个 HTTP 面试题 ：<strong>HTTP状态码301和302的区别，都有哪些用途？</strong></p><blockquote><p><strong>小技巧</strong>：在面试中，可以参考下面的<strong>示例回答</strong>，这样回答简洁明了。<strong>详细介绍</strong>部分则是为了帮助大家系统学习，以便应对面试官深入提问。</p></blockquote><p><strong>示例回答：</strong> 301 表示永久重定向，资源位置永久改变，搜索引擎会更新链接（将旧 URL 更新为新 URL）。302 表示临时重定向，资源位置临时改变，搜索引擎不会更新链接。</p><hr><h3 id="详细介绍："><a href="#详细介绍：" class="headerlink" title="详细介绍："></a>详细介绍：</h3><h4 id="1-HTTP-301-Moved-Permanently"><a href="#1-HTTP-301-Moved-Permanently" class="headerlink" title="1. HTTP 301 Moved Permanently"></a>1. HTTP 301 Moved Permanently</h4><p><strong>含义</strong>：请求的资源已永久移动到新的 URL。<br><strong>使用场景</strong>：</p><ul><li><strong>网站改版</strong>：旧页面永久移动到新地址。</li><li><strong>SEO 优化</strong>：告诉搜索引擎资源的新位置，搜索引擎会更新索引。</li></ul><p><strong>客户端行为</strong>：浏览器和搜索引擎会自动将旧 URL 更新为新 URL。<br><strong>示例</strong>：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">301</span> Moved Permanently</span><br><span class="line"><span class="attribute">Location</span><span class="punctuation">: </span>http://www.newsite.com/newpage</span><br></pre></td></tr></table></figure><h4 id="2-HTTP-302-Found"><a href="#2-HTTP-302-Found" class="headerlink" title="2. HTTP 302 Found"></a>2. HTTP 302 Found</h4><p><strong>含义</strong>：请求的资源临时移动到新的 URL。<br><strong>使用场景</strong>：</p><ul><li><strong>临时重定向</strong>：暂时性资源位置变动。</li><li><strong>A&#x2F;B 测试</strong>：将部分用户临时引导到不同的页面进行测试。</li></ul><p><strong>客户端行为</strong>：浏览器会临时重定向到新 URL，但不会更新书签，搜索引擎不会更新索引。<br><strong>示例</strong>：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">302</span> Found</span><br><span class="line"><span class="attribute">Location</span><span class="punctuation">: </span>http://www.newsite.com/temporarypage</span><br></pre></td></tr></table></figure><h4 id="3-主要区别"><a href="#3-主要区别" class="headerlink" title="3. 主要区别"></a>3. 主要区别</h4><p><strong>永久性 vs 临时性</strong>：</p><ul><li><strong>301</strong>：永久重定向，表示资源永久性移动。</li><li><strong>302</strong>：临时重定向，表示资源临时性移动。</li></ul><p><strong>搜索引擎处理</strong>：</p><ul><li><strong>301</strong>：搜索引擎会更新索引到新 URL。</li><li><strong>302</strong>：搜索引擎不会更新索引，继续索引旧 URL。</li></ul><h4 id="4-实际应用建议"><a href="#4-实际应用建议" class="headerlink" title="4. 实际应用建议"></a>4. 实际应用建议</h4><ul><li><strong>使用 301</strong>：当资源永久移动到新地址时使用，例如网站改版、永久 URL 变更。</li><li><strong>使用 302</strong>：当资源临时移动或进行短期调整时使用，例如临时维护、A&#x2F;B 测试。</li></ul><h2 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h2><p>欢迎大家关注我的微信公众号「<strong>跟着小康学编程</strong>」！本号致力于分享<strong>C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习、计算机基础原理、Linux 编程、数据库、微服务、容器技术</strong> 等内容。文章力求通俗易懂，并配有代码示例，方便初学者理解。如果您对这些内容感兴趣，欢迎关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p>后续，我还会陆续分享各个方向的编程面试题，包括<strong>C&#x2F;C++、Java、Go，以及操作系统、计算机网络、数据结构、数据库和微服务</strong>等领域，为大家的面试提供帮助。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> 计算机网络面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP 面试题 — 如何理解 HTTP 协议是无状态的？</title>
      <link href="/httpNoState/"/>
      <url>/httpNoState/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康。</p><p>今天给大家分享一个 HTTP 面试题 ：<strong>如何理解 HTTP 协议是无状态的？</strong></p><blockquote><p><strong>小技巧</strong>：在面试中，可以参考下面的<strong>示例回答</strong>，这样回答简洁明了。<strong>详细介绍</strong>部分则是为了帮助大家系统学习，以便应对面试官深入提问。</p></blockquote><h3 id="示例回答："><a href="#示例回答：" class="headerlink" title="示例回答："></a>示例回答：</h3><p>HTTP 是无状态的，意味着每个请求都是独立的，服务器不会记住之前请求的信息。每次请求都必须包含完成该请求所需的所有信息。</p><hr><h3 id="详细介绍："><a href="#详细介绍：" class="headerlink" title="详细介绍："></a>详细介绍：</h3><h4 id="1-无状态的含义"><a href="#1-无状态的含义" class="headerlink" title="1. 无状态的含义"></a>1. 无状态的含义</h4><ul><li><strong>独立性</strong>：HTTP 协议是无状态的，表示每个请求都是独立的，服务器不会保留任何关于以前请求的信息。</li><li><strong>每次请求都独立</strong>：客户端的每次请求都需要包含完成该请求所需的全部信息，因为服务器不会记住之前的请求。</li></ul><h4 id="2-无状态的优势"><a href="#2-无状态的优势" class="headerlink" title="2. 无状态的优势"></a>2. 无状态的优势</h4><ul><li><strong>简单性</strong>：服务器不需要维护每个客户端的会话状态，简化了服务器设计和实现。</li><li><strong>扩展性</strong>：由于服务器不需要保留状态信息，容易进行负载均衡和分布式处理。</li></ul><h4 id="3-无状态的劣势"><a href="#3-无状态的劣势" class="headerlink" title="3. 无状态的劣势"></a>3. 无状态的劣势</h4><ul><li><strong>缺少连续性</strong>：对于需要连续状态的应用（如用户登录会话），需要额外机制来维持状态。</li></ul><h4 id="4-解决方案"><a href="#4-解决方案" class="headerlink" title="4. 解决方案"></a>4. 解决方案</h4><ul><li><strong>Cookies</strong>：客户端存储少量数据并在每次请求时发送给服务器，以保持状态。例如，存储用户登录信息。</li><li><strong>Session</strong>：服务器端存储用户会话信息，并通过会话 ID 识别用户。例如，用户登录后服务器生成一个 Session ID，客户端每次请求时发送该 ID。</li><li><strong>Token</strong>：使用 JWT（JSON Web Token）等令牌机制，客户端在每次请求时发送令牌，服务器通过验证令牌来保持状态。例如，客户端登录后服务器返回一个 JWT，客户端每次请求时附带该 JWT。</li></ul><h4 id="示例应用"><a href="#示例应用" class="headerlink" title="示例应用"></a>示例应用</h4><ul><li><strong>无状态请求</strong>：API 请求每次都需要带上认证信息，如 API 密钥。</li><li><strong>状态保持请求</strong>：用户登录后，使用 Cookies 或 Token 来维持会话状态。</li></ul><h2 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h2><p>欢迎大家关注我的微信公众号「<strong>跟着小康学编程</strong>」！本号致力于分享<strong>C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习、计算机基础原理、Linux 编程、数据库、微服务、容器技术</strong> 等内容。文章力求通俗易懂，并配有代码示例，方便初学者理解。如果您对这些内容感兴趣，欢迎关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p>后续，我还会陆续分享各个方向的编程面试题，包括<strong>C&#x2F;C++、Java、Go，以及操作系统、计算机网络、数据结构、数据库和微服务</strong>等领域，为大家的面试提供帮助。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> 计算机网络面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP 面试题 — HTTP 常用的状态码有哪些？分别的使用场景？</title>
      <link href="/httpCode/"/>
      <url>/httpCode/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康。</p><p>今天给大家分享一个 HTTP 面试题 ：<strong>HTTP 常用的状态码有哪些？分别的使用场景？</strong></p><blockquote><p><strong>小技巧</strong>：在面试中，可以参考下面的<strong>示例回答</strong>，这样回答简洁明了。<strong>详细介绍</strong>部分则是为了帮助大家系统学习，以便应对面试官深入提问。</p></blockquote><h3 id="示例回答："><a href="#示例回答：" class="headerlink" title="示例回答："></a>示例回答：</h3><p>常用的 HTTP 状态码有：</p><ul><li><strong>200 OK</strong>：请求成功，返回所请求的资源。</li><li><strong>301 Moved Permanently</strong>：资源永久移动到新位置。</li><li><strong>302 Found</strong>：资源临时移动到新位置。</li><li><strong>400 Bad Request</strong>：请求无效，服务器无法理解请求。</li><li><strong>401 Unauthorized</strong>：未授权，需提供认证。</li><li><strong>403 Forbidden</strong>：服务器拒绝请求。</li><li><strong>404 Not Found</strong>：资源未找到。</li><li><strong>500 Internal Server Error</strong>：服务器内部错误。</li></ul><hr><h3 id="详细介绍"><a href="#详细介绍" class="headerlink" title="详细介绍"></a>详细介绍</h3><h4 id="1-200-OK"><a href="#1-200-OK" class="headerlink" title="1. 200 OK"></a>1. 200 OK</h4><ul><li><strong>含义</strong>：请求成功，服务器已成功处理请求。</li><li><strong>使用场景</strong>：访问网页、获取 API 数据成功时返回。</li><li><strong>示例</strong>：用户请求某个网页，服务器成功返回该网页内容。</li></ul><h4 id="2-301-Moved-Permanently"><a href="#2-301-Moved-Permanently" class="headerlink" title="2. 301 Moved Permanently"></a>2. 301 Moved Permanently</h4><ul><li><strong>含义</strong>：请求的资源已永久移动到新位置。</li><li><strong>使用场景</strong>：资源永久重定向，SEO 优化时常用。</li><li><strong>示例</strong>：网站改版，旧 URL 重定向到新 URL。</li></ul><h4 id="3-302-Found"><a href="#3-302-Found" class="headerlink" title="3. 302 Found"></a>3. 302 Found</h4><ul><li><strong>含义</strong>：请求的资源临时移动到新位置。</li><li><strong>使用场景</strong>：资源临时重定向，不应被缓存。</li><li><strong>示例</strong>：用户登录后重定向到主页。</li></ul><h4 id="4-400-Bad-Request"><a href="#4-400-Bad-Request" class="headerlink" title="4. 400 Bad Request"></a>4. 400 Bad Request</h4><ul><li><strong>含义</strong>：请求无效，服务器无法理解请求。</li><li><strong>使用场景</strong>：客户端发送的请求有语法错误。</li><li><strong>示例</strong>：用户提交的表单数据格式不正确。</li></ul><h4 id="5-401-Unauthorized"><a href="#5-401-Unauthorized" class="headerlink" title="5. 401 Unauthorized"></a>5. 401 Unauthorized</h4><ul><li><strong>含义</strong>：未授权，需提供身份认证。</li><li><strong>使用场景</strong>：用户未登录或认证信息无效。</li><li><strong>示例</strong>：用户访问受保护的资源但未登录。</li></ul><h4 id="6-403-Forbidden"><a href="#6-403-Forbidden" class="headerlink" title="6. 403 Forbidden"></a>6. 403 Forbidden</h4><ul><li><strong>含义</strong>：服务器拒绝请求，权限不足。</li><li><strong>使用场景</strong>：用户权限不足以访问某资源。</li><li><strong>示例</strong>：普通用户尝试访问管理员页面。</li></ul><h4 id="7-404-Not-Found"><a href="#7-404-Not-Found" class="headerlink" title="7. 404 Not Found"></a>7. 404 Not Found</h4><ul><li><strong>含义</strong>：请求的资源未找到。</li><li><strong>使用场景</strong>：用户请求的页面不存在或 URL 错误。</li><li><strong>示例</strong>：用户访问不存在的网页 URL。</li></ul><h4 id="8-500-Internal-Server-Error"><a href="#8-500-Internal-Server-Error" class="headerlink" title="8. 500 Internal Server Error"></a>8. 500 Internal Server Error</h4><ul><li><strong>含义</strong>：服务器内部错误，无法完成请求。</li><li><strong>使用场景</strong>：服务器代码或配置出错导致无法处理请求。</li><li><strong>示例</strong>：服务器程序抛出异常未被捕获。</li></ul><h4 id="状态码分类"><a href="#状态码分类" class="headerlink" title="状态码分类"></a>状态码分类</h4><ul><li><strong>1xx Informational</strong>：信息性状态码，表示接收到请求并继续处理。</li><li><strong>2xx Success</strong>：成功状态码，表示请求已成功处理。</li><li><strong>3xx Redirection</strong>：重定向状态码，表示资源已移动，需客户端进一步操作。</li><li><strong>4xx Client Error</strong>：客户端错误状态码，表示请求有错误或权限问题。</li><li><strong>5xx Server Error</strong>：服务器错误状态码，表示服务器处理请求时出错。</li></ul><h2 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h2><p>欢迎大家关注我的微信公众号「<strong>跟着小康学编程</strong>」！本号致力于分享<strong>C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习、计算机基础原理、Linux 编程、数据库、微服务、容器技术</strong> 等内容。文章力求通俗易懂，并配有代码示例，方便初学者理解。如果您对这些内容感兴趣，欢迎关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p>后续，我还会陆续分享各个方向的编程面试题，包括<strong>C&#x2F;C++、Java、Go，以及操作系统、计算机网络、数据结构、数据库和微服务</strong>等领域，为大家的面试提供帮助。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> 计算机网络面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP 面试题 — GET 的长度限制是多少？</title>
      <link href="/get-len/"/>
      <url>/get-len/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康。</p><p>今天给大家分享一个 HTTP 面试题 ：<strong>GET 的长度限制是多少？</strong></p><blockquote><p><strong>小技巧</strong>：在面试中，可以参考下面的<strong>示例回答</strong>，这样回答简洁明了。<strong>详细介绍</strong>部分则是为了帮助大家系统学习，以便应对面试官深入提问。</p></blockquote><h3 id="示例回答："><a href="#示例回答：" class="headerlink" title="示例回答："></a>示例回答：</h3><p>HTTP 协议本身没有对 GET 请求的 URL 长度限制，但实际情况中，浏览器和服务器对 URL 长度有各自的限制。Internet Explorer 限制为 2048 个字符，其他现代浏览器通常支持更长的 URL，但为了兼容性，建议限制在 2048 个字符以内。服务器端限制通常在 8192 个字符（8KB）或更少。为了安全和处理大数据量的请求，建议使用 POST 请求。  </p><hr><h3 id="详细介绍："><a href="#详细介绍：" class="headerlink" title="详细介绍："></a>详细介绍：</h3><p>HTTP 协议规范并没有对 GET 请求的 URL 长度做出明确的限制。然而不同的浏览器和服务器会对 URL 长度有不同的限制，一般来说，浏览器对 URL 的长度限制在 2048 字符以内。</p><h4 id="浏览器限制："><a href="#浏览器限制：" class="headerlink" title="浏览器限制："></a>浏览器限制：</h4><ul><li><strong>Internet Explorer</strong>：对 URL 长度限制为 2048 字符，这是比较常见的限制。</li><li><strong>其他浏览器</strong>（如 Chrome、Firefox、Safari）：通常支持更长的 URL，但为了兼容性，最好将 URL 长度控制在 2048 字符以内。</li></ul><h4 id="服务器限制："><a href="#服务器限制：" class="headerlink" title="服务器限制："></a>服务器限制：</h4><ul><li><strong>服务器配置</strong>：服务器（如 Apache、Nginx）可以配置允许的最大 URL 长度，默认配置可能有所不同。</li><li><strong>实际应用</strong>：大多数服务器在默认配置下对 URL 长度的限制在 8192 字符（8KB）或更少。</li></ul><h4 id="影响因素："><a href="#影响因素：" class="headerlink" title="影响因素："></a>影响因素：</h4><ul><li><strong>安全性</strong>：过长的 URL 可能会导致服务器拒绝请求或产生安全问题，如缓冲区溢出。</li><li><strong>兼容性</strong>：为了确保所有浏览器和服务器都能正确处理 GET 请求，建议将 URL 长度控制在 2048 字符以内。</li></ul><p>​</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h2><p>欢迎大家关注我的微信公众号「<strong>跟着小康学编程</strong>」！本号致力于分享<strong>C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习、计算机基础原理、Linux 编程、数据库、微服务、容器技术</strong> 等内容。文章力求通俗易懂，并配有代码示例，方便初学者理解。如果您对这些内容感兴趣，欢迎关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p>后续，我还会陆续分享各个方向的编程面试题，包括<strong>C&#x2F;C++、Java、Go，以及操作系统、计算机网络、数据结构、数据库和微服务</strong>等领域，为大家的面试提供帮助。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> 计算机网络面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP 面试题 — POST和GET有哪些区别？各自的应用场景？</title>
      <link href="/postGet/"/>
      <url>/postGet/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康。</p><p>今天给大家分享一个 HTTP 面试题 ：<strong>POST和GET有哪些区别？各自的应用场景？</strong></p><blockquote><p><strong>小技巧</strong>：在面试中，可以参考下面的<strong>示例回答</strong>，这样回答简洁明了。<strong>详细介绍</strong>部分则是为了帮助大家系统学习，以便应对面试官深入提问。</p></blockquote><h3 id="示例回答："><a href="#示例回答：" class="headerlink" title="示例回答："></a>示例回答：</h3><p>GET 请求用于获取数据，参数通过 URL 传递，有长度限制，适合小数据量和非敏感数据。POST 请求用于提交数据，参数在请求体中传递，无长度限制，适合大数据量和敏感数据。  </p><hr><h3 id="详细介绍："><a href="#详细介绍：" class="headerlink" title="详细介绍："></a>详细介绍：</h3><h3 id="GET-请求"><a href="#GET-请求" class="headerlink" title="GET 请求"></a>GET 请求</h3><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><ul><li>GET 请求用于从服务器请求数据。</li></ul><h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><ul><li><strong>幂等性</strong>：GET 请求是幂等的，重复相同的GET请求会得到相同的结果，不会对服务器上的数据产生副作用。</li><li><strong>参数传递</strong>：参数通过 URL 传递，通常使用查询字符串（Query String）。</li><li><strong>长度限制</strong>：GET 请求的 URL 长度有限制（具体限制取决于浏览器和服务器）。</li><li><strong>缓存</strong>：GET 请求的数据可以被缓存。</li><li><strong>安全性</strong>：因为参数包含在 URL 中，所以不适合传递敏感数据。</li><li><strong>可见性</strong>：URL 及其参数会出现在浏览器地址栏中。</li></ul><h4 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h4><ul><li>获取网页数据：例如，访问一个网页时，浏览器会发送 GET 请求。</li><li>获取资源：例如，下载文件、图片等。</li></ul><h3 id="POST-请求"><a href="#POST-请求" class="headerlink" title="POST 请求"></a>POST 请求</h3><h4 id="定义：-1"><a href="#定义：-1" class="headerlink" title="定义："></a>定义：</h4><ul><li>POST 请求用于向服务器提交数据，通常用于表单提交。</li></ul><h4 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a>特点：</h4><ul><li><strong>幂等性</strong>：POST 请求是非幂等的，重复相同的POST请求可能会导致服务器上的资源多次变化（如多次提交表单，导致重复数据）。</li><li><strong>参数传递</strong>：参数通过请求体（Request Body）传递。</li><li><strong>长度限制</strong>：POST 请求理论上没有长度限制（实际受服务器和客户端配置的限制）。</li><li><strong>缓存</strong>：POST 请求的数据通常不会被缓存。</li><li><strong>安全性</strong>：相对 GET 请求更安全，因为参数不暴露在 URL 中，但仍需使用 HTTPS 确保数据安全。</li><li><strong>可见性</strong>：参数不出现在浏览器地址栏中。</li></ul><h4 id="应用场景：-1"><a href="#应用场景：-1" class="headerlink" title="应用场景："></a>应用场景：</h4><ul><li>提交表单：例如，用户注册、登录时，表单数据通过 POST 请求提交。</li><li>上传文件：例如，上传图片、文档等。</li><li>提交数据以进行处理：例如，提交搜索条件以获取搜索结果。</li></ul><h3 id="深度解析和补充"><a href="#深度解析和补充" class="headerlink" title="深度解析和补充"></a>深度解析和补充</h3><h4 id="安全性："><a href="#安全性：" class="headerlink" title="安全性："></a>安全性：</h4><ul><li>GET 请求的参数在 URL 中明文传输，容易被截获，因此不适合传输敏感信息。</li><li>POST 请求虽然在请求体中传输数据，但在没有加密的情况下仍不够安全，建议使用 HTTPS。</li></ul><h4 id="可见性："><a href="#可见性：" class="headerlink" title="可见性："></a>可见性：</h4><ul><li>GET 请求的 URL 可以被书签保存，容易分享和记录。</li><li>POST 请求的数据在浏览器历史记录中不可见，适合需要数据保密的场景。</li></ul><h4 id="缓存控制："><a href="#缓存控制：" class="headerlink" title="缓存控制："></a>缓存控制：</h4><ul><li>GET 请求常用于获取资源，可以被缓存，提高访问效率。</li><li>POST 请求一般用于提交数据，数据变化频繁，不适合缓存。</li></ul><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><h4 id="GET-请求示例："><a href="#GET-请求示例：" class="headerlink" title="GET 请求示例："></a>GET 请求示例：</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://example.com/search?query=network&quot;</span>&gt;</span>Search Network<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="POST-请求示例："><a href="#POST-请求示例：" class="headerlink" title="POST 请求示例："></a>POST 请求示例：</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;http://example.com/login&quot;</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Username&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Password&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>Login<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h2><p>欢迎大家关注我的微信公众号「<strong>跟着小康学编程</strong>」！本号致力于分享<strong>C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习、计算机基础原理、Linux 编程、数据库、微服务、容器技术</strong> 等内容。文章力求通俗易懂，并配有代码示例，方便初学者理解。如果您对这些内容感兴趣，欢迎关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p>后续，我还会陆续分享各个方向的编程面试题，包括<strong>C&#x2F;C++、Java、Go，以及操作系统、计算机网络、数据结构、数据库和微服务</strong>等领域，为大家的面试提供帮助。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> 计算机网络面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP 面试题 — HTTP有哪些请求方式？</title>
      <link href="/httpMethod/"/>
      <url>/httpMethod/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康。</p><p>今天给大家分享一个 HTTP 面试题 ：<strong>HTTP 有哪些请求方式？</strong></p><blockquote><p><strong>小技巧</strong>：在面试中，可以参考下面的<strong>示例回答</strong>，这样回答简洁明了。<strong>详细介绍</strong>部分则是为了帮助大家系统学习，以便应对面试官深入提问。</p></blockquote><h3 id="示例回答："><a href="#示例回答：" class="headerlink" title="示例回答："></a>示例回答：</h3><p>HTTP 有几种主要请求方式：GET 用于获取数据，POST 用于提交数据，PUT 用于更新数据，DELETE 用于删除数据，HEAD 用于获取响应头，OPTIONS 用于查询服务器支持的方法，PATCH 用于部分更新，TRACE 用于回显请求。  </p><hr><h3 id="详细介绍："><a href="#详细介绍：" class="headerlink" title="详细介绍："></a>详细介绍：</h3><p><strong>GET</strong>：</p><ul><li><strong>定义</strong>：用于从服务器获取数据。</li><li><strong>应用场景</strong>：请求网页、获取资源数据（例如图片、文档）。</li><li><strong>特点</strong>：数据在URL中传递，参数可被缓存和记录，适合查询操作，不应用于提交敏感数据。</li><li><strong>幂等性</strong>：幂等。重复相同的GET请求会得到相同的结果，不会对服务器上的数据产生副作用。</li></ul><p><strong>POST</strong>：</p><ul><li><strong>定义</strong>：用于向服务器提交数据，通常用于表单提交。</li><li><strong>应用场景</strong>：用户注册、登录、提交表单数据。</li><li><strong>特点</strong>：数据在请求体中传递，较为安全，适合发送较大数据和敏感信息。</li><li><strong>幂等性</strong>：非幂等。重复相同的POST请求可能会导致服务器上的资源多次变化（如多次提交表单，导致重复数据）。</li></ul><p><strong>PUT</strong>：</p><ul><li><strong>定义</strong>：用于向服务器上传或更新资源。</li><li><strong>应用场景</strong>：更新用户信息、上传文件。</li><li><strong>特点</strong>：幂等操作（同样的请求结果不会因重复请求而改变），通常用于更新资源。</li><li><strong>幂等性</strong>：幂等。重复相同的PUT请求会产生相同的效果，不会导致多次修改。</li></ul><p><strong>DELETE</strong>：</p><ul><li><strong>定义</strong>：用于从服务器删除资源。</li><li><strong>应用场景</strong>：删除用户账号、移除文件。</li><li><strong>特点</strong>：幂等操作，确保删除操作可以重复执行而不会影响结果。</li><li><strong>幂等性</strong>：幂等。重复相同的DELETE请求会产生相同的效果，不会导致额外的资源删除。</li></ul><p><strong>HEAD</strong>：</p><ul><li><strong>定义</strong>：类似于GET请求，但服务器只返回响应头，不返回响应体。</li><li><strong>应用场景</strong>：检查资源的元数据（如文件大小、类型），验证资源是否存在。</li><li><strong>特点</strong>：用于获取资源元信息而不获取资源本身，节省带宽。</li><li><strong>幂等性</strong>：幂等。重复相同的HEAD请求会得到相同的响应头信息。</li></ul><p><strong>OPTIONS</strong>：</p><ul><li><strong>定义</strong>：用于查询服务器支持的HTTP方法和其他功能。</li><li><strong>应用场景</strong>：跨域请求前的预检请求，检查服务器允许的请求方法。</li><li><strong>特点</strong>：不涉及资源数据，返回服务器支持的请求方法列表。</li><li><strong>幂等性</strong>：幂等。重复相同的OPTIONS请求会得到相同的结果，不会对服务器上的资源产生副作用。</li></ul><p><strong>PATCH</strong>：</p><ul><li><strong>定义</strong>：用于对资源进行部分更新。</li><li><strong>应用场景</strong>：更新用户部分信息，修改部分配置。</li><li><strong>特点</strong>：非幂等操作，只对资源进行部分修改而不影响其他部分。</li><li><strong>幂等性</strong>：非幂等。重复相同的PATCH请求可能会导致不同的资源状态。</li></ul><p><strong>TRACE</strong>：</p><ul><li><strong>定义</strong>：用于在目标资源上执行一个消息环回测试。</li><li><strong>应用场景</strong>：用于诊断，追踪请求路径。</li><li><strong>特点</strong>：返回服务器收到的请求，主要用于调试。</li><li><strong>幂等性</strong>：幂等。重复相同的TRACE请求会得到相同的结果。</li></ul><h3 id="额外加分点"><a href="#额外加分点" class="headerlink" title="额外加分点"></a>额外加分点</h3><ul><li><strong>示例</strong>：能给出每种请求方式的实际例子，例如GET请求用于获取用户信息，POST请求用于提交用户注册表单。</li><li><strong>安全性</strong>：提及安全性方面的考虑，如POST请求较GET请求更适合提交敏感信息，因为数据在请求体中传递。</li></ul><h2 id="最后"><a href="#最后" class="headerlink" title="最后:"></a>最后:</h2><p>欢迎大家关注我的微信公众号「<strong>跟着小康学编程</strong>」！本号致力于分享<strong>C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习、计算机基础原理、Linux 编程、数据库、微服务、容器技术</strong> 等内容。文章力求通俗易懂，并配有代码示例，方便初学者理解。如果您对这些内容感兴趣，欢迎关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p>后续，我还会陆续分享各个方向的编程面试题，包括<strong>C&#x2F;C++、Java、Go，以及操作系统、计算机网络、数据结构、数据库和微服务</strong>等领域，为大家的面试提供帮助。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>此外，小康最近创建了一个技术交流群，专门用来讨论技术问题和解答读者的疑问。在阅读文章时，如果有不理解的知识点，欢迎大家加入交流群提问。我会尽力为大家解答。期待与大家共同进步！</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 计算机网络面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> 计算机网络面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 架构解析：从主从复制到哨兵和集群模式</title>
      <link href="/RedisCluster/"/>
      <url>/RedisCluster/</url>
      
        <content type="html"><![CDATA[<p>大家好，我是小康，今天我们来聊下 Redis 的几种架构模式，包括<strong>主从复制、哨兵和集群模式</strong>。</p><h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>设想一下，你的咖啡馆在城市中太受欢迎，导致每天都人满为患。为了缓解这种压力，你决定在其他地方开设分店，这样顾客就可以在附近的分店享受咖啡，而不必涌向一个地方，这就好比 Redis 的主从复制，让数据备份并允许多个地方进行读取。</p><p>但这还不够，因为你需要确保当主要的咖啡馆遇到问题时，例如突然断电，有其他分店能够迅速接手，成为新的主要店铺，继续为顾客提供服务。这就像 Redis 的哨兵系统，它会自动检测故障并进行转移，确保服务始终在线。</p><p>最后，随着咖啡馆连锁店的增长，每家店都开始独立运作，甚至可能有自己的特色饮品和优惠活动，同时仍然保持整体的协调和一致性。这就是 Redis 集群的工作方式，它将数据分片到不同的节点，每个节点都可以独立处理请求，但都是整个系统的一部分。</p><p>现在，让我们深入探讨 Redis 如何通过<strong>主从复制、哨兵和集群</strong>来确保它的强大性能和高可靠性。</p><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p><img src="/images/RedisCluster/1.png"></p><h3 id="主从复制基本概念"><a href="#主从复制基本概念" class="headerlink" title="主从复制基本概念"></a>主从复制基本概念</h3><p>在日常工作中，我们都知道团队合作的重要性。就像团队中有领导者和执行者，Redis 也采用了一种类似的策略 —<strong>主从复制</strong>，使其能够更有效地处理数据。</p><h4 id="什么是主从复制？"><a href="#什么是主从复制？" class="headerlink" title="什么是主从复制？"></a>什么是主从复制？</h4><p>主从复制是一种允许多个 Redis 服务器（节点）协同工作的策略。其中，一个服务器作为“主节点”，负责接受所有写操作。其他服务器则作为“从节点”，复制并存储主节点的数据。这样，从节点可以为读操作服务，从而分散主节点读取压力。</p><h4 id="简单图示"><a href="#简单图示" class="headerlink" title="简单图示:"></a>简单图示:</h4><p><img src="/images/RedisCluster/02.png"></p><h3 id="主从复制的工作原理"><a href="#主从复制的工作原理" class="headerlink" title="主从复制的工作原理"></a>主从复制的工作原理</h3><p>Redis 的主从复制功能使得一个或多个从节点可以复制一个主节点的全部数据。主节点负责进行写操作，而从节点则可以用来进行读操作，从而分担读的负载。</p><h4 id="主从复制流程图"><a href="#主从复制流程图" class="headerlink" title="主从复制流程图"></a>主从复制流程图</h4><p><img src="/images/RedisCluster/03.png"></p><p><strong>步骤说明:</strong></p><p>从节点首先执行 <code>REPLICAOF ip port</code> 命令，准备复制主节点的数据。</p><p><strong>第一步：连接与同步请求</strong></p><ul><li><p>从节点与主节点建立 TCP 连接，并正式请求同步数据，发送 PSYNC ? -1。</p></li><li><p>主节点接收到请求后，向从节点回复 FULLRESYNC runid offset ，做好开始传输 RDB 数据的准备。</p></li></ul><p><strong>第二步: RDB 文件同步</strong></p><ul><li><p>主节点执行 bgsave 命令，生成当前数据的快照—也就是 RDB 文件。</p></li><li><p>主节点随后将这个 RDB 文件传输给从节点。</p></li><li><p>从节点收到 RDB 文件后，开始加载到自己的数据库中。</p></li></ul><p><strong>第三步 : 持续命令同步</strong></p><ul><li><p>之后，每当主节点有新的写命令，它都会立即传输给从节点并同时将新命令追加到复制缓冲区中。</p></li><li><p>从节点持续接收并执行这些命令，确保与主节点的数据始终保持同步。</p></li></ul><h4 id="断线重连与部分同步"><a href="#断线重连与部分同步" class="headerlink" title="断线重连与部分同步"></a>断线重连与部分同步</h4><p>在实际应用中，因为网络不稳定、系统资源限制等因素，Redis 主从节点间的连接有时会遭遇中断。为了应对这些突发情况并确保数据同步不被中断，Redis  设计了一套智能的同步恢复机制: <strong>部分同步</strong>。</p><p><strong>断线重连与部分同步流程图</strong></p><p><img src="/images/RedisCluster/04.png"></p><p><strong>步骤说明:</strong></p><ol><li><p>🔌 [<strong>连接断开</strong>]</p><p> 🚫 主从节点的连接中断。</p></li><li><p>🔄 [<strong>重连尝试</strong>]</p><p>  📡 从节点尝试重新连接主节点。</p></li><li><p>💬 [<strong>部分同步请求</strong>]</p><p> 📩 从节点发送 <code>PSYNC</code> 带有上次的运行 ID 和数据偏移量。</p></li><li><p>🤔 [<strong>主节点决策数据同步方式</strong>]</p><p>  ✅ 如果条件满足：回复 <code>CONTINUE</code>，表示进行部分数据同步。</p><p>  ❌ 否则：回复 <code>FULLRESYNC</code>，表示进行全量数据同步。</p></li><li><p>🏁 [<strong>执行命令</strong>]</p><p>  🛠 从节点执行接收到的新命令，确保数据与主节点一致。</p></li></ol><p><strong>这里重点讲解下部分数据同步的过程</strong>:</p><p>当从节点重新连接到主节点时，它会发送之前保存的主节点运行 ID 和自己的复制偏移量给主节点。</p><p>主节点在验证接收到的运行 ID 与自己的相符后，会进一步检查其复制缓冲区。如果缓冲区包含从节点缺失的所有命令，主节点仅发送这些缺失命令。否则，将进行全量同步。</p><h3 id="主从复制配置详解"><a href="#主从复制配置详解" class="headerlink" title="主从复制配置详解"></a>主从复制配置详解</h3><p>关于 Redis 主从复制的配置项，只需在 redis.conf 配置文件中搜索 replication 即可定位到。</p><p><strong>1.连接 &amp; 身份验证</strong>:  </p><ul><li><code>replicaof  masterip  masterport</code>  : 设定从节点连接到的主节点地址和端口。</li><li><code>masteruser username</code>               : 设定连接到主节点的用户名。</li><li><code>masterauth master-password</code>        : 设定连接到主节点的密码。</li></ul><p><strong>2.数据服务策略</strong></p><ul><li><p><code>replica-serve-stale-data</code> : 当与主节点断开连接时，从节点应如何响应客户端的数据请求，默认值 yes。</p><p>yes: 提供当前拥有的数据（即使可能过时）</p><p>no: 不提供任何数据，返回“正在与主节点同步”的错误。</p></li><li><p><code>replica-read-only</code> : 是否设置从节点为只读，默认值 yes。</p><p> yes : 只读，  no  : 可写。</p></li></ul><p><strong>3.同步策略</strong></p><ul><li><p><code>repl-diskless-sync </code>: 选择 RDB 数据同步方式，默认值 no。</p><p>yes : 直接通过网络同步 RDB 数据。</p><p>no  : 先将 RDB 数据写入磁盘，然后再同步。</p></li><li><p><code>repl-diskless-sync-delay timeout</code> : 当启用无磁盘同步时（repl-diskless-sync 设置为 yes），主节点在开始数据同步前的等待时间（秒），以便集合更多的从节点连接请求，从而进行高效的一次性同步。</p></li><li><p><code>repl-diskless-load disabled</code>  : 从节点如何加载 RDB 数据，默认值 disabled。</p><p><strong>disabled</strong>   : 从节点会先把接收到的RDB文件保存到磁盘，然后从磁盘读取这个文件。</p><p><strong>on-empty-db</strong> : 从节点直接从网络加载 RDB 数据，但只有当它的数据库是空的时。</p><p><strong>swapdb</strong>     : 从节点会同时保存旧数据和从主节点接收的新数据在内存中，不通过磁盘。但需要注意，这需要很多内存。</p></li></ul><p><strong>4.PING &amp; 超时</strong></p><ul><li><p><code>repl-ping-replica-period 10</code> : 从节点向主节点发送 PING 的频率，用于确认主从节点的连接状态。默认值 10s。</p></li><li><p><code>repl-timeout 60</code> : 主节点和从节点之间数据传输的超时时间（以秒为单位）。默认值 60s。</p></li><li><p><code>repl-disable-tcp-nodelay no</code> : 是否禁用 TCP_NODELAY，默认值 no。</p><p> yes: 禁用，       no: 启用。</p></li></ul><p><strong>5.积压策略</strong></p><ul><li><p><code>repl-backlog-size 1mb</code>       : 设置复制积压缓冲区大小，默认值 1MB。</p></li><li><p><code>repl-backlog-ttl 3600</code>       : 复制积压的生存时间，默认值 1h。</p></li></ul><p><strong>6.从节点属性</strong></p><ul><li><p><code>replica-priority 100</code> : 设置从节点的优先级，使用哨兵 Sentinel 进行故障转移时，就用到了这个配置。</p><p><strong>数值越小，优先级越高</strong>。设置为 0 时，该从节点不会被提升为主节点。默认值 100。</p></li><li><p><code>replica-announced yes</code>    : 该配置决定是否让其他的 Redis 工具（如哨兵 Sentinel，Redis 集群）知道这个从节点的存在。默认值 yes。</p><p>yes : 当设置为”yes”，这意味着其他 Redis工具可以看到和识别这个从节点。该节点可以进行正常的故障转移。</p><p>no: 当设置为”no”，这意味着该从节点对其他 Redis 工具是不可见的，它会”隐藏”自己。这在某些特定的部署或安全场景下可能是有用的，比如你不希望某些从节点被外部发现或被用于故障转移。</p></li><li><p><code>replica-announce-ip </code>、<code>replica-announce-port</code> : 用于指定 Redis 实例应当通告给其他节点的IP地址和端口。</p><p><strong>场景</strong>：考虑一个使用 Docker 部署的 Redis 实例。默认情况下，该Redis 实例的IP地址为容器的内部私有地址，可能不适合外部访问。</p><p><strong>replica-announce-ip</strong>   : 在这种设置下，你需要将此配置项设为外部网络可访问的地址，如宿主机的IP，以确保其他 Redis 节点或客户端可以正常连接。</p><p><strong>replica-announce-port</strong> : 若你的容器内部 Redis 实例使用的是标准端口 6379，但在宿主机上通过 7000 端口映射为外部访问，那么你应该将此配置项设置为 7000。</p><p>这样的配置确保无论是 Redis 节点还是客户端，都能使用正确的 IP 和端口与容器内的 Redis 实例进行通信。</p></li></ul><p><strong>7.写操作确认参数</strong></p><ul><li><p><code>min-replicas-to-write</code> : 它定义了主节点在执行写操作时，至少需要多少个从节点确认已经接收了这个写操作。这样，主节点才会回应客户端写操作是成功的。</p></li><li><p><code>min-replicas-max-lag</code>  : 它定义了从节点与主节点之间的最大允许数据同步延迟（以秒为单位）。如果某个从节点的同步延迟超过这个设定的时间，那么该从节点的确认将不会被计入 <strong>min-replicas-to-write</strong> 所需的确认数量。</p></li></ul><h3 id="主从复制使用场景"><a href="#主从复制使用场景" class="headerlink" title="主从复制使用场景"></a>主从复制使用场景</h3><p><strong>1.负载均衡</strong></p><p><strong>背景</strong> ：大规模的应用可能会产生大量的读请求，这些读请求如果都落到一个服务器上，可能会导致性能瓶颈，进而影响用户体验。</p><p><strong>解决方法</strong>：</p><ul><li><p>使用 Redis 的主从复制，可以将读请求负载均衡到多个从节点上，而主节点主要负责处理写请求</p></li><li><p>这种方式可以有效地分散请求，减轻主节点的负担，确保系统的流畅运行。</p></li></ul><p><strong>2.数据冗余与备份</strong></p><p><strong>背景</strong>：为了确保数据安全性，我们需要在多个地方存储数据的备份。</p><p><strong>解决方法</strong>：</p><ul><li>通过主从复制，数据在多个从节点上都有拷贝。</li><li>即使主节点遭遇故障，数据仍然安全，因为可以从任何从节点恢复。</li></ul><p><strong>3.读写分离</strong></p><p><strong>背景</strong>：当业务增长导致单一 Redis 实例的读写请求压力增大时，采用主从复制进行读写分离可以确保系统性能稳定并提高可用性。</p><p><strong>解决方法</strong>：</p><ul><li>使用主从复制进行读写分离：主节点负责所有写操作，而从节点处理大部分读操作。</li><li>这确保了即使主节点遭遇大量写入，读操作的性能仍然保持稳定。</li></ul><p><strong>4.故障恢复</strong></p><p><strong>背景</strong>：当主节点出现故障时，服务可能会中断。</p><p><strong>解决方法</strong>：</p><ul><li>通过配置主从复制和搭建哨兵集群，当主节点故障时，一个从节点可以被晋升为新的主节点，这样，服务可以快速恢复，减少停机时间。</li></ul><h3 id="主从复制的局限性及其解决策略"><a href="#主从复制的局限性及其解决策略" class="headerlink" title="主从复制的局限性及其解决策略"></a>主从复制的局限性及其解决策略</h3><p>前文详细介绍了 Redis 主从复制的基本概念及其工作原理和配置方法。但如同所有技术一样，主从复制也有其局限性。为了更全面地应用 Redis，接下来我们将探讨其局限性及其解决策略。</p><ol><li>单点故障（SPOF）</li></ol><ul><li><strong>局限性</strong>：如果主节点发生故障，整个系统的写能力会受到影响，直到手动干预恢复或切换到从节点。</li><li><strong>解决策略</strong>：部署Redis哨兵（Sentinel）系统来实现故障自动检测和主节点的自动故障转移，减少系统恢复时间，提高可用性。</li></ul><ol start="2"><li>数据一致性问题</li></ol><ul><li><p><strong>局限性</strong>：在 Redis 主从复制中，数据更新首先在主节点上进行，然后异步复制到从节点。这种异步复制是滞后的，从节点的数据状态可能落后于主节点，导致读操作可能读取到过时的数据。</p></li><li><p><strong>解决策略</strong>：</p><p><strong>a. 对于读操作</strong>：为了减少读取过时数据的风险，可以人为地在从节点上引入延迟回应读请求的机制。这意味着从节点会等待一定的时间（足以让大部分的写操作被复制）后再回应读请求。这种策略并不是 Redis直接提供的功能，而是需要通过应用逻辑或中间件来实现。具体做法可能包括在应用程序中增加缓冲逻辑，或者使用代理层来控制对从节点的读请求延迟。</p><p><strong>b.对于写操作</strong>:<br>使用 WAIT 命令，WAIT 命令是 Redis 提供的一种机制，允许在写操作后等待直到指定数量的从节点确认接收到了这次更新。这样可以在写入数据后立即强制数据同步，减少数据不一致的风险。具体实现就是在执行关键写操作后，通过调用 WAIT 命令并指定要等待的从节点数量和超时时间，可以确保这些更新在继续执行后续操作前被足够多的从节点接收，从而提高整体数据一致性。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WAIT 命令格式：WAIT &lt;numslaves&gt; &lt;timeout&gt;</span><br><span class="line">&lt;numslaves&gt;：等待确认写操作的从节点数量。</span><br><span class="line">&lt;timeout&gt;：等待的最长时间（毫秒）。如果超时，命令会返回实际确认的从节点数量，即使这个数量小于&lt;numslaves&gt;。</span><br></pre></td></tr></table></figure><p><strong>3. 写入能力受限</strong></p><ul><li><strong>局限性</strong>：所有的写操作都必须由主节点处理，限制了系统的整体写入吞吐量。</li><li><strong>解决策略</strong>：通过搭建Redis集群，分散写入操作到多个主节点，实现写入能力的水平扩展。</li></ul><h2 id="Redis-哨兵"><a href="#Redis-哨兵" class="headerlink" title="Redis 哨兵"></a>Redis 哨兵</h2><p>通过 Redis 的主从复制机制，我们可以实现数据的冗余备份，负载均衡。但在实际的生产环境中仅仅有主从复制是不够的。当主节点出现故障时，系统如何自动、快速地将一个从节点提升为新的主节点以保证服务的连续性呢？这就引出了我们接下来要讨论的话题—Redis 哨兵 <strong>Sentinel</strong>。</p><p><img src="/images/RedisCluster/05.png"></p><h3 id="哨兵基本概念"><a href="#哨兵基本概念" class="headerlink" title="哨兵基本概念"></a>哨兵基本概念</h3><h4 id="什么是哨兵？"><a href="#什么是哨兵？" class="headerlink" title="什么是哨兵？"></a>什么是哨兵？</h4><p>Redis 哨兵是一种监控工具，确保你的 Redis 始终可用。想象一下，你的主Redis 节点突然停机了，怎么办？这时，<strong>哨兵</strong>进入舞台中央！它自动检测问题，并迅速选择一个备用 Redis（从节点）来接管，确保数据服务不中断。</p><h3 id="哨兵的配置和部署"><a href="#哨兵的配置和部署" class="headerlink" title="哨兵的配置和部署"></a>哨兵的配置和部署</h3><h4 id="哨兵的配置"><a href="#哨兵的配置" class="headerlink" title="哨兵的配置"></a>哨兵的配置</h4><p>Redis 哨兵使用的配置文件是 <strong>sentinel.conf</strong></p><p>这里，我只讲解几个重要的配置项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 哨兵的监听端口</span><br><span class="line">port 26379</span><br><span class="line"># yes 代表哨兵以后台的方式启动</span><br><span class="line">daemonize yes</span><br><span class="line"># 设置哨兵的日志文件路径</span><br><span class="line">logfile &quot;/var/log/redis/sentinel.log&quot;</span><br><span class="line"></span><br><span class="line"># 为哨兵指定要监控的主节点。</span><br><span class="line"># mymaster，127.0.0.1，6379 分别是主节点的名字，主节点的ip地址，端口</span><br><span class="line"># 数字2 代表的是故障转移的阈值（这意味着，当2个哨兵都同意主节点不可用时，故障转移过程才会开始。）</span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6379 2  </span><br><span class="line"></span><br><span class="line">#设置哨兵等待主节点响应的时间，超过30s 代表主节点主观下线。</span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line">#当哨兵完成主从切换之后，这个配置决定有多少个从节点可以同时与新的主节点进行数据同步。</span><br><span class="line">sentinel parallel-syncs mymaster 1                 </span><br></pre></td></tr></table></figure><h4 id="哨兵的部署"><a href="#哨兵的部署" class="headerlink" title="哨兵的部署"></a>哨兵的部署</h4><p>为了确保更高的可靠性和稳定性，建议在至少三台机器上分别部署哨兵实例以形成一个集群。</p><p><strong>分别在三台机器上执行以下命令启动哨兵</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel /path/to/sentinel.conf</span><br><span class="line"></span><br><span class="line"># /path/to/sentinel.conf   哨兵配置文件的实际路径</span><br></pre></td></tr></table></figure><h4 id="哨兵集群交互图"><a href="#哨兵集群交互图" class="headerlink" title="哨兵集群交互图"></a>哨兵集群交互图</h4><p><img src="/images/RedisCluster/06.png"></p><p>哨兵集群中，关于哨兵与哨兵、哨兵与节点之间的通信，有以下三个核心问题需要我们弄清楚：</p><ol><li>哨兵与主节点之间的连接是如何建立的？</li><li>各个哨兵实例是如何建立连接的？</li><li>哨兵又是如何与从节点进行连接的？</li></ol><p><strong>第一个问题：</strong></p><p><strong>sentinel.conf</strong>  中提供了以下配置项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor 主节点名字 主节点ip 主节点端口  quorum</span><br></pre></td></tr></table></figure><p>该配置项提供了主节点的 ip 和 端口, 哨兵通过该地址就可以与主节点建立连接，从而监控它。</p><p><strong>第二个问题：</strong></p><p>哨兵之间的互相发现和连接主要基于 Redis 的发布与订阅机制：</p><p>当哨兵启动并监控主节点时，它会订阅主节点的 <code>__sentinel__:hello</code> 频道，并且也会在 <code>__sentinel__:hello</code> 频道上定期发布自己的信息（如IP和端口）。这样各个哨兵就可以实时获取到对方的 IP 地址和 端口信息。</p><p>通过观察上面的交互图，我们可以看到哨兵 B 会先订阅主节点频道 <code>__sentinel__:hello</code>，哨兵 A 、C 会定期在该频道上发布自己的 IP 地址和端口信息，因此，哨兵 B 就会实时获取到 A、C 的地址端口信息，从而与它们建立连接并通信。</p><p><strong>第三个问题：</strong><br>哨兵是通过定时发送 <code>INFO Replication</code> 命令给主节点，来获取所有从节点的 IP 地址和端口信息的。这样，哨兵就可以分别和各个从节点建立连接并进行通信。</p><p><strong>INFO Replication</strong> 的响应：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; INFO Replication</span><br><span class="line"># Replication</span><br><span class="line">role:master</span><br><span class="line">connected_slaves:2</span><br><span class="line">slave0:ip=192.168.1.1,port=6381,state=online,offset=1249761,lag=0</span><br><span class="line">slave1:ip=192.168.1.2,port=6380,state=online,offset=1249761,lag=1</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"># slave0、slave1、slaveXX 等代表的是各个从节点的信息。</span><br></pre></td></tr></table></figure><h3 id="哨兵的工作原理"><a href="#哨兵的工作原理" class="headerlink" title="哨兵的工作原理"></a>哨兵的工作原理</h3><p>我们都体验过这样的时刻：正当电视剧来到精彩的高潮，突然电视信号断开。如果此时，系统自动帮你切换到一个备用频道，继续播放剧情，你的体验会不会好很多？这正是 <strong>Redis 哨兵</strong>所提供的功能。</p><p>在数据世界中，当 Redis 主节点遇到问题，哨兵就如同这个智能切换系统，自动选择一个备用节点，确保服务的持续。</p><p><strong>这一切都归功于哨兵的三大核心职责：哨兵监控、哨兵 Leader 选举、故障转移与恢复。</strong></p><p>接下来，让我们探索这三大功能如何确保 Redis 服务的稳定运行。</p><h4 id="哨兵监控"><a href="#哨兵监控" class="headerlink" title="哨兵监控"></a>哨兵监控</h4><p><strong>Redis 哨兵监控图示:</strong> </p><p><img src="/images/RedisCluster/07.png"></p><p>通过上图我们可以看到，哨兵集群是通过定期发送 PING 命令到主节点和从节点，等待它们的 PONG 响应来监控它们的健康状态。如果在设定的时间间隔内（比如 10s，配置项为：down-after-milliseconds）未收到回应，哨兵则认为相应的节点可能出现故障，并将其标记为<strong>「主观下线」</strong>状态。</p><p>上面在理解了<strong>「主观下线」</strong> 后，你可能会想，一个哨兵的主观判断足够可靠吗？实际上，为了避免单点判断误差，哨兵系统一般以集群的方式部署，并且采取一种更集体、更“客观”的判断方式来判定主节点处于下线状态。</p><p><strong>更“客观”的判断方式</strong> ：</p><p>当一个哨兵认为某节点<strong>「主观下线」</strong> 后，它会询问其他哨兵是否也觉得该节点不可用。只有当超过半数的哨兵都认为该节点下线时，节点状态才会被标记为<strong>「客观下线」</strong> 。这种方式确保了系统对主节点状态的判断更为准确和可靠。一旦主节点被哨兵系统判定为<strong>「客观下线」</strong> 状态后，哨兵系统才会进行后续步骤（<strong>哨兵 Leader 选举、故障转移</strong>）。</p><p><strong>主节点客观下线图解：</strong></p><p><img src="/images/RedisCluster/08.png"></p><p><strong>主节点客观下线图解步骤说明</strong>：</p><p><strong>1. 哨兵健康检查</strong>：</p><p>哨兵 A 尝试 PING 主节点，等待 PONG 响应。</p><p><strong>2. 主观下线判断</strong>：</p><p>如果哨兵 A 未收到响应，它将主节点标为 “主观下线”。</p><p><strong>3. 询问其他哨兵</strong>：</p><p>哨兵 A 向其他哨兵（如哨兵B、C）广播主节点主观下线的消息，消息格式为：<code>+sdown master 主节点ip 主节点port</code>。</p><p>哨兵B &amp; 哨兵C 根据自己的观察，回复是否同意主节点主观下线。</p><p>如果同意，则会向哨兵 A 回复消息 <code>+sdown master 主节点ip 主节点port</code> 。</p><p>如果不同意，则会选择不回复，哨兵 A 如果长时间收不到哨兵 B、C 的回复，则会判定哨兵 B、C 是不同意主节点主观下线。</p><p><strong>4. 主节点客观下线确认</strong></p><p>如果大多数哨兵都同意主节点是 “主观下线”，那么主节点就被确定为 “客观下线”。随后，哨兵开始选举 <strong>Leader</strong> ，启动故障转移。</p><h4 id="哨兵-Leader-选举"><a href="#哨兵-Leader-选举" class="headerlink" title="哨兵 Leader 选举"></a>哨兵 Leader 选举</h4><p>在 Redis 的哨兵模式中，<strong>Leader</strong> 选举过程是至关重要的。当主节点出现问题时，为确保系统的稳定和高可用，哨兵们需要通过投票机制决定一个<strong>哨兵「Leader」</strong>来处理这次的故障切换。</p><p>但我们得知道，哨兵不是单独工作的，它们通常是以集群形式部署的。在这个集群中，哨兵可以分为两类：<strong>普通哨兵和候选哨兵</strong>。</p><p><strong>普通哨兵</strong>：它们的主要任务是持续监测Redis主从节点的健康状态。当它们观察到主节点无法正常响应时，它们会标记这个主节点为“主观下线”。</p><p><strong>候选哨兵</strong>：第一个发现主节点“客观下线”的哨兵就有资格成为候选哨兵，它会尝试启动选举过程，成为领导来处理主节点的故障。</p><p><strong>注意： 只要候选哨兵才能够参与选举 Leader</strong>。</p><p><strong>Leader 选举时序图</strong>：</p><p><img src="/images/RedisCluster/09.png"></p><p><strong>Leader 选举步骤详解</strong>：</p><p><strong>1. 请求投票</strong></p><ul><li><p>广播请求：<br>候选哨兵会广播一个特定的消息给所有其他哨兵，这个消息可以被理解为：“我认为主节点下线了（客观下线），我可以恢复请投票支持我。</p><p><strong>消息请求格式</strong>：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># ip ，port 是主节点的 IP 地址和端口。current-epoch 是请求哨兵的当前纪元，candidate-name 是请求成为领导者的哨兵的名称。</span><br><span class="line">SENTINEL is-master-down-by-addr &lt;ip&gt;  &lt;port&gt;  &lt;current-epoch&gt;  &lt;candidate-name&gt;</span><br><span class="line"></span><br><span class="line"># “纪元”（epoch）指的是一个递增的整数，用于标识故障转移尝试的次数和同步哨兵之间的状态。</span><br></pre></td></tr></table></figure><ul><li>响应与投票：</li></ul><p>如果其他哨兵觉得主节点还在线，它们拒绝投票。</p><p>如果其他哨兵同样觉得主节点下线并且还未投票，它们支持当前候选哨兵。</p><p><strong>响应消息格式</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># &lt;down-state&gt;     : 是一个整数，1 表示响应者认为主节点下线，0 表示认为主节点在线</span><br><span class="line"># &lt;leader-epoch&gt;   : 是 响应者 知道的最大的领导者纪元</span><br><span class="line"># &lt;candidate-name&gt; : 是响应者认为的当前选举的候选领导者的名字。</span><br><span class="line">&lt;down-state&gt; &lt;leader-epoch&gt; &lt;candidate-name&gt;</span><br></pre></td></tr></table></figure><ul><li>多个候选哨兵的处理</li></ul><p>如果在一个较短的时间窗口内，有多个哨兵都检测到主节点的客观下线并广播成为 Leader 的请求，其他哨兵需要做出选择。在同一纪元中，每个哨兵只能投票一次，通常倾向于支持最早发起请求的候选哨兵。</p><p><strong>2. 统计投票结果</strong></p><p>当候选哨兵收到的投票数达到哨兵总数的大多数时（超过半数），该候选哨兵就已经赢得了这次选举，成为哨兵 Leader，从而进行下一步操作 : <strong>故障转移</strong>。</p><p>上面的”半数“由配置项 <code>sentinel monitor mymaster 127.0.0.1 6379 2</code> 中的 quorum 参数（最后一个参数）决定。</p><h4 id="哨兵-Leader-进行故障转移与恢复"><a href="#哨兵-Leader-进行故障转移与恢复" class="headerlink" title="哨兵 Leader 进行故障转移与恢复"></a>哨兵 Leader 进行故障转移与恢复</h4><p>Redis 哨兵 Leader 的核心目标是自动选择一个新的主节点来替代失效的主节点。那么，具体是如何进行的呢？</p><p><strong>第一步：选出新主节点</strong></p><p>在所有的从节点中，哨兵 Leader 会找出一个最适合的节点来替代失效的主节点。选择的准则包括：</p><ul><li><p><strong>主从节点断开时间</strong></p><p>哨兵 Leader 会检查从节点与主节点断开的时间。如果这段时间太长，超出<strong>预设值</strong>，则这个从节点可能数据不新鲜或不稳定，不适合成为新主节点。</p><p><strong>预设值</strong>：$(down—after-milliseconds * 10) + $milliseconds_since_master_is_in_SDOWN_state$ $</p><p><strong>公式解释</strong>：主从服务器超时时间的十倍加上从哨兵 Leader 看主服务器不可用的时间。</p><p><strong>down—after-milliseconds</strong> : 主从服务器超时时间。<br><strong>milliseconds_since_master_is_in_SDOWN_state</strong> : 指的是哨兵 Leader 认为主节点进入主观下线状态后经过的时间。</p></li><li><p><strong>从节点优先级</strong></p><p>哨兵 Leader 根据主从节点断开时间就可以剔除不合适的从节点，接着将根据从节点的优先级进行过滤。</p><p>每个 Redis 从节点都有一个 replica-priority 配置值，表示节点的优先级。数值越小，优先级越高，其被选作新主节点的机会就越大。Redis 哨兵 Leader 首先会选择优先级比较高的从节点作为新的主节点。</p></li><li><p><strong>已处理的复制偏移量</strong></p><p>接着哨兵 Leader 会考虑从节点数据的新鲜度。在优先级相同的情况下，数据更新得越频繁的从节点更可能被选为新主节点。</p></li><li><p><strong>运行 ID</strong></p><p>运行 ID 是每个 Redis 实例启动时生成的唯一标识。当上述条件都相同时，哨兵 Leader 会选择字母顺序中运行 ID 最小的从节点，保证了选择的一致性。</p></li></ul><p><strong>选定新主节点后，哨兵 Leader 会发送 SLAVEOF no one 命令，将该从节点转化为主节点状态。</strong></p><p><strong>第二步：从节点连接新主节点</strong></p><p>哨兵 Leader 向每个从节点发出 <code>SLAVEOF [新主节点的IP] [新主节点的端口]</code> 指令。从节点执行该指令后，会首先与原主节点断开连接，然后与新主节点建立连接，并开始同步数据。</p><p><strong>第三步：将旧的主节点变成从节点</strong></p><p>旧的主节点恢复后，它不再是主节点，因为我们已经有了新的主节点。为了避免数据冲突和保证数据一致性，哨兵需要做以下调整：</p><p><strong>检测旧主节点</strong>：</p><p>哨兵会持续地监控所有的 Redis 节点，包括旧的主节点。当检测到旧的主节点重新上线并变得可达时，哨兵会进行下一步操作。</p><p><strong>自动降级和数据同步</strong>：</p><p>接着，哨兵 Leader 会自动发送 <code>SLAVEOF [新主节点的IP] [新主节点的端口] </code>命令给旧的主节点。这会指示旧的主节点开始从新的主节点复制数据，并且降级为从节点。</p><p><strong>持续监控</strong>：</p><p>哨兵集群会继续监控这个旧的主节点，以及其他所有节点，确保整个系统的稳定运行。</p><p><strong>第四步：通知应用程序和客户端</strong></p><p>新主节点准备就绪后，为保证数据的正常存取，我们必须让外部应用和客户端知晓这一变化。此时，哨兵通过 Redis 的<strong>发布&#x2F;订阅（Pub&#x2F;Sub）</strong> 机制来发送通知。</p><p><strong>了解一下 Redis 的发布&#x2F;订阅：</strong></p><p><strong>发布者</strong> ：负责发送消息到特定的频道。</p><p><strong>订阅者</strong> ：负责接收某个频道上的消息。</p><p><strong>频道</strong>   ：频道是消息传递的媒介。</p><p><strong>事件</strong>   ：当在一个特定的频道上发布了一个消息时，这就是一个事件。事件表示了某种特定的状态改变或通知。</p><p>发布者（如哨兵）可以将消息发送到特定的频道，而所有订阅了该频道的订阅者都会收到这个消息。</p><p><strong>哨兵如何使用发布&#x2F;订阅？</strong></p><p>首先，当哨兵 Leader 完成故障转移的主从切换之后，它就会记录下新主节点的 IP 和端口信息，并通知整个哨兵集群。</p><p><strong>消息发布</strong>：</p><p>接收到新主节点信息的所有哨兵（无论是 Leader 还是其他哨兵）都会利用 Redis 的发布&#x2F;订阅功能，在各自的 <strong>+switch-master</strong> 频道上发布这一新信息。</p><p><strong>客户端订阅与接收</strong>：客户端和应用程序只需向哨兵节点订阅该频道，即可实时获取新主节点的IP 地址和端口信息。</p><p><strong>例如</strong>：想要监听主从节点切换的通知，客户端只需向哨兵节点订阅<br><code>SUBSCRIBE +switch-master</code> 频道 ，这样，一旦有主从节点切换，通过这个订阅，客户端会立即被通知新的主节点 IP 和端口信息。</p><h3 id="哨兵的优点"><a href="#哨兵的优点" class="headerlink" title="哨兵的优点"></a>哨兵的优点</h3><ul><li><strong>高可用性</strong>：</li></ul><p>当 Redis 主节点（master）出现故障时，哨兵能够自动将某个从节点（slave）晋升为新的主节点，确保 Redis 服务的持续可用性。</p><ul><li><strong>服务发现</strong>:</li></ul><p>客户端和应用程序可通过 Redis 的发布&#x2F;订阅功能实时查询哨兵，以获取当前主节点的最新地址信息。</p><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p>回想一下，前面我们聊到了 Redis 的主从复制和哨兵，让我们进行一个小回顾：</p><p><strong>Redis的主从复制</strong>：简单来说，就是一个主节点有多个从节点复制其数据，这样做的好处是可以分摊读取的压力。</p><p><strong>哨兵机制</strong>：当主节点出现问题时，哨兵会帮我们自动选出一个新的主节点，确保系统不会因为一个节点的故障而中断。</p><p>听起来很完美对吧？但随着我们数据的增长，有一个问题逐渐浮现：如果我们的数据量超出了一个服务器的处理能力怎么办？毕竟单台服务器的资源是有限的。或者说，我想更快地读写数据，单纯的复制够用吗？</p><p>为了解决这样的问题，Redis 推出了一个叫做“集群”的模式。简单来说，它就是把数据分散到多个服务器上，让每个服务器只处理一部分数据，从而达到“集体努力”的效果。</p><p>听起来很酷吧？但是它是如何工作的？在我们接下来的探讨中，我们会一步步揭开 Redis 集群的神秘面纱，让大家对它有一个更加清晰的认识！</p><p><img src="/images/RedisCluster/10.png"></p><h3 id="Redis-集群基本概念"><a href="#Redis-集群基本概念" class="headerlink" title="Redis 集群基本概念"></a>Redis 集群基本概念</h3><h4 id="什么是-Redis-集群？"><a href="#什么是-Redis-集群？" class="headerlink" title="什么是 Redis 集群？"></a>什么是 Redis 集群？</h4><p>Redis 集群是一种允许多个 Redis 节点协同工作的技术，它提供了数据分片和故障恢复能力。在 Redis 集群中，数据会被划分为多个分片，每个分片存储在不同的节点上。这不仅使 Redis 能够存储更多的数据，而且，当某个节点出现故障时，其他节点可以迅速地接管它的任务，确保整体服务的连续性。</p><h4 id="为什么需要集群？"><a href="#为什么需要集群？" class="headerlink" title="为什么需要集群？"></a>为什么需要集群？</h4><p><strong>数据增长</strong>：随着应用程序和业务的发展，数据量持续增长，可能超出单个 <strong>Redis</strong> 实例的处理能力。</p><p><strong>业务持续性</strong>：为了确保业务的持续运行，即使在硬件故障或其他问题的情况下，我们需要一种更稳健的解决方案。</p><p><strong>性能要求</strong>：随着用户基数的增长和服务的扩展，性能要求也随之提高，集群可以提供更好的读写能力。</p><h3 id="Redis-集群的工作原理"><a href="#Redis-集群的工作原理" class="headerlink" title="Redis 集群的工作原理"></a>Redis 集群的工作原理</h3><h4 id="数据分片"><a href="#数据分片" class="headerlink" title="数据分片"></a>数据分片</h4><p><strong>什么是数据分片？</strong></p><p>在 <strong>Redis</strong> 集群中，数据分片是将所有的键分布到多个节点上的方法，从而每个节点只需要持有整个数据集的一部分。</p><p><strong>数据分片的好处</strong></p><ul><li><p>横向扩展：随着数据或请求负载的增长，可以简单地添加更多的节点来分担负载。</p></li><li><p>增加总吞吐量：因为数据和请求被分散到多个节点，每个节点只处理一部分的数据和请求，因此整体吞吐量得到提升。</p></li></ul><p> <strong>数据如何在集群中分片？</strong></p><p>在 Redis 集群中，数据的分布取决于一个非常核心的概念，那就是<strong>哈希槽</strong>。那么，这一切是如何工作的呢？</p><p><strong>1. 哈希槽：集群的基石</strong></p><p>Redis 集群总共定义了 16384 个哈希槽。</p><p>这些哈希槽的职责就是确定一个特定的键应该被存储在哪个节点上。</p><p><strong>2. 如何映射键到哈希槽？</strong></p><p>当你尝试在集群中保存一个键值对时，Redis 并不是随机选择一个哈希槽。</p><p>它使用键的名字，对其进行计算，确定应该归属于哪个哈希槽。</p><p><strong>计算公式</strong>：</p><p>$slot &#x3D; CRC16(key) \mod 16384$</p><p>CRC16 :计算键的哈希值的函数，slot 是该键所对应的槽号。</p><p>这意味着每个键名都会被映射到 0 到 16383 之间的某个哈希槽。</p><p><strong>3. 哈希槽与节点：亲密的伙伴</strong></p><p>当集群设置完毕后，这些哈希槽会被均匀地分配到所有的主节点上。当然也可以通过手动的方式进行分配。</p><p>比如，如果你有三个主节点，如果是均匀分配的话，可能第一个节点负责前 5461 个哈希槽，第二个节点负责接下来的 5461 个，第三个节点负责剩余的。</p><p> <strong>4. 客户端请求：如何找到正确的节点？</strong></p><ul><li>当客户端想要读取或写入一个键时，它会先计算出这个键应该属于哪个哈希槽。</li><li>知道了哈希槽，它就能找到对应的节点，并向该节点发送请求。</li></ul><p><strong>为了便于理解，我画一张示意图来解释一下，数据、哈希槽、主节点这三者的映射关系：</strong></p><p><img src="/images/RedisCluster/11.png"></p><h4 id="节点的角色：主节点与从节点"><a href="#节点的角色：主节点与从节点" class="headerlink" title="节点的角色：主节点与从节点"></a>节点的角色：主节点与从节点</h4><p>在 <strong>Redis</strong> 集群中，数据分片使得数据分布在多个节点上，而这些节点分为<strong>主节点</strong>和<strong>从节点</strong>。它们各自承担不同的职责，共同确保 <strong>Redis</strong> 集群的高可用性和高性能。</p><p><strong>Redis 集群节点交互图：</strong></p><p><img src="/images/RedisCluster/12.png"></p><p><strong>主节点 （Master Node）</strong></p><p><strong>主节点是 Redis 集群的核心，它们的职责如下：</strong></p><ul><li><p><strong>数据存储</strong>：每个主节点都负责存储整个数据集的一个子集，这取决于它所管理的哈希槽。</p></li><li><p><strong>处理写请求</strong>：所有写入数据的请求（例如：SET, HSET 等）都直接发送到相应的主节点。</p></li><li><p><strong>管理从节点</strong>：主节点负责向其从节点同步数据，确保数据的一致性。</p></li></ul><p><strong>从节点 （Slave Node）</strong></p><p>从节点为 <strong>Redis</strong> 集群提供额外的数据冗余和读取能力，每个主节点都会有一个或多个从节点，它们的职责如下：</p><ul><li><p><strong>数据备份</strong>：从节点复制并存储其对应主节点上的数据，为系统提供一个数据的备份。</p></li><li><p><strong>处理读请求</strong>：为了分担主节点的读负载，客户端可以从从节点读取数据。</p></li><li><p><strong>故障转移</strong>：如果主节点故障，从节点可以被晋升为新的主节点，继续为客户端提供服务。</p></li></ul><p><strong>如何在节点之间进行数据的读写？</strong></p><ul><li><p><strong>写操作</strong>：客户端首先计算键的哈希槽，确定应该由哪个主节点处理，然后直接向该主节点发送写请求。</p></li><li><p><strong>读操作</strong>：客户端可以选择从主节点或其任何从节点读取数据。当从节点用于读操作时，它可以帮助提高整体的读取性能，特别是在读操作比写操作多的场景下。</p></li></ul><h4 id="Redis-集群与-Gossip-协议"><a href="#Redis-集群与-Gossip-协议" class="headerlink" title="Redis 集群与 Gossip 协议"></a>Redis 集群与 Gossip 协议</h4><p>在深入了解 Redis 集群中的各个节点的角色之后，你可能会产生这样的疑问：这些节点如何找到彼此，并高效地共享信息和状态呢？当某个节点遇到问题时，其他节点如何迅速得知并做出相应调整？</p><p><strong>答案在于 Redis 集群采用的一个特殊的通信机制—“Gossip” 协议。</strong></p><p><strong>什么是 Gossip 协议？</strong></p><p>让我们用一个简单的例子来理解。想象一下，你在一个聚会上分享了一个趣事给几位朋友，这些朋友又告诉了其他人。很快，整个聚会上的人都知道了这个趣事。这种信息的传播方式，就是 Gossip 协议的核心思想：<strong>节点间通过“聊天”来共享和扩散信息。</strong></p><p>更专业地说，<strong>Gossip 协议</strong>是一种在分布式系统中进行信息同步和故障检测的轻量级通信机制。节点随机选择其他节点交换信息和状态。</p><p><strong>Redis 集群如何应用 Gossip 协议？</strong></p><p>Redis 集群的 Gossip 协议是基于传统 Gossip 协议之上进行的优化，以满足其特定的需求和特性。</p><ul><li><p><strong>节点发现</strong>：</p><p>新加入的节点使用 <strong>Gossip 协议</strong>来识别和握手与集群中的现有节点。进而将自己加入到集群中。</p></li><li><p><strong>状态交换</strong>：</p><p>节点定期使用 <strong>Gossip</strong> 协议与其他节点交换自身及已知的其他节点状态，节点状态包括：节点角色、节点的健康状态，是正常、故障、还是疑似故障。</p></li><li><p><strong>故障检测与通知</strong>：</p><p>如果某节点发现另一节点长时间无响应，它会利用 Gossip 协议迅速传播这一信息，确保整个集群得到通知并采取行动。</p></li><li><p><strong>数据路由</strong>：</p><p>在 Redis 集群中，数据的存储与检索是基于哈希槽的。节点之间需要交换它们各自负责的哈希槽信息，确保客户端请求能准确路由到对应的节点。</p></li></ul><p><strong>总结</strong>：</p><p><strong>Redis</strong> 集群利用 <strong>Gossip</strong> 协议实现节点间的有效通信，确保节点发现、状态同步、故障检测与通知以及数据路由，从而保障集群的高可用性和数据一致性。</p><h4 id="Redis-集群的故障转移与恢复"><a href="#Redis-集群的故障转移与恢复" class="headerlink" title="Redis 集群的故障转移与恢复"></a>Redis 集群的故障转移与恢复</h4><p>当我们谈论 Redis 集群的鲁棒性时，故障转移与恢复是不可或缺的部分。这确保即使面临节点故障，集群仍然可以正常运行。</p><p><strong>什么是故障转移？</strong></p><p>当主节点遇到问题并无法正常工作时，从节点准备接管并成为新的主节点。这个过程被称为故障转移。</p><p>你或许还记得，在哨兵模式中也有故障转移的流程。但 <strong>Redis</strong> 集群采用了其独有的故障转移策略，完全无需哨兵的介入。尽管两者在故障转移上有诸多相似之处，但关键的不同在于：<strong>Redis</strong> 集群不依赖于外部的监视器（哨兵），而是依赖集群内部的节点来共同参与和决策来实现故障转移。</p><p><strong>接下来，让我们来看下 Redis 集群故障转移与恢复的具体步骤：</strong></p><p><strong>故障转移第一步：故障检测</strong></p><p><strong>主观下线</strong>:</p><p>每个节点通过发送 <strong>PING</strong> 指令来周期性地对其他节点进行健康检查。若某节点在一个预定的 <strong>cluster-node-timeout</strong> 间隔内未接收到特定节点的 <strong>PONG</strong> 回复，它将标记该节点为主观下线状态。此状态仅代表单一节点的观察结果，并非集群共识。</p><p><strong>客观下线</strong></p><p>单一节点的主观观察并不触发集群级别的行动。只有当超过集群半数的节点都标记某节点为主观下线时，该节点才被认定为<strong>客观下线</strong>。这确保了故障转移的决策基于<strong>多数节点</strong>的共识，从而增加决策的准确性。</p><p><strong>首先，让我们来看下 Redis 集群中节点客观下线的判断过程。实际过程可能会更复杂，我这里只是简单举例说明</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># 假设 Redis 集群目前存在 A、B、C、D、E 五个节点</span><br><span class="line"></span><br><span class="line">步骤1: </span><br><span class="line">A ------&gt; B (节点 A 向 节点 B 发送 PING 请求，X 代表未收到回复消息)</span><br><span class="line">       X</span><br><span class="line">       </span><br><span class="line">步骤2:</span><br><span class="line">A -------&gt; 其他节点 (广播：“我认为B有问题！”)</span><br><span class="line"></span><br><span class="line"># 广播消息格式：&lt;当前节点ID&gt; FAIL &lt;被认为故障的节点ID&gt; &lt;当前节点的当前时间戳&gt;</span><br><span class="line"></span><br><span class="line">步骤3:</span><br><span class="line">其他节点分别发送 PING 请求 检查与 B 的通信情况：</span><br><span class="line"></span><br><span class="line">C -------&gt; B</span><br><span class="line">       X</span><br><span class="line">D -------&gt; B</span><br><span class="line">       X</span><br><span class="line">E -------&gt; B</span><br><span class="line">       ✓</span><br><span class="line"></span><br><span class="line">步骤4:</span><br><span class="line">收集所有关于B的故障报告：</span><br><span class="line"></span><br><span class="line">A: B故障</span><br><span class="line">C: B故障</span><br><span class="line">D: B故障</span><br><span class="line">E: B响应正常</span><br><span class="line"></span><br><span class="line">步骤5:</span><br><span class="line">如果超过半数的节点报告 B 故障，B 被标记为客观下线。接下来就是故障转移第二步。</span><br></pre></td></tr></table></figure><p> <strong>故障转移第二步：从节点晋升</strong></p><p>当一个主节点被确定为客观下线，需要从其关联的从节点中选举一个进行晋升，来替代失效的主节点。</p><p>主节点一般都会有多个从节点，这就带来了一个问题：<strong>在多个从节点中，哪一个是最合适的候选者来晋升为新的主节点？</strong></p><p>为了确定最佳的从节点，Redis 集群使用以下的选举策略来挑选从节点。</p><ul><li><p><strong>数据同步进度</strong>：</p><p>每个从节点都会定期与其主节点进行数据同步。但因为网络或其他原因，有些从节点的数据可能更新。在故障转移时，拥有最新数据的从节点将被优先考虑，以减少数据丢失。</p></li><li><p><strong>配置优先级</strong>：</p><p>在数据同步进度相同的情况下，优先级较高（值较小）的从节点会被选为新的主节点。</p></li><li><p><strong>网络连接质量</strong>：</p><p>如果上面的两个条件都一样，Redis 则会考虑网络连接稳定、响应时间短的从节点成为新的主节点，因为它更有可能快速且准确地响应客户端的请求。</p></li></ul><p>当从节点被选择并晋升为新的主节点后，整个集群需要进行<strong>自动重新配置</strong>来适应这种变化：</p><p><strong>自动重新配置</strong>：</p><ul><li><strong>哈希槽分配</strong>：新晋升的主节点会自动接管失效主节点的哈希槽，确保集群数据的连续访问性。</li><li><strong>集群元数据更新</strong>：为了适应拓扑变化，集群中的其他节点会更新其内部的元数据和配置(比如：新主节点的 ip 地址和 port 信息)，以识别并与新的主节点通信。</li></ul><p> <strong>故障转移第三步：故障恢复</strong></p><p><strong>1. 数据同步</strong>：</p><p>为了确保数据的一致性和完整性，新晋升的主节点需要分别和其他从节点之间建立连接并进行数据同步：</p><ul><li><p>那些继续作为从节点的节点会开始与新的主节点同步数据，这是为了确保从节点的数据是最新的。</p></li><li><p>同步过程可以是全量复制，也可以是部分复制，具体取决于自上次成功同步以来的数据变化量。</p></li></ul><p><strong>2. 客户端重新连接</strong>: </p><p>故障期间，客户端可能遭受了中断。为了恢复正常的数据库操作，它们需要重新定位并连接到新晋升的主节点。</p><p><strong>3. 旧主节点的恢复</strong>：</p><p>如果原先的失效主节点后来恢复了，并重新加入了集群，它将不再作为主节点，而是会被降级为从节点。</p><p>并且还需要与新的主节点同步数据，确保它自己的数据与新主节点的其他从节点数据一致。</p><p><strong>这里顺便提个问题：在上述故障恢复的第二步：客户端重新连接中，客户端如何知道新主节点的 IP 地址和端口信息的？</strong></p><p>我直接说答案吧，一般有以下两种做法：</p><p><strong>1. 客户端的 Redis Cluster 支持</strong>：这是最常见的方法。许多现代的 Redis 客户端，如 Redis-py （Python）、Jedis （Java）、Redigo （Go） 等，都内置了对 Redis Cluster 的支持。这些客户端会自动处理 “MOVED” 错误，重新路由请求到正确的节点，并更新其内部的节点映射缓存。使用这种方法可以大大简化应用程序的开发和维护，因为客户端库会自动处理集群的变动。</p><p><strong>2. 集群发现</strong>：对于那些需要更细粒度控制的应用或者使用没有内置 Redis Cluster 支持的客户端的场景，集群发现是一个有用的方法。通过定期发送 CLUSTER NODES 或 CLUSTER SLOTS 命令，应用程序可以自己管理和更新哈希槽到节点的映射。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#返回集群中所有节点的信息。返回的信息包括每个节点的 ID、地址、角色（主/从）、与其他节点的关系、哈希槽范围等</span><br><span class="line">CLUSTER NODES：</span><br><span class="line"></span><br><span class="line"># 返回集群中哈希槽和其相应节点的映射信息。这对于理解哪个节点负责哪些哈希槽非常有用。</span><br><span class="line">CLUSTER SLOTS</span><br></pre></td></tr></table></figure><h4 id="重新分片"><a href="#重新分片" class="headerlink" title="重新分片"></a>重新分片</h4><p>在我们了解 <strong>Redis</strong> 集群的节点角色和故障转移后，有一个非常重要的概念需要讲解：<strong>重新分片</strong>。随着数据量的增长或节点的变化，我们可能需要调整数据在集群中的分布。这就涉及到重新分片的过程。</p><p><strong>什么是重新分片？</strong></p><p>重新分片是一个过程，允许你在集群的不同节点之间移动哈希槽，这样可以确保数据在集群中均匀分布。</p><p><strong>为什么要进行重新分片？</strong></p><p><strong>集群扩展</strong>：随着业务的增长，我们可能需要添加更多的节点到集群中。此时，需要将一部分数据迁移到新的节点。</p><p><strong>数据均衡</strong>：为了防止某个节点数据过多导致性能瓶颈，我们可能需要将数据在各个节点之间重新分布。</p><p><strong>接下来，让我们来看下 Redis 集群是如何进行重新分片的？</strong></p><p>Redis 集群进行重新分片主要是通过以下 5 个步骤来进行的。</p><p><strong>步骤 1: 检查集群信息</strong></p><p>首先，通过 <code>redis-cli -c -p 7000 cluster nodes </code>命令，你获得了一个集群状态的信息，包括每个节点的ID、状态、IP 地址和端口，以及它们负责的哈希槽范围。这为我们提供了一个集群的总体布局和节点间的哈希槽分配情况。</p><p><strong>步骤 2: 识别负载不平衡的节点以及确定源节点和目标节点</strong></p><p><strong>观察节点负载</strong>：这一步需要额外信息，比如使用 INFO 命令或其他监控工具来查看节点的内存使用、CPU 负载、网络带宽等指标。这些数据有助于我们识别出源节点和目标节点 。</p><p><strong>源节点选择</strong>：源节点通常是那些负载较高的节点，你可能会选择那些内存使用率高、处理大量请求的节点作为哈希槽迁移的起点。</p><p><strong>目标节点选择</strong>：目标节点则是负载相对较低，有能力接收更多哈希槽的节点。如果你最近向集群中添加了新节点，这些新节点也是很好的目标节点候选。</p><p><strong>步骤 3: 确定迁移的哈希槽</strong></p><p>现在，我们已经确定了要迁移哈希槽的源节点以及目标节点。接下来就要确定要迁移的源节点的哈希槽。</p><p>并没有直接的 Redis 命令可以告诉你每个哈希槽的详细数据量，因为 Redis 集群的设计是将数据分布在不同的哈希槽中，但你可以通过键的分布来间接获取每个哈希槽的数据量。这可能需要你编写脚本或使用现有的管理工具来帮助分析。</p><p><strong>比如：编写脚本统计每个哈希槽的键数量</strong> </p><p>可以遍历节点上的所有键，使用 <code>CLUSTER KEYSLOT</code> 命令确定每个键属于哪个哈希槽，然后对每个哈希槽的键数量进行计数。这需要通过 Redis 的命令行接口或客户端库来实现。</p><p><strong>这个脚本的基本逻辑是</strong>：</p><ul><li>连接到源节点。</li><li>使用 SCAN 命令遍历所有键（以避免大量键时的性能问题）。</li><li>对于 SCAN 返回的每个键，使用 CLUSTER KEYSLOT 命令确定其哈希槽。</li><li>维护一个计数器，对每个哈希槽内的键数量进行统计。</li></ul><p>通过脚本收集到每个哈希槽内键的数量后，你可以分析这些数据来确定哪些哈希槽的数据量较大。通常，数据量大的哈希槽可能会导致源节点负载较高。基于这个分析，你可以选择数据量大（可能负载也较高）的哈希槽进行迁移。至此，我们便可以知道源节点要迁移的哈希槽。</p><p><strong>步骤 4: 执行重新分片</strong></p><p>经过上面的步骤，我们已经可以确定源节点、源节点要迁移的哈希槽以及将哈希槽要迁移的目标节点。</p><p><strong>接下来，就要执行重新分片：</strong></p><p>这个过程可以手动完成，也可以使用 Redis 的自动重新分片工具。手动重新分片提供了更好的控制，但自动重新分片更方便。</p><p><strong>手动重新分片</strong>：</p><p>使用 <strong>redis-cli –cluster reshard</strong> 命令开始重新分片过程。该命令可以在集群的任意节点上执行。</p><p><code>redis-cli --cluster reshard &lt;任意节点的IP&gt;:&lt;任意节点的端口&gt;</code><br>该命令会启动一个交互式会话，询问你需要从哪个节点移动哈希槽，迁移哈希槽的范围，移动多少个哈希槽，以及目标节点。</p><p><strong>自动重新分片</strong>:<br>如果你希望自动重新分片，可以使用 <strong>–cluster-rebalance</strong> 选项。这会尝试自动平衡集群的哈希槽分配。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster rebalance &lt;any-node-ip&gt;:&lt;any-node-port&gt; --cluster-use-empty-masters</span><br><span class="line">这里，&lt;any-node-ip&gt;:&lt;any-node-port&gt; 是集群中任一节点的 IP 地址和端口号。</span><br><span class="line">--cluster-use-empty-masters 选项允许命令使用没有分配任何哈希槽的节点。</span><br></pre></td></tr></table></figure><p><strong>–cluster-use-empty-masters</strong> ：这个选项指示rebalance命令，在重平衡操作中包括那些当前未持有任何哈希槽的主节点。默认情况下，重平衡操作可能不会向这些空闲的主节点分配哈希槽，因为目标是在已有槽的节点之间进行平衡。启用这个选项后，重平衡逻辑会将这些空闲的主节点考虑在内，尝试向它们分配一些哈希槽，从而使得这些节点参与到集群的工作负载中。</p><p><strong>步骤五:分片完成后的检查</strong></p><p><strong>验证集群状态</strong></p><p>首先使用 <code>redis-cli --cluster check</code> 命令：</p><p>这个命令提供了一种快速检查 Redis 集群状态的方法。它会检测诸如配置不一致、连接问题及槽分配不均等的问题。</p><p>执行命令：<code>redis-cli --cluster check &lt;any-node-ip&gt;:&lt;any-node-port&gt;</code>。这里，<any-node-ip>:<any-node-port> 代表集群中任意节点的IP地址和端口号。</p><p>命令输出将报告集群健康状况，包括所有节点是否在线、槽是否被正确分配和覆盖全范围、以及是否有任何节点之间的配置不匹配。</p><p><strong>确保节点可达性和同步状态</strong>：</p><p>检查命令输出中的每个节点状态，确认它们都是可达的并且处于联机状态。<br>确认所有的节点都正确同步了其他节点的状态信息，尤其是槽的分配信息。这一点对于集群的稳定运行和高可用性至关重要。</p><p><strong>监控重平衡效果</strong></p><p><strong>观察性能指标</strong>：</p><ul><li><strong>延迟</strong>：检查命令响应时间是否符合预期。任何异常的延迟增加都可能指示背后有问题，如网络问题或节点过载。</li><li><strong>吞吐量</strong>：监测集群处理请求的能力是否有所提升或至少保持在重平衡前的水平。</li><li><strong>负载分布</strong>：观察重平衡后节点的负载是否更均衡。使用INFO命令或Redis监控工具来查看各节点的负载情况。</li></ul><p><strong>使用 INFO 命令和监控工具</strong>：</p><ul><li>执行 <code>redis-cli -h &lt;node-ip&gt; -p &lt;node-port&gt; INFO</code> 命令，可以获取到Redis节点的详细运行时信息和统计数据。这对于评估节点健康状况和性能非常有帮助。</li><li>考虑使用Redis 监控工具，如 Prometheus 配合Redis Exporter，或其他第三方监控解决方案。这些工具可以提供实时的性能图表，帮助你更直观地理解集群状态和性能变化。</li></ul><p><strong>重新分片与客户端的挑战</strong></p><p>当我们讨论 <strong>Redis</strong> 集群的重新分片时，除了涉及哈希槽的迁移和节点之间的数据传输，还需要考虑一个重要的客户端层面的问题：<strong>如何确保在迁移过程中数据的连续访问性</strong>？</p><p>想象一下，当一个客户端正在访问一个特定的键值时，而这个键值恰好位于正在被迁移的哈希槽中，客户端会遇到什么情况呢？</p><p><strong>答案是</strong>：客户端会收到一个 <strong>ASK 重定向错误</strong>。</p><p><strong>深入理解 ASK 重定向</strong></p><p>当客户端试图在源节点访问正处于迁移过程的哈希槽中的数据时，源节点并不直接拒绝，而是返回一个 <strong>ASK</strong> 重定向错误。这一错误实际上是 <strong>Redis</strong> 集群为保证数据访问连续性而设计的机制，它引导客户端去目标节点重新请求数据，从而避免服务中断。</p><p><strong>如何处理 ASK 重定向？</strong></p><p><strong>流程图</strong>：</p><p><img src="/images/RedisCluster/13.png"></p><p><strong>重要步骤说明</strong>：</p><p>1.当客户端收到 <strong>ASK</strong> 重定向错误后，首先从错误信息中提取目标节点的 <strong>IP</strong> 地址和端口。</p><p>2.在向目标节点发送命令请求之前，客户端需要先发送一个特殊命令 <strong>ASKING</strong>。</p><p>3.发送 <strong>ASKING</strong> 命令后，客户端可以正常地重新向目标节点发送原命令请求。</p><p>4.客户端收到数据后，继续其后续的操作。</p><p><strong>这里提个问题</strong> ：上述的第二步中，在向目标节点发送命令请求之前，客户端需要先发送一个特殊命令 <strong>ASKING</strong>，该命令有何作用？</p><p>答：<strong>ASKING</strong> 命令是 <strong>Redis</strong> 集群在数据迁移时的特殊协议。当客户端收到一个 <strong>ASK</strong> 重定向提示时，它必须首先向目标节点发送 <strong>ASKING</strong> 命令。这是为了告诉目标节点：尽管该数据在常态下并不由你处理，但由于数据正在迁移，我需要暂时地从你这获取它。</p><p>值得注意的是，<strong>ASKING</strong> 命令的影响仅适用于紧随其后的那个请求。如果客户端后续还有其他请求收到ASK重定向，那么它必须为每一个这样的请求都重新发送 ASKING 命令。</p><h4 id="客户端与集群的交互"><a href="#客户端与集群的交互" class="headerlink" title="客户端与集群的交互"></a>客户端与集群的交互</h4><p>在我们讨论到 <strong>Redis</strong> 集群时，我们常常聚焦于后端的节点如何互相协作，而忽略了一个同样重要的角色：客户端。其实，客户端与集群的交互在 <strong>Redis</strong> 集群的日常运作中起到了举足轻重的作用。</p><p><strong>先来看下它们是怎样交互的？</strong></p><p><strong>交互流程图：</strong></p><p><img src="/images/RedisCluster/14.png"></p><p><strong>重要步骤说明：</strong></p><p><strong>1. 判断节点是否可用</strong></p><p>  客户端首先向已知节点发送命令，如果某个节点暂时不可用或发生了故障转移，客户端可能会收到 CLUSTERDOWN 或 TRYAGAIN 错误。在这种情况下，客户端应该稍等片刻，并重新尝试操作，因为集群很可能在短时间内自我恢复。</p><p><strong>而如果当前节点时可用的，就执行第二步。</strong></p><p><strong>2. 计算槽号</strong></p><p><strong>计算方式</strong>:  $slot &#x3D; CRC16(key) \mod 16384$</p><p><strong>3.判断槽号是否为当前节点所负责</strong></p><p>如果该槽号是当前节点负责的，则直接在当前节点执行命令并返回结果给客户端。<strong>如果不是当前节点所负责的，就执行下一步。</strong></p><p><strong>4. 客户端重定向</strong></p><p>如果槽号不是由当前节点负责的，节点会返回一个 <strong>MOVED</strong> 错误，告诉客户端正确的节点地址和端口。客户端则需要重新连接新节点，并再次发送命令，等待返回结果。</p><blockquote><p><strong>注意</strong>：在 Redis 集群中，客户端可能遇到 MOVED 或 ASK 错误，表示要查询的数据在另一个节点上。客户端必须能自动重定向请求到正确节点。因此，使用集群时，需要选择支持这种重定向功能的客户端库。</p></blockquote><h3 id="集群的优点和缺点"><a href="#集群的优点和缺点" class="headerlink" title="集群的优点和缺点"></a>集群的优点和缺点</h3><p>那相比主从复制和哨兵机制，Redis 集群都有哪些优缺点呢？</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p><strong>数据容量</strong>：单个 Redis 节点可能受限于物理内存，而集群通过分片技术，将数据分散在多个节点上，允许我们存储超出单机物理内存限制的大量数据。</p><p><strong>性能提升</strong>：由于数据和请求都被分散到多个节点上，集群可以更有效地处理高并发的读写请求，为应用提供更高的吞吐量。</p><p><strong>高可用性</strong>：当单一节点出现问题时，集群中的其他节点可以接管其工作，确保服务不中断。这种自动的故障转移能力提高了系统的可靠性和稳定性。而主从复制的高可用需要哨兵的参与。</p><p><strong>扩展性</strong>：随着业务的增长，可以简单地向集群添加更多节点，以满足存储和性能需求，而不需要停机或进行复杂的迁移。</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p><strong>配置复杂性</strong>：设置 Redis 集群意味着要协调多个节点，包括主节点和从节点。与简单的主从复制相比，集群的槽分配和管理更为复杂。而且，当需要增加或减少节点时，调整集群配置可能需要手动干预。</p><p><strong>数据迁移</strong>：在进行节点的增加或减少时，需要进行数据的重新分片，这可能会对性能产生短暂的影响。</p><p><strong>网络开销</strong>：Redis 集群中多个节点需要频繁通信以同步数据。在大的集群里，这可能导致网络变慢和更高的带宽消耗。</p><p><strong>命令限制</strong>：由于数据分片的原因，一些涉及多键操作的命令在集群模式下可能受到限制，比如 <strong>HMSET</strong>、<strong>HMGET等</strong>。</p><h3 id="Redis-集群的配置详解"><a href="#Redis-集群的配置详解" class="headerlink" title="Redis 集群的配置详解"></a>Redis 集群的配置详解</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># yes 代表启用集群模式</span><br><span class="line">cluster-enabled yes     </span><br><span class="line"># Redis 用于保存集群状态信息的文件，状态信息包括：所有节点的信息（IP和Port）、它们的状态（故障，在线）、哈希槽信息等</span><br><span class="line">cluster-config-file nodes-6379.conf     </span><br><span class="line"># 如果一个节点在15000毫秒（15秒）内没有收到来自另一个节点的PONG响应（即对PING请求的回应），那么它会认为那个节点是不可达或失效的（处于主观下线状态）。</span><br><span class="line">cluster-node-timeout 15000</span><br><span class="line"># 这个配置项决定了一个从节点断开与主节点连接多久后，会被认为不能进行故障转移和晋升为主节点。默认是10s</span><br><span class="line">cluster-replica-validity-factor 10  </span><br><span class="line"># 当一个主节点失效，为了晋升其下的从节点成为新的主节点，至少需要有多少个从节点在线，否则不会进行晋升过程。</span><br><span class="line">cluster-migration-barrier 1    </span><br><span class="line"># 是否允许从节点在集群的不同主节点之间迁移。这有助于在负载不均的情况下平衡从节点。</span><br><span class="line">cluster-allow-replica-migration yes  </span><br><span class="line">#  如果设置为 &quot;yes&quot;，则集群要保证所有的哈希槽都必须有一个主节点来管理它，否则整个集群将停止服务。</span><br><span class="line">cluster-require-full-coverage yes</span><br><span class="line">#   这个配置选项决定了当主节点失效时，从节点是否可以自动升级为主节点。置为 &quot;no&quot; 允许从节点尝试变为新的主节点。设置为 &quot;yes&quot; 则不允许这种晋升。</span><br><span class="line">cluster-replica-no-failover no   </span><br><span class="line">#  该配置项决定了在集群出现问题时，是否允许在从节点上进行读操作。设置为 &quot;no&quot; 时，从节点不允许读取。如果设置为 &quot;yes&quot;，即使集群有问题，从节点还是可以读取。</span><br><span class="line">cluster-allow-reads-when-down no        </span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在本文中，我们深入探讨了 <strong>Redis</strong> 的核心架构组件和它们如何相互作用以确保数据的可靠性和高性能。通过主从复制，Redis 实现了数据的冗余备份，为读操作提供了负载分担。而哨兵系统则为我们提供了自动故障转移，确保了系统的高可用性。最后，通过 Redis 集群，我们可以实现数据的水平分片，提供了更大规模的数据存储和处理能力。</p><p>为了让大家对 Redis 架构有更加深入的了解，我又对其进行了总结：</p><p><strong>主从复制</strong></p><ul><li><strong>目的</strong>：通过复制数据到多个副本，主从复制增强了数据的可用性和读取性能。</li><li><strong>工作原理</strong>：一个主节点负责写操作，同时将数据变更同步到一个或多个从节点，从节点主要处理读请求。</li><li><strong>局限性</strong>：主节点故障时，需人工干预进行故障恢复，可能导致数据丢失或服务不可用。</li><li><strong>应用场景</strong>：适用于读写分离，提高读取性能的场景。</li></ul><p><strong>哨兵</strong></p><ul><li><strong>目的</strong>：自动化处理故障转移，提高系统的可用性和稳定性。</li><li><strong>工作原理</strong>：通过监控主从节点状态，自动进行主节点故障的检测、选举和故障转移。</li><li><strong>优点</strong>：自动化故障恢复，减少了人工干预的需要，提高了系统的鲁棒性。</li><li><strong>应用场景</strong>：适用于需要高可用性解决方案的场景。</li></ul><p><strong>集群</strong></p><ul><li><strong>目的</strong>：通过数据分片和自动故障转移，实现数据的水平扩展和高可用性。</li><li><strong>工作原理</strong>：将数据分布在多个节点上，每个节点存储一部分数据，通过哈希槽来定位数据的位置。</li><li><strong>优缺点</strong>：提供了高性能的数据读写能力和良好的伸缩性，但配置和管理相对复杂。</li><li><strong>应用场景</strong>：适用于大规模数据存储和高并发访问的场景。</li></ul><p><strong>理论掌握了，接下来就是实战</strong>。下篇文章，我将带领大家实际搭建 Redis 的主从复制、哨兵与集群。想知道如何实际操作？那可以先关注我的公众号「<strong>跟着小康学编程</strong>」，这里不仅有持续更新的计算机原理相关的文章，还有如何系统学习 C、C++，Linux 系统编程以及网络编程的文章等。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>另外，小康最近创建了一个技术交流群，专门用来探讨技术相关或者解答读者的问题。大家在阅读这篇文章的时候，如果觉得有问题的或者有不理解的知识点，欢迎大家加群或者评论区询问。我能够解决的，尽量给大家回复。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> NoSQL数据库 </category>
          
          <category> 数据库技术 </category>
          
          <category> Redis教程 </category>
          
          <category> 高可用架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis架构 </tag>
            
            <tag> Redis主从复制 </tag>
            
            <tag> Redis哨兵 </tag>
            
            <tag> Redis集群 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>全面解析 Redis 持久化：RDB、AOF与混合持久化</title>
      <link href="/RedisPersistence/"/>
      <url>/RedisPersistence/</url>
      
        <content type="html"><![CDATA[<p>大家好，我是小康，今天给大家聊下 Redis 的几种持久化机制。</p><h1 id="Redis-持久化"><a href="#Redis-持久化" class="headerlink" title="Redis 持久化"></a>Redis 持久化</h1><p><strong>前言：</strong></p><p>在数字时代，数据的价值越来越被人们所重视。但数据只有在经过妥善保管和管理时，才能真正发挥其潜在价值。对于使用 Redis 这一热门的内存数据库的开发者和企业来说，数据的持久化无疑是一个必须面对的重要议题。</p><p>我们都知道，Redis 以其卓越的性能和灵活的数据结构而著称，但如何确保内存中的数据不因突发事件而丢失？如何在确保性能的前提下，为数据提供一个更加稳固的避风港？</p><p>本文将为你揭开 Redis 持久化的神秘面纱，探讨其背后的机制，并帮助你为你的应用选择合适的持久化策略。</p><h2 id="Redis与内存数据库的特性"><a href="#Redis与内存数据库的特性" class="headerlink" title="Redis与内存数据库的特性"></a>Redis与内存数据库的特性</h2><h3 id="为什么Redis是内存数据库？"><a href="#为什么Redis是内存数据库？" class="headerlink" title="为什么Redis是内存数据库？"></a>为什么Redis是内存数据库？</h3><p>Redis是一种键值存储系统，其数据主要存储在<strong>内存</strong>中，因此被称为<strong>内存数据库</strong>。与传统的磁盘存储数据库不同，Redis的设计初衷是为了提供高速、低延迟的数据访问。由于数据直接存储在内存中，可以避免磁盘I&#x2F;O的开销，从而实现极高的读写速度。</p><p>🔍例子: 想象一下你在家里找一本书。如果这本书就放在你的桌子上（相当于内存），你可以立刻拿到它。但如果它放在地下室的一个盒子里（相当于磁盘），那你可能需要花费更多时间去找。Redis的工作方式就像那本放在桌子上的书。</p><h3 id="内存数据库的优点和缺点"><a href="#内存数据库的优点和缺点" class="headerlink" title="内存数据库的优点和缺点"></a>内存数据库的优点和缺点</h3><p><strong>优点：</strong></p><ul><li><strong>速度：</strong>内存数据库如Redis能够提供快速的读写能力，因为内存的访问速度远超过磁盘。</li><li><strong>低延迟：</strong>数据存取的响应时间短，适合需要快速响应的应用。</li><li><strong>灵活性：</strong>由于数据结构存储在内存中，Redis等内存数据库支持丰富的数据类型和操作。</li><li><strong>简化的数据模型：</strong>键值存储方式简化了数据模型，便于开发和维护。</li></ul><p><strong>缺点：</strong></p><ul><li><strong>成本：</strong>内存通常比磁盘更昂贵，大量的数据存储需要大量的内存，可能导致高成本。</li><li><strong>数据持久性风险：</strong>如果没有合适的持久化策略，突然的系统崩溃可能导致数据丢失。</li><li><strong>数据容量限制：</strong>由于依赖内存，数据的容量受到物理内存大小的限制。</li></ul><h2 id="什么是持久化"><a href="#什么是持久化" class="headerlink" title="什么是持久化"></a>什么是持久化</h2><p><strong>持久化的定义：</strong></p><p><strong>持久化</strong>，顾名思义，指的是将短暂的、易失的数据转化为长时间保存，且不易丢失的格式。在数据库的语境中，持久化常常指的是将内存中的数据保存到硬盘或其他长期存储介质中，从而确保即使在系统崩溃、断电或其他突发事件中，数据也不会丢失。</p><p><strong>持久化的必要性：</strong></p><p><strong>数据安全性</strong>：技术世界并非总是完美的。系统可能会遭受故障、崩溃或遭受攻击。在没有持久化的情况下，所有存储在内存中的数据在这些情况下都可能丢失。持久化提供了一种机制，确保这些数据在发生故障后可以被恢复。</p><p>🔍例子: 想象一下你在电脑上工作了好几个小时，突然停电了。如果你没有定期保存你的工作，那么你可能会失去所有的努力。数据库持久化就像定期保存你的文件，确保即使发生意外，你的数据也不会丢失。</p><h2 id="Redis-持久化的方式"><a href="#Redis-持久化的方式" class="headerlink" title="Redis 持久化的方式"></a>Redis 持久化的方式</h2><p>Redis 提供三种持久化的方式: 分别是 <strong>RDB</strong>（Redis Database Snapshot） 和 <strong>AOF</strong>（Append Only File）以及 <strong>混合持久化</strong>。</p><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><h4 id="RDB是什么？"><a href="#RDB是什么？" class="headerlink" title="RDB是什么？"></a>RDB是什么？</h4><p>RDB 持久化方式是 Redis 将当前内存中的数据快照（snapshot）保存到硬盘的过程。换句话说，Redis 会创建一个代表某一时刻的数据集的磁盘文件。</p><p><strong>例子</strong>: 想象一下相机的快门点击。每当你点击快门，你都会捕捉到那个特定时刻的场景。RDB的工作方式很相似，只不过它捕捉的是数据的状态。</p><p>理解 RDB 的本质后，你可能会问，我们如何生成这个快照呢？使用 <strong>SAVE</strong> 和 <strong>BGSAVE</strong> 命令即可。</p><h4 id="RDB-生成图解"><a href="#RDB-生成图解" class="headerlink" title="RDB 生成图解"></a>RDB 生成图解</h4><p><img src="/images/RedisPersistence/1.png"></p><h4 id="RDB-工作原理"><a href="#RDB-工作原理" class="headerlink" title="RDB 工作原理"></a>RDB 工作原理</h4><h5 id="RDB-生成的流程图"><a href="#RDB-生成的流程图" class="headerlink" title="RDB 生成的流程图"></a>RDB 生成的流程图</h5><p><img src="/images/RedisPersistence/2.png"></p><p><strong>步骤说明</strong>：</p><p><strong>1.触发RDB生成</strong>:</p><p>触发 RDB 文件的生成有以下两种方式:</p><p><strong>手动触发</strong>：通过执行 SAVE 或 BGSAVE 命令。</p><p><strong>自动触发</strong>：基于 Redis 配置文件中的 save 指令设置的条件。（默认是通过 BGSAVE 命令来触发的）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis 配置文件 save 指令设置： </span><br><span class="line">save 3600 1        # 3600秒内如果超过1个key被修改则生成 RDB</span><br><span class="line">save 300 100       # 300秒内如果超过100个key被修改则生成 RDB</span><br><span class="line">save 60 10000      # 60秒内如果超过10000个key被修改则生成 RDB</span><br></pre></td></tr></table></figure><p><strong>2.创建子进程</strong>:</p><p>当执行 BGSAVE 命令时，Redis 主进程（父进程）会执行 fork 操作来创建一个子进程。这是一个昂贵的操作，尤其当数据集很大时。但好处是，一旦 fork 完成，父进程可以立即返回处理其他客户端请求，而不需要等待 RDB 的生成过程。</p><p>这里涉及到操作系统级别的知识。当 fork 操作执行后，子进程会获得父进程内存中的数据副本。但由于操作系统使用<strong>写时复制</strong>（Copy-On-Write, COW）技术，任何在父进程（Redis主进程）上发生的写操作不会影响子进程中的数据。这确保了子进程中的数据是隔离的，不受父进程中数据更改的影响。</p><p><strong>3.子进程生成RDB文件</strong>:</p><p>子进程将开始遍历整个数据集，将所有的数据写入一个新的临时RDB文件。这是一个纯I&#x2F;O操作，并且是线性的，所以非常快。子进程不需要处理任何客户端请求，只专注于写 RDB 文件，所以效率很高。</p><p><strong>注意 ：线性指的是数据在磁盘上是连续写入的。</strong></p><p><strong>4.RDB文件替换</strong>：</p><p>一旦子进程完成了新的 RDB 文件的写入，它会替换掉旧的 RDB 文件，并发送一个信号通知父进程任务完成。然后子进程退出。</p><h5 id="RDB-的载入"><a href="#RDB-的载入" class="headerlink" title="RDB 的载入"></a>RDB 的载入</h5><p>当 Redis 重新启动时，如果配置为使用 RDB 持久化，它会查找 RDB 文件，并加载它。由于 RDB 文件是一个紧凑的二进制表示形式，数据加载非常快。</p><h4 id="RDB-配置详解"><a href="#RDB-配置详解" class="headerlink" title="RDB 配置详解"></a>RDB 配置详解</h4><p>Redis 默认是不会开启持久化选项的，只要重启 redis，redis 之前保存的数据都会丢失的。因此在实际的生产环境中，我们都会配置 Redis 的 RDB 配置。</p><p>redis.conf 中关于 RDB 的所有配置:</p><pre><code>save &lt;seconds&gt; &lt;changes&gt;stop-writes-on-bgsave-errorrdbcompressionrdbchecksumsanitize-dump-payloaddbfilenamerdb-del-sync-filesdir</code></pre><p><strong>核心配置的常见问题解答：</strong></p><p><strong>Q: save seconds changes 是什么意思？</strong></p><p>A: 这个配置控制 Redis 如何定期保存数据到磁盘。当指定的时间（秒）内，数据发生的变化次数超过或等于<changes>时，Redis 将触发数据的保存操作。如果想禁用 RDB 持久化，可以在配置文件中注释掉所有的 save 指令，并且重启 Redis 服务即可。</p><p><strong>Q: 我看到了 stop-writes-on-bgsave-error，它的作用是什么？</strong></p><p>A: 当此选项被设置为 yes 时，如果后台保存数据出现错误，Redis 将停止所有写入操作。这是一种保护机制，确保在可能的磁盘问题或其他故障时，不再接受可能导致数据丢失的写操作。<br>当该选项被设置为 no 时，即使后台保存数据出现错误，Redis 仍然会继续接受写入操作。</p><p><strong>Q: rdbcompression 能给我带来什么好处？</strong></p><p>A: rdbcompression 设置为 yes 时，表示启用 rdbcompression， 启用 rdbcompression 会使Redis在保存数据前先对其进行压缩，这样可以减少存储空间的使用。但这也意味着在数据加载时可能需要额外的 CPU 时间来解压。</p><p><strong>Q: 我在配置中看到了 rdbchecksum，这是什么意思</strong>？</p><p>A: rdbchecksum 决定是否在 RDB 文件末尾添加一个 CRC64 校验和。这个校验和帮助检测 RDB 文件是否在传输或存储过程中受到损坏。如果你设置为yes，那么每次 Redis 保存或加载 RDB 文件时，它都会计算并检查这个校验和，确保数据的完整性。</p><p><strong>Q: 什么是sanitize-dump-payload？我应该如何配置它？</strong></p><p>A: 当你有一个Redis数据备份（RDB文件）或者使用 RESTORE 命令来导入数据时，你会希望这些数据是安全的，没有任何问题。但是，有些时候数据可能存在问题，这可能会导致 Redis 在后续的操作中崩溃或者出现错误。</p><p>sanitize-dump-payload 这个配置项就是帮助你在加载数据时检查这些数据的安全性。</p><p>如果你设置为no，那么Redis不会检查数据，这样会更快，但是风险也更大。</p><p>如果设置为yes，Redis会检查所有的数据，确保它们是安全的，不会导致问题。这样更安全，但可能会稍微慢一些。</p><p>如果设置为clients，只有从客户端（比如你的应用程序）发来的数据会被检查，而从其它 Redis 实例同步来的数据或RDB文件不会被检查。</p><p><strong>Q: rdb-del-sync-files 配置是做什么的？</strong></p><p>A: 这个配置项决定是否在某些场景下删除与复制（replication）相关的RDB文件。</p><p>在 Redis 的主从复制过程中，主节点需要生成 RDB 文件并将其发送给从节点，帮助从节点进行数据同步。在某些特定的安全环境中，一旦复制完毕，可能会要求尽快删除这些RDB文件。</p><p>rdb-del-sync-files 这个选项，当设置为 yes 时，并且主节点没有启用 RDB 和 AOF持久化，redis 会自动删除这些与复制相关的 RDB 文件。</p><p>默认为no，这意味着与复制相关的RDB文件在同步后不会被自动删除。</p><p><strong>Q8: dbfilename 和 dir 分别指的是什么？</strong></p><p>A: dbfilename 是 RDB 文件名（默认是 dump.rdb）；dir 则是 RDB 文件存放的目录，默认值 .&#x2F;（当前目录：Redis服务器启动时的工作目录），但推荐指定一个固定的目录，例如：&#x2F;var&#x2F;redis&#x2F;data&#x2F;</p><p><strong>注意：</strong></p><ul><li><p>上述的save 、dbfilename、以及 dir 指令配置是我们重点关注的，其他了解即可。</p></li><li><p>在更改 redis.conf 配置之后，我们需要重启 redis 服务，才能生效。</p></li></ul><h4 id="RDB-持久化的优缺点"><a href="#RDB-持久化的优缺点" class="headerlink" title="RDB 持久化的优缺点"></a>RDB 持久化的优缺点</h4><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><p><strong>快速备份</strong>：RDB可以迅速为你创建一个数据的“快照”，这是一个备份文件，方便你存储或者迁移数据。</p><p><strong>启动快</strong>：当Redis重新启动时，RDB能帮助它更快速地加载数据，因为它直接读取一个完整的数据文件。</p><p><strong>节省空间</strong>：与其他持久化方式相比，RDB的文件大小通常较小，因为它是经过压缩的。</p><h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><p><strong>可能丢数据</strong>：因为RDB只是不时地保存一次数据快照，如果在两次保存之间Redis出了问题，那中间的数据就可能会丢失。</p><p><strong>有时会卡</strong>：在数据很多的情况下，创建 RDB 文件时可能会使服务器短暂地感觉有些卡顿。</p><p><strong>卡顿的原因</strong>：尽管 Redis 使用写时复制（Copy-On-Write, COW）技术来减少内存的复制，fork( ) 在大数据集上的调用仍然可能相当耗时。这是因为操作系统需要为子进程准备一个与父进程相同的虚拟内存空间。在这个准备过程中，即使不立即复制物理内存，操作系统也需要复制和设置父进程的页表，这在数据集很大时会占用相当一部分时间。fork( ) 的执行时间与服务器上的数据量大小成正比。因此在数据集较大时，fork 可能会有比较久的延迟才能返回，所以才造成的卡顿。</p><h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><h4 id="AOF是什么？"><a href="#AOF是什么？" class="headerlink" title="AOF是什么？"></a>AOF是什么？</h4><p>想象你正在写日记，每次有新的事件，你就写下来。AOF 就像是 Redis 的日记，记录了所有的写操作命令。</p><h4 id="简单图解："><a href="#简单图解：" class="headerlink" title="简单图解："></a>简单图解：</h4><p><img src="/images/RedisPersistence/3.png"></p><h4 id="AOF-的工作原理"><a href="#AOF-的工作原理" class="headerlink" title="AOF 的工作原理"></a>AOF 的工作原理</h4><h5 id="基本机制和流程"><a href="#基本机制和流程" class="headerlink" title="基本机制和流程"></a>基本机制和流程</h5><p>Redis 中的 AOF 持久化方式旨在持续地保存服务器上的所有修改操作。每当执行一个会改变数据的命令时，Redis 都会将该命令写入 AOF 文件中。这样，当 Redis 需要恢复数据时，只需执行 AOF 文件中的命令就可以恢复到原来的状态。</p><h5 id="AOF-文件的生成"><a href="#AOF-文件的生成" class="headerlink" title="AOF 文件的生成"></a>AOF 文件的生成</h5><h5 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h5><p><img src="/images/RedisPersistence/4.png"></p><p><strong>步骤说明：</strong></p><p>AOF 持久化的实现主要是以上三步：<strong>命令追加、文件写入、文件同步</strong></p><ul><li><strong>命令追加</strong>: 将 redis 写操作命令追加到 aof_buf 缓冲区</li><li><strong>文件写入</strong>: 周期性地将 aof_buf 缓冲区的命令写入 AOF 文件的内核缓冲区。</li><li><strong>文件同步</strong>:根据配置同步策略，将 AOF 文件缓冲区的内容同步到磁盘。</li></ul><p>其中文件同步策略 redis 提供了三种，分别是以下三种：</p><p><strong>always</strong>：每次有命令写入时都立即同步。这提供了最高的数据安全性，但效率最低。</p><p><strong>everysec</strong>：每秒同步一次。这是一个权衡安全性和效率的策略。最多只丢失 1 秒 的数据</p><p><strong>no</strong>：让操作系统决定最佳的同步时间。这可能导致数据丢失，但提供了最高的效率。</p><h5 id="AOF-文件的载入"><a href="#AOF-文件的载入" class="headerlink" title="AOF 文件的载入"></a>AOF 文件的载入</h5><p>当 Redis 服务器启动时，如果配置为使用 AOF 持久化，它会检查 AOF 文件的存在。如果找到 AOF 文件，Redis 会加载并执行其中的命令来恢复数据的。</p><p><strong>这里顺带提个问题</strong>：假如 Redis 的 RDB 和 AOF 持久化都启用，redis 在载入数据的时候，是载入 AOF 文件？还是 RDB 文件？</p><p>我直接说答案：Redis 会优先载入 AOF 文件来恢复数据，而不是 RDB 文件。这是因为 AOF 文件通常包含了更完整的操作记录，从而能够恢复更完整的数据状态。而 RDB 文件是定时生成的数据快照，所以它可能没有记录到最后一次快照之后发生的所有更改。因此，使用 AOF 文件恢复数据可以提供更高的数据完整性。</p><h4 id="AOF-重写"><a href="#AOF-重写" class="headerlink" title="AOF 重写"></a>AOF 重写</h4><p>在了解了 AOF 的工作原理之后，我们知道它是通过追加写操作命令到文件的方式来恢复数据的。但这会带来一个新的问题: 随着追加命令的不断增加，这个 AOF 文件可能会变得很大和冗长。面对这样的问题，Redis 提供了一个非常有效的优化手段，那就是 <strong>AOF 重写</strong>。</p><p><strong>AOF重写是什么？</strong></p><p>AOF 重写，可以看作是对 AOF文件 进行的一次“精简”操作。它的目的是减少AOF文件的大小，并去除那些冗余的、不再必要的命令，使得该文件只包含恢复当前数据集所需的最小命令集。</p><p><strong>为什么需要AOF重写？</strong></p><p><strong>节省磁盘空间</strong>：随着操作的积累，原始AOF文件可能会变得非常大。通过重写，我们可以减少文件的大小。</p><p><strong>加速恢复速度</strong>：一个更小、更简洁的AOF文件意味着在Redis重启时，数据的恢复过程会更快。</p><p><strong>AOF 重写流程图</strong>：</p><p><img src="/images/RedisPersistence/5.png"></p><p><strong>步骤说明</strong>： </p><p><strong>AOF 重写主要有以下四步：</strong></p><ul><li>redis 主进程 fork 子进程来进行 AOF 的重写，生成 AOF 文件。</li><li>在子进程进行 AOF 重写的同时，redis 主进程将新的写操作命令写入 AOF重写缓冲区</li><li>主进程将 AOF 重写缓冲区的内容写入到新的 AOF 文件中</li><li>使用新的 AOF 文件替换旧的 AOF 文件</li></ul><p><strong>这里思考一下</strong>：子进程 进行 AOF 重写，具体怎么重写，是根据现有的 AOF 文件进行重写还是其他方式？</p><p>子进程是通过读取 Redis 当前的内存数据来进行重写的。假如:  redis 数据库存在列表键 List &#x3D; [a,b,c,d,e,f,g,h] ，在旧的 AOF 文件中，可能有多个命令添加和删除这些元素。但在 AOF 重写时，子进程只需要看 List键 的当前状态，然后生成一个简短的命令，如 RPUSH List a b c d e f g h，直接设置正确的值，避免了任何冗余操作。</p><h4 id="AOF-配置详解"><a href="#AOF-配置详解" class="headerlink" title="AOF 配置详解"></a>AOF 配置详解</h4><p>我们只需要在 Redis 配置文件 redis.conf 中搜索 APPEND ONLY MODE 即可搜到 AOF 配置项。</p><p><strong>Q: 我想启用 AOF 模式，我应该怎么做？</strong></p><p>A: 将 appendonly 设置为 yes。默认是 no。</p><p><strong>Q: 我想改变 AOF 文件的名称，该怎么做？</strong></p><p>A: 使用 appendfilename 选项。默认名称是 appendonly.aof。</p><p><strong>Q: 有哪些方式可以控制 AOF 数据同步到磁盘的频率？</strong></p><p>A: 使用 appendfsync 选项。你有三个选择：</p><p><strong>always</strong>: 每次写操作后都同步。</p><p><strong>everysec</strong>: 每秒同步一次。</p><p><strong>no</strong>: 由操作系统决定何时同步。</p><p>默认设置是 <strong>everysec</strong>。</p><p><strong>Q: 当 Redis 进行 AOF 重写或快照保存时，我怎样避免主进程 fsync 的延迟？</strong></p><p>A: 设置 no-appendfsync-on-rewrite 为 yes。默认是 no。</p><p><strong>Q: 我怎样自动触发 AOF 文件重写？</strong></p><p>A: 使用以下两个配置：</p><p><strong>auto-aof-rewrite-percentage</strong>: AOF 文件增长的百分比，达到此值则触发 AOF 重写。例如，如果设置为100%，那么当 AOF 文件的大小是上次重写后的两倍时，Redis 会考虑触发自动重写。</p><p><strong>auto-aof-rewrite-min-size</strong>: AOF 文件大小门槛，超过此值即使增长的百分比小也会触发 AOF 重写。</p><p><strong>Q: 如果 AOF 文件在末尾被截断，Redis怎么办？</strong></p><p>A: 使用 aof-load-truncated 选项。如果设置为 yes，Redis 尝试加载并启动，同时发出日志警告；如果为 no，Redis 会中止并拒绝启动。默认是 yes。</p><h4 id="AOF-持久化的优缺点"><a href="#AOF-持久化的优缺点" class="headerlink" title="AOF 持久化的优缺点"></a>AOF 持久化的优缺点</h4><p><strong>优点</strong>：</p><p><strong>不轻易丢数据</strong>：AOF 记录了所有的写操作，所以即使服务器突然断电，数据丢失的机会也很小。</p><p><strong>易于理解</strong>：AOF是一个文本文件，里面就是一系列的命令，你可以打开查看。</p><p><strong>出问题也能救</strong>：如果 AOF 文件最后有点损坏，Redis 也能够修复它，避免大量数据丢失。</p><p><strong>缺点</strong>：</p><p><strong>可能会慢一些</strong>：因为要不断写入操作，所以比 RDB 要慢一点。</p><p><strong>文件可能很大</strong>：AOF 会记录所有操作，所以文件可能迅速增大，占用更多空间。</p><p><strong>恢复时间长</strong>：如果需要从 AOF 文件中恢复数据，由于文件可能很大，所以这个过程可能会比较慢。</p><h3 id="混合持久化"><a href="#混合持久化" class="headerlink" title="混合持久化"></a>混合持久化</h3><p>  回顾一下，我们已经探讨了 Redis 的 RDB 和 AOF 持久化。RDB 提供快速的数据恢复，但可能有数据丢失风险；AOF 保证了数据完整性，但文件可能过大，恢复速度较慢。那么，是否有一种既快速又可靠的方法？接下来，我们将介绍 Redis 的<strong>混合持久化策略</strong>。</p><h4 id="混合持久化是什么？"><a href="#混合持久化是什么？" class="headerlink" title="混合持久化是什么？"></a>混合持久化是什么？</h4><p>混合持久化是 Redis 4.0 新引入的持久化策略，结合了 RDB 的快速恢复和 AOF 的数据完整性的优点，它首先以 RDB 格式保存当前数据状态，然后继续以 AOF 格式记录新的写操作，确保数据完整性并优化恢复速度。</p><h4 id="简单图解"><a href="#简单图解" class="headerlink" title="简单图解"></a>简单图解</h4><p><img src="/images/RedisPersistence/6.png"></p><h4 id="混合持久化的工作原理"><a href="#混合持久化的工作原理" class="headerlink" title="混合持久化的工作原理"></a>混合持久化的工作原理</h4><p>在 AOF 重写之前，RDB 和 AOF 都是按照它们各自的持久化策略工作的。当 AOF 重写被触发时，混合持久化才开始发挥作用：将当前的数据集会首先以RDB 格式写入新 AOF 文件的顶部，然后再追加新的命令到文件的末尾。</p><h5 id="混合持久化的工作流程图"><a href="#混合持久化的工作流程图" class="headerlink" title="混合持久化的工作流程图"></a>混合持久化的工作流程图</h5><p><img src="/images/RedisPersistence/7.png"></p><p><strong>步骤说明</strong>：</p><p>混合持久化的实现主要是靠主进程和子进程共同来完成的。</p><p><strong>子进程</strong>: </p><p>   子进程进行 AOF 重写：</p><ul><li>首先创建新的 AOF 文件 appendonly.rdb</li><li>将 Redis 当前的数据生成 RDB 快照写入 appendonly.rdb 文件的开始部分</li></ul><p><strong>主进程</strong></p><ul><li>主进程先将新的写操作命令写入 AOF 重写缓冲区<br>   -主进程将 AOF 重写缓冲区的内容追加到 appendonly.rdb<br>文件的 RDB 数据的末尾</li><li>使用 appendonly.rdb 文件替换旧的 AOF 文件</li></ul><h4 id="混合持久化的配置"><a href="#混合持久化的配置" class="headerlink" title="混合持久化的配置"></a>混合持久化的配置</h4><p><strong>Q: Redis 的混合持久化如何开启？</strong></p><p>A: 将 aof-use-rdb-preamble 选项设置为 yes，并且要同时启用 RDB 和 AOF 两种持久化。</p><p><strong>混合持久化的 AOF 重写与普通的 AOF 重写的区别</strong>：</p><p>在不使用混合持久化的情况下，普通的 AOF 重写是通过读取当前的内存数据并记录达到这一状态所需的最少命令来减少 AOF 文件的大小的。</p><p>而混合持久化在 AOF 重写时，会首先将当前数据集以 RDB 格式快照的形式写入新 AOF 文件的开始位置，然后再追加新的写命令到文件末尾。</p><h4 id="混合持久化的优缺点"><a href="#混合持久化的优缺点" class="headerlink" title="混合持久化的优缺点"></a>混合持久化的优缺点</h4><p><strong>优点</strong>：</p><p><strong>更快的启动速度</strong>：混合持久化结合了RDB的速度优势，所以Redis可以更快地重新启动，不用等待很久。</p><p><strong>数据安全</strong>：利用AOF的方式，即使服务器突然断电，也只会丢失极短的时间内的数据。</p><p><strong>文件更小巧</strong>：因为混合持久化结合了 RDB 和 AOF 的优势，所以文件大小和冗余度都可以得到控制。</p><p><strong>两全其美</strong>：简单说，它就是RDB和AOF的结合体，带来了两者的好处。</p><p><strong>缺点</strong>：</p><p><strong>稍微复杂</strong>：因为它结合了两种技术，所以处理起来比单一的 RDB 或 AOF 要复杂一点。</p><p><strong>可能占更多空间</strong>：在某些情况下，保存数据的文件可能会比只使用 RDB 或AOF 的文件要大一些。</p><p><strong>写入速度</strong>：可能会稍慢一些，特别是当数据需要经常被保存到硬盘时（比如当 appendfsync 配置为“always”时）</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在本系列文章中，我们深入探讨了 Redis 的持久化机制。通过详细介绍 RDB、AOF 以及混合持久化这三种主流的持久化方法，我们不仅学习了它们各自的工作机制和配置策略，还探讨了它们的优缺点，以帮助读者根据自己的实际需求选出合适的持久化方式。</p><ul><li>RDB 持久化以其高效的数据恢复速度和较小的性能开销脱颖而出，适合数据备份和灾难恢复场景。</li><li>AOF 持久化通过记录每个写操作确保了更高级别的数据安全性，尽管它可能导致文件体积增大和写入性能的轻微下降。</li><li>混合持久化模式结合了 RDB 的快速数据恢复能力和 AOF 的数据安全性，提供了一种既快速又可靠的数据恢复解决方案。</li></ul><p>所以大家在选择持久化策略时，需要考虑到数据安全性、恢复速度、以及系统性能三者之间的平衡。RDB 适合需要定期备份的场景，AOF 适合对数据丢失有严格要求的应用，而混合持久化模式则是一种比较折中的方案，它结合了 RDB 的快速数据恢复能力和 AOF 的数据安全性。</p><p><strong>这里我又将 Redis 的三种持久化方式的优缺点以及使用场景做了详细的对比</strong>:</p><table><thead><tr><th align="left">持久化方式</th><th align="center">优点</th><th align="right">缺点</th><th align="right">使用场景</th></tr></thead><tbody><tr><td align="left">RDB</td><td align="center">1. 生成文件速度快。2. 恢复数据速度快。3. 磁盘空间占用少。</td><td align="right">1. 数据丢失风险。2. 快照操作可能的性能下降。</td><td align="right">1. 数据备份。2. 数据迁移。3. 灾难恢复时的快速数据恢复。</td></tr><tr><td align="left">AOF</td><td align="center">1. 提供更高的数据安全性。2. 记录实际操作命令（可读性好）。3. 可以自定义保存频率。</td><td align="right">1. 文件可能较大。2. 数据恢复速度较慢。</td><td align="right">数据安全性要求高的场合</td></tr><tr><td align="left">混合持久化</td><td align="center">提供了数据安全和更快的数据恢复速度。</td><td align="right">维护两种文件格式，增加磁盘占用空间。</td><td align="right">快速的数据恢复和高数据安全性的场景。</td></tr></tbody></table><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>如果你对 Linux C&#x2F;C++ 编程，Redis 等后端技术感兴趣或者想学习计算机原理相关的知识，不妨关注我的公众号<strong>「跟着小康学编程」</strong>。这里不仅有持续更新的计算机基础相关的文章，还有如何系统学习 C、C++，Linux 系统编程以及网络编程的文章等。后续也会持续新增关于 Go微服务 、docker、k8s等云原生领域的内容。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>另外，小康最近创建了一个技术交流群，专门用来探讨技术相关或者解答读者的问题。大家在阅读这篇文章的时候，如果觉得有问题的或者有不理解的知识点，欢迎大家加群询问。我能够解决的，尽量给大家回复。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> NoSQL数据库 </category>
          
          <category> 数据库技术 </category>
          
          <category> Redis教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis持久化 </tag>
            
            <tag> RDB </tag>
            
            <tag> AOF </tag>
            
            <tag> 混合持久化 </tag>
            
            <tag> Redis教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis入门指南：掌握常见数据类型</title>
      <link href="/RedisObject/"/>
      <url>/RedisObject/</url>
      
        <content type="html"><![CDATA[<p><strong>前言:</strong></p><p>每次你在游戏中看到玩家排行榜，或者在音乐应用中浏览热门歌单，有没有想过这个排行榜是如何做到实时更新的？当然，依靠 Redis 即可做到。</p><p>在技术领域，我们经常听到<strong>「键值存储」</strong> 这个词。但在 Redis 的世界里，这只是冰山一角。Redis 的对象，不仅仅是简单的数据，它们是为各种任务量身定制的超能工具。</p><p>接下来，让我们走进 Redis 的对象世界，Redis 5.0版本就已经支持了下面的 9 种类型，分别是 ：<strong>字符串对象、列表对象、哈希对象、集合对象、有序集合对象、Bitmaps 对象、HyperLogLog 对象、Geospatial 对象、Stream对象。</strong></p><p><img src="/images/RedisObject/1.png"></p><h1 id="Redis-对象："><a href="#Redis-对象：" class="headerlink" title="Redis 对象："></a><strong>Redis 对象：</strong></h1><p>首先，我们要知道，<strong>Redis</strong> 中保存的数据是以<strong>键值对</strong>的形式存在的。</p><h2 id="对象的类型与编码"><a href="#对象的类型与编码" class="headerlink" title="对象的类型与编码"></a><strong>对象的类型与编码</strong></h2><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a><strong>类型</strong></h3><p>在 <strong>Redis</strong> 的大家庭中，每个键值对都有两个重要的“<strong>身份证</strong>”。那就是<strong>键的类型</strong>和<strong>值的类型</strong>。就好像我们的名字和职业，其中名字（键）总是一个字符串，而职业（值）则可以是各种各样：可以是字符串、列表、哈希、集合，甚至是有序集合。这就是我们所说的对象类型，五彩斑斓，各有特色。</p><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a><strong>编码</strong></h3><p>我们都知道超级英雄有着不同的超能力，蜘蛛侠(Spider-Man) 有蜘蛛感应，钢铁侠(Iron Man)有高科技装备。同样，Redis 中的每个对象都有一种称为“编码”的隐藏能力。这是什么呢？</p><p>简单说，编码是对象的“内部魔法”。它决定了对象在 Redis 内部的存储方式。就好像手机里的照片可以是 JPEG 或 PNG 格式，Redis 对象也可以有不同的编码格式。</p><p>但为什么这很重要呢？因为不同的编码方式意味着不同的存储效率和性能。Redis 非常聪明，它会选择最佳的编码方式，为我们节省空间和提高性能。</p><p>我们先来看下 <strong>Redis 对象结构体</strong>声明</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct redisObject &#123;</span><br><span class="line">    unsigned type:4;       # 数据类型，使用了4位来表示</span><br><span class="line">    unsigned encoding:4;   # 编码方式 </span><br><span class="line">    void *ptr;             # 指向底层数据结构的指针</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><p><strong>Redis</strong> 中的每个对象都是由 <strong>redisObject</strong> 结构表示，其中的 <strong>encoding</strong> 成员记录了对象所使用的编码，<strong>encoding</strong> 的取值不同，对象内部使用的数据结构也会有所不同。关于 redis 对象的各个数据结构的讲解，本篇不涉及，后续会补上。</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a><strong>分类</strong></h2><h3 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a><strong>字符串对象</strong></h3><h4 id="基本概念："><a href="#基本概念：" class="headerlink" title="基本概念："></a><strong>基本概念：</strong></h4><p>字符串对象是最简单的类型，也是二进制安全的，意味着可以存储任何形式的数据，例如 JPEG 图片、序列化的对象或者纯文本。</p><h4 id="简单图解"><a href="#简单图解" class="headerlink" title="简单图解:"></a><strong>简单图解:</strong></h4><p><img src="/images/RedisObject/2.png"></p><p><strong>value 可以存储任何类型的数据：包括普通字符串，数值类型(int,float) 等</strong></p><h4 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a><strong>内部实现</strong></h4><p>Redis 的 String 对象使用一种称为 简单动态字符串<strong>SDS（Simple Dynamic String）</strong> 的结构来存储数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">对象结构体声明:</span><br><span class="line">typedef struct redisObject &#123;</span><br><span class="line">    unsigned type:4;      # 数据类型，使用了4位来表示 </span><br><span class="line">    unsigned encoding:4;  # 编码方式</span><br><span class="line">    void *ptr;            # 指向底层数据结构的指针 </span><br><span class="line">&#125; robj;</span><br><span class="line"></span><br><span class="line">SDS 结构体声明:</span><br><span class="line">struct sdshdr &#123;</span><br><span class="line">    size_t len;           # 记录buf数组中已使用字节的数量。</span><br><span class="line">    size_t alloc;         # 记录buf数组的总容量。</span><br><span class="line">    char buf[];           # 字节数组，用于保存字符串。</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="String-对象的编码"><a href="#String-对象的编码" class="headerlink" title="String 对象的编码"></a><strong>String 对象的编码</strong></h4><p>String 对象的编码有三种: <strong>int、embstr、raw</strong> 。</p><ul><li>int 编码 ：对象 robj 的 ptr 成员指向的是 long 类型的整数</li><li>embstr 和 raw 编码 : 对象 robj 的 ptr 成员指向的是 sdshdr 结构体，值存储在 buf 中。</li></ul><p><strong>使用限制:</strong> 单个 <strong>String</strong> 对象的值可以存储的数据大小上限为 <strong>512MB</strong></p><h4 id="常见命令："><a href="#常见命令：" class="headerlink" title="常见命令："></a><strong>常见命令：</strong></h4><p><strong>基本操作</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SET key value : 设置键的值</span><br><span class="line">GET key       : 获取键的值</span><br><span class="line">DEL key       : 删除键</span><br><span class="line"></span><br><span class="line">&gt; SET username &quot;xiaokang&quot;</span><br><span class="line">OK</span><br><span class="line">&gt; GET username</span><br><span class="line">&quot;xiaokang&quot;</span><br><span class="line">&gt; DEL username</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p><strong>字符串操作</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">APPEND key value           : 向字符串尾部追加</span><br><span class="line">STRLEN key                 : 获取字符串的长度</span><br><span class="line">SETRANGE key offset value  : 覆盖部分内容</span><br><span class="line">GETRANGE key start end     : 获取子字符串</span><br><span class="line"># 上面命令的参数 offset、start、end 都指的是下标(从0开始)</span><br><span class="line"></span><br><span class="line"># 初始键值对 : SET username &quot;xiaokang&quot;</span><br><span class="line">&gt; APPEND username 1998</span><br><span class="line">(integer) 12</span><br><span class="line">&gt; GET username</span><br><span class="line">&quot;xiaokang1998&quot;</span><br><span class="line">&gt; STRLEN username</span><br><span class="line">(integer) 12</span><br><span class="line">&gt; SETRANGE username 0 kang</span><br><span class="line">(integer) 12</span><br><span class="line">&gt; GET username</span><br><span class="line">&quot;kangkang1998&quot;</span><br><span class="line">&gt; GETRANGE username 8 -1  # -1代表的是值的结尾</span><br><span class="line">&quot;1998&quot;</span><br></pre></td></tr></table></figure><p><strong>数值操作</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">INCR/DECY key                 : 自增1或自减1</span><br><span class="line">INCRBY/DECRBY key increment   : 自增或自减整数，步长为 increment 必须为整数，可正可负</span><br><span class="line">INCRBYFLOAT key increment     : 自增、自减浮点数，increment 推荐使用浮点数，代表你是在操作浮点数，可正可负</span><br><span class="line"># redis 中没有提供 DECRBYFLOAT，所以要想递减浮点数，increment 为负即可</span><br><span class="line"></span><br><span class="line">&gt; set count 2</span><br><span class="line">OK</span><br><span class="line">&gt; INCR count</span><br><span class="line">(integer) 3</span><br><span class="line">&gt; DECR count</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; INCRBY count 3</span><br><span class="line">(integer) 5</span><br><span class="line">127.0.0.1:6379&gt; DECRBY count 3</span><br><span class="line">(integer) 2</span><br><span class="line">&gt; SET float_count 5.5</span><br><span class="line">OK</span><br><span class="line">&gt; INCRBYFLOAT float_count 2.5</span><br><span class="line">&quot;8&quot;</span><br><span class="line">&gt; INCRBYFLOAT float_count -3.5</span><br><span class="line">&quot;4.5&quot;</span><br></pre></td></tr></table></figure><p><strong>批量操作</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MSET key1 value1 key2 value2 : 批量设置键值</span><br><span class="line">MGET key1 key2               : 批量获取键值</span><br><span class="line"></span><br><span class="line">&gt; MSET username xiaokang age 25</span><br><span class="line">OK</span><br><span class="line">&gt; GET username</span><br><span class="line">&quot;xiaokang&quot;</span><br><span class="line">&gt; MGET username age</span><br><span class="line">1) &quot;xiaokang&quot;</span><br><span class="line">2) &quot;25&quot;</span><br></pre></td></tr></table></figure><p><strong>条件设置</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SETNX key value                   : 仅当键不存在时设置值,键存在则不会执行任何操作</span><br><span class="line">MSETNX key value [key value ...]  : 批量设置</span><br><span class="line"></span><br><span class="line">&gt; SETNX career programmer</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; MSETNX sex man hobby swim</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p><strong>带有过期时间的设置</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SETEX key seconds value : 为键值设置过期时间</span><br><span class="line"></span><br><span class="line"># 10s 后 redis 会自动删除这个 key</span><br><span class="line">&gt; SETEX username 10 xiaokang</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><h4 id="应用案例"><a href="#应用案例" class="headerlink" title="应用案例"></a><strong>应用案例</strong></h4><p><strong>计数器</strong></p><p><strong>描述</strong>: 利用 Redis 追踪某些事物的数量。</p><p><strong>具体应用 :</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">1. 文章访问计数：文章的阅读次数</span><br><span class="line">#当某篇文章被访问时，递增该文章的阅读计数器。</span><br><span class="line">INCR article:12345:views</span><br><span class="line">#获取某篇文章的阅读次数。</span><br><span class="line">GET article:12345:views</span><br><span class="line"></span><br><span class="line">2. 社交媒体互动计数 ：点赞数</span><br><span class="line">#当某个帖子被点赞时，递增该帖子的点赞计数器。</span><br><span class="line">INCR post:67890:likes</span><br><span class="line">#检查某个帖子的点赞数。</span><br><span class="line">GET post:67890:likes</span><br><span class="line"></span><br><span class="line">3. 实时统计 ：例如，一个电商网站可以使用 Redis 来跟踪网站上当前的在线用户数量</span><br><span class="line">#当用户在线时，递增在线用户计数器。</span><br><span class="line">INCR website:online_users</span><br><span class="line">#检查当前在线的用户数量。</span><br><span class="line">GET website:online_users</span><br><span class="line"></span><br><span class="line">4. 限流: 例如，你可能想限制一个 API 在一定时间内的调用次数。</span><br><span class="line"># 设置一个 API 的调用次数限制。这里以 60 秒内最多调用 10 次为例。</span><br><span class="line">SETEX api:call_limit:client_ip 60 10</span><br><span class="line"># 当 API 被调用时，递减调用计数器。如果值小于或等于 0，则表示已达到限流。</span><br><span class="line">DECRBY api:call_limit:client_ip 1</span><br><span class="line"># 检查某个 API 的剩余调用次数。</span><br><span class="line">GET api:call_limit:client_ip</span><br></pre></td></tr></table></figure><p><strong>分布式锁 : 超越传统的锁机制</strong></p><p>想象一下，一个电商网站正在进行一次秒杀活动，该活动只有100个商品库存。当活动开始时，数万用户同时尝试购买这些商品。</p><p>如果秒杀系统只部署在一个服务器上，那么我们可以使用<strong>普通锁</strong>来保证库存不会被超卖。但是，现在的大型电商平台的抢购系统都是部署在多个服务器上的，所以单个服务器上的普通锁并不能保证整个系统的<strong>数据一致性</strong>。</p><p>这时候，我们需要一个更强大的锁：<strong>分布式锁</strong>， 那什么是分布式锁呢？分布式锁，顾名思义，是能在多个系统或多台机器之间都起到限制访问的“锁”。</p><p>在秒杀活动这个场景中，分布式锁确保了即便是数万用户在多个服务器上同时尝试购买，系统也能正确、有序地处理每一个购买请求，确保不会出现超卖的情况。</p><p><strong>基本概念：</strong></p><p>分布式锁是一种能够在多个计算机、服务器或节点之间确保任何时候只有一个进程在执行的机制。它是在复杂的分布式环境中维持顺序和一致性的关键工具。</p><p><strong>实现方式：</strong></p><p>使用 Redis 实现分布式锁一般步骤：</p><ol><li>加锁：SET lock_key unique_id EX expire_time NX</li></ol><ul><li>lock_key    ：分布式锁名</li><li>unique_id   ：唯一标识符</li><li>EX     ：设置过期时间</li><li>NX     ：当 lock_key 不存在时命令才会成功</li></ul><ol><li>操作共享资源</li><li>释放锁：通过 Lua 脚本来释放锁，先 GET 判断锁是否归属自己，再 DEL 释放锁</li></ol><p><strong>Lua 脚本 : 用来保证释放锁操作的原子性</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">判断锁是自己的，才释放</span><br><span class="line">if redis.call(&quot;GET&quot;,KEYS[1]) == ARGV[1]</span><br><span class="line">then</span><br><span class="line">    return redis.call(&quot;DEL&quot;,KEYS[1])</span><br><span class="line">else</span><br><span class="line">    return 0</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p><strong>上面实现方式存在一个问题：分布式锁的过期时间如何确定？</strong></p><p>如果客户端预期的操作时间超过锁的过期时间，这该怎么办？锁的超时时间设置过长过短都不好。一个合理的方案就是采用自动续期。</p><p><strong>续期具体做法：</strong></p><p>加锁时，我们设定一个到期时间，启动一个<strong>「守护线程」</strong> 定时查看锁的状态。如果锁即将到期且任务未完成，我们自动「<strong>续期」</strong> 这个锁，重新设置其到期时间。如果续期失败，为避免并发问题，客户端应立刻停止操作。</p><p>然而幸运的是，一些编程语言已经实现了专门的客户端库，如 Java 的 Redisson和 Go 的 redsync，它们提供了简化的分布式锁实现。这些库已内置了自动续期等关键功能，避免开发者手动构建这些逻辑。</p><p><strong>注意：</strong></p><p>以上只是实现了一个单机版的分布式锁，而 Redis 在实际生产环境中都会采用主从集群 + 哨兵的模式部署，这样当主库异常宕机时，哨兵可以实现「故障自动切换」，把从库提升为主库，继续提供服务，以此保证可用性。</p><p><strong>我们来考虑一个问题：当「主从发生切换」时，这个分布锁会依旧安全吗？</strong></p><p>关于这个问题我这里不做深入探讨，感兴趣的可以参考这篇文章：<strong>「链接地址在文章末尾」</strong></p><p><strong>缓存</strong></p><p><strong>描述</strong>：利用 Redis 缓存 MYSQL 等关系型数据库查询结果，从而减少关系型数据库的压力。</p><p><strong>具体实现:</strong></p><p>当用户请求某个数据时，首先检查 Redis 是否有这个数据。如果有，直接从 Redis 返回，这样可以避免查询数据库。如果 Redis 中没有，那么查询关系型数据库，获取数据后，存入 Redis，并设置一个适当的过期时间。</p><p><strong>简单示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func getUserInfo(rdb *redis.Client, userID string) string &#123;</span><br><span class="line"> // 尝试从 Redis 中获取用户信息</span><br><span class="line"> val, err := rdb.Get(ctx, userID).Result()</span><br><span class="line"> if err == redis.nil&#123;</span><br><span class="line">     userData := queryDatabase(userID) #在这里模拟一个数据库查询</span><br><span class="line">     rdb.Set(ctx, userID, userData, time.Hour)  # 缓存结果1小时 </span><br><span class="line">     return userData</span><br><span class="line"> &#125;</span><br><span class="line"> return val</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func queryDatabase(userID string) string &#123;</span><br><span class="line">    //查询数据库</span><br><span class="line">    // ...</span><br><span class="line">   return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Session 存储</strong></p><p><strong>Session 是什么：</strong></p><p>每次你在网上购物时，在浏览、选择商品、加入购物车，网站都能“记得”你的选择，这是因为它使用了”Session”。简单来说，Session 是服务器给你的一个小“记忆空间”。</p><p>在日常的网页浏览中，每当一个用户的请求到达服务器，例如页面访问、API调用，为了维持用户状态或提供个性化的服务，系统通常需要读取该用户的 session 数据。</p><p><strong>具体实现：</strong></p><p>当用户登录到一个系统时，后端通常会为该用户生成一个唯一的 session ID 。这个 ID 会被传回给客户端，通常存储在 cookie 中。随后，每次客户端发出请求时，都会携带这个 session ID，允许服务器识别出该用户。</p><p>为了应对这种频繁的数据读取需求，我们可以将这个 session ID 和 session 数据分别作为键值存储到 redis 中。session 数据包括 : 用户 ID、用户名等。使用 Redis 来存储 session 数据不仅提供了高速的读取效率，还让用户体验更为流畅。</p><p><strong>使用示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 在设置 session 存储时，一般会设置过期时间的。</span><br><span class="line">SET session:userId expired_time &quot;user_data_in_json_or_serialized_format&quot;</span><br><span class="line">GET session:userId</span><br></pre></td></tr></table></figure><h3 id="列表对象"><a href="#列表对象" class="headerlink" title="列表对象"></a>列表对象</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>Redis 的列表对象是一个有序的字符串集合，这里的有序指的是<strong>添加元素有先后顺序</strong>的，可以被看作是一个双向链表。在 Redis 中，每个列表可以包含超过 4 亿个元素。</p><h4 id="简单图解-1"><a href="#简单图解-1" class="headerlink" title="简单图解"></a>简单图解</h4><p><img src="/images/RedisObject/3.png"></p><h4 id="内部实现-1"><a href="#内部实现-1" class="headerlink" title="内部实现"></a>内部实现</h4><ul><li><strong>压缩列表</strong> <strong>(Ziplist)</strong>: 当列表对象保存的所有字符串元素的长度都小于 64 字节并且列表对象保存的元素数量小于 512 个，列表对象会使用压缩列表(ziplist)作为其底层实现。</li><li><strong>双向链表(Linkedlist)</strong>:不满足上述两个条件之一的, 列表对象会使用双向链表(Linkedlist) 作为其底层实现。</li></ul><h4 id="常见命令：-1"><a href="#常见命令：-1" class="headerlink" title="常见命令："></a><strong>常见命令：</strong></h4><p><strong>查找元素</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">LRANGE key start stop  : 获取列表指定范围内的元素</span><br><span class="line">LINDEX key index       : 通过索引获取列表中的元素</span><br><span class="line">LLEN key               : 返回列表的长度</span><br><span class="line"></span><br><span class="line"># 查看列表对象的所有元素，-1 代表列表对象的最后一个元素</span><br><span class="line">&gt; LRANGE myList 0 -1</span><br><span class="line">1) &quot;grape&quot;</span><br><span class="line">2) &quot;banana&quot;</span><br><span class="line">3) &quot;apple&quot;</span><br><span class="line">4) &quot;orange&quot;</span><br><span class="line">&gt; LINDEX myList 1</span><br><span class="line">&quot;banana&quot;</span><br><span class="line">&gt; LLEN myList</span><br><span class="line">(integer) 4</span><br></pre></td></tr></table></figure><p><strong>插入元素 :</strong></p><ul><li>普通插入</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">LPUSH key element [element ...]   : 将一个或多个值插入到列表头部</span><br><span class="line">RPUSH key element [element ...]   : 将一个或多个值插入到列表尾部</span><br><span class="line"></span><br><span class="line">&gt; LPUSH myList &quot;apple&quot; &quot;banana&quot;</span><br><span class="line">(integer) 2</span><br><span class="line">&gt; LRANGE myList 0 -1</span><br><span class="line">1) &quot;banana&quot;</span><br><span class="line">2) &quot;apple&quot;</span><br><span class="line">&gt; RPUSH myList &quot;orange&quot; &quot;pear&quot;</span><br><span class="line">(integer) 4</span><br><span class="line">&gt; LRANGE myList 0 -1</span><br><span class="line">1) &quot;banana&quot;</span><br><span class="line">2) &quot;apple&quot;</span><br><span class="line">3) &quot;orange&quot;</span><br><span class="line">4) &quot;pear&quot;</span><br></pre></td></tr></table></figure><ul><li>条件插入</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">LPUSHX key element  [element ...] : 只有当列表存在时，将值插入到列表的头部，如果列表不存在，则什么也不做</span><br><span class="line">RPUSHX key element  [element ...] : 只有当列表存在时，将值插入到列表的尾部，如果列表不存在，则什么也不做</span><br><span class="line"></span><br><span class="line">&gt; LPUSHX myList &quot;grape&quot;</span><br><span class="line">(integer) 5</span><br><span class="line">&gt; LRANGE myList 0 -1</span><br><span class="line">1) &quot;grape&quot;</span><br><span class="line">2) &quot;banana&quot;</span><br><span class="line">3) &quot;apple&quot;</span><br><span class="line">4) &quot;orange&quot;</span><br><span class="line">5) &quot;pear&quot;</span><br><span class="line">&gt; LPUSHX noExistList &quot;peach&quot;</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure><p><strong>删除元素:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">LPOP key [count]      : 移除并返回列表的前 count 个元素</span><br><span class="line">RPOP key [count]      : 移除并返回列表的最后 count 个元素</span><br><span class="line">LREM key count value  : 移除列表中与参数 value 相等的 count 个元素</span><br><span class="line"></span><br><span class="line"># 先查看列表中的元素</span><br><span class="line">&gt; LRANGE myList 0 -1</span><br><span class="line">1) &quot;grape&quot;</span><br><span class="line">2) &quot;banana&quot;</span><br><span class="line">3) &quot;apple&quot;</span><br><span class="line">4) &quot;orange&quot;</span><br><span class="line">5) &quot;pear&quot;</span><br><span class="line">&gt; LPOP myList</span><br><span class="line">&quot;grape&quot;</span><br><span class="line">&gt; LRANGE myList 0 -1</span><br><span class="line">1) &quot;banana&quot;</span><br><span class="line">2) &quot;apple&quot;</span><br><span class="line">3) &quot;orange&quot;</span><br><span class="line">4) &quot;pear&quot;</span><br><span class="line">&gt; RPOP myList</span><br><span class="line">&quot;pear&quot;</span><br><span class="line">&gt; LRANGE myList 0 -1</span><br><span class="line">1) &quot;banana&quot;</span><br><span class="line">2) &quot;apple&quot;</span><br><span class="line">3) &quot;orange&quot;</span><br></pre></td></tr></table></figure><p><strong>修改元素：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">LSET key index value : 通过索引来设置元素的值</span><br><span class="line">LTRIM key start stop ：裁剪列表</span><br><span class="line"># 先查看列表中的元素</span><br><span class="line">&gt; LRANGE myList 0 -1</span><br><span class="line">1) &quot;grape&quot;</span><br><span class="line">2) &quot;banana&quot;</span><br><span class="line">3) &quot;apple&quot;</span><br><span class="line">4) &quot;orange&quot;</span><br><span class="line">&gt; LSET myList 0 &quot;peach&quot;</span><br><span class="line">OK</span><br><span class="line">&gt; LRANGE myList 0 -1</span><br><span class="line">1) &quot;peach&quot;</span><br><span class="line">2) &quot;banana&quot;</span><br><span class="line">3) &quot;apple&quot;</span><br><span class="line">4) &quot;orange&quot;</span><br><span class="line">&gt; LTRIM myList 0 2</span><br><span class="line">OK</span><br><span class="line">&gt; LRANGE myList 0 -1</span><br><span class="line">1) &quot;peach&quot;</span><br><span class="line">2) &quot;banana&quot;</span><br><span class="line">3) &quot;apple&quot;</span><br></pre></td></tr></table></figure><p><strong>元素转移:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RPOPLPUSH source destination: 将 source 列表的最后一个元素弹出，并将该元素添加到 destination 列表的头部，同时返回该元素，如果 destination 列表不存在，redis 会自动创建 destination 列表</span><br><span class="line"></span><br><span class="line">&gt; LRANGE myList 0 -1</span><br><span class="line">1) &quot;banana&quot;</span><br><span class="line">2) &quot;apple&quot;</span><br><span class="line">&gt; RPOPLPUSH myList destList</span><br><span class="line">&quot;apple&quot;</span><br><span class="line">&gt; LRANGE destList 0 -1</span><br><span class="line">1) &quot;apple&quot;</span><br></pre></td></tr></table></figure><p>要注意的是列表对象并不存在 LPOPRPUSH 命令，可以通过组合 LPOP 和 RPUSH 命令来实现类似效果。</p><p><strong>阻塞操作:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">BLPOP key [key ...] timeout            : 移除并获取列表的第一个元素，或阻塞直到有一个可用</span><br><span class="line">BRPOP key [key ...] timeout            : 移除并获取列表的最后一个元素，或阻塞直到有一个可用</span><br><span class="line">BRPOPLPUSH source destination timeout  : 将 source 列表的最后一个元素弹出，并将该元素添加到 destination 列表的头部，同时返回该元素</span><br><span class="line"></span><br><span class="line"># 先查看列表中的元素</span><br><span class="line">&gt; LRANGE myList 0 -1</span><br><span class="line">1) &quot;peach&quot;</span><br><span class="line">2) &quot;banana&quot;</span><br><span class="line">3) &quot;apple&quot;</span><br><span class="line">4) &quot;orange&quot;</span><br><span class="line">&gt;  LRANGE noExistList 0 -1</span><br><span class="line">(empty array)</span><br><span class="line">&gt; BLPOP myList noExistList 10</span><br><span class="line">1) &quot;myList&quot;</span><br><span class="line">2) &quot;peach&quot;</span><br><span class="line">&gt; LRANGE myList 0 -1</span><br><span class="line">1) &quot;banana&quot;</span><br><span class="line">2) &quot;apple&quot;</span><br><span class="line">3) &quot;orange&quot;</span><br><span class="line">&gt; BRPOP myList noExistList 10</span><br><span class="line">1) &quot;myList&quot;</span><br><span class="line">2) &quot;orange&quot;</span><br><span class="line"># 先查看列表的初识元素</span><br><span class="line">&gt; LRANGE myList 0 -1</span><br><span class="line">1) &quot;banana&quot;</span><br><span class="line">&gt; LRANGE destList 0 -1</span><br><span class="line">1) &quot;apple&quot;</span><br><span class="line">&gt; BRPOPLPUSH myList destList 10</span><br><span class="line">&quot;banana&quot;</span><br><span class="line">&gt; LRANGE myList 0 -1</span><br><span class="line">(empty array)</span><br><span class="line">&gt; LRANGE destList 0 -1</span><br><span class="line">1) &quot;banana&quot;</span><br><span class="line">2) &quot;apple&quot;</span><br></pre></td></tr></table></figure><h4 id="应用案例："><a href="#应用案例：" class="headerlink" title="应用案例："></a><strong>应用案例：</strong></h4><p>1.<strong>消息队列</strong> ：</p><p>当用户在网上购物下订单后，为了不让他们等待各种后续处理（如检查库存、处理付款、发货），我们直接把订单放入一个消息队列，然后由后台进程从队列中获取并处理订单。</p><p><strong>实现步骤：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 生产者（下订单的用户）        </span><br><span class="line">LPUSH orders_queue order_id</span><br><span class="line">2. 消费者服务获取订单（ 消费者：后台处理订单的服务）   </span><br><span class="line">BRPOP orders_queue 5</span><br><span class="line">3. 处理订单 :                   </span><br><span class="line">一旦消费者从队列中获取了一个新订单，它可以开始进行必要的处理，</span><br><span class="line">例如检查库存、处理付款等。</span><br></pre></td></tr></table></figure><p>2.<strong>栈和队列</strong> ：</p><p><strong>栈：</strong> 想象一个浏览器的返回功能。用户访问了几个页面，你希望能够提供一个[返回] 按钮让用户回到他们之前浏览的页面。</p><p><strong>实现步骤：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 添加元素</span><br><span class="line">LPUSH browser_history &quot;page1&quot;</span><br><span class="line">LPUSH browser_history &quot;page2&quot;</span><br><span class="line">LPUSH browser_history &quot;page3&quot;</span><br><span class="line"></span><br><span class="line">2.当用户点击返回按钮时:</span><br><span class="line">LPOP browser_history  # Fetches &quot;page3&quot;, the most recently visited</span><br></pre></td></tr></table></figure><p><strong>队列：</strong></p><p>当我们在电商网站上浏览商品、点击广告或执行其他操作时，这些行为都可以被捕获为一个”事件”。每个事件通常都包含一些基本信息，如用户ID、商品ID、点击时间、页面URL等。</p><p><strong>实现步骤：</strong></p><ul><li>用户点击事件捕获</li></ul><p>假设一个用户点击了一个商品。此时，我们可以创建一个 JSON 对象来存储这次点击的详细信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$json = &#123;</span><br><span class="line">    &quot;user_id&quot;: &quot;12345&quot;,</span><br><span class="line">    &quot;product_id&quot;: &quot;98765&quot;,</span><br><span class="line">    &quot;timestamp&quot;: &quot;2023-09-01T12:00:00Z&quot;,</span><br><span class="line">    &quot;page_url&quot;: &quot;/products/98765&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>发送事件到队列</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LPUSH click_events $json</span><br></pre></td></tr></table></figure><ul><li>消费者进程获取事件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RPOP click_events</span><br></pre></td></tr></table></figure><p>当消费者进程从队列中获取事件后，可以进一步解析这个JSON对象，并进行所需的处理，例如更新商品的点击率等，以便将该商品推荐给更多的用户。</p><p>3.<strong>历史追踪</strong>：</p><p>可以使用 Redis 列表来跟踪最近的历史记录，例如最近访问的网页或其他活动。</p><p><strong>以最近访问的网页举例说明:</strong> 在一个网站上，你可能希望追踪用户最近访问了哪些页面。每当用户访问一个新页面时，你可以使用 LPUSH 将这个页面 URL 添加到一个列表中，并使用 LTRIM 确保列表只保存最近 N 次访问。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LPUSH user_recent_pages &quot;/home&quot;</span><br><span class="line">LPUSH user_recent_pages &quot;/product/1&quot;</span><br><span class="line">LTRIM user_recent_pages 0 9  # 保留最近10个访问的页面</span><br></pre></td></tr></table></figure><p>使用 Redis 列表来跟踪最近的历史记录能够高效地保存和查询用户的近期活动，从而为用户提供个性化的推荐。</p><h3 id="哈希对象"><a href="#哈希对象" class="headerlink" title="哈希对象"></a><strong>哈希对象</strong></h3><h4 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a><strong>基本概念</strong></h4><p>Redis 哈希对象也是一种用于存储键值对集合的数据结构，它允许你将多个键值对存储在一个 Redis 键中。</p><p>我们一般会使用 Redis 的 Hash 对象来存储对象信息，比如用户信息，用户的名字、年龄、爱好、电子邮箱、密码等。与使用普通的 key-value 存储方式相比 , 哈希对象的存储方式更为高效和节省空间，特别是当我们要存储大量小对象时。</p><h4 id="简单图解："><a href="#简单图解：" class="headerlink" title="简单图解："></a>简单图解：</h4><p><img src="/images/RedisObject/4.png"></p><p><strong>简单说明：</strong></p><p>假设你有一把大钥匙，这把钥匙可以打开一个特定的箱子。这箱子里面有很多物品，每个物品都有标签来描述它。</p><ul><li>大钥匙 就是我们的 key</li><li>箱子 就代表一个 哈希对象</li><li>箱子里的物品与其标签 就是 field-value 键值对</li></ul><h4 id="内部实现-2"><a href="#内部实现-2" class="headerlink" title="内部实现"></a><strong>内部实现</strong></h4><ul><li><strong>压缩列表(ziplist)</strong> ：当哈希对象保存的所有键值对的键和值的字符串长度都小于64字节并且哈希对象保存的键值对的数量小于 512 个，哈希对象会采用压缩列表作为其底层实现。</li><li><strong>字典(基于哈希表实现)</strong> ：当不能满足上述条件之一时，哈希对象则会采用字典作为其底层实现。</li></ul><h4 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a><strong>常见命令</strong></h4><p><strong>设置值</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HSET key field value [field value ...] : 设置哈希的 Field-Value 对,可以设置多个</span><br><span class="line">HSETNX key field value                 : 只有在字段 field 不存在时，才设置对应的 value 值，否则什么也不做。</span><br><span class="line"></span><br><span class="line">&gt; HSET userInfo username xiaokang age 25 hobby swim</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure><p><strong>获取值</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">HGET key field              : 获取哈希指定字段的值</span><br><span class="line">HMGET key field [field ...] : 获取哈希多个字段的值 # 批量获取</span><br><span class="line">HGETALL key                 : 获取哈希表中的所有字段和值</span><br><span class="line">HKEYS key                   : 获取哈希中所有的字段名(field)</span><br><span class="line">HVALS key                   : 获取哈希中所有的字段值(value)</span><br><span class="line"></span><br><span class="line">&gt; HGET userInfo username</span><br><span class="line">&quot;xiaokang&quot;</span><br><span class="line">&gt; HMGET userInfo &quot;username&quot; &quot;age&quot;</span><br><span class="line">1) &quot;xiaokang&quot;</span><br><span class="line">2) &quot;25&quot;</span><br><span class="line">&gt; HGETALL userInfo</span><br><span class="line">1) &quot;username&quot;</span><br><span class="line">2) &quot;xiaokang&quot;</span><br><span class="line">3) &quot;age&quot;</span><br><span class="line">4) &quot;25&quot;</span><br><span class="line">5) &quot;hobby&quot;</span><br><span class="line">6) &quot;swim&quot;</span><br><span class="line">&gt; HKEYS userInfo</span><br><span class="line">1) &quot;username&quot;</span><br><span class="line">2) &quot;age&quot;</span><br><span class="line">3) &quot;hobby&quot;</span><br><span class="line">&gt; HVALS userInfo</span><br><span class="line">1) &quot;xiaokang&quot;</span><br><span class="line">2) &quot;25&quot;</span><br><span class="line">3) &quot;swim&quot;</span><br></pre></td></tr></table></figure><p><strong>自增操作</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">HINCRBY key field increment       : 为哈希字段的整数值加上增量 # increment 可正可负</span><br><span class="line">HINCRBYFLOAT key field increment  : 为哈希字段的浮点数值加上增量 # increment 可正可负</span><br><span class="line"></span><br><span class="line">&gt; HGET userInfo age</span><br><span class="line">&quot;25&quot;</span><br><span class="line">&gt; HINCRBY userInfo age 1</span><br><span class="line">(integer) 26</span><br><span class="line">&gt; HGET userInfo age</span><br><span class="line">&quot;26&quot;</span><br><span class="line"></span><br><span class="line"># HINCRBYFLOAT 命令类似，increment 既可以是整数也可以是浮点数，可正可负</span><br></pre></td></tr></table></figure><p><strong>删除操作</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">HDEL key field [field ...] : 删除一个或多个哈希表字段</span><br><span class="line"></span><br><span class="line"># 先查看 hash 字段的所有字段和值</span><br><span class="line">&gt; HGETALL userInfo</span><br><span class="line">1) &quot;username&quot;</span><br><span class="line">2) &quot;xiaokang&quot;</span><br><span class="line">3) &quot;age&quot;</span><br><span class="line">4) &quot;25&quot;</span><br><span class="line">5) &quot;hobby&quot;</span><br><span class="line">6) &quot;swim&quot;</span><br><span class="line">&gt; HDEL userInfo &quot;hobby&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; HGETALL userInfo</span><br><span class="line">1) &quot;username&quot;</span><br><span class="line">2) &quot;xiaokang&quot;</span><br><span class="line">3) &quot;age&quot;</span><br><span class="line">4) &quot;25&quot;</span><br></pre></td></tr></table></figure><p><strong>其他操作</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">HEXISTS key field     : 检查哈希对象中是否存在给定的字段</span><br><span class="line">HLEN key              : 获取哈希中字段的数量</span><br><span class="line">HSTRLEN key field     : 获取哈希字段的字符串长度</span><br><span class="line"></span><br><span class="line"># 先查看哈希的所有字段和值</span><br><span class="line">&gt; HGETALL userInfo</span><br><span class="line">1) &quot;username&quot;</span><br><span class="line">2) &quot;xiaokang&quot;</span><br><span class="line">3) &quot;age&quot;</span><br><span class="line">4) &quot;25&quot;</span><br><span class="line">&gt; HLEN userInfo</span><br><span class="line">(integer) 2</span><br><span class="line">&gt; HSTRLEN userInfo &quot;username&quot;</span><br><span class="line">(integer) 8</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong></p><ul><li><strong>小哈希优化：</strong> Redis 对于哈希对象的内存布局进行了优化。小哈希（即哈希对象字段数量很少且字段值大小较小）的内存使用会更加高效。</li><li><strong>避免大量删除：</strong> 使用 HDEL 一次删除大量字段可能会影响性能，建议分批进行。</li><li><strong>使用哈希而非多个键：</strong> 当需要存储有关特定对象的多个相关字段时，使用单个哈希键比使用多个独立的 Redis 键更为高效。</li></ul><h4 id="应用案例-1"><a href="#应用案例-1" class="headerlink" title="应用案例"></a><strong>应用案例</strong></h4><ul><li><strong>对象存储 :</strong></li></ul><p>主要是指将某种实体或数据（如用户信息）持久性地保存在 Redis 中，如 ：用户的用户名、邮箱、密码等信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">保存用户信息：</span><br><span class="line">HSET user:1234 name &quot;John Doe&quot; email &quot;john.doe@example.com&quot; age 30</span><br><span class="line">获取用户的邮箱：</span><br><span class="line">HGET user:1234 email</span><br></pre></td></tr></table></figure><ul><li><strong>对象缓存：</strong></li></ul><p>这是指当数据原本存储在其他存储系统（如关系型数据库）中，但由于频繁访问或读取，我们决定在 Redis 中缓存该数据的一份副本，以减少对原始数据源的访问压力并提高读取速度。</p><p><strong>场景描述：</strong></p><p>假设你有一个博客网站，用户可以阅读和评论各种博客文章。每当用户点击一个博客标题，系统都会从关系型数据库中获取该文章的详细内容进行显示。但是，由于某些热门文章被大量用户频繁访问，直接从数据库中获取文章可能会对数据库造成很大的压力，从而影响网站的性能。</p><p><strong>具体实现：</strong></p><p><strong>伪代码展示 :</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">    &quot;github.com/go-redis/redis/v8&quot;</span><br><span class="line">    &quot;context&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var ctx = context.Background()</span><br><span class="line">options := &amp;redis.Options&#123;</span><br><span class="line">    Addr: &quot;localhost:6379&quot;,  // Redis服务器地址</span><br><span class="line">&#125;</span><br><span class="line">// 初始化Redis客户端：</span><br><span class="line">rdb := redis.NewClient(options)</span><br><span class="line"></span><br><span class="line">// 检查缓存：当用户请求一篇文章时，首先检查Redis缓存中是否存在该文章的数据。</span><br><span class="line">exists, err := rdb.HExists(ctx, &quot;article:ID&quot;, &quot;title&quot;).Result()</span><br><span class="line">if err != nil &#123;</span><br><span class="line">    // Handle error</span><br><span class="line">&#125;</span><br><span class="line">//从缓存中获取数据：如果文章存在于Redis中，则直接从Redis的哈希对象中获取所有相关字段，并显示给用户。</span><br><span class="line">if exists &#123;</span><br><span class="line">    articleData, err := rdb.HGetAll(ctx, &quot;article:ID&quot;).Result()</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        // Handle error</span><br><span class="line">    &#125;</span><br><span class="line">    display(articleData)</span><br><span class="line">&#125;</span><br><span class="line">//从数据库中获取数据：如果文章不在Redis缓存中，则从关系型数据库中获取数据保存到 Redis 缓存中，并且设置超时。</span><br><span class="line">if !exists &#123;</span><br><span class="line">    articleData := Database.fetchArticleByID(&quot;article:ID&quot;)</span><br><span class="line">    _, err := rdb.HMSet(ctx, &quot;article:ID&quot;, map[string]interface&#123;&#125;&#123;</span><br><span class="line">        &quot;title&quot;:   articleData.Title,</span><br><span class="line">        &quot;author&quot;:  articleData.Author,</span><br><span class="line">        &quot;content&quot;: articleData.Content,</span><br><span class="line">    &#125;).Result()</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        // Handle error</span><br><span class="line">    &#125;</span><br><span class="line">    rdb.Expire(ctx, &quot;article:ID&quot;, time.Hour) // 设置1小时的过期时间</span><br><span class="line">    // 显示给用户</span><br><span class="line">    display(articleData)</span><br><span class="line">&#125;</span><br><span class="line">//显示给用户的函数</span><br><span class="line">func display(articleData map[string]string) &#123;</span><br><span class="line">    // ... 你的显示逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>实时统计 ：</strong></li></ul><p>为了跟踪网站的实时活动，我们可以使用哈希来保存当前在线用户、页面浏览量和API 请求次数等。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">增加在线用户数：</span><br><span class="line">HINCRBY website:stats online_users 1</span><br><span class="line">减少在线用户数：</span><br><span class="line">HINCRBY website:stats online_users -1</span><br><span class="line">记录每个页面的访问次数：</span><br><span class="line">HINCRBY pageviews:20230901 &quot;/home&quot; 1</span><br></pre></td></tr></table></figure><h3 id="集合对象"><a href="#集合对象" class="headerlink" title="集合对象"></a>集合对象</h3><h4 id="基本概念：-1"><a href="#基本概念：-1" class="headerlink" title="基本概念："></a>基本概念：</h4><p>集合对象（Set）是一种存储多个唯一元素的无序集合数据结构，它提供了丰富的操作使得集合对象成为非常强大和灵活的工具。集合对象特别适用于存储不允许重复的数据项，例如标签、社交网络中的好友列表或者任何需要快速判断某个元素是否存在的场景。</p><h4 id="简单图解-2"><a href="#简单图解-2" class="headerlink" title="简单图解"></a>简单图解</h4><p><img src="/images/RedisObject/5.png"></p><h4 id="内部实现-3"><a href="#内部实现-3" class="headerlink" title="内部实现"></a>内部实现</h4><ul><li><strong>整数集合（intset） :</strong> 当集合对象保存的所有元素都是整数或者集合对象保存的整数个数不超过512个时，集合对象采用 intset 作为其底层实现。</li><li><strong>字典（基于哈希表实现）：</strong> 不满足上面的两个条件之一，则采用字典作为其底层实现。</li></ul><h4 id="常见命令-1"><a href="#常见命令-1" class="headerlink" title="常见命令"></a>常见命令</h4><p><strong>基本操作:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">SADD key member [member ...] ：向集合添加一个或多个成员</span><br><span class="line">SMEMBERS key                 ：获取集合中的所有成员</span><br><span class="line">SCARD key                    ：获取集合的成员数量</span><br><span class="line">SISMEMBER key member         ：判断 member 元素是否是集合 key 的成员</span><br><span class="line">SREM key member [member ...] ：移除集合中的一个或多个成员</span><br><span class="line"></span><br><span class="line">&gt; SADD mySet &quot;apple&quot; &quot;banana&quot; &quot;peach&quot;</span><br><span class="line">(integer) 3</span><br><span class="line">&gt; SMEMBERS mySet</span><br><span class="line">1) &quot;peach&quot;</span><br><span class="line">2) &quot;banana&quot;</span><br><span class="line">3) &quot;apple&quot;</span><br><span class="line">&gt; SCARD mySet</span><br><span class="line">(integer) 3</span><br><span class="line">&gt; SISMEMBER mySet &quot;peach&quot;   # 成员存在返回 1</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; SISMEMBER mySet &quot;pear&quot;    # 成员不存在返回 0</span><br><span class="line">(integer) 0</span><br><span class="line">&gt; SREM mySet &quot;peach&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; SMEMBERS mySet</span><br><span class="line">1) &quot;banana&quot;</span><br><span class="line">2) &quot;apple&quot;</span><br></pre></td></tr></table></figure><p><strong>集合运算:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">SINTER key [key ...]                  ：返回所有给定集合的交集</span><br><span class="line">SINTERSTORE destination key [key ...] ：交集存储在 destination 集合中</span><br><span class="line">SUNION key [key ...]                  ：返回所有给定集合的并集</span><br><span class="line">SUNIONSTORE destination key [key ...] ：并集存储在 destination 集合中</span><br><span class="line">SDIFF key [key ...]                   ：返回第一个集合与其他集合之间的差集</span><br><span class="line">SDIFFSTORE destination key [key ...]  ：差集存储在 destination 集合中</span><br><span class="line"></span><br><span class="line">&gt; SMEMBERS mySet</span><br><span class="line">1) &quot;pear&quot;</span><br><span class="line">2) &quot;banana&quot;</span><br><span class="line">3) &quot;apple&quot;</span><br><span class="line">&gt; SMEMBERS yourSet</span><br><span class="line">1) &quot;peach&quot;</span><br><span class="line">2) &quot;banana&quot;</span><br><span class="line">3) &quot;apple&quot;</span><br><span class="line">&gt; SINTER mySet yourSet</span><br><span class="line">1) &quot;banana&quot;</span><br><span class="line">2) &quot;apple&quot;</span><br><span class="line">&gt; SINTERSTORE resultSet mySet yourSet</span><br><span class="line">(integer) 2</span><br><span class="line">&gt; SMEMBERS resultSet</span><br><span class="line">1) &quot;banana&quot;</span><br><span class="line">2) &quot;apple&quot;</span><br><span class="line"># 并集我这里不提了，和交集操作类似</span><br><span class="line">&gt; SDIFF mySet yourSet</span><br><span class="line">1) &quot;pear&quot;</span><br><span class="line">&gt; SDIFFSTORE result mySet yourSet</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; SMEMBERS result</span><br><span class="line">1) &quot;pear&quot;</span><br></pre></td></tr></table></figure><p><strong>随机操作：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">SRANDMEMBER key [count]               ：随机返回集合中的一个或多个成员</span><br><span class="line">SPOP key [count]                      ：随机移除并返回集合中的一个或多个成员</span><br><span class="line"></span><br><span class="line">&gt; SMEMBERS mySet</span><br><span class="line">1) &quot;pear&quot;</span><br><span class="line">2) &quot;banana&quot;</span><br><span class="line">3) &quot;apple&quot;</span><br><span class="line"># 可以看到每次返回的成员都不一样</span><br><span class="line">&gt; SRANDMEMBER mySet</span><br><span class="line">&quot;pear&quot;</span><br><span class="line">&gt; SRANDMEMBER mySet</span><br><span class="line">&quot;apple&quot;</span><br><span class="line">&gt; SPOP mySet</span><br><span class="line">&quot;pear&quot;</span><br><span class="line">&gt; SMEMBERS mySet</span><br><span class="line">1) &quot;banana&quot;</span><br><span class="line">2) &quot;apple&quot;</span><br></pre></td></tr></table></figure><p><strong>其他操作:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">SMOVE source destination member       : 将 member 成员从 source 集合移动到 destination 集合</span><br><span class="line"></span><br><span class="line">&gt; SMEMBERS mySet</span><br><span class="line">1) &quot;pear&quot;</span><br><span class="line">2) &quot;banana&quot;</span><br><span class="line">3) &quot;apple&quot;</span><br><span class="line">&gt; SMEMBERS yourSet</span><br><span class="line">1) &quot;peach&quot;</span><br><span class="line">2) &quot;banana&quot;</span><br><span class="line">3) &quot;apple&quot;</span><br><span class="line">&gt; SMOVE mySet yourSet &quot;pear&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; SMEMBERS mySet</span><br><span class="line">1) &quot;banana&quot;</span><br><span class="line">2) &quot;apple&quot;</span><br><span class="line">&gt; SMEMBERS yourSet</span><br><span class="line">1) &quot;peach&quot;</span><br><span class="line">2) &quot;pear&quot;</span><br><span class="line">3) &quot;banana&quot;</span><br><span class="line">4) &quot;apple&quot;</span><br></pre></td></tr></table></figure><h4 id="应用案例-2"><a href="#应用案例-2" class="headerlink" title="应用案例"></a><strong>应用案例</strong></h4><ul><li><strong>社交网站的好友与关注系统</strong></li></ul><p>利用集合来存储每个用户的朋友或关注者列表。例如，我们可以为每个用户维护一个集合，其中包含他们的所有朋友或关注者。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SADD &quot;alice:friends&quot; &quot;bob&quot;     # Alice 关注了 Bob</span><br><span class="line">SADD &quot;bob:friends&quot; &quot;charlie&quot;   # Bob 关注了 Charlie</span><br><span class="line">SISMEMBER &quot;alice:friends&quot;, &quot;bob&quot; # 判断 Bob 是否是 Alice 的朋友</span><br></pre></td></tr></table></figure><ul><li><strong>标签系统</strong></li></ul><p>可以为内容（如文章、图片等）添加标签，并利用集合存储这些标签。</p><p><strong>场景描述：</strong>假设你正在运行一个博客平台，你希望为每篇文章添加一组标签，使用户可以更容易地根据主题或兴趣查找相关文章。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1.为文章添加标签：</span><br><span class="line"># 当你发布文章&quot;Redis入门指南&quot;，其ID为1001，你为它添加了标签&quot;technology&quot;, &quot;tutorial&quot;,和&quot;redis&quot;。</span><br><span class="line">SADD tag:technology 1001</span><br><span class="line">SADD tag:tutorial 1001</span><br><span class="line">SADD tag:redis 1001</span><br><span class="line"></span><br><span class="line">2.查找具有特定标签的文章</span><br><span class="line"># 如果用户想要查看所有与&quot;redis&quot;相关的文章：</span><br><span class="line">SMEMBERS tag:redis   # 输出 1001 ：这表示文章ID为1001的文章带有&quot;redis&quot;标签。</span><br><span class="line"></span><br><span class="line">3.获取文章的所有标签</span><br><span class="line"># 每当你需要查看某篇文章的标签，你可以为其创建一个集合。以文章ID为1001为例：</span><br><span class="line">SADD article:1001:tags &quot;technology&quot;</span><br><span class="line">SADD article:1001:tags &quot;tutorial&quot;</span><br><span class="line">SADD article:1001:tags &quot;redis&quot;</span><br><span class="line"></span><br><span class="line"># 要查看文章1001的所有标签：</span><br><span class="line">SMEMBERS article:1001:tags</span><br><span class="line"># 输出：</span><br><span class="line">1) &quot;technology&quot;</span><br><span class="line">2) &quot;tutorial&quot;</span><br><span class="line">3) &quot;redis&quot;</span><br></pre></td></tr></table></figure><ul><li><strong>唯一计数</strong></li></ul><p>例如，记录网站的独立访客数。集合可以帮助我们做到这一点，因为它们只存储唯一的元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.存储当天登录的所有用户ID：</span><br><span class="line">SADD visitors:2023-09-20 user12345</span><br><span class="line">SADD visitors:2023-09-20 user67890</span><br><span class="line">2.获得当天登录的独立用户数</span><br><span class="line">SCARD visitors:2023-09-20</span><br></pre></td></tr></table></figure><h3 id="有序集合对象"><a href="#有序集合对象" class="headerlink" title="有序集合对象"></a>有序集合对象</h3><h4 id="基本概念：-2"><a href="#基本概念：-2" class="headerlink" title="基本概念："></a>基本概念：</h4><p>Redis 有序集合（Sorted Set）对象是一种存储非重复元素集合的数据结构，每个元素都关联一个双精度浮点数分数（score），用于维护元素之间的排序顺序。有序集合支持高效的元素插入和删除操作，同时保持元素按分数排序，使其非常适合于需要按照排序顺序访问元素的场景，如排行榜、带权重的任务队列等。</p><h4 id="简单图解-3"><a href="#简单图解-3" class="headerlink" title="简单图解:"></a>简单图解:</h4><p><img src="/images/RedisObject/6.png"></p><h4 id="内部实现-4"><a href="#内部实现-4" class="headerlink" title="内部实现"></a>内部实现</h4><ul><li>压缩列表（ziplist）:  当有序集合保存的元素数量小于 128 个 并且有序集合保存的所有元素成员的长度小于 64 字节，有序集合对象会采用 ziplist 作为其底层实现。</li><li>跳表(skiplist )：不满足以上2个条件之一的采用 skiplist 作为其底层实现。</li></ul><h4 id="常见命令-2"><a href="#常见命令-2" class="headerlink" title="常见命令"></a>常见命令</h4><p><strong>添加与更新成员</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ZADD key score member [score member ...] : 添加一个或多个成员到有序集合，或者更新已存在成员的分数</span><br><span class="line">ZINCRBY key increment member             : 增加有序集合中指定成员的分数</span><br><span class="line"></span><br><span class="line">&gt; ZADD myZSet 10 member1 20 member2</span><br><span class="line">(integer) 2</span><br><span class="line"># 获取有序集合中的所有成员及其分数</span><br><span class="line">&gt; ZRANGE myZSet 0 -1 WITHSCORES</span><br><span class="line">1) &quot;member1&quot;</span><br><span class="line">2) &quot;10&quot;</span><br><span class="line">3) &quot;member2&quot;</span><br><span class="line">4) &quot;20&quot;</span><br><span class="line">&gt; ZINCRBY myZSet 5 &quot;member1&quot;</span><br><span class="line">&quot;15&quot;</span><br><span class="line">&gt; ZRANGE myZSet 0 -1 WITHSCORES</span><br><span class="line">1) &quot;member1&quot;</span><br><span class="line">2) &quot;15&quot;</span><br><span class="line">3) &quot;member2&quot;</span><br><span class="line">4) &quot;20&quot;</span><br></pre></td></tr></table></figure><p><strong>查询操作</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">ZCARD key            : 获取有序集合的成员数量</span><br><span class="line">ZSCORE key member    : 获取指定成员的分数值</span><br><span class="line">ZRANK key member     : 返回有序集合中指定成员的排名，排名依次是 0，1，2 ...</span><br><span class="line">ZREVRANK key member  : 返回有序集合中指定成员的排名，成员按分数值递减排列</span><br><span class="line">&gt; ZCARD myZSet</span><br><span class="line">(integer) 2</span><br><span class="line">&gt; ZSCORE myZSet &quot;member2&quot;</span><br><span class="line">&quot;20&quot;</span><br><span class="line">&gt; ZRANK myZSet &quot;member1&quot;</span><br><span class="line">(integer) 0</span><br><span class="line">&gt; ZRANK myZSet &quot;member2&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; ZREVRANK myZSet &quot;member2&quot;</span><br><span class="line">(integer) 0</span><br><span class="line">&gt; ZREVRANK myZSet &quot;member1&quot;</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">ZRANGE key min max [WITHSCORES]        : 返回有序集中指定区间内的成员  # min 和 max 是要获取的排名范围（排名可以理解为索引，从0开始，其中0是分数最低的成员），可选的 [WITHSCORES] 参数表示除了返回成员名外，还要返回它们的分数</span><br><span class="line">ZREVRANGE key start stop [WITHSCORES]  : 返回有序集中指定区间内的成员，成员按分数递减排列</span><br><span class="line"></span><br><span class="line">&gt; ZRANGE myZSet 0 1</span><br><span class="line">1) &quot;member1&quot;</span><br><span class="line">2) &quot;member2&quot;</span><br><span class="line">&gt; ZRANGE myZSet 0 1 WITHSCORES</span><br><span class="line">1) &quot;member1&quot;</span><br><span class="line">2) &quot;15&quot;</span><br><span class="line">3) &quot;member2&quot;</span><br><span class="line">4) &quot;20&quot;</span><br><span class="line">&gt; ZREVRANGE myZSet 0 1</span><br><span class="line">1) &quot;member2&quot;</span><br><span class="line">2) &quot;member1&quot;</span><br><span class="line">&gt; ZREVRANGE myZSet 0 1 WITHSCORES</span><br><span class="line">1) &quot;member2&quot;</span><br><span class="line">2) &quot;20&quot;</span><br><span class="line">3) &quot;member1&quot;</span><br><span class="line">4) &quot;15&quot;</span><br><span class="line"></span><br><span class="line">ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]                                        : 获取分数在指定区间的所有成员，建议：max &gt;= min</span><br><span class="line">ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]: 获取分数在指定区间的所有成员，成员按分数递减排列; 建议：max &gt;= min</span><br><span class="line">#[LIMIT offset count]  这是一个限制返回的成员数量的可选项。其中，offset 是开始返回的起始位置（基于0的索引），count 是返回的成员总数。例如，LIMIT 1 3 会返回从下标为1开始的3个成员</span><br><span class="line"></span><br><span class="line">&gt; ZRANGEBYSCORE myZSet 16 22</span><br><span class="line">1) &quot;member2&quot;</span><br><span class="line">&gt; ZRANGEBYSCORE myZSet 16 22 WITHSCORES</span><br><span class="line">1) &quot;member2&quot;</span><br><span class="line">2) &quot;20&quot;</span><br><span class="line">&gt; ZRANGEBYSCORE myZSet 15 22 WITHSCORES LIMIT 0 2</span><br><span class="line">1) &quot;member1&quot;</span><br><span class="line">2) &quot;15&quot;</span><br><span class="line">3) &quot;member2&quot;</span><br><span class="line">4) &quot;20&quot;</span><br><span class="line">&gt; ZREVRANGEBYSCORE myZSet 22 15 WITHSCORES</span><br><span class="line">1) &quot;member2&quot;</span><br><span class="line">2) &quot;20&quot;</span><br><span class="line">3) &quot;member1&quot;</span><br><span class="line">4) &quot;15&quot;</span><br><span class="line"></span><br><span class="line">ZCOUNT key min max: 计算在有序集合中指定区间分数的成员数</span><br><span class="line">ZLEXCOUNT key min max: 用于计算基于成员名称的字典序位于指定区间内的成员数量 # 对于 min和 max，要使用方括号 [ 或 ( 来指示范围的边界是否包含在计数中。方括号 [ 表示该值是包含的，而小括号 ( 表示该值是不包含的。</span><br><span class="line"></span><br><span class="line">&gt; ZCOUNT myZSet 15 20</span><br><span class="line">(integer) 2</span><br><span class="line">&gt; ZLEXCOUNT myZSet [a [z</span><br><span class="line">(integer) 2</span><br><span class="line">&gt; ZLEXCOUNT myZSet [a [b</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">ZSCAN key cursor [MATCH pattern] [COUNT count]: 迭代Redis的有序集合（ZSET）的元素，包括它的成员和分数。是一种渐进地遍历有序集的方法，而不是一次返回所有结果，这对于大型数据集尤为有用，因为它不会因为要返回大量的结果而阻塞服务器。</span><br><span class="line"># cursor: 用于迭代的游标。初次调用时，通常设置为&quot;0&quot;，之后的调用将使用上次返回的游标值。</span><br><span class="line">MATCH pattern (可选): 一个可选的匹配模式，用于筛选具有特定模式的元素。</span><br><span class="line">COUNT count (可选): 提示服务器每次迭代应返回多少元素。实际数目可能会稍多或稍少。</span><br><span class="line"></span><br><span class="line">&gt; ZSCAN myZSet  0</span><br><span class="line">1) &quot;0&quot;</span><br><span class="line">2) 1) &quot;member1&quot;</span><br><span class="line">   2) &quot;15&quot;</span><br><span class="line">   3) &quot;member2&quot;</span><br><span class="line">   4) &quot;20&quot;</span><br><span class="line">&gt; ZSCAN myZSet  0 MATCH  mem*</span><br><span class="line">1) &quot;0&quot;</span><br><span class="line">2) 1) &quot;member1&quot;</span><br><span class="line">   2) &quot;15&quot;</span><br><span class="line">   3) &quot;member2&quot;</span><br><span class="line">   4) &quot;20&quot;</span><br><span class="line">&gt; ZSCAN myZSet  0 COUNT 1</span><br><span class="line">1) &quot;0&quot;</span><br><span class="line">2) 1) &quot;member1&quot;</span><br><span class="line">   2) &quot;15&quot;</span><br><span class="line">   3) &quot;member2&quot;</span><br><span class="line">   4) &quot;20&quot;</span><br></pre></td></tr></table></figure><p><strong>删除操作</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">ZREM key member [member ...]    : 移除有序集合中的一个或多个成员</span><br><span class="line"># 先查看有序集合中的成员及分数</span><br><span class="line">&gt; ZRANGE myZSet 0 -1 WITHSCORES</span><br><span class="line">1) &quot;member1&quot;</span><br><span class="line">2) &quot;15&quot;</span><br><span class="line">3) &quot;member2&quot;</span><br><span class="line">4) &quot;20&quot;</span><br><span class="line">&gt; ZREM myZSet &quot;member1&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; ZRANGE myZSet 0 -1 WITHSCORES</span><br><span class="line">1) &quot;member2&quot;</span><br><span class="line">2) &quot;20&quot;</span><br><span class="line"></span><br><span class="line">ZPOPMAX key [count]             : 移除并返回有序集合中的最大的一些成员</span><br><span class="line">&gt; ZADD myZSet 15 &quot;member1&quot; 30 &quot;member3&quot; 55 &quot;member5&quot; 40 &quot;member4&quot;</span><br><span class="line">(integer) 4</span><br><span class="line">&gt; ZRANGE myZSet 0 -1 WITHSCORES</span><br><span class="line"> 1) &quot;member1&quot;</span><br><span class="line"> 2) &quot;15&quot;</span><br><span class="line"> 3) &quot;member2&quot;</span><br><span class="line"> 4) &quot;20&quot;</span><br><span class="line"> 5) &quot;member3&quot;</span><br><span class="line"> 6) &quot;30&quot;</span><br><span class="line"> 7) &quot;member4&quot;</span><br><span class="line"> 8) &quot;40&quot;</span><br><span class="line"> 9) &quot;member5&quot;</span><br><span class="line">10) &quot;55&quot;</span><br><span class="line">&gt; ZPOPMAX myZSet 2</span><br><span class="line">1) &quot;member5&quot;</span><br><span class="line">2) &quot;55&quot;</span><br><span class="line">3) &quot;member4&quot;</span><br><span class="line">4) &quot;40&quot;</span><br><span class="line">&gt; ZRANGE myZSet 0 -1 WITHSCORES</span><br><span class="line">1) &quot;member1&quot;</span><br><span class="line">2) &quot;15&quot;</span><br><span class="line">3) &quot;member2&quot;</span><br><span class="line">4) &quot;20&quot;</span><br><span class="line">5) &quot;member3&quot;</span><br><span class="line">6) &quot;30&quot;</span><br><span class="line"></span><br><span class="line">ZPOPMIN key [count]             : 移除并返回有序集合中的最小的一些成员</span><br><span class="line"># ZPOPMIN 我这里就不举例了，和 ZPOPMAX 类似</span><br><span class="line"></span><br><span class="line">ZREMRANGEBYRANK key start stop  : 移除有序集合中给定的排名区间的所有成员</span><br><span class="line">ZREMRANGEBYSCORE key min max    : 移除有序集合中给定的分数区间的所有成员</span><br><span class="line">ZREMRANGEBYLEX key min max      : 移除有序集合中给定的成员名字典区间的所有成员</span><br><span class="line"></span><br><span class="line">&gt; ZREMRANGEBYSCORE myZSet 20 30</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; ZRANGE myZSet 0 -1 WITHSCORES</span><br><span class="line">(empty array)</span><br><span class="line">&gt;  ZADD myZSet 15 &quot;member1&quot; 30 &quot;member3&quot; 55 &quot;member5&quot; 40 &quot;member4&quot;</span><br><span class="line">(integer) 4</span><br><span class="line">&gt; ZRANGE myZSet 0 -1 WITHSCORES</span><br><span class="line">1) &quot;member1&quot;</span><br><span class="line">2) &quot;15&quot;</span><br><span class="line">3) &quot;member3&quot;</span><br><span class="line">4) &quot;30&quot;</span><br><span class="line">5) &quot;member4&quot;</span><br><span class="line">6) &quot;40&quot;</span><br><span class="line">7) &quot;member5&quot;</span><br><span class="line">8) &quot;55&quot;</span><br><span class="line">&gt; ZREMRANGEBYLEX myZSet [&quot;member1&quot; [&quot;member4&quot;</span><br><span class="line">(integer) 3</span><br><span class="line">&gt; ZRANGE myZSet 0 -1 WITHSCORES</span><br><span class="line">1) &quot;member5&quot;</span><br><span class="line">2) &quot;55&quot;</span><br></pre></td></tr></table></figure><p><strong>集合操作</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">ZUNIONSTORE destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]    : 计算给定的一个或多个有序集的并集，并存储在新的 destination 中</span><br><span class="line">ZINTERSTORE destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]    : 计算给定的一个或多个有序集的交集，并存储在新的 destination 中</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line">destination   - 新的有序集合的名字，用于存放结果。</span><br><span class="line">numkeys       - 指定将要合并的有序集合的数量。</span><br><span class="line">key [key ...] - 需要合并的有序集合的名字。</span><br><span class="line">WEIGHTS       - 可选参数，用于为每一个输入的有序集分配一个乘法因子。例如，如果某个集合的 WEIGHT 是2，那么在计算并集时，该集合中的每个元素的分数都会乘以2。</span><br><span class="line">AGGREGATE     - 可选参数，它决定了当多个有序集合中存在相同元素时，如何处理这些元素的分数。有三个选项：SUM（默认）、MIN和MAX。SUM将相同元素的分数加起来，MIN 使用最小分数，而 MAX 使用最大分数。</span><br><span class="line"></span><br><span class="line">&gt; ZADD set1 1 &quot;one&quot; 2 &quot;two&quot;</span><br><span class="line">(integer) 2</span><br><span class="line">&gt; ZADD set2 1 &quot;one&quot; 3 &quot;three&quot;</span><br><span class="line">(integer) 2</span><br><span class="line">&gt; ZRANGE set1 0 -1 WITHSCORES</span><br><span class="line">1) &quot;one&quot;</span><br><span class="line">2) &quot;1&quot;</span><br><span class="line">3) &quot;two&quot;</span><br><span class="line">4) &quot;2&quot;</span><br><span class="line">&gt; ZRANGE set2 0 -1 WITHSCORES</span><br><span class="line">1) &quot;one&quot;</span><br><span class="line">2) &quot;1&quot;</span><br><span class="line">3) &quot;three&quot;</span><br><span class="line">4) &quot;3&quot;</span><br><span class="line">&gt; ZUNIONSTORE result 2 set1 set2</span><br><span class="line">(integer) 3</span><br><span class="line">&gt; ZRANGE result 0 -1 WITHSCORES</span><br><span class="line">1) &quot;one&quot;</span><br><span class="line">2) &quot;2&quot;</span><br><span class="line">3) &quot;two&quot;</span><br><span class="line">4) &quot;2&quot;</span><br><span class="line">5) &quot;three&quot;</span><br><span class="line">6) &quot;3&quot;</span><br><span class="line"># 当然，你可以使用 WEIGHTS 和 AGGREGATE 参数来调整结果的计算方式。例如，如果你想要为 set1 的每个成员加倍其分数，然后和 set2 求并集，并取每个成员的最大值作为结果：</span><br><span class="line"></span><br><span class="line"># set1 set2 两个集合的初始值没变，还是上面的数据</span><br><span class="line">&gt; ZUNIONSTORE result 2 set1 set2  WEIGHTS 2 1 AGGREGATE MAX</span><br><span class="line">(integer) 3</span><br><span class="line">&gt; ZRANGE result 0 -1 WITHSCORES</span><br><span class="line">1) &quot;one&quot;</span><br><span class="line">2) &quot;2&quot;</span><br><span class="line">3) &quot;three&quot;</span><br><span class="line">4) &quot;3&quot;</span><br><span class="line">5) &quot;two&quot;</span><br><span class="line">6) &quot;4&quot;</span><br></pre></td></tr></table></figure><h4 id="应用案例-3"><a href="#应用案例-3" class="headerlink" title="应用案例"></a>应用案例</h4><p><strong>实时排行榜</strong></p><ul><li><strong>游戏排行榜</strong></li></ul><p>在线游戏的实时排行榜，玩家或用户的得分可以即时更新，并按分数进行排序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 添加或更新分数</span><br><span class="line">ZADD leaderboard 1500 &quot;player1&quot;</span><br><span class="line">ZADD leaderboard 2200 &quot;player2&quot;</span><br><span class="line">ZADD leaderboard 1800 &quot;player3&quot;</span><br><span class="line">#查询前3名玩家</span><br><span class="line">ZREVRANGE leaderboard 0 2 WITHSCORES</span><br><span class="line"># 获取某个玩家的排名</span><br><span class="line">ZREVRANK leaderboard &quot;player1&quot;</span><br></pre></td></tr></table></figure><ul><li>网站文章或视频的热门排行</li></ul><p>网站可能希望展示其上点击量最高的文章或视频。每次有用户点击时，相关内容的计数就会增加，然后可以使用有序集合实时显示热门内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 文章被点击：</span><br><span class="line">ZINCRBY article_views 1 &quot;article123&quot;</span><br><span class="line">#获取最热门的 3 篇文章</span><br><span class="line">ZREVRANGE article_views 0 2 WITHSCORES</span><br></pre></td></tr></table></figure><ul><li>电商平台的热门产品排行</li></ul><p>电商平台可能希望展示最受欢迎的产品。每当产品被购买，其热度都会增加。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#产品被购买：</span><br><span class="line">ZINCRBY product_sales 1 &quot;product123&quot;</span><br><span class="line">#获取最受欢迎的10个产品</span><br><span class="line">ZREVRANGE product_sales 0 9 WITHSCORES</span><br></pre></td></tr></table></figure><p><strong>时间线事件记录</strong></p><p><strong>场景描述：</strong>假设我们正在为一个社交网络网站设计功能，用户每次登录、发帖或评论都会在其时间线上生成一个事件。我们希望可以跟踪这些事件并能够检索特定时间范围内的事件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#用户在某个时间点登录了网站</span><br><span class="line">ZADD user123:timeline 1631498200 &quot;Logged in&quot;</span><br><span class="line">#该用户稍后发表了一篇文章</span><br><span class="line">ZADD user123:timeline 1631498300 &quot;Posted an article about Redis&quot;</span><br><span class="line">#查询该用户在指定的时间范围内的所有事件</span><br><span class="line">ZRANGEBYSCORE user123:timeline 1631498200 1631498400</span><br></pre></td></tr></table></figure><p><strong>延迟任务队列</strong></p><p><strong>场景描述：</strong>用户订阅了一个在线服务，比如说一个<strong>音乐服务</strong>，它提供了<strong>一个月</strong>的免费试用。为了提醒用户及时续费或者保存他们的歌单数据，服务提供商可以在试用期结束前的几天，发送一个“您的试用即将结束，请及时续费”的提醒。这个提醒任务就可以放入延迟队列。</p><p><strong>具体实现步骤：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 用户注册: 当用户开始他们的免费试用时，你会将这个用户和他们试用结束时间的时间戳（减去3天，这样在结束前3天提醒他们）加入到一个有序集合中。</span><br><span class="line">ZADD trial_end_reminders (start_timestamp + trial_period - few_days) user_id  # 一般时间戳是以秒为单位的，对于这个例子，trial_period = 24*86400，few_days = 3 * 86400。</span><br><span class="line">#后台任务：后台任务每天定期检查这个有序集合，查看哪些用户需要在今天被提醒。</span><br><span class="line">ZRANGEBYSCORE trial_end_reminders (current_timestamp) (current_timestamp + 86400)</span><br><span class="line"></span><br><span class="line">#发送提醒：对于上面命令返回的每一个用户，你的系统会发送一个提醒邮件或者应用内通知，告诉他们试用即将结束，并提供一个续订链接。</span><br><span class="line"></span><br><span class="line">#清理：在发送提醒后，你需要从有序集合中移除这些用户，确保他们不会被再次提醒。</span><br><span class="line">ZREM trial_end_reminders user_id_1 user_id_2 ...</span><br></pre></td></tr></table></figure><h3 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps"></a><strong>Bitmaps</strong></h3><h4 id="基本概念：-3"><a href="#基本概念：-3" class="headerlink" title="基本概念："></a><strong>基本概念：</strong></h4><p>Redis 的 Bitmaps（位图）是一种特殊的数据结构，用于高效地处理大量的布尔值（true&#x2F;false或者1&#x2F;0）。在 Redis 中，Bitmaps 实际上并不是一种独立的数据类型，而是字符串（String）类型的一种特殊操作方式。通过 <strong>位操作</strong> 命令，Redis 允许用户在一个很大的字节数组中设置和获取位（bit）的值。</p><h4 id="简单图解-4"><a href="#简单图解-4" class="headerlink" title="简单图解:"></a><strong>简单图解:</strong></h4><p><img src="/images/RedisObject/7.png"></p><h4 id="内部实现-5"><a href="#内部实现-5" class="headerlink" title="内部实现"></a>内部实现</h4><p><strong>Bitmaps</strong> 实际上就是一个 String，底层采用字节数组来存储数据。</p><p>Bitmaps 提供了一系列的命令来操作和查询二进制位。</p><h4 id="基本命令："><a href="#基本命令：" class="headerlink" title="基本命令："></a>基本命令：</h4><p><strong>设置和获取位值：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SETBIT key offset value    : 设置或清除操作只需将对应位 置 0 即可指定的位 # 清除操作只需将对应位 置 0 即可， offset只能是非负整数。</span><br><span class="line">GETBIT key offset          : 获取指定位的值</span><br><span class="line"></span><br><span class="line">#  将位于索引7的位设置为1</span><br><span class="line">&gt; SETBIT mymap 7 1</span><br><span class="line">(integer) 0</span><br><span class="line">#  获取位于索引7的位的值</span><br><span class="line">&gt; GETBIT mymap 7</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p><strong>统计和查找：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">BITCOUNT key                 ：计算整个字符串中设置为1的位数</span><br><span class="line">BITCOUNT key [start end]     ：计算在指定范围内设置为1的位数</span><br><span class="line">BITPOS key bit [start] [end] : 找到第一个设置为1或0的位</span><br><span class="line"></span><br><span class="line">其中，start和end是字符串的字节索引（不是bit索引）</span><br><span class="line"></span><br><span class="line">&gt; BITCOUNT mymap  </span><br><span class="line">(integer) 1</span><br><span class="line">&gt; BITCOUNT mymap 0 1  # 计算从字节0到字节1之间设置为1的位数</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; BITPOS mymap 1</span><br><span class="line">(integer) 7</span><br><span class="line">&gt; BITPOS mymap 0</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure><p><strong>其他运算</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BITOP operation destkey key [key ...]   ： 对一个或多个bitmaps进行位运算</span><br><span class="line">operation 可能是 AND, OR, XOR, NOT 其中一种</span><br><span class="line">AND:逻辑与 、OR:逻辑或、XOR:逻辑异或、NOT：逻辑非</span><br><span class="line"></span><br><span class="line">&gt; SETBIT yourmap 5 1</span><br><span class="line">(integer) 0</span><br><span class="line">&gt; BITOP AND destMap mymap yourmap</span><br><span class="line">(integer) 1         # 返回 1，表示 destMap 的长度是 1 字节         </span><br></pre></td></tr></table></figure><h4 id="应用案列："><a href="#应用案列：" class="headerlink" title="应用案列："></a><strong>应用案列：</strong></h4><p><strong>员工打卡签到：</strong></p><p>大家都知道，员工打卡签到系统几乎是每家公司的标配功能。每天上班，员工都需要打卡来记录他们的出勤情况。今天我们来探讨一下，如何利用 Redis 中的 Bitmaps 来高效地实现这个功能。</p><p><strong>为什么选择 Bitmaps?</strong></p><p>员工打卡签到无非就是两种结果：签到和未签到。这种二元状态正好与Bitmaps的存储方式相契合，每位员工的每天签到状态只需用一个位（0或1）来表示。</p><p>每天使用一个特定日期格式的 key（如 user:12345:attendance:2023-09-01）存储Bitmaps。员工的 ID 直接作为位索引，如 ID 为 42 的员工签到，则将sign_2023-09-01的第 42 位设为 1。</p><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#员工打卡签到</span><br><span class="line">SETBIT user:42:attendance:2023-09-01 42 1    # 员工 ID 42 在2023-09-01签到</span><br><span class="line">SETBIT user:42:attendance:2023-09-01 1024 1  # 员工 ID 1024 在2023-09-01签到</span><br><span class="line"></span><br><span class="line">#检查特定用户是否在某天签到</span><br><span class="line">GETBIT user:42:attendance:2023-09-01 42  # 查看员工 ID 42 在2023-09-01是否签到</span><br><span class="line">GETBIT user:42:attendance:2023-09-01 500  # 查看员工 ID 500 在2023-09-01是否签到</span><br><span class="line"></span><br><span class="line">#计算某一天的签到用户数</span><br><span class="line">BITCOUNT user:42:attendance:2023-09-01  # 查看2023-09-01的签到用户数</span><br></pre></td></tr></table></figure><p><strong>日活跟踪:</strong></p><p>记录特定日期所有活跃用户的信息。例如，我们可以使用一个特定日期的 bitmaps 来跟踪该日期的所有活跃用户。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 用户 ID 为 12345 和 67890 在 2023-09-01 都活跃了</span><br><span class="line">SETBIT active_users:2023-09-01 12345 1</span><br><span class="line">SETBIT active_users:2023-09-01 67890 1</span><br><span class="line"></span><br><span class="line"># 检查用户 ID 为 12345 在 2023-09-01 是否活跃</span><br><span class="line">GETBIT active_users:2023-09-01 12345</span><br><span class="line"></span><br><span class="line">#检查某一天所有的活跃用户数</span><br><span class="line">BITCOUNT user:42:attendance:2023-09-01</span><br></pre></td></tr></table></figure><p><strong>用户登录：</strong></p><p>可以使用 bitmaps 来跟踪用户的登录状态，例如，确定用户是否已登录。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 用户 ID 为 12345 登录了</span><br><span class="line">SETBIT user:12345:login_status 1</span><br><span class="line"></span><br><span class="line"># 检查用户 ID 为 12345 是否登录</span><br><span class="line">GETBIT user:12345:login_status</span><br></pre></td></tr></table></figure><p><strong>这三个应用的关注点区别：</strong></p><p><strong>打卡签到：</strong> 主要关注个体用户的连续行为，例如连续签到多少天。</p><p><strong>日活跟踪：</strong> 关注整体的用户行为，例如在某一天有多少用户活跃了。</p><p><strong>用户登录：</strong> 主要跟踪用户的即时状态，例如某用户当前是否在线或已登录。</p><h3 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h3><p>在大数据应用中，我们经常需要计算或估算某个集合中不重复元素的数量（<strong>基数</strong>），例如统计网站的独立访客(UV)。但当数据规模非常大时，传统的统计方法会消耗大量的存储和计算资源。这时，Redis 的 HyperLogLog（简称HLL）提供了一个很好的解决方案。</p><h4 id="基本概念：-4"><a href="#基本概念：-4" class="headerlink" title="基本概念："></a>基本概念：</h4><p>从广义上说，HyperLogLog 是一个概率性的数据结构，用于估算集合的<strong>基数</strong>（即<strong>不重复元素的数量</strong>）。它不会提供完美准确的计数，但它使用的存储空间非常小（最多使用12KB的内存）。</p><p>在 <strong>Redis</strong> 的语境中，我们可以将 HyperLogLog 视为一种特定的数据类型。</p><h4 id="简单图解：-1"><a href="#简单图解：-1" class="headerlink" title="简单图解："></a>简单图解：</h4><p><img src="/images/RedisObject/8.png"></p><p><strong>步骤说明：</strong></p><ul><li>输入值通过哈希函数生成固定长度的二进制哈希值。</li><li>哈希值的前几位决定了它应该进入数组的位置。</li><li>存储值，将给定值的前导零的个数存储在数组的对应位置</li><li>数组中的值可能会根据新的哈希值进行更新（新的哈希值的前导零个数大于数组值才会更新）</li><li>根据数组元素进行基数估计</li></ul><h4 id="内部实现-6"><a href="#内部实现-6" class="headerlink" title="内部实现"></a>内部实现</h4><p>Redis 的 HyperLogLog 是一种特殊的数据类型，用来估计一个集合中有多少不同的元素。它不会给出完全准确的答案，但它的估计接近真实值，并且使用的存储空间非常小。它是基于一种名为 ‘HyperLogLog’ 的聪明算法来工作的，这种算法使用概率学的魔法来做估计，而不是真正地数每一个元素。</p><h4 id="基本命令：-1"><a href="#基本命令：-1" class="headerlink" title="基本命令："></a><strong>基本命令：</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">PFADD key element [element ...]           :  添加元素</span><br><span class="line">PFCOUNT key [key ...]                     :  查询基数估计值</span><br><span class="line">PFMERGE destkey sourcekey [sourcekey ...] :  合并多个 HyperLogLog 数据集</span><br><span class="line"></span><br><span class="line">&gt; PFADD myhll a b c d e f g</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; PFCOUNT myhll</span><br><span class="line">(integer) 7</span><br><span class="line">&gt; PFADD yourhll a b c d h i j k</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; PFMERGE desthll myhll yourhll</span><br><span class="line">OK</span><br><span class="line">&gt; PFCOUNT desthll</span><br><span class="line">(integer) 11</span><br></pre></td></tr></table></figure><h4 id="应用案例：-1"><a href="#应用案例：-1" class="headerlink" title="应用案例："></a><strong>应用案例：</strong></h4><p><strong>网站的 UV（独立访客）统计</strong></p><p>当你要统计一个网站的UV（独立访客）时，你的目标是确定有多少独立的用户访问了你的网站，而不是访问的总次数。传统的方法（比如，基于关系型数据库的计数）可能会很耗资源，特别是当访客量非常大时。</p><p>而 Redis 的 HyperLogLog 提供了一个空间效率非常高的方式来进行这样的估算。每当有用户访问网站时，你可以记录其 IP 地址或者某个与用户相关的唯一标识符（sessionID），然后使用 PFADD 命令将其加入到 HyperLogLog 中。</p><p><strong>具体实现：</strong></p><p><strong>为每个独立的访客生成唯一标识：</strong></p><p>现在大部分网站都会采用 cookie 技术。每当用户访问网站时，服务器都会为这位新访客生成一个唯一的 ID 并将其存储在 cookie 中。这个唯一的 ID 用于在后续的访问中识别该用户，从而跟踪其在网站上的行为和偏好。</p><p>我们使用 <strong>user_cookie_12345</strong> ，<strong>user_cookie_12346</strong> 等来标识不同的cookie</p><p><strong>添加 Cookie 到 HyperLogLog:</strong></p><p>为了跟踪一天的 UV，可以为每天创建一个 HyperLogLog。当用户访问你的网站时，使用PFADD命令将他们的唯一标识添加到 HyperLogLog 中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; PFADD uv_2023_09_01 user_cookie_12345 </span><br><span class="line">&gt; PFADD uv_2023_09_01 user_cookie_12346 </span><br><span class="line">&gt; PFADD uv_2023_09_01 user_cookie_12347 </span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><strong>估算该日的UV：</strong></p><p>使用 PFCOUNT 命令来获取估算的UV值。</p><p>该命令会返回一个估算的独立访客数量。请注意，这是一个估算值，但其精度在大多数情况下是足够的。</p><p><strong>存储历史数据：</strong></p><p>如果你想跟踪UV的历史数据，可以为每天保留一个 HyperLogLog。例如：uv_2023_09_01、uv_2023_09_02等。</p><p><strong>合并多日数据：</strong></p><p>如果你想要一个时间范围内的估算 UV（例如一个月），你可以使用 PFMERGE 命令合并多个 HyperLogLog。</p><p>以上就是使用 Redis 的 HyperLogLog 进行网站UV统计的基本方法。使用这种方法，你可以用非常少的空间（每个 HyperLogLog 只需要12KB）来跟踪大量的独立访客。</p><h3 id="Geospatial"><a href="#Geospatial" class="headerlink" title="Geospatial"></a>Geospatial</h3><p><strong>简介：</strong></p><p>Redis支持一个称为 Geospatial 的地理空间索引功能。这一功能在许多需要地理定位数据的应用中都有着广泛应用，如找到某个位置附近的餐厅或商店等。</p><h4 id="基本概念：-5"><a href="#基本概念：-5" class="headerlink" title="基本概念："></a>基本概念：</h4><p>“Geo” 来源于希腊语，意为“地球”，而 “spatial” 则表示“与空间有关”。结合起来，Geospatial 主要关注地球上的空间位置或地域。在 Redis 中，这意味着我们可以使用坐标系统（如经纬度）来存储和查询地理位置的数据。</p><h4 id="简单图解-5"><a href="#简单图解-5" class="headerlink" title="简单图解:"></a>简单图解:</h4><p><img src="/images/RedisObject/9.png"></p><h4 id="内部实现-7"><a href="#内部实现-7" class="headerlink" title="内部实现:"></a>内部实现:</h4><p><strong>地图到数字：</strong></p><p>想象一下，我们的地球是一个巨大的地图。如果我们要在这张地图上标记一个位置，通常会使用经纬度来描述它。但计算机更擅长处理数字而不是这样的坐标。因此，Redis 使用了一种叫做 Geohash 的技巧，它可以把这些坐标（比如经纬度）转换成一个数字。</p><p><strong>把位置存进列表：</strong></p><p>Redis 有一种特殊的列表叫做 zset（有序集合）。在 Geospatial 中，位置的名字（比如”北京”）作为元素，而转换得到的数字（Geohash）作为这个元素的“分数”。</p><p><strong>查找附近的地方：</strong></p><p>当我们想知道某个位置附近的其他地方时，Redis 会先找出这个位置的数字（Geohash），然后在 zset 中查找分数接近的其他元素。这样就可以快速地找出附近的位置。</p><p><strong>注意：</strong></p><p>使用 Geohash 的方法可能不是百分之百精确的，因为它是一种近似的方法。但在实际应用中，这种小小的误差通常不会导致太大的问题，而它让存储和查找变得非常迅速。</p><h4 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a><strong>基本命令</strong></h4><p><strong>添加操作：</strong></p><p>向指定的键中添加地理空间位置（经度、纬度、名称）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GEOADD key longitude latitude member [longitude latitude member ...]                    : 向指定的键中添加地理空间位置（经度、纬度、名称）</span><br><span class="line"></span><br><span class="line">&gt; GEOADD china:city 114.085947 22.547 shenzhen 113.280637 23.125178 guangzhou</span><br><span class="line">(integer) 2</span><br><span class="line">&gt; GEOADD china:city 121.472644 31.231706 shanghai 116.405285 39.904989 beijing</span><br><span class="line">(integer) 2</span><br><span class="line">&gt; GEOADD china:city 108.948024 34.263161 xian 106.504962 29.533155 chongqing</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure><p><strong>获取操作：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">GEOPOS key member [member ...]                      : 获取一个或多个位置元素的经纬度</span><br><span class="line">GEODIST key member1 member2 [m|km|ft|mi]            : 获取两个地点之间的距离    # [m|km|ft|mi]:  分别是：米，千米，英尺，英里</span><br><span class="line">GEORADIUS key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [ASC|DESC] [COUNT count]  : 根据给定的经纬度坐标，返回位于给定距离内的位置。</span><br><span class="line"></span><br><span class="line">#参数详解</span><br><span class="line">WITHCOORD    ： 返回查询结果中地理位置的经纬度坐标</span><br><span class="line">WITHDIST     ： 返回每个查询结果地点到给定坐标的距离</span><br><span class="line">WITHHASH     ： 返回位置的 52 位整数表示的 geohash</span><br><span class="line">ASC|DESC     ： 决定了查询结果的排序方式，按距离升序排列、按距离降序排列 </span><br><span class="line">COUNT count  :  限制查询结果的数量。</span><br><span class="line"></span><br><span class="line">&gt; GEOADD china:city 108.948024 34.263161 xian 106.504962 29.533155 chongqing</span><br><span class="line">(integer) 2</span><br><span class="line">&gt; GEOPOS china:city xian chongqing</span><br><span class="line">1) 1) &quot;108.94802302122116089&quot;</span><br><span class="line">   2) &quot;34.2631604414749944&quot;</span><br><span class="line">2) 1) &quot;106.50495976209640503&quot;</span><br><span class="line">   2) &quot;29.53315530684997015&quot;</span><br><span class="line">&gt; GEODIST china:city shenzhen xian km</span><br><span class="line">&quot;1396.1268&quot;</span><br><span class="line">&gt; GEORADIUS china:city 118.767413 32.041544 500 km</span><br><span class="line">1) &quot;shanghai&quot;</span><br><span class="line">&gt; GEORADIUS china:city 118.767413 32.041544 500 km WITHCOORD</span><br><span class="line">1) 1) &quot;shanghai&quot;</span><br><span class="line">   2) 1) &quot;121.47264629602432251&quot;</span><br><span class="line">      2) &quot;31.23170490709807012&quot;</span><br><span class="line">&gt; GEORADIUS china:city 118.767413 32.041544 500 km WITHDIST</span><br><span class="line">1) 1) &quot;shanghai&quot;</span><br><span class="line">   2) &quot;271.5419&quot;</span><br></pre></td></tr></table></figure><p><strong>我们来看一个混合使用参数的例子：</strong></p><p>查询距离某个位置 1000 公里内的所有地方，并返回其名称、距离、坐标，然后按距离升序排序，只显示前 3 个结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt; GEORADIUS china:city 118.767413 32.041544 1000 km WITHDIST WITHCOORD ASC COUNT 3</span><br><span class="line">1) 1) &quot;shanghai&quot;</span><br><span class="line">   2) &quot;271.5419&quot;</span><br><span class="line">   3) 1) &quot;121.47264629602432251&quot;</span><br><span class="line">      2) &quot;31.23170490709807012&quot;</span><br><span class="line">2) 1) &quot;beijing&quot;</span><br><span class="line">   2) &quot;899.9931&quot;</span><br><span class="line">   3) 1) &quot;116.40528291463851929&quot;</span><br><span class="line">      2) &quot;39.9049884229125027&quot;</span><br><span class="line">3) 1) &quot;xian&quot;</span><br><span class="line">   2) &quot;946.7395&quot;</span><br><span class="line">   3) 1) &quot;108.94802302122116089&quot;</span><br><span class="line">      2) &quot;34.2631604414749944&quot;</span><br></pre></td></tr></table></figure><h4 id="应用案例-4"><a href="#应用案例-4" class="headerlink" title="应用案例"></a><strong>应用案例</strong></h4><p><strong>位置数据存储与查询</strong>：</p><ul><li><strong>社交应用</strong>：用户可以查找附近的朋友或兴趣点。例如，一个社交网络应用可以允许用户查看附近的其他用户或活动。</li><li><strong>出行与导航</strong>：用于存储和查询地理位置数据，如共享单车或共享汽车的当前位置，以及用户附近的可用车辆。</li></ul><h3 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a><strong>Stream</strong></h3><h4 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a><strong>基本概念</strong></h4><p>Redis Stream 是 Redis 5.0 中引入的新数据类型，设计用来存储和查询日志数据结构。Stream 是 Redis 对“日志”数据结构的实现，这种结构在各种场景中都很有用，如<strong>消息队列</strong>和<strong>事件日志</strong>。</p><p>与简单的 List 不同，Stream 能够更好地支持多用户并发操作，同时还提供了复杂的消息确认和消费机制。</p><h4 id="Stream-基本组件介绍"><a href="#Stream-基本组件介绍" class="headerlink" title="Stream 基本组件介绍"></a>Stream 基本组件介绍</h4><p><strong>Stream：</strong>一个Stream是一个按时间顺序排列的消息列表。每个消息都有一个唯一的ID和键值对组成的数据。</p><p><strong>Consumer：</strong>这是一个从 Stream 读取消息的客户端。每个 Consumer 都有一个唯一的名字。</p><p><strong>Consumer Group：</strong>一个 Consumer Group 包含一组 Consumer，它们共同读取一个 Stream。这样做是为了并行处理消息。</p><h4 id="简单图解-6"><a href="#简单图解-6" class="headerlink" title="简单图解"></a>简单图解</h4><p><img src="/images/RedisObject/10.png"></p><h4 id="内部实现-8"><a href="#内部实现-8" class="headerlink" title="内部实现:"></a>内部实现:</h4><p><strong>ListPack :</strong> Redis 中的 Stream 的底层用的是一种名为 ListPack 的数据结构，它非常紧凑并且效率高。</p><p><strong>唯一ID :</strong> 每个消息都有一个由时间戳和序列号组成的唯一ID，确保消息的全局唯一性。</p><h4 id="基本命令-1"><a href="#基本命令-1" class="headerlink" title="基本命令:"></a><strong>基本命令:</strong></h4><p><strong>基础操作</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">添加操作：</span><br><span class="line">XADD key  *|ID field value [field value ...]  :   </span><br><span class="line"># *|ID: 消息的 ID。使用 * 会自动生成一个ID，或者你可以指定一个</span><br><span class="line"></span><br><span class="line">&gt; XADD mystream * name xiaokang age 25</span><br><span class="line">&quot;1695020949856-0&quot;</span><br><span class="line">&gt; XADD mystream * hobby swim job programmer</span><br><span class="line">&quot;1695029970290-0&quot;</span><br><span class="line"></span><br><span class="line">查询操作:</span><br><span class="line">XRANGE key start end [COUNT count]      ：  查询指定ID范围内的消息</span><br><span class="line">XREVRANGE key end start [COUNT count]   :   反向查询指定ID范围内的消息</span><br><span class="line"></span><br><span class="line">#  参数说明：</span><br><span class="line">key            : 表示你要检索的 Stream 的名字</span><br><span class="line">[COUNT count]  : 可选参数，用于限制返回的消息数量</span><br><span class="line">对于 XRANGE 命令，参数 start 和 end 的含义：</span><br><span class="line">start          : 检索的起始消息 ID</span><br><span class="line">end            : 检索的结束消息 ID</span><br><span class="line"></span><br><span class="line">对于 XRANGE 命令，参数 start 和 end 的含义： </span><br><span class="line">start          : 反向检索的起始消息 ID</span><br><span class="line">end            : 反向检索的结束消息 ID</span><br><span class="line"></span><br><span class="line">特殊符号解释:</span><br><span class="line">参数 start 取 &#x27;-&#x27; ， 表示最早的消息，取 + 表示最新的消息</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 检索所有消息</span><br><span class="line">&gt; XRANGE mystream - +</span><br><span class="line">1) 1) &quot;1695020949856-0&quot;</span><br><span class="line">   2) 1) &quot;name&quot;</span><br><span class="line">      2) &quot;xiaokang&quot;</span><br><span class="line">      3) &quot;age&quot;</span><br><span class="line">      4) &quot;25&quot;</span><br><span class="line">2) 1) &quot;1695029970290-0&quot;</span><br><span class="line">   2) 1) &quot;hobby&quot;</span><br><span class="line">      2) &quot;swim&quot;</span><br><span class="line">      3) &quot;job&quot;</span><br><span class="line">      4) &quot;programmer&quot;</span><br><span class="line">#  反向检索所有消息</span><br><span class="line">&gt; XREVRANGE  mystream +  -</span><br><span class="line">1) 1) &quot;1695029970290-0&quot;</span><br><span class="line">   2) 1) &quot;hobby&quot;</span><br><span class="line">      2) &quot;swim&quot;</span><br><span class="line">      3) &quot;job&quot;</span><br><span class="line">      4) &quot;programmer&quot;</span><br><span class="line">2) 1) &quot;1695020949856-0&quot;</span><br><span class="line">   2) 1) &quot;name&quot;</span><br><span class="line">      2) &quot;xiaokang&quot;</span><br><span class="line">      3) &quot;age&quot;</span><br><span class="line">      4) &quot;25&quot;</span><br><span class="line"></span><br><span class="line">获取长度：</span><br><span class="line">XLEN key                   ：获取Stream中的消息数量</span><br><span class="line"></span><br><span class="line">&gt; XLEN mystream</span><br><span class="line">(integer) 2</span><br><span class="line"></span><br><span class="line">裁剪操作：</span><br><span class="line">XTRIM key MAXLEN|MINID [=|~] threshold [LIMIT count]  ：裁减Stream 的长度，控制其大小</span><br><span class="line"># 参数说明</span><br><span class="line">MAXLEN|MINID  : 裁减策略选择。</span><br><span class="line">MAXLEN        ：使 Stream 最多保持指定数量的消息。</span><br><span class="line">MINID         ：删除所有小于指定ID的消息。</span><br><span class="line"></span><br><span class="line">[=|~]: 这是一个可选的修饰符，与上面的 MAXLEN 或 MINID 一起使用。</span><br><span class="line"></span><br><span class="line">=：这意味着长度或ID应该精确匹配。对于 MAXLEN，它确保Stream的长度恰好等于指定的长度（删除任何额外的消息）；对于 MINID，它确保删除的所有消息的ID值都小于等于给定值。</span><br><span class="line">~：这意味着长度或ID是一个近似值。这可能会导致更快的裁减操作，但Stream的实际长度可会略微超过或低于指定的值。</span><br><span class="line">[LIMIT count]  : 这是一个可选的参数，它限制了在一个操作中可以删除的消息数</span><br><span class="line"></span><br><span class="line">&gt; XTRIM mystream MAXLEN = 1</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; XRANGE mystream - +</span><br><span class="line">1) 1) &quot;1695029970290-0&quot;</span><br><span class="line">   2) 1) &quot;hobby&quot;</span><br><span class="line">      2) &quot;swim&quot;</span><br><span class="line">      3) &quot;job&quot;</span><br><span class="line">      4) &quot;programmer&quot;</span><br><span class="line">      </span><br><span class="line">删除操作：</span><br><span class="line">XDEL key ID [ID ...]       ： 从Stream中删除指定的消息</span><br><span class="line"></span><br><span class="line">&gt; XDEL mystream &quot;1695029970290-0&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; XRANGE mystream - +</span><br><span class="line"></span><br><span class="line">读取消息操作:</span><br><span class="line"></span><br><span class="line">XREAD [COUNT count] [BLOCK milliseconds] STREAMS key [key ...] ID [ID ...]                    : 用于从一个或多个流中读取消息</span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line">COUNT count                  :可选参数，指定要从每个流中读取的最大消息数。</span><br><span class="line">BLOCK milliseconds           :可选参数，阻塞操作的时间（以毫秒为单位）。该命令会等待指定的时间，直到有新的消息可用。 在给定的时间内没有新消息，则命令会返回一个空响应</span><br><span class="line">STREAMS                      :指示后面要列出要从中读取的流的名称。这是一个固定的关键字。</span><br><span class="line">key [key ...]                :要从中读取的流的名称列表</span><br><span class="line">ID [ID ...]                  :为每个指定的流提供一个消息 ID，从该 ID 之后（不包括该 ID）开始读取消息。</span><br><span class="line">特殊 ID $                     :表示只读取新的消息，也就是那些在发出此 XREAD 命令之后添加到流中的消息。</span><br></pre></td></tr></table></figure><p><strong>消费者和消费者组操作</strong></p><p>XGROUP：用于创建、修改或删除消费者组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 参数说明:</span><br><span class="line">CREATE : 创建一个新的消费者组。</span><br><span class="line">XGROUP CREATE key groupname ID|$ [MKSTREAM]</span><br><span class="line"></span><br><span class="line">key        : Stream 的名称。</span><br><span class="line">groupname  : 消费者组的名称。</span><br><span class="line">ID         : 从哪个消息 ID 开始消费。如果选择 $，则只会消费新添加到 Stream 的消息。</span><br><span class="line">MKSTREAM   : 可选参数。如果 Stream 不存在，它会创建一个新的空 Stream。</span><br><span class="line"></span><br><span class="line">SETID  :  设置消费者组的开始消费消息的 ID。</span><br><span class="line">XGROUP SETID key groupname ID|$</span><br><span class="line">key        : Stream 的名称。</span><br><span class="line">groupname  : 消费者组的名称。</span><br><span class="line">ID         : 从哪个消息 ID 开始消费。如果选择 $，则只会消费新添加到 Stream 的消息。</span><br><span class="line"></span><br><span class="line">DESTROY  :  删除一个消费者组。</span><br><span class="line">XGROUP DESTROY key groupname</span><br><span class="line">key        : Stream 的名称。</span><br><span class="line">groupname  : 消费者组的名称。</span><br><span class="line"></span><br><span class="line">CREATECONSUMER  :  在给定的消费者组中显式地创建一个消费者。</span><br><span class="line">XGROUP CREATECONSUMER key groupname consumername</span><br><span class="line">key          : Stream 的名称。</span><br><span class="line">groupname    : 消费者组的名称。</span><br><span class="line">consumername : 新创建的消费者的名称。</span><br></pre></td></tr></table></figure><p>XREADGROUP：使用消费者组从Stream中读取消息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [key ...] ID [ID ...] </span><br><span class="line"># 参数说明：</span><br><span class="line">group               : 指的是你想读取消息的消费者组的名称。</span><br><span class="line">consumer            : 是该消费者组内的消费者名称。每次使用 XREADGROUP，都需要指定消费者名称。</span><br><span class="line">COUNT count         : 可选参数，指定从每个流中读取的最大消息数量。</span><br><span class="line">NOACK               : 消息在被读取时不会被标记为“未确认”。因此，不需要（也不能）对它们进行确认。默认情况下，当消费者读取消息后，是需要对消息进行确认的。</span><br><span class="line">ID [ID ...]         : 为每个指定的流提供一个消息 ID，从该 ID 之后（不包括该 ID）开始读取消息。</span><br><span class="line">特殊 ID &gt;            : 表示从上次读取的位置继续读取（只在使用 XREADGROUP 时有效）。</span><br></pre></td></tr></table></figure><p>XACK   : 用来确认消费者已成功处理的特定消息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">XACK key group ID [ID ...] </span><br><span class="line"></span><br><span class="line"># 参数解释 </span><br><span class="line">key            : 这是你要确认消息的 Stream 的名字。</span><br><span class="line">group          : 这是消息所属的消费者组的名称。</span><br><span class="line">ID [ID ...]    : 一个或多个你想确认的消息的 ID。</span><br></pre></td></tr></table></figure><p>XPENDING  ：用于查询消费者组中待处理（已发送但未确认）的消息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">XPENDING key group [[IDLE min-idle-time] start end count [consumer]]</span><br><span class="line">key                           : 你要查询的 Stream 的名称。</span><br><span class="line">group: 你要查询的消费者组的名称。</span><br><span class="line">IDLE min-idle-time            : 这是一个可选的参数，它允许你只查询那些已经空闲或未确认超过指定毫秒数的消息。</span><br><span class="line">start                         : 起始消息 ID。</span><br><span class="line">end                           : 结束消息 ID。</span><br><span class="line">count                         : 你要返回的消息的最大数量。</span><br><span class="line">consumer                      : 这是一个可选的参数，它允许你只查询特定消费者的待处理消息。</span><br></pre></td></tr></table></figure><p>XCLAIM ：允许一个消费者重新认领消费者组中的挂起消息，通常用于处理由失效消费者未完成的消息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">XCLAIM key group consumer min-idle-time ID [ID ...] [IDLE ms] [TIME ms-unix-time] [RETRYCOUNT count] [force] [justid] </span><br><span class="line"></span><br><span class="line">key                        : 指定的 Stream 名称。</span><br><span class="line">group                      : 你想要操作的消费者组名称。</span><br><span class="line">consumer                   : 这是尝试认领消息的消费者的名字。</span><br><span class="line">min-idle-time              : 以毫秒为单位的时间，仅当消息的闲置时间超过此值时，消费者才能认领该消息。</span><br><span class="line">ID [ID ...]                : 你想要认领的消息的 ID 列表。</span><br><span class="line">IDLE ms                    : 设置消息的新的闲置时间（自从最后一次被消费以来的时间）。</span><br><span class="line">TIME ms-unix-time          : 修改消息的最后一次被读取的时间为给定的 Unix 时间</span><br><span class="line">RETRYCOUNT count           : 设置消息的投递计数（即这条消息已经被送达的次数）。</span><br><span class="line">force                      : 这个选项允许你不考虑 min-idle-time 条件，直接强制认领消息。</span><br><span class="line">justid                     : 如果设置这个选项，命令只返回消息 ID，不返回消息的内容。</span><br></pre></td></tr></table></figure><p>接下来，我通过一个示例来演示如何使用Redis Stream中的命令进行消息的添加、消费和确认。</p><p><strong>场景：</strong></p><p>以一个在线订单系统为例，当一个用户下单时，订单详细信息被添加到一个名为“orders”的stream中。有一个消费者组叫做“order-processors”，里面有两个消费者：“processor1”和“processor2”。它们的任务是处理这些订单，例如更新库存、发送确认邮件等。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">1. 添加订单</span><br><span class="line">XADD orders * order_id 123 item_id A1 count 2  # 用户A下了一个订单，订单编号为123,买了 2件</span><br><span class="line">&quot;1695103666038-0&quot;</span><br><span class="line">2.创建消费者组</span><br><span class="line">XGROUP CREATE orders order-processors $ MKSTREAM            # 创建一个名为“order-processors”的消费者组，从                    stream 的开始处监听新的订单。</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">3.读取和处理订单</span><br><span class="line"># processor1读取了订单123并开始处理它</span><br><span class="line">XREADGROUP GROUP order-processors processor1 COUNT 1 STREAMS orders &gt;</span><br><span class="line"># 同时，另一个用户B下了一个订单，编号为124</span><br><span class="line">XADD orders * order_id 124 item_id A2 quantity 1</span><br><span class="line"># 然后，processor2 开始读取订单：</span><br><span class="line">XREADGROUP GROUP order-processors processor2 COUNT 1 STREAMS orders &gt;</span><br><span class="line"></span><br><span class="line">4.确认订单已处理</span><br><span class="line"># 当processor1成功处理订单123时，它会确认处理完成：</span><br><span class="line">XACK orders order-processors messageID1</span><br><span class="line"># 注意：messageID1是processor1从Stream读取到的订单123的ID。</span><br><span class="line"></span><br><span class="line">5.查看未处理的订单</span><br><span class="line">XPENDING orders order-processors</span><br><span class="line"># 假设processor2由于某种原因暂时不能处理订单124，这时我们会看到订单124尚未被处理。</span><br><span class="line"></span><br><span class="line">6.重新处理失败的订单</span><br><span class="line"># 如果processor2出现故障，processor1可以认领并处理订单124：</span><br><span class="line">XCLAIM orders order-processors processor1 3600000 messageID2</span><br></pre></td></tr></table></figure><p>这个简单的在线订购系统例子展示了如何使用Redis Streams进行实时订单处理。这种模式可以确保即使某个消费者失败，订单也能被其他消费者接手并顺利处理。</p><h4 id="应用案例-5"><a href="#应用案例-5" class="headerlink" title="应用案例:"></a><strong>应用案例:</strong></h4><p><strong>消息队列</strong></p><p>消息队列是一种应用程序之间传递数据的方式。它允许应用程序异步地发送和接收消息，这意味着发送消息的应用程序和接收消息的应用程序无需同时运行。</p><p><strong>以在线购物系统的订单处理为例进行说明：</strong></p><p>考虑一个在线购物系统。当用户下单时，系统不应该让用户等待直到所有的后端处理（例如库存检查、付款处理、通知仓库等）都完成。相反，一旦订单提交，系统应该立即给用户一个响应，而后端的处理可以稍后进行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#1. 添加订单到队列：</span><br><span class="line">#用户下单后，我们将订单数据添加到名为orders的Redis Stream中。</span><br><span class="line">XADD orders * order_id 101 product_id P01 quantity 3</span><br><span class="line"></span><br><span class="line">#2.处理订单：</span><br><span class="line"># 后台有多个workers（进程），它们不断地监听新的订单，并进行处理。这些worke 可以是分布在多台机器上的多个进程。</span><br><span class="line"></span><br><span class="line">首先，我们创建一个消费者组：</span><br><span class="line">XGROUP CREATE orders order-processors $ MKSTREAM</span><br><span class="line"></span><br><span class="line">接着，一个worker可以开始读取并处理订单：</span><br><span class="line">XREADGROUP GROUP order-processors worker1 COUNT 1 STREAMS orders &gt;</span><br><span class="line"># 这里，worker1是处理订单的消费者名称。&gt;意味着从最新的消息开始读取。</span><br><span class="line"></span><br><span class="line">确认订单处理完成：</span><br><span class="line">一旦worker1处理完订单，它需要确认该订单已被处理：</span><br><span class="line">XACK orders order-processors &lt;messageID&gt;    # 其中，&lt;messageID&gt;是在步骤1中Redis生成的订单ID。 </span><br></pre></td></tr></table></figure><p>通过此例子，我们展示了如何使用 Redis Stream 作为消息队列，来异步处理在线购物系统中的订单。这种结构确保了用户下单后能够迅速得到响应，同时订单处理也能在后台高效地进行。</p><p><strong>事件日志</strong></p><p>事件日志就是记录系统或应用中发生的各种事件，如用户操作、系统异常等。</p><p><strong>事件日志的常见应用是在电商平台中记录用户的购物行为。</strong></p><p>假设你运营一个电商平台，每当用户浏览、搜索、点击、购买或者评论商品时，都会产生一个事件。你可以使用Redis Streams来记录这些事件。<strong>基于这些事件，可以做一些实时分析，比如：分析用户的购物模式和偏好，为他们提供更相关的商品推荐。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1.浏览商品:</span><br><span class="line">事件：商品浏览</span><br><span class="line">数据：用户ID，商品ID，浏览时间，来源页面等。</span><br><span class="line">XADD user-activity * event &quot;商品浏览&quot; userID &quot;12345&quot; productID &quot;abcd&quot; timestamp &quot;1632067200&quot; source &quot;主页&quot;</span><br><span class="line">2.搜索商品:</span><br><span class="line">事件：商品搜索</span><br><span class="line">数据：用户ID，搜索关键词，搜索时间，搜索结果数等。</span><br><span class="line">XADD user-activity * event &quot;商品搜索&quot; userID &quot;12345&quot; keyword &quot;运动鞋&quot; timestamp &quot;1632067250&quot; results &quot;50&quot;</span><br><span class="line">3.点击商品:</span><br><span class="line">事件：商品点击</span><br><span class="line">数据：用户ID，商品ID，点击时间。</span><br><span class="line">XADD user-activity * event &quot;商品点击&quot; userID &quot;12345&quot; productID &quot;abcd&quot; timestamp &quot;1632067300&quot;</span><br><span class="line">4.购买商品:</span><br><span class="line">事件：商品购买</span><br><span class="line">数据：用户ID，商品ID，购买数量，总价，购买时间。</span><br><span class="line">XADD user-activity * event &quot;商品购买&quot; userID &quot;12345&quot; productID &quot;abcd&quot; quantity &quot;2&quot; total &quot;200&quot; timestamp &quot;1632067400&quot;</span><br><span class="line">5.商品评价:</span><br><span class="line">事件：商品评价</span><br><span class="line">数据：用户ID，商品ID，评分，评论内容，评价时间。</span><br><span class="line">XADD user-activity * event &quot;商品评价&quot; userID &quot;12345&quot; productID &quot;abcd&quot; rating &quot;5&quot; review &quot;非常满意&quot; timestamp &quot;1632067500&quot;</span><br></pre></td></tr></table></figure><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a><strong>总结：</strong></h2><p>在上文，我们深入探讨了 Redis 的九种对象类型，包括字符串(String)、列表(List)、哈希(Hash)、集合(Set)、有序集合(Sorted Set)、Bitmaps、HyperLogLog、Geospatial 和 Stream。</p><p><strong>这里简单总结下各种数据结构的使用场景：</strong></p><ul><li><strong>字符串对象</strong>是最简单的数据类型，适用于缓存、临时存储等场景。</li><li><strong>列表对象</strong>提供了队列的实现，非常适合消息队列和栈的应用。</li><li><strong>哈希对象</strong>是存储对象属性的理想选择，适用于存储和访问对象。</li><li><strong>集合对象和有序集合对象</strong>适用于存储不重复元素，其中有序集合还可以进行排名和范围查询。</li><li><strong>Bitmaps和 HyperLogLog</strong> 提供了高效的计数和统计功能。</li><li><strong>Geospatial</strong> 允许进行地理位置的存储和查询。</li><li><strong>Stream</strong> 为构建复杂的消息传递提供了基础。</li></ul><p>Redis 作为一个高性能的键值数据库，已经成为现代应用开发不可或缺的组成部分。通过深入了解 Redis 的各种对象及其编码方式，我们不仅可以更加高效地利用其提供的功能，还能针对不同的应用场景选择最适合的对象类型，从而优化我们的应用性能和资源使用。</p><p>本篇文章旨在为大家提供一个关于 Redis 各个对象的全面指南，从基本概念到内部实现，再到实际应用案例。不管您是刚开始接触 Redis 还是已经有很多经验，希望本文都能为您带来新的启示。</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a><strong>最后</strong></h3><p>如果你对 Linux C&#x2F;C++ 编程，Redis 等后端技术感兴趣或者想学习计算机原理相关的知识，不妨关注我的公众号「跟着小康学编程」**。这里不仅有丰富的学习资源，还有持续更新的简单易懂的技术文章。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>另外，小康最近创建了一个技术交流群，专门用来探讨技术相关或者解答读者的问题。大家在阅读这篇文章的时候，如果觉得有问题的或者有不理解的知识点，欢迎大家加群或者评论区询问。我能够解决的，尽量给大家回复。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h3><p>[1]Redis分布式锁到底安全吗？: <em><a href="http://kaito-kidd.com/2021/06/08/is-redis-distributed-lock-really-safe/">http://kaito-kidd.com/2021/06/08/is-redis-distributed-lock-really-safe/</a></em></p>]]></content>
      
      
      <categories>
          
          <category> NoSQL数据库 </category>
          
          <category> 数据库技术 </category>
          
          <category> Redis教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis基础 </tag>
            
            <tag> Redis数据类型 </tag>
            
            <tag> Redis案例 </tag>
            
            <tag> 键值存储 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 命令入门指南：快速掌握基础命令</title>
      <link href="/LinuxCmd/"/>
      <url>/LinuxCmd/</url>
      
        <content type="html"><![CDATA[<p>作为程序员，我们在日常的工作中或多或少都会接触 Linux ，掌握其基本命令也是必不可少的。网上很多人都会推荐去看《<strong>鸟哥的私房菜—基础篇》</strong>，作为 Linux 编程的爱好者的我，还是不建议初学者一上来就看这本书，感觉对初学者不太友好，当手册去查还是可以的。</p><p>为了让更多想学习 Linux 的朋友快速入门，我这里专门给大家提供一个<strong>系统性学习 Linux 命令的详细指南</strong>，该指南主要是介绍要掌握的 Linux 基本命令有哪些，以及提供一些基础的示例，更加详细的命令参数大家可以在这个网站上查询，很方便的。<a href="https://man.niaoge.com/">https://man.niaoge.com/</a></p><p><strong>先来大致浏览下我们本篇文章要讲解的命令</strong>：</p><p><img src="/images/LinuxCmd/1.png"></p><h2 id="文件和目录操作命令"><a href="#文件和目录操作命令" class="headerlink" title="文件和目录操作命令"></a>文件和目录操作命令</h2><p><strong>ls：列出目录内容</strong>，想看看当前目录下有什么？简单！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls</span><br></pre></td></tr></table></figure><p><strong>cd：更改当前目录</strong>，<br>想跳转到桌面目录？试试这个：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~/Desktop</span><br></pre></td></tr></table></figure><p><strong>touch: 创建新文件</strong>，<br>快速创建一个新文件 note.txt：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch note.txt</span><br></pre></td></tr></table></figure><p><strong>pwd：显示当前目录的完整路径</strong>，<br>确认你现在在哪个目录？只需一条命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwd</span><br></pre></td></tr></table></figure><p><strong>mkdir：创建新目录</strong>，<br>需要一个新的项目目录 project？轻松搞定：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir project</span><br></pre></td></tr></table></figure><p><strong>rm：删除文件或目录</strong>，<br>要小心使用！彻底删除一个目录 project：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># -f 或 --force 选项强制删除文件或目录</span><br><span class="line"># -r 或 -R 或 --recursive 选项告诉rm命令递归地删除目标目录以及目录内的所有内容（文件和子目录）</span><br><span class="line">rmdir -fr  project  </span><br></pre></td></tr></table></figure><p><strong>cp：复制文件或目录</strong>，<br>将文件 example.txt 复制到目录 backup 中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp example.txt backup/</span><br></pre></td></tr></table></figure><p><strong>mv：移动或重命名文件或目录</strong>，<br>更改文件名 old_name.txt 为 new_name.txt：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv old_name.txt new_name.txt</span><br></pre></td></tr></table></figure><p>将文件 report.txt 移动到另一个目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv report.txt ~/Documents/</span><br></pre></td></tr></table></figure><p><strong>tree : 树形结构显示目录，首先确保已安装 tree</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 安装 tree</span><br><span class="line">sudo apt-get install tree  # Debian/Ubuntu</span><br><span class="line"></span><br><span class="line">然后运行：</span><br><span class="line">tree</span><br></pre></td></tr></table></figure><p><strong>ln   : 创建链接文件</strong>，<br>创建 source.txt 的硬链接 hard_link.txt：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln source.txt hard_link.txt</span><br></pre></td></tr></table></figure><p>或者创建符号链接（软链接）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s source.txt soft_link.txt</span><br></pre></td></tr></table></figure><h2 id="权限管理命令"><a href="#权限管理命令" class="headerlink" title="权限管理命令"></a>权限管理命令</h2><p><strong>chown：更改文件或目录的所有者和群组</strong>，<br>文件归谁？chown说了算：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown newowner filename</span><br></pre></td></tr></table></figure><p><strong>chmod：更改文件或目录权限</strong>，<br>谁能看？谁能改？chmod让你决定：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 755 filename</span><br></pre></td></tr></table></figure><p><strong>chgrp：专门用于更改文件或目录的群组归属</strong>，<br>改变文件或文件夹的所属群组，轻松管理访问权限：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chgrp newgroup filename</span><br></pre></td></tr></table></figure><h2 id="软件包管理命令"><a href="#软件包管理命令" class="headerlink" title="软件包管理命令"></a>软件包管理命令</h2><p><strong>Debian&#x2F;Ubuntu系统</strong></p><p><strong>apt-get：一键管理软件</strong>。安装、更新或删除软件包</p><p>装软件、升级都不是问题，apt-get帮你忙：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install packagename</span><br></pre></td></tr></table></figure><p><strong>CentOS&#x2F;RHEL系统</strong></p><p><strong>yum：包管理器</strong>，包管理器让软件安装更简单，安装、更新或删除软件包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install packagename</span><br></pre></td></tr></table></figure><h2 id="压缩和解压命令"><a href="#压缩和解压命令" class="headerlink" title="压缩和解压命令"></a>压缩和解压命令</h2><p><strong>tar：文件打包工具</strong>，<br>把一堆文件或文件夹打包成一个文件，超方便的备份方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -cvf myfiles.tar /path/to/directory</span><br></pre></td></tr></table></figure><p><strong>gzip：压缩文件</strong>，<br>想让文件小一点，传输快一点？gzip来帮忙：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip filename</span><br></pre></td></tr></table></figure><p><strong>bzip2：另一压缩选择</strong>，<br>寻找比gzip还要压得更紧的？试试 bzip2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bzip2 filename</span><br></pre></td></tr></table></figure><h2 id="文本处理命令"><a href="#文本处理命令" class="headerlink" title="文本处理命令"></a>文本处理命令</h2><p><strong>cat：查看和合并文件</strong>，<br>想快速查看文件内容或把几个文件拼成一个？用 cat：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 查看文件内容</span><br><span class="line">cat file1.txt</span><br><span class="line"># 合并文件</span><br><span class="line">cat file1.txt file2.txt &gt; combined.txt</span><br></pre></td></tr></table></figure><p><strong>more&#x2F;less：分页浏览文本</strong>，<br>文件太长，一屏看不完？试试 more 和 less：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">more longfile.txt</span><br><span class="line">less longfile.txt</span><br></pre></td></tr></table></figure><p><strong>grep：文本中的搜寻高手</strong>，<br>在文本文件中查找某个字符串,如：找出文件中包含”error”的所有行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep &#x27;error&#x27; logfile.txt</span><br></pre></td></tr></table></figure><p><strong>sed：流编辑器</strong>，<br>把文本中的”old”全部替换成”new”：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;s/old/new/g&#x27; file.txt</span><br></pre></td></tr></table></figure><p><strong>awk：文本处理小能手</strong>，<br>打印文件的第一列：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;&#123;print $1&#125;&#x27; file.txt</span><br></pre></td></tr></table></figure><p><strong>sort：给你的文本排排队</strong>，<br>对文件的内容按行排序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort file.txt</span><br></pre></td></tr></table></figure><p><strong>uniq：重复行不见了</strong>，<br>过滤掉重复行，记得先sort：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sort file.txt | uniq</span><br><span class="line"># | 符号被称为管道符（pipe）。管道是一种将一个命令的输出作为另一个命令输入的机制，在这个例子中，管道的作用是将 sort file.txt 的输出直接传输给 uniq 命令。</span><br></pre></td></tr></table></figure><p><strong>cut：文本的</strong>“<strong>剪刀手</strong>“ ，<br>只看每行的前5个字符：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cut -c1-5 file.txt</span><br></pre></td></tr></table></figure><p><strong>wc：数数大师</strong>，<br>数一数文件里有多少行、词、字符：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wc file.txt</span><br></pre></td></tr></table></figure><p><strong>find：文件搜查官</strong>，<br>搜索某文件，在目录中搜索所有.txt文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /path/to/search -name &quot;*.txt&quot;</span><br></pre></td></tr></table></figure><p><strong>head&#x2F;tail：文件的头和尾</strong>，<br>看文件的开头10行或结尾10行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">head file.txt</span><br><span class="line">tail file.txt </span><br></pre></td></tr></table></figure><h2 id="系统管理命令"><a href="#系统管理命令" class="headerlink" title="系统管理命令"></a>系统管理命令</h2><p><strong>top：实时监控系统状态</strong>，<br>想知道你的电脑现在在忙什么？top就像电脑的健康监测器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top</span><br></pre></td></tr></table></figure><p><strong>ps：查看运行中的进程</strong>，<br>想找出所有正在运行的程序？ps 给你全视角：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ps aux </span><br><span class="line"></span><br><span class="line">#一般这样使用：</span><br><span class="line">ps -ef | grep processName</span><br></pre></td></tr></table></figure><p><strong>kill：结束进程</strong>，<br>有个进程不听话，要“礼貌地”让它停止？用 kill：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill PID</span><br></pre></td></tr></table></figure><p><strong>useradd&#x2F;userdel：用户账号管理</strong>，<br>新来了个同事，需要账号？或者有人离开了？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">useradd newuser</span><br><span class="line">userdel olduser</span><br></pre></td></tr></table></figure><p><strong>df：检查磁盘空间</strong>，<br>硬盘还有空间吗？df一目了然：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -h</span><br></pre></td></tr></table></figure><p><strong>du：分析文件夹大小</strong>，<br>这个文件夹占了多少空间？du告诉你答案：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du -sh /path/to/directory</span><br></pre></td></tr></table></figure><p><strong>hostname：查看或设置主机名</strong>，<br>这台机器叫什么？或者想给它起个新名字？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 查看主机名</span><br><span class="line">hostname</span><br><span class="line"># 设置主机名</span><br><span class="line">hostname newname</span><br></pre></td></tr></table></figure><p><strong>uname：获取系统信息</strong>，<br>这台机器上跑的是什么操作系统？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -a</span><br></pre></td></tr></table></figure><p><strong>man：手册页</strong>，<br>忘记了某个命令的参数？man命令是你的救星：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">man command</span><br><span class="line"></span><br><span class="line">比如：man ls</span><br></pre></td></tr></table></figure><p><strong>passwd：更改密码</strong>，<br>需要更改密码或重置别人的密码？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd username</span><br></pre></td></tr></table></figure><p><strong>su：切换用户</strong> ，<br>需要临时变身为另一个用户？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su  username</span><br></pre></td></tr></table></figure><p><strong>fdisk&#x2F;gdisk：分区大师</strong>，<br>用于管理磁盘分区的工具，硬盘需要新分区或调整？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fdisk /dev/sdx</span><br><span class="line">gdisk /dev/sdx</span><br></pre></td></tr></table></figure><p><strong>mount&#x2F;unmount：挂载与卸载文件系统</strong>，<br>把新的硬盘或USB挂载上去，或者安全地移除它：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mount /dev/sdx /mnt</span><br><span class="line">umount /mnt</span><br></pre></td></tr></table></figure><h2 id="网络操作命令"><a href="#网络操作命令" class="headerlink" title="网络操作命令"></a>网络操作命令</h2><p><strong>ping：检查网络连接</strong>，<br>想确认你的电脑能不能访问互联网上的某个地址？ping是你的朋友：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping google.com</span><br></pre></td></tr></table></figure><p><strong>ifconfig：配置和显示网络接口</strong>，<br>查看或设置网络接口的 IP 地址等信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure><p><strong>ssh：安全地远程登录</strong>，<br>远程登录到另一台电脑上，安全又方便：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh username@remotehost</span><br></pre></td></tr></table></figure><p><strong>scp：安全地远程复制文件</strong>，<br>从一台电脑安全地传输文件到另一台电脑：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp localfile.txt username@remotehost:/remote/directory</span><br></pre></td></tr></table></figure><p><strong>wget：从网上下载文件</strong>，<br>需要下载网上的文件？wget就搞定：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://example.com/file.zip</span><br></pre></td></tr></table></figure><p><strong>curl：与网站交互</strong>，<br>发送请求到网站，可以用来下载文件或测试API：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://example.com</span><br></pre></td></tr></table></figure><p><strong>netstat&#x2F;ss：查看网络连接</strong>，<br>查看你的机器上的网络连接信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">netstat</span><br><span class="line"></span><br><span class="line">一般这样使用：</span><br><span class="line">netstat -anpt | grep &quot;80&quot; # 输出涉及端口号为80的连接</span><br><span class="line"></span><br><span class="line">-a:显示所有的套接字（sockets）</span><br><span class="line">-n :以数字形式显示地址和端口号</span><br><span class="line">-p :显示每个连接所对应的进程标识符（PID）和进程名</span><br><span class="line">-t :只显示TCP连接</span><br></pre></td></tr></table></figure><p>或者使用ss，一个更现代的替代：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ss</span><br><span class="line">ss -anpt | grep &quot;80&quot; # 输出涉及端口号为80的连接</span><br></pre></td></tr></table></figure><p><strong>traceroute：追踪数据包的路径</strong>，<br>查看数据包从你的电脑到目标地址经过了哪些路由器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">traceroute example.com</span><br></pre></td></tr></table></figure><p><strong>dig：DNS查询</strong>，<br>查找域名的IP地址等DNS信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dig example.com</span><br></pre></td></tr></table></figure><p><strong>tcpdump：网络抓包工具</strong>，<br>监听并打印想要的数据包：例如，如果你想要捕获从特定IP地址和端口443的数据包，可以使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth0 src host 192.168.1.1 and port 443 -w https_traffic_from_192.168.1.1.pcap</span><br></pre></td></tr></table></figure><p><strong>telnet：远程访问工具</strong>，<br>测试远程服务的连接性，虽然现在多用ssh替代：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet remotehost port</span><br></pre></td></tr></table></figure><p><strong>lsof：查看打开的文件和套接字</strong>，<br>列出哪些进程正在使用网络套接字：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -i</span><br></pre></td></tr></table></figure><p><strong>nc：网络连接小工具</strong>，<br>建立TCP&#x2F;UDP连接，进行数据监听和传输：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -l 1234 # 监听端口1234</span><br></pre></td></tr></table></figure><h2 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a>其他常用命令</h2><p><strong>echo：输出文字到终端，也能写入文件</strong>，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;This is a test.&quot; &gt; test.txt</span><br></pre></td></tr></table></figure><p><strong>history：显示历史命令</strong>，<br>看看你都敲过什么：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">history</span><br></pre></td></tr></table></figure><p><strong>crontab：定时运行命令，自动化管理</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># crontab -e 命令用于编辑当前用户的cron作业列表。</span><br><span class="line">crontab -e</span><br></pre></td></tr></table></figure><p>cron 是 Linux 和 Unix 系统中用来定时执行任务的工具。<br>通过crontab -e命令，你可以为当前用户添加、编辑或删除计划任务。</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>至此，你已经系统地学习了 Linux 常见的基本命令，覆盖了文件和目录的操作、权限管理、软件包处理、压缩与解压、文本处理、系统管理以及网络操作等多个方面。这些命令是Linux 开发必须掌握的。</p><p>通过本篇文章的指南，希望初学者能够对 Linux 命令有了清晰的认识和实际操作的能力。记住，掌握这些命令只是开始，真正的精通还需要你在实践中不断探索和应用。遇到问题时，不要忘记利用 man 命令或在线资源寻求帮助，持续地学习和实践，你才能更加自如地驾驭 Linux 系统。</p><h3 id="最后："><a href="#最后：" class="headerlink" title="最后："></a>最后：</h3><p>掌握了基本的 Linux 命令，接下来就是如何在 Linux 环境下进行编程，想要深入学习 Linux 编程的朋友们可以先关注我的公众号「<strong>跟着小康学编程</strong>」，这里不仅有持续更新的计算机基础相关的文章，还有如何系统学习 C、C++，Linux 系统编程以及网络编程的文章等。后续也会持续新增关于 Go微服务 、docker、k8s等云原生领域的内容。</p><p>感兴趣的朋友可以关注我的公众号，扫描下方二维码即可关注。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>另外，小康最近创建了一个技术交流群，专门用来探讨技术相关或者解答读者的问题。大家在阅读这篇文章的时候，如果觉得有问题的或者有不理解的知识点，欢迎大家加群或者评论区询问。我能够解决的，尽量给大家回复。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> Linux 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux 命令 </tag>
            
            <tag> Linux 入门 </tag>
            
            <tag> Linux 基础教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>必读：2024年度最佳计算机编程书籍推荐</title>
      <link href="/techbooks/"/>
      <url>/techbooks/</url>
      
        <content type="html"><![CDATA[<p>读大学期间，自己买了很多技术书，加上图书馆借的，自己读了不少。</p><p>技术书有很多，大家怎么选呢？</p><p>作为过来人，小康自己读过许多好书，也遇到过一些效果不佳的。为了帮助大家节省时间，避免走弯路，我在这里精心挑选了一些极具价值的书籍进行推荐。<br>这些书籍不仅数量精简，而且都是经典之作，值得深入研读。因为小康自己从事的是后台开发的，所以这里推荐的书籍也是偏向后台的。但有一些通用计算机原理相关的书籍，对于以后想从事编程相关工作的朋友，也都是可以看的。</p><p><strong>下面是我大学以及工作之后买的一些书籍</strong>：</p><p><img src="/images/techbooks/1.png"></p><p>微信搜索「<strong>跟着小康学编程</strong>」关注公众号后，在后台回复「<strong>书单</strong>」即可获取本文书单链接。</p><p>回复「<strong>pdf</strong>」即可获取本文提到的书籍电子版 pdf</p><p><img src="/images/techbooks/2.png"></p><h3 id="一、语言类"><a href="#一、语言类" class="headerlink" title="一、语言类"></a>一、语言类</h3><p>C 语言</p><ul><li><p>《C程序设计语言》(第2版，新版) - 作者 : K&amp;R</p></li><li><p>《C Primer Plus》(第6版) - 作者 : Stephen Prata</p></li><li><p>《C和指针》  作者: Kenneth A. Reek</p></li></ul><p>C++ 语言</p><ul><li>《C++ Primer》(第5版) （作者: Stanley B. Lippman, Josée Lajoie, 和 Barbara E. Moo ）</li><li>《Accelerated C++》   作者: Andrew Koenig 和 Barbara E. Moo</li><li>《Effective C++》       作者: Scott Meyers</li><li>《深度探索C++对象模型》     作者：Stanley B. Lippman</li><li>《C++ STL标准程序库开发指南》   作者：闫常友、王敏</li><li>《C++ STL源码剖析》        作者：侯捷</li><li>《深入理解 C++11：C++11 新特性解析与应用》 作者：Michael Wong IB</li></ul><p>Java 语言</p><ul><li>《Java核心技术 卷I》（原书第11版） 作者: Cay S. Horstmann</li><li>《Effective java》（第3版）      作者: Joshua Bloch</li><li>《深入理解 Java 虚拟机》（第3版）  作者: 周志明</li><li>《Java 并发编程实战》            作者: Brian Goetz 和 Tim Peierls</li></ul><p>Go 语言</p><ul><li>《Go程序设计语言》             作者: Alan A. A. Donovan 和 Brian W. Kernighan</li><li>《Go语言实战》                作者: William Kennedy 等</li><li>《Go语言高级编程》             作者: 柴树杉、曹春晖</li><li>《Go Web编程》               作者: 郑兆雄</li><li>《Go 语言学习笔记》            作者: 雨痕</li><li>《Go 语言底层原理剖析》         作者: 郑建勋</li></ul><p>微信搜索「<strong>跟着小康学编程</strong>」关注公众号后，在后台回复「<strong>书单</strong>」即可获取本文书单链接。</p><p>回复「<strong>pdf</strong>」即可获取本文提到的书籍电子版 pdf</p><p><img src="/images/techbooks/2.png"></p><h3 id="二、计算机基础"><a href="#二、计算机基础" class="headerlink" title="二、计算机基础"></a>二、计算机基础</h3><h4 id="计算机组成原理："><a href="#计算机组成原理：" class="headerlink" title="计算机组成原理："></a>计算机组成原理：</h4><ul><li>《计算机组成与设计：硬件&#x2F;软件接口》（第5版）  作者: David A. Patterson 和 John L. Hennessy</li></ul><h4 id="操作系统："><a href="#操作系统：" class="headerlink" title="操作系统："></a>操作系统：</h4><ul><li>《现代操作系统》（第4版）作者: Andrew S. Tanenbaum 和 Herbert Bos</li><li>《现代操作系统 原理与实现》 作者: 陈海波 、 夏虞斌</li></ul><h4 id="数据结构与算法："><a href="#数据结构与算法：" class="headerlink" title="数据结构与算法："></a>数据结构与算法：</h4><ul><li>《大话数据结构》 作者:程杰</li><li>《算法图解》     作者: Aditya Bhargava</li></ul><h4 id="计算机网络："><a href="#计算机网络：" class="headerlink" title="计算机网络："></a>计算机网络：</h4><ul><li><p>《计算机网络》            作者: 谢希仁</p></li><li><p>《计算机网络：自顶向下方法》 作者: James F. Kurose 和 Keith W. Ross</p></li><li><p>《TCP&#x2F;IP详解 卷1：协议》  作者: W. Richard Stevens</p></li></ul><h3 id="三、系统编程、网络编程"><a href="#三、系统编程、网络编程" class="headerlink" title="三、系统编程、网络编程"></a>三、系统编程、网络编程</h3><ul><li><p>《程序员自我修养—链接、装载与库》(主要讲编译链接的)      作者:  俞甲子、石凡以及潘爱民</p></li><li><p>《Linux系统编程》                  作者: Robert Love</p></li><li><p>《UNIX网络编程 卷1：套接字联网API》  作者: W. Richard Stevens, 与 Bill Fenner 和 Andrew M. Rudoff</p></li><li><p>《UNIX网络编程 卷2：进程间通信》  作者: W. Richard Stevens</p></li><li><p>《UNIX环境高级编程》            作者: W. Richard Stevens</p></li><li><p>《Linux高性能服务器编程》       作者: 游双</p></li><li><p>《Linux&#x2F;UNIX系统编程手册》（上下册）作者：Michael Kerrisk</p></li><li><p>《深入理解计算机系统》            作者：Randal E. Bryant和David O’Hallaron。</p></li></ul><h3 id="四、Linux-内核"><a href="#四、Linux-内核" class="headerlink" title="四、Linux 内核"></a>四、Linux 内核</h3><ul><li>《深入理解Linux内核》          作者: Daniel P. Bovet 和 Marco Cesati</li><li>《Linux内核设计与实现》        作者: Robert Love</li></ul><h3 id="五、数据库"><a href="#五、数据库" class="headerlink" title="五、数据库"></a>五、数据库</h3><h4 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h4><ul><li><p>《MySQL必知必会》         作者: Ben Forta</p></li><li><p>《MySQL技术内幕：InnoDB存储引擎》    作者: 姜承尧</p></li><li><p>《高性能MySQL》    作者Peter Zaitsev</p></li></ul><h4 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h4><ul><li>《Redis入门指南》(第二版)    作者: 李子骅</li><li>《Redis设计与实现》         作者: 黄健宏</li><li>《Redis实战》              作者: Josiah L. Carlson</li></ul><h4 id="。。。。未完待续，后续会补充的更加完善，更加成体系。"><a href="#。。。。未完待续，后续会补充的更加完善，更加成体系。" class="headerlink" title="。。。。未完待续，后续会补充的更加完善，更加成体系。"></a>。。。。未完待续，后续会补充的更加完善，更加成体系。</h4><p>微信搜索「<strong>跟着小康学编程</strong>」关注公众号后，在后台回复「<strong>书单</strong>」即可获取本文书单链接。</p><p>回复「<strong>pdf</strong>」即可获取本文提到的书籍电子版 pdf</p><p><img src="/images/techbooks/2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 书籍推荐 </category>
          
          <category> 编程资源 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程入门 </tag>
            
            <tag> 软件开发 </tag>
            
            <tag> 计算机科学 </tag>
            
            <tag> 编程最佳实践 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手把手教你搭建 Linux C/C++ 编程环境</title>
      <link href="/SetupLinuxEnv/"/>
      <url>/SetupLinuxEnv/</url>
      
        <content type="html"><![CDATA[<p>废话不多说，手把手教你如何搭建 <strong>Linux 编程环境</strong>。</p><h2 id="搭建环境具体步骤"><a href="#搭建环境具体步骤" class="headerlink" title="搭建环境具体步骤"></a>搭建环境具体步骤</h2><h3 id="选择一个-Linux-发行版："><a href="#选择一个-Linux-发行版：" class="headerlink" title="选择一个 Linux 发行版："></a>选择一个 Linux 发行版：</h3><p>如果你是 Linux 初学者，我建议你选择 Ubuntu。该系统对新手友好，安装过程简单，而且有大量的在线资源和社区支持。</p><h3 id="考虑使用虚拟机-："><a href="#考虑使用虚拟机-：" class="headerlink" title="考虑使用虚拟机 ："></a>考虑使用虚拟机 ：</h3><p>不想直接安装 Linux 系统 ?  没问题！使用虚拟机可以在你的主操作系统上模拟运行 Linux。</p><p>有以下两种虚拟机软件可供选择：</p><ul><li><strong>VirtualBox</strong> - 一个开源的、免费的虚拟化软件，非常适合初学者。</li><li><strong>VMware Workstation</strong> - 一个功能强大的虚拟化工具。</li></ul><p>这里我推荐直接使用 VMware，一旦你选择了虚拟机软件，就可以下载 Ubuntu 的 ISO 镜像并在虚拟机中安装它。</p><p><strong>1.下载 VMware 虚拟机并安装</strong></p><p> <a href="https://www.vmware.com/content/vmware/vmware-published-sites/us/products/workstation-player/workstation-player-evaluation.html.html">VMware虚拟机下载地址</a> </p><p><strong>2.下载 ISO 镜像并安装</strong></p><p><a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu-releases/">Ubuntu 的 ISO 镜像下载地址</a></p><p>以下载 20.04.6 ISO 镜像版本举例：</p><p><img src="/images/Linux%E7%BC%96%E7%A8%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/1.png"></p><p>我们可以看到两个版本：desktop 版本（图形桌面版）和 server 版本（无图形界面的服务器版）。</p><p>建议初学者直接下载 desktop 版本，这是一个桌面版的镜像，对初学者来说更友好，因为它提供了图形用户界面。</p><h3 id="vmware-安装-ubuntu-iso-镜像具体步骤"><a href="#vmware-安装-ubuntu-iso-镜像具体步骤" class="headerlink" title="vmware 安装 ubuntu iso 镜像具体步骤"></a>vmware 安装 ubuntu iso 镜像具体步骤</h3><h4 id="第一步：新建虚拟机，对于初学者，选择「典型」即可。"><a href="#第一步：新建虚拟机，对于初学者，选择「典型」即可。" class="headerlink" title="第一步：新建虚拟机，对于初学者，选择「典型」即可。"></a>第一步：新建虚拟机，对于初学者，选择「典型」即可。</h4><p><img src="/images/Linux%E7%BC%96%E7%A8%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/2.png"></p><h4 id="第二步：选择浏览，选择已经下载的-iso-镜像文件，直接点击下一步"><a href="#第二步：选择浏览，选择已经下载的-iso-镜像文件，直接点击下一步" class="headerlink" title="第二步：选择浏览，选择已经下载的 iso 镜像文件，直接点击下一步"></a>第二步：选择浏览，选择已经下载的 iso 镜像文件，直接点击下一步</h4><p><img src="/images/Linux%E7%BC%96%E7%A8%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/3.png"></p><h4 id="第三步：设置用户名密码，点击下一步"><a href="#第三步：设置用户名密码，点击下一步" class="headerlink" title="第三步：设置用户名密码，点击下一步"></a>第三步：设置用户名密码，点击下一步</h4><p><img src="/images/Linux%E7%BC%96%E7%A8%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/4.png"></p><h4 id="第四步：设置安装位置，点击下一步"><a href="#第四步：设置安装位置，点击下一步" class="headerlink" title="第四步：设置安装位置，点击下一步"></a>第四步：设置安装位置，点击下一步</h4><p><img src="/images/Linux%E7%BC%96%E7%A8%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/5.png"></p><h4 id="第五步：设置最大磁盘大小，其他默认即可，点击下一步"><a href="#第五步：设置最大磁盘大小，其他默认即可，点击下一步" class="headerlink" title="第五步：设置最大磁盘大小，其他默认即可，点击下一步"></a>第五步：设置最大磁盘大小，其他默认即可，点击下一步</h4><p><img src="/images/Linux%E7%BC%96%E7%A8%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/6.png"></p><h4 id="第六步：自定义硬件"><a href="#第六步：自定义硬件" class="headerlink" title="第六步：自定义硬件"></a>第六步：自定义硬件</h4><p>可以设置内存大小、CPU 核数以及网络适配器模式（推荐使用桥接模式）等，设置完毕，点击完成。完成之后<strong>点击开启虚拟机</strong>即可。</p><p><img src="/images/Linux%E7%BC%96%E7%A8%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/7.png"></p><h3 id="设置开发环境："><a href="#设置开发环境：" class="headerlink" title="设置开发环境："></a>设置开发环境：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 1.更新包列表: 更新包管理器的包列表，确保你能从最新的仓库中获取软件。</span><br><span class="line">sudo apt update</span><br><span class="line"></span><br><span class="line"># 2.安装 GCC 编译器 : GCC 是 GNU Compiler Collection 的简称，是最常用的C 和 C++ 编译器。</span><br><span class="line">sudo apt install gcc</span><br><span class="line"></span><br><span class="line"># 3.安装构建工具: build-essential 包提供了很多开发标准C和C++程序所需的工具。</span><br><span class="line"># 包括 g++（GNU C++ 编译器）、make（用于自动化编译的工具）和一些其他必要的库和开发文件。</span><br><span class="line">sudo apt install build-essential</span><br><span class="line"></span><br><span class="line"># 3.安装调试工具</span><br><span class="line">sudo apt install gdb</span><br><span class="line"> </span><br><span class="line"># 3.安装检测内存泄漏工具 valgrind</span><br><span class="line">sudo apt install valgrind</span><br><span class="line"># Valgrind 主要用于内存泄露检测、内存调试以及性能分析的工具。</span><br><span class="line"></span><br><span class="line"># 安装其他</span><br><span class="line">sudo apt install openssh-server     # 安装 OpenSSH 服务器，以支持 ssh 连接</span><br></pre></td></tr></table></figure><h3 id="安装调试工具"><a href="#安装调试工具" class="headerlink" title="安装调试工具"></a>安装调试工具</h3><p>调试是开发过程中不可或缺的一部分。gdb 是一个广泛使用的 GNU C&#x2F;C++ 调试器，能帮助你分析程序运行时的问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install gdb</span><br></pre></td></tr></table></figure><p>另外，这里给大家推荐一个终端神器 MobaXterm，它可以远程操作服务器。<br>它集成了多种网络工具和服务器，提供了包括 SSH、Telnet、RDP、VNC 和 FTP 等在内的远程网络连接功能。这款软件特别适合那些需要远程开发的人群。</p><p>笔者用过很多终端工具，Putty、Xshell，MobaXterm 等，综合使用下来还是使用 MobaXterm 最方便，MobaXterm 提供了用户友好的图形界面，带有多标签和多会话支持，使得管理多个连接变得轻而易举。</p><p><a href="https://mobaxterm.mobatek.net/download.html">mobaxterm 下载链接</a></p><p>具体如何使用可以看这篇文章，讲的还不错。<a href="https://zhuanlan.zhihu.com/p/56341917">全能终端神器 MobaXterm 使用指南</a></p><h3 id="安装-IDE-或代码编辑器"><a href="#安装-IDE-或代码编辑器" class="headerlink" title="安装 IDE 或代码编辑器"></a>安装 IDE 或代码编辑器</h3><p><strong>注意</strong>：下面除了 vim 需要在 Linux 环境（ubuntu）安装，vscode、Visual Studio 以及 cLion 在 windows 和 Linux 下都可以安装，但是我推荐在 Windows 上安装，写代码比较方便。最后只需要将代码上传至 Linux 服务器即可。关于如何上传，大家可以设置一下 IDE 的远程开发。不管是 Visual Studio 还是 cLion 都可以配置远程开发，比如下面这篇文章：</p><p><a href="https://blog.csdn.net/weixin_42264234/article/details/120937676">cLion 配置远程开发教程</a></p><p>根据你的偏好，你可以选择一个适合自己的集成开发环境（IDE）或代码编辑器。以下是我比较推荐的工具：</p><h4 id="vi、vim"><a href="#vi、vim" class="headerlink" title="vi、vim"></a>vi、vim</h4><p>所有的 Unix Like 系统，包括 Linux 系统都会内建 vi 文书编辑器，其他的文书编辑器则不一定会存在。但是目前我们使用比较多的是 vim 编辑器。</p><p>vim 是从 vi 发展出来的一个文本编辑器。代码补全、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。因此，我们一般会使用vim，而不是vi。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 安装 vim</span><br><span class="line">sudo apt install vim</span><br></pre></td></tr></table></figure><p>vim 安装完成之后，我们一般会做一些简单的配置，方便我们开发使用。</p><p>以下是一些 vim 配置的相关教程：</p><p><a href="https://www.ruanyifeng.com/blog/2018/09/vimrc.html">vim 配置教程1</a></p><p><a href="https://blog.csdn.net/m0_49499097/article/details/125951478">vim 配置教程2</a></p><p>还不知道如何在 Linux 使用 Vim 的朋友可以看这篇文章：</p><p><a href="https://www.runoob.com/linux/linux-vim.html">Vim 操作使用教程</a></p><h4 id="vscode"><a href="#vscode" class="headerlink" title="vscode"></a>vscode</h4><p>Visual Studio Code（VS Code）是微软开发的一个免费、开源的轻量级代码编辑器，支持多种编程语言（C&#x2F;C++ 比较常用），提供语法高亮、智能代码补全、代码调试等功能，并通过扩展支持更多工具和语言，适用于各种软件开发项目。</p><p><a href="https://code.visualstudio.com/Download">vscode 下载链接</a></p><h4 id="Visual-Studio"><a href="#Visual-Studio" class="headerlink" title="Visual Studio"></a>Visual Studio</h4><p>Visual Studio 是微软开发的一款强大的集成开发环境（IDE），专为 .NET 和 C&#x2F;C++ 等多种编程语言提供全面的软件开发工具，支持从代码编写到调试和运行的整个开发过程。</p><p><a href="https://code.visualstudio.com/Download">Visual Studio 下载链接</a></p><p>关于如何安装 Visual Studio， 大家可以参考下面这篇文章：</p><p><a href="https://zhuanlan.zhihu.com/p/475267922">Visual Studio 安装教程</a></p><h4 id="cLion"><a href="#cLion" class="headerlink" title="cLion"></a>cLion</h4><p>CLion 是 JetBrains 公司旗下发布的一款跨平台 C&#x2F;C++IDE 开发工具。相对于 visual studio 动辄五六个G的安装包，clion安装包不到300M。其功能非常强大，不输于vs，并且同样支持丰富的插件。</p><p><a href="https://www.jetbrains.com/clion/download/other.html">CLion 下载链接</a></p><p>需要注意的是 CLion 正版需要收费，但是网上提供破解版的教程：</p><p><a href="https://studygolang.com/articles/36388">Clion 2023.1.3破解激活教程，附激活码！</a> （<strong>亲测有效</strong>）</p><p>下载安装完成之后，还需要安装 C&#x2F;C++ 编译环境，<br>尽管 CLion 是一个强大的IDE，但它本身不包含编译器。这意味着你需要安装一个外部编译器来编译和运行你的C&#x2F;C++代码。</p><p>对于 Windows 用户来说，MinGW 和 Cygwin 是两个流行的选择，它们都能为 CLion 提供所需的编译器和工具链。</p><p><strong>两者如何选择？</strong>：</p><ul><li>对于需要开发原生 Windows 应用程序，同时希望保持代码在其他平台上也能编译和运行的跨平台项目，<strong>MinGW</strong> 是更好的选择。</li><li>如果你的目标是在 Windows 上模拟 Unix&#x2F;Linux 环境，或者移植原本只能在 Unix&#x2F;Linux 上运行的程序到 Windows，<strong>Cygwin</strong> 提供了必要的环境和工具。</li></ul><p><strong>下面是我帮大家整理的 MinGW 和 Cygwin 的下载安装教程，方便大家安装</strong>：</p><p><a href="https://sourceforge.net/projects/mingw-w64/files/">MinGW 下载链接</a></p><p><a href="https://www.w3cschool.cn/c/c-dh5j3owj.html">MinGW 安装教程</a></p><p><a href="https://www.cygwin.com/">Cygwin 下载链接</a></p><p><a href="https://juejin.cn/post/7047049435452276750#heading-2">Cygwin 安装教程</a></p><h3 id="安装版本控制系统"><a href="#安装版本控制系统" class="headerlink" title="安装版本控制系统"></a>安装版本控制系统</h3><p>对于任何规模的软件项目来说，版本控制都是不可或缺的。Git 是目前最流行的版本控制系统，可以通过以下命令安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install git</span><br></pre></td></tr></table></figure><p><strong>安装完成后，配置您的Git用户信息</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;YourName&quot;</span><br><span class="line">git config --global user.email &quot;youremail@example.com&quot;</span><br></pre></td></tr></table></figure><p>安装和配置好 Git 之后，你已经迈出了使用版本控制的第一步。接下来，大家还必须学会使用 Git 来远程操作 GitHub 等仓库，因为无论是在将来的工作中，还是在个人项目中，你都会频繁地使用 Git 来与 GitHub 这样的公共托管平台，或 GitLab 等私有仓库平台进行代码的推送、拉取和合作。</p><p>GitHub，作为一个基于 Git 的在线托管平台，使得共享代码、协作开发变得轻而易举。还没有注册过 GitHub 账户的朋友可以先去注册，<a href="https://github.com/">GitHub 账户注册</a></p><p>接下来，我来介绍下本地 Git 如何连接 GitHub：</p><p><strong>1.首先我们要知道</strong>：GitHub 支持通过 HTTPS 和 SSH 两种方式与远程仓库进行通信，这两种方法各有特点：</p><ul><li><p><strong>使用 HTTPS 连接 GitHub 时</strong>，你只需在克隆仓库或推送更改时输入<strong>用户名和密码</strong>。这种方式简单，但可能需要频繁输入认证信息。</p></li><li><p><strong>而通过 SSH 连接 GitHub</strong>，你需要先生成 SSH 密钥对，并将公钥添加到 GitHub 账户。完成设置后，每次操作时 Git 会自动使用你的私钥进行认证，无需手动输入认证信息，提供了更便利的使用体验。</p><p> <strong>在终端执行以下命令生成新的 SSH 密钥</strong>:</p><p><code>ssh-keygen -t ed25519 -C &quot;youremail@example.com</code></p><p>这个命令会在~&#x2F;.ssh 目录下创建一个新的密钥文件（默认是id_rsa）和一个公钥文件（id_rsa.pub）。</p><p><strong>然后将 <strong>SSH</strong> 公钥添加到 GitHub</strong>：</p><ul><li>复制 ~&#x2F;.ssh&#x2F;id_rsa.pub 公钥文件的内容。</li><li>登录到你的 GitHub 账户，进入“Settings &gt; SSH and GPG keys”。</li><li>点击“New SSH key”，在“Title”中输入一个描述性的标题，将复制的公钥粘贴到“Key”字段中，然后点击“Add SSH key”。</li></ul></li></ul><p><strong>2.测试SSH连接</strong>：在终端中执行以下命令测试 SSH 连接是否成功：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>如果一切配置正确，你应该会看到一条消息确认你已经成功认证。</p><p>至此，本地 Git 连接 GitHub 就成功了。接下来，你就可以愉快的使用 Git 来上传项目至 Github 了。如果你还不会 Git 的基本操作，可以看 B 站的这几个视频，帮你快速入门：</p><p><a href="https://www.bilibili.com/video/BV1gs411j7Rd?p=3&vd_source=404f52a7ebbf2477ea859f9609a15c65">git视频教程（入门篇）</a></p><p><a href="https://www.bilibili.com/video/BV1y4411a7Nn/?spm_id_from=333.788.recommend_more_video.1&vd_source=404f52a7ebbf2477ea859f9609a15c65">git视频教程（进阶篇）</a></p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>在这篇指南中，我们提供了详细的步骤来搭建一个高效的 Linux C&#x2F;C++ 编程环境。我们从选择适合新手的 Ubuntu 系统入手，然后引导你使用 VMware 或 VirtualBox 这样的虚拟机软件来安装和运行 Linux，这样即便是在 Windows 系统上也能轻松体验 Linux 编程的魅力。</p><p>安装系统后，我们详细介绍了如何在 Ubuntu 上安装编译器、构建工具和其他必要的开发软件，确保了你的开发环境是完整和功能齐全的。无论是通过命令行工具还是现代IDE，这些工具的安装都是为了让你的开发工作流更加顺畅。</p><p>最后，我们还强调了版本控制系统 Git 的重要性，并提供了如何配置 Git 和 GitHub 的步骤，这对于现代软件开发来说是不可或缺的。</p><p>通过阅读这篇文章，你应该能够独立地搭建自己的 Linux 编程环境，并且准备好开始你的编程旅程。希望本篇指南对你有所帮助，如果你有任何问题，欢迎在评论区留言。</p><p>也欢迎你来关注我的微信公众号「<strong>跟着小康学编程</strong>」，微信搜索<strong>跟着小康学编程</strong>或者扫描下方二维码关注 。 这里不仅有持续更新的计算机基础相关的文章，还有如何系统学习 C、C++，Linux 系统编程以及网络编程的文章等。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p>]]></content>
      
      
      <categories>
          
          <category> Linux 开发 </category>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux 编程 </tag>
            
            <tag> C/C++ 开发 </tag>
            
            <tag> 环境配置 </tag>
            
            <tag> 开发工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何快速掌握 C++：从新手到高手的学习指南</title>
      <link href="/how-to-learn-C++/"/>
      <url>/how-to-learn-C++/</url>
      
        <content type="html"><![CDATA[<p>大家好，我是小康，今天我们来聊下如何快速学习 C++ 语言。</p><p>本篇文章适合于有 C 语言编程基础的小伙伴们，如果还没有学习过 C，请看这篇文章先入个门：<a href="https://mp.weixin.qq.com/s?__biz=MzkyNjQyMTMyOA==&mid=2247487373&idx=1&sn=6304025e2c0a846e97999e765667d866&chksm=c236d7b2f5415ea4b12b87fddf981abcd325d7458885aeade0957db5344da97f1b82d7e65cce&token=733890015&lang=zh_CN#rd">C语言快速入门</a></p><h3 id="引言："><a href="#引言：" class="headerlink" title="引言："></a>引言：</h3><p>C++，作为一门集面向过程和面向对象编程于一体的强大语言，既保留了 C 语言的高效性，又引入了类、继承、多态、模板等现代编程概念，是学习计算机编程不可或缺的一环。本文旨在为初学者提供一个<strong>清晰的 C++ 学习路径</strong>，帮助你快速入门并掌握这门语言。</p><p>大家可以先浏览下本篇文章要讲解的 C++ 知识图谱：</p><p><img src="/images/C++%E8%AF%AD%E8%A8%80/1.png"></p><p>C++的基础语法我就不讲解了，包括<code>变量和常量的定义</code>、<code>标识符和关键字</code>、<code>语句</code>等，这些和 C 的一样，如果你还没有学习过 C 语言，可以看我之前的文章：「如何快速学习 C 语言 ？」</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>C++的基本数据类型包括  <code>字符型</code>、<code>整型</code>、<code>浮点型和布尔型</code>。</p><p><strong>字符型</strong> (char)：用于存储单个字符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> letter = <span class="string">&#x27;A&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>整型</strong> (int, short, long, long long)：用于存储整数, 以及它们的 unsigned 变体(unsigned int, unsigned short,unsigned long,unsigned long long)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> age = <span class="number">30</span>;</span><br><span class="line"><span class="type">long</span> var = <span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> bigInt = <span class="number">1000000</span>;</span><br></pre></td></tr></table></figure><p><strong>浮点型</strong> (float, double)：用于存储小数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> temperature = <span class="number">36.6</span>;</span><br><span class="line"><span class="type">double</span> distance = <span class="number">384400.0</span>; <span class="comment">// 从地球到月亮的距离，单位千米</span></span><br></pre></td></tr></table></figure><p><strong>布尔型</strong> (bool)：用于存储真（true）或假（false）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> isRainy = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><h3 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h3><p>枚举类型允许定义一个变量，它可以在几个预定义的值之间进行选择。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span> &#123;</span> RED, GREEN, BLUE &#125;;</span><br><span class="line">Color my_color = RED;</span><br></pre></td></tr></table></figure><h3 id="复合数据类型"><a href="#复合数据类型" class="headerlink" title="复合数据类型"></a>复合数据类型</h3><p>复合数据类型（也称为复杂数据类型）允许你将多个不同类型的数据项组合成一个单一的实体。这种类型的典型代表是<code>结构体</code>（struct）、<code>共用体</code>（union）和<code>类</code>（class）。</p><h4 id="结构体-struct"><a href="#结构体-struct" class="headerlink" title="结构体 (struct)"></a>结构体 (struct)</h4><p>结构体允许将多个不同类型的数据项组合成一个单一的复合类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义结构体类型</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义结构体类型变量并初始化</span></span><br><span class="line">Person person = &#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>&#125;;</span><br></pre></td></tr></table></figure><h4 id="联合体（union）"><a href="#联合体（union）" class="headerlink" title="联合体（union）"></a>联合体（union）</h4><p>联合体是一个用于优化内存使用的特殊数据类型，允许在同一内存位置存储不同的数据类型，但任一时刻只能使用其中一个成员。联合体变量使用关键字 <strong>union</strong> 来定义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Data</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">float</span> f;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Data</span> <span class="title">data</span>;</span></span><br></pre></td></tr></table></figure><h4 id="类-class"><a href="#类-class" class="headerlink" title="类 (class)"></a>类 (class)</h4><p>类是C++的核心，是支持面向对象编程的基础。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义 Book 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> title;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> author;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">read</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Reading &quot;</span> &lt;&lt; title &lt;&lt; <span class="string">&quot; by &quot;</span> &lt;&lt; author &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 定义 book 对象</span></span><br><span class="line">Book book = &#123;<span class="string">&quot;The C++ Programming Language&quot;</span>, <span class="string">&quot;Bjarne Stroustrup&quot;</span>&#125;;</span><br><span class="line"><span class="comment">// 调用 book 对象的 read 方法</span></span><br><span class="line">book.read();</span><br></pre></td></tr></table></figure><p>看不懂代码没关系，这里只需要了解 <code>类</code> 是 C++ 的一种特有数据类型。关于类的讲解下文会提及。</p><h3 id="派生数据类型"><a href="#派生数据类型" class="headerlink" title="派生数据类型"></a>派生数据类型</h3><p>派生数据类型是通过对已有的数据类型（基本类型、复合类型）进行某种形式的“扩展”或“派生”而得到的。典型的派生数据类型包括数组和指针。</p><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>数组用来存储固定大小的相同类型元素序列。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> numbers[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure><h4 id="指针："><a href="#指针：" class="headerlink" title="指针："></a>指针：</h4><p>指针用来存储变量的内存地址。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> var = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* ptr = &amp;var;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Value of var: &quot;</span> &lt;&lt; *ptr &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>这里我只简单提下。在上一篇文章<a href="https://mp.weixin.qq.com/s?__biz=MzkyNjQyMTMyOA==&mid=2247487373&idx=1&sn=6304025e2c0a846e97999e765667d866&chksm=c236d7b2f5415ea4b12b87fddf981abcd325d7458885aeade0957db5344da97f1b82d7e65cce&token=733890015&lang=zh_CN#rd">C语言快速入门</a><br>中关于数组和指针有过详细的讲解，不太了解的可以去看那片文章。C++ 的数组和指针和C的用法一样。只不过 C++ 多了一种比较特殊的类型-引用。</p><h4 id="引用："><a href="#引用：" class="headerlink" title="引用："></a>引用：</h4><p>C++中的引用是一种给已存在的变量起一个新名字（或别名）的机制。一旦一个引用被初始化为指向一个变量，它就一直指向那个变量：你对引用所做的任何操作都会影响到原始变量。</p><h5 id="引用的基本用法："><a href="#引用的基本用法：" class="headerlink" title="引用的基本用法："></a>引用的基本用法：</h5><p>引用在定义时必须被初始化，并且一旦被绑定到一个变量上，就不能再绑定到另一个变量上。引用的语法是在变量类型后面加上 <strong>&amp;</strong> 符号。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp; refA = a; <span class="comment">// refA是变量a的引用</span></span><br></pre></td></tr></table></figure><h5 id="引用的特性："><a href="#引用的特性：" class="headerlink" title="引用的特性："></a>引用的特性：</h5><ul><li>引用必须在定义时被初始化，并且一旦被初始化绑定到一个变量，就不能再指向其他变量。</li><li>引用不占用任何内存空间（引用只是变量的一个别名）。</li><li>不存在null引用。引用必须连接到一块合法的内存。</li></ul><h5 id="引用的用途："><a href="#引用的用途：" class="headerlink" title="引用的用途："></a>引用的用途：</h5><p>引用主要用于以下几个方面：</p><p><strong>1. 函数参数传递</strong>：通过传递引用给函数，可以让函数直接修改外部变量的值，而不是拷贝其值。这样做可以提高效率（尤其是对于大型对象）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过使用引用作为函数参数，可以使得函数能够修改调用者提供的参数。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">increment</span><span class="params">(<span class="type">int</span>&amp; value)</span> &#123;</span><br><span class="line">    value += <span class="number">1</span>; <span class="comment">// 直接修改传入的参数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line">    increment(x); <span class="comment">// x被修改为6</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;x after increment: &quot;</span> &lt;&lt; x &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 C++ 中，函数参数传递时，参数是类对象比较常见。</p><p><strong>2. 函数返回值</strong>：函数可以返回一个引用，从而允许对函数返回值直接赋值。这在操作重载运算符时尤其有用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="type">int</span> myNumber = <span class="number">10</span>; <span class="comment">// 全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回全局变量myNumber的引用</span></span><br><span class="line"><span class="type">int</span>&amp; <span class="title function_">getMyNumberRef</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> myNumber;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Original myNumber: &quot;</span> &lt;&lt; myNumber &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: 10</span></span><br><span class="line">    <span class="comment">// 通过函数返回的引用直接修改myNumber的值</span></span><br><span class="line">    getMyNumberRef() = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Modified myNumber: &quot;</span> &lt;&lt; myNumber &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: 20</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对于拷贝代价较大的对象（比如大型的类实例），通过引用传递或返回可以避免拷贝，提高程序效率。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>C++ 中的函数是一组一起执行一个任务的语句。函数允许你定义一次代码块并多次调用它，这有助于代码的重用和模块化。</p><h3 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h3><p>一个 C++ 函数定义包括以下几个主要部分：</p><ul><li><strong>返回类型</strong>：函数可以返回一个值。返回类型是函数返回值的数据类型。如果函数不返回值，则使用void类型。</li><li><strong>函数名称</strong>：标识函数的唯一名称。</li><li><strong>参数列表</strong>：括号内的参数，用于从函数调用者向函数传递信息。如果函数不接受任何参数，则括号为空。</li><li><strong>函数体</strong>：大括号内的一系列语句，定义了函数的执行任务。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数定义示例</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="函数声明（函数原型）"><a href="#函数声明（函数原型）" class="headerlink" title="函数声明（函数原型）"></a>函数声明（函数原型）</h3><p>为了在定义函数之前调用函数，你需要在调用点之前声明函数原型。函数声明（或称为函数原型）仅需要指定函数返回类型、函数名和参数类型，不需要函数体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>; <span class="comment">// 函数声明</span></span><br></pre></td></tr></table></figure><h3 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3><p>定义函数后，你可以通过提供函数名和所需的参数（如果有的话）来调用函数。</p><h4 id="函数调用方式"><a href="#函数调用方式" class="headerlink" title="函数调用方式"></a>函数调用方式</h4><p><strong>函数名(参数1，参数2，…)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> result = add(<span class="number">5</span>, <span class="number">3</span>); <span class="comment">// 函数调用</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出：Result: 8</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>C++支持几种参数传递方式：</p><ul><li><strong>按值传递</strong>：调用函数时，实参的值被拷贝给形参。在函数内对形参的修改不会影响实参。</li><li><strong>按引用传递</strong>：允许函数修改调用者的变量。这通过将形参定义为引用类型实现。</li><li><strong>按指针传递</strong>：意味着将变量地址作为参数传递给函数，函数通过这个指针直接访问和修改原始变量的值。</li></ul><h4 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// 按值传递</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">byValue</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">    value = <span class="number">10</span>; <span class="comment">// 只修改形参的值，对实参无影响</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 按引用传递</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">byReference</span><span class="params">(<span class="type">int</span>&amp; value)</span> &#123;</span><br><span class="line">    value = <span class="number">20</span>; <span class="comment">// 修改了实参的值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 按指针传递</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">byPointer</span><span class="params">(<span class="type">int</span>* value)</span> &#123;</span><br><span class="line">    *value = <span class="number">30</span>; <span class="comment">// 通过解引用修改了实参的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">1</span>, c = <span class="number">1</span>;</span><br><span class="line">    byValue(a);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After byValue: &quot;</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 1</span></span><br><span class="line">    byReference(b);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After byReference: &quot;</span> &lt;&lt; b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 20 </span></span><br><span class="line">    byPointer(&amp;c);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After byPointer: &quot;</span> &lt;&lt; c &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 30</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>C++中的函数重载（Function Overloading）是指允许在同一作用域内声明多个具有相同名称的函数，只要它们的参数列表（参数的类型、数量或顺序）不同即可。编译器根据函数调用时提供的参数类型和数量来决定具体调用哪个函数。</p><h4 id="代码示例：-1"><a href="#代码示例：-1" class="headerlink" title="代码示例："></a>代码示例：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下两个 print 函数构成重载</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Printing int: &quot;</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">double</span> f)</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Printing float: &quot;</span> &lt;&lt; f &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  print(<span class="number">10</span>);</span><br><span class="line">  print(<span class="number">10.5</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="特殊函数"><a href="#特殊函数" class="headerlink" title="特殊函数"></a>特殊函数</h3><h4 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h4><p>在 C++ 的类中定义的函数称为成员函数（Member Functions）。成员函数可以访问类的私有（private）、保护（protected）和公有（public）成员。</p><p>代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">myFunction</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 成员函数实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="常量成员函数"><a href="#常量成员函数" class="headerlink" title="常量成员函数"></a>常量成员函数</h4><p>常量成员函数是 C++ 中的一种特殊的成员函数，它保证在函数执行过程中<strong>不会修改对象的任何成员变量</strong>。这种函数通过在成员函数声明的末尾添加 <strong>const</strong> 关键字来定义。常量成员函数可以被任何类型的对象调用，包括常量对象。</p><p>在类的实现中，常量成员函数对类内部的状态（成员变量）只能进行只读操作，不能进行修改。这为类的使用提供了额外的安全保证，确保了不会意外改变对象状态的函数逻辑。</p><p>代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义 MyClass 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">private:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">public:</span><br><span class="line">    MyClass(<span class="type">int</span> v) : value(v) &#123;&#125; <span class="comment">// 构造函数，初始化value</span></span><br><span class="line">    <span class="comment">// 常量成员函数声明，使用const关键字</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span> <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value; <span class="comment">// 这里只是返回成员变量的值，不会修改它</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 尝试在常量成员函数中修改成员变量将导致编译错误</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">tryToModify</span><span class="params">()</span> <span class="type">const</span> &#123;</span><br><span class="line">        <span class="comment">// value = 100; // 错误：不能在常量成员函数中修改成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    MyClass <span class="title function_">obj</span><span class="params">(<span class="number">42</span>)</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The value is: &quot;</span> &lt;&lt; obj.getValue() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出：The value is: 42</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> MyClass <span class="title function_">constObj</span><span class="params">(<span class="number">55</span>)</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The value is: &quot;</span> &lt;&lt; constObj.getValue() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出：The value is: 55</span></span><br><span class="line">    <span class="comment">// constObj.tryToModify(); // 错误：不能在常量对象上调用非常量成员函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码看不懂不要紧，这里只要了解常量成员函数的基本概念，以及如何声明即可。看完下文类和对象的讲解，再回过头来看代码就可以理解。</p><h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><p>C++的面向对象编程（OOP）是一种编程范式，它使用“对象”来设计软件。对象可以包含数据（称为属性或成员变量）和代码（称为方法或成员函数）。C++的 OOP 建立在几个核心概念之上：类、封装、继承、多态。让我们一一详细讲解这些知识点。</p><h3 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h3><h4 id="类的定义："><a href="#类的定义：" class="headerlink" title="类的定义："></a>类的定义：</h4><p>类是创建对象的蓝图。它定义了对象的属性（成员变量）和行为（成员函数或方法），在C++中，使用关键字<code>class</code> 来定义类。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义 MyClass 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="成员的访问权限："><a href="#成员的访问权限：" class="headerlink" title="成员的访问权限："></a>成员的访问权限：</h4><p>在C++中，类的成员（包括变量和函数）可以具有三种不同的访问权限：<code>public</code>、<code>private</code>和<code>protected</code>。这些访问权限控制了类外部的代码对类成员的访问级别，从而实现了封装和数据隐藏。</p><ul><li><p><strong>public</strong>（公有成员）：可以被任何其他代码访问，无论是类的内部还是外部。如果类的成员声明为public，那么在类的实例化对象外部也可以直接访问这些成员。</p></li><li><p><strong>private</strong>（私有成员）：只能被该类的成员函数、友元函数和该类的其他实例访问。如果类的成员声明为private，那么这些成员只能在类的内部被访问。这是默认的访问级别，如果没有指定访问权限，则成员默认为private。</p></li><li><p><strong>protected</strong>（受保护成员）：可以被该类的成员函数、友元函数、该类的派生类中的成员访问。如果类的成员声明为protected，那么这些成员既可以在类的内部被访问，也可以在派生类中被访问，但不能直接通过类的实例在类的外部被访问。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> publicVar;  <span class="comment">// 公有成员变量，任何地方都可访问</span></span><br><span class="line">protected:</span><br><span class="line">    <span class="type">int</span> protectedVar;  <span class="comment">// 受保护成员变量，类内部和派生类可访问</span></span><br><span class="line">private:</span><br><span class="line">    <span class="type">int</span> privateVar;  <span class="comment">// 私有成员变量，仅类内部可访问</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">void</span> <span class="title function_">privateMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 私有成员函数，仅类内部可访问</span></span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">publicMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 公有成员函数，任何地方都可访问</span></span><br><span class="line">        privateVar = <span class="number">0</span>; <span class="comment">// 可以访问私有成员</span></span><br><span class="line">        privateMethod(); <span class="comment">// 可以调用私有成员函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="成员访问权限有什么用？"><a href="#成员访问权限有什么用？" class="headerlink" title="成员访问权限有什么用？"></a>成员访问权限有什么用？</h4><ul><li><strong>封装</strong>：通过将成员设为私有或受保护，类可以隐藏其实现细节，仅通过公有接口与外界交互。这样做可以在不影响外部代码的情况下自由修改类的内部实现。</li><li><strong>维护性</strong>：限制对成员的访问可以减少因错误使用类成员而产生的bug，使得代码更加可维护。</li><li><strong>扩展性</strong>：合理使用访问权限可以在不破坏原有类的基础上进行扩展，增加新的功能。</li></ul><h4 id="成员变量和成员函数"><a href="#成员变量和成员函数" class="headerlink" title="成员变量和成员函数"></a>成员变量和成员函数</h4><p>类中定义的变量称为成员变量，类中定义的函数称为成员函数。它们定义了类的属性和行为。</p><p>成员变量初始化有以下两种方式：</p><p><strong>1. 构造函数初始化列表</strong>：使用构造函数的初始化列表直接初始化成员变量，这是最常用且推荐的初始化成员变量的方式，特别是对于常量成员和引用成员。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> &#123;</span></span><br><span class="line">private:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">public:</span><br><span class="line">    Example(<span class="type">int</span> d) : data(d) &#123;&#125; <span class="comment">// 构造函数初始化列表</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>2. 在构造函数体内赋值</strong>：在函数体内对成员进行初始化。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> &#123;</span></span><br><span class="line">private:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">public:</span><br><span class="line">    Example(<span class="type">int</span> d) &#123;</span><br><span class="line">        data = d; <span class="comment">// 在构造函数体内赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h4><p><strong>构造函数</strong>：构造函数的名称与类名相同，可以有参数，也可以重载（即定义多个构造函数，每个构造函数有不同的参数列表）。如果你不提供任何构造函数，C++编译器会自动生成一个默认的无参构造函数。</p><p>构造函数在创建对象时自动调用，用于初始化对象。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    Car() &#123; <span class="comment">// 默认构造函数</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Car object created.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Car(<span class="built_in">string</span> brand) &#123; <span class="comment">// 带有参数的构造函数</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; brand &lt;&lt; <span class="string">&quot; car object created.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>析构函数</strong>：析构函数的名称是类名前加上波浪符号<code>~</code>，它不能带参数，因此一个类只能有一个析构函数。析构函数用于执行对象销毁前的清理工作，比如释放分配的资源等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    ~Car() &#123; <span class="comment">// 析构函数</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Car object destroyed.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过合理定义和使用构造函数和析构函数，我们可以确保对象在创建和销毁时维持合理的状态，以及有效地管理资源。</p><p>一个简单的 Car 类定义示例：</p><p>该 Car 类包含构造函数和析构函数，成员变量和成员函数等基本成员。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义 Car 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">string</span> brand;  <span class="comment">// 汽车的品牌</span></span><br><span class="line">    <span class="comment">// 构造函数，使用初始化列表来初始化成员变量。</span></span><br><span class="line">    Car(<span class="built_in">string</span> b) : brand(b) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; brand &lt;&lt; <span class="string">&quot; car is created.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~Car() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; brand &lt;&lt; <span class="string">&quot; car is destroyed.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 成员函数</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">drive</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Driving &quot;</span> &lt;&lt; brand &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Car <span class="title function_">myCar</span><span class="params">(<span class="string">&quot;Ford&quot;</span>)</span>;  <span class="comment">// 创建一个Car对象，品牌为&quot;Ford&quot;</span></span><br><span class="line">    myCar.drive();      <span class="comment">// 调用drive成员函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="对象的创建："><a href="#对象的创建：" class="headerlink" title="对象的创建："></a>对象的创建：</h4><p>对象是类的实例。通过类，我们可以创建对象，并使用其属性和方法。对象可以通过成员访问运算符<code>.</code>访问其成员变量和成员函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Car <span class="title function_">myCar</span><span class="params">(<span class="string">&quot;Ford&quot;</span>)</span>; <span class="comment">// 福特汽车</span></span><br><span class="line">myCar.drive();     <span class="comment">// 访问 myCar 对象的成员方法</span></span><br></pre></td></tr></table></figure><h4 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h4><p>在C++中，this指针是一个特殊的指针，它指向当前对象。每个非静态成员函数（包括构造函数、析构函数以及其他成员函数）都有一个this指针作为其隐式参数，这使得成员函数能够访问调用它的对象的成员。this指针在成员函数内部使用，特别是在需要引用调用函数的当前对象时。</p><p>当我们在类的成员函数中需要引用对象本身时，就会用到this指针。这在以下几种情况中尤其有用：</p><ul><li>当参数名称与成员变量名称相同时，用以区分成员变量和参数。</li><li>在实现链式调用时返回对象的引用。</li><li>当需要返回对象本身的指针时。</li></ul><p>示例代码：</p><p><strong>1. 区分成员变量和参数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> width;</span><br><span class="line">    Box(<span class="type">int</span> width) &#123;</span><br><span class="line">        <span class="comment">// 使用this指针区分成员变量和构造函数参数</span></span><br><span class="line">        this-&gt;width = width;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">displayWidth</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Width: &quot;</span> &lt;&lt; width &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 直接访问width，实际上是this-&gt;width</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个例子中，构造函数的参数width与类的成员变量width同名。通过使用this-&gt;width，我们明确指出了左边的width是对象的成员变量，而不是参数。</p><p><strong>2. 实现链式调用</strong></p><p>链式调用是一种编程风格，通过在成员函数末尾返回对象本身，可以连续调用多个成员函数。</p><p>示例代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span> &#123;</span></span><br><span class="line">private:</span><br><span class="line">    <span class="type">int</span> width;</span><br><span class="line">public:</span><br><span class="line">    Box&amp; <span class="title function_">setWidth</span><span class="params">(<span class="type">int</span> width)</span> &#123;</span><br><span class="line">        this-&gt;width = width;</span><br><span class="line">        <span class="keyword">return</span> *this;  <span class="comment">// 返回当前对象的引用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">displayWidth</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Width: &quot;</span> &lt;&lt; width &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Box box;</span><br><span class="line">    box.setWidth(<span class="number">10</span>).displayWidth();  <span class="comment">// 链式调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在setWidth函数中，返回*this允许链式调用，即连续调用对象的成员函数。</p><p><strong>3. 返回对象本身的指针</strong></p><p>有时候，我们可能需要在成员函数中返回指向当前对象的指针。</p><p>示例代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    Box* <span class="title function_">getPointer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> this;  <span class="comment">// 返回指向当前对象的指针</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在getPointer函数中，通过返回this，我们得到了一个指向当前对象的指针。</p><p>this指针是 C++ 中一个强大的工具，它提供了一个自引用的机制。通过 this 指针，类的成员函数可以访问调用它们的对象的其他成员。理解 this 指针对于深入学习C++面向对象编程非常重要。</p><p><strong>而理解 this 指针，关键是要了解它的底层原理</strong>：</p><p>在C++中，this指针的底层实现其实非常直观。当一个非静态成员函数被调用时，编译器隐式地将当前对象的地址作为一个参数传递给函数。这个隐式参数就是this指针。因此，每个非静态成员函数在内部都有一个名为this的额外参数，指向调用该函数的对象。</p><h5 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h5><ul><li><p>对于一个类<code>ClassType</code>中的非静态成员函数<code>memberFunction</code>，调用形式<code>object.memberFunction(args...)</code>,实际上在底层被编译器处理为<code>ClassType::memberFunction(&amp;object, args...)</code>，其中<code>&amp;object</code>就是<code>this指针</code>。</p></li><li><p>因此，即使你在成员函数定义中没有显式地看到<code>this</code>参数，编译器仍然按照每个非静态成员函数都有一个类型为<code>ClassType*</code>的<code>this指针</code>作为其第一个参数的方式来处理。</p></li></ul><p>考虑以下类定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">myFunction</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Value of a: &quot;</span> &lt;&lt; this-&gt;a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当你创建一个MyClass对象并调用其成员函数myFunction时：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyClass obj;</span><br><span class="line">obj.a = <span class="number">10</span>;</span><br><span class="line">obj.myFunction();</span><br></pre></td></tr></table></figure><p>在调用 obj.myFunction() 时，实际上编译器在底层将其转换为类似以下形式的调用（这是一种简化的表达，实际转换会依赖于具体的编译器）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyClass::myFunction(&amp;obj);</span><br></pre></td></tr></table></figure><p>这里，&amp;obj 是对象 obj 的地址，它被隐式地作为 this 指针传递给 myFunction。所以，在 myFunction 内部，当你访问 this-&gt;a 时，实际上就是通过 obj 的地址来访问它的成员变量 a。</p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>封装在 C++ 面向对象编程中是一种将数据（属性）和行为（方法）捆绑在一起的机制，同时对外隐藏内部实现的细节，仅通过定义好的接口与外界交互。</p><p><strong>简单来说</strong>:封装实质上是关于数据隐藏和接口暴露的。在定义一个类时，你会将某些数据成员标记为 private，这意味着它们只能被类的内部成员函数访问，对类的使用者来说，这些细节被隐藏了。然而，你也会提供public的成员函数作为操作这些数据的接口，这样类的使用者可以在不知道内部实现细节的情况下，通过这些接口来操作对象。</p><h4 id="封装的实现"><a href="#封装的实现" class="headerlink" title="封装的实现"></a>封装的实现</h4><p>在C++中，封装通过<strong>类</strong>实现，类中可以定义三种类型的成员：public（公有成员）、private（私有成员）和protected（受保护成员）。这些访问修饰符定义了成员的访问范围：</p><ul><li><strong>private</strong> 成员只能由同一类的成员函数访问。</li><li><strong>public</strong> 成员可以由任何可以访问类对象的代码访问。</li><li><strong>protected</strong> 成员可以被基类和派生类中的成员函数访问。</li></ul><p>通过精心设计公有接口，类的设计者可以控制外部代码对内部数据的访问方式，保护对象的状态不被非法操作破坏。</p><h4 id="封装的优势"><a href="#封装的优势" class="headerlink" title="封装的优势"></a>封装的优势</h4><ul><li><strong>数据安全</strong>：通过隐藏内部实现细节，减少了外部对内部数据的直接访问，降低了数据被误用或误修改的风险。</li><li><strong>接口清晰</strong>：用户只需关注类提供的公有接口，不必深究类的内部实现，使得类更加易于使用和理解。</li><li><strong>易于维护和扩展</strong>：类的内部实现可以自由修改，只要公有接口保持不变，就不会影响到使用该类的代码，提高了代码的可维护性和扩展性。</li></ul><p><strong>一个体现 C++ 封装的类的实现</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">private:</span><br><span class="line">    <span class="built_in">string</span> name;  <span class="comment">// 私有成员变量，存储人的姓名</span></span><br><span class="line">    <span class="type">int</span> age;      <span class="comment">// 私有成员变量，存储人的年龄</span></span><br><span class="line">public:</span><br><span class="line">    <span class="comment">// 构造函数，初始化姓名和年龄，使用初始化列表来初始化成员变量。</span></span><br><span class="line">    Person(<span class="built_in">string</span> n, <span class="type">int</span> a) : name(n), age(a) &#123;&#125;</span><br><span class="line">    <span class="comment">// 公有成员函数，设置姓名</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">setName</span><span class="params">(<span class="built_in">string</span> n)</span> &#123;</span><br><span class="line">        name = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 公有成员函数，获取姓名</span></span><br><span class="line">    <span class="built_in">string</span> <span class="title function_">getName</span><span class="params">()</span> <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 公有成员函数，设置年龄</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(a &gt;= <span class="number">0</span>) &#123; <span class="comment">// 确保年龄是非负数</span></span><br><span class="line">            age = a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 公有成员函数，获取年龄</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 成员函数，打印Person信息</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">printInfo</span><span class="params">()</span> <span class="type">const</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;, Age: &quot;</span> &lt;&lt; age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Person <span class="title function_">person</span><span class="params">(<span class="string">&quot;John Doe&quot;</span>, <span class="number">30</span>)</span>; <span class="comment">// 创建Person对象</span></span><br><span class="line">    person.printInfo(); <span class="comment">// 打印信息</span></span><br><span class="line">    <span class="comment">// 尝试修改Person的姓名和年龄</span></span><br><span class="line">    person.setName(<span class="string">&quot;Jane Doe&quot;</span>);</span><br><span class="line">    person.setAge(<span class="number">25</span>);</span><br><span class="line">    <span class="comment">// 再次打印修改后的信息</span></span><br><span class="line">    person.printInfo(); <span class="comment">// 打印信息</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h4 id="继承的定义"><a href="#继承的定义" class="headerlink" title="继承的定义"></a>继承的定义</h4><p>继承允许新的类（派生类）继承现有类（基类）的属性和方法。它支持代码重用，并建立了类之间的层次关系。</p><h4 id="继承的分类"><a href="#继承的分类" class="headerlink" title="继承的分类"></a>继承的分类</h4><h5 id="单一继承"><a href="#单一继承" class="headerlink" title="单一继承"></a>单一继承</h5><p>在单一继承中，一个派生类只继承自一个基类。这意味着派生类包含了基类的所有属性和方法，同时还可以添加自己的属性和方法，或者重写基类的方法。</p><p><strong>定义方式</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseClass</span> &#123;</span></span><br><span class="line">    <span class="comment">// 基类的成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedClass</span> :</span> public BaseClass &#123;</span><br><span class="line">    <span class="comment">// 派生类的成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里，DerivedClass 是通过单一继承从 BaseClass派生而来的。</p><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Eating.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span> public Animal &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">bark</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Barking.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Dog myDog;</span><br><span class="line">    myDog.eat(); <span class="comment">// 调用基类的方法</span></span><br><span class="line">    myDog.bark(); <span class="comment">// 调用派生类的方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h5><p>多重继承允许一个派生类同时从多个基类继承属性和方法。这种方式增加了灵活性，但也可能引入复杂性，例如需要处理潜在的命名冲突，以及著名的“菱形问题”。</p><p><strong>定义方式</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseClass1</span> &#123;</span></span><br><span class="line">    <span class="comment">// 基类1的成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseClass2</span> &#123;</span></span><br><span class="line">    <span class="comment">// 基类2的成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedClass</span> :</span> public BaseClass1, public BaseClass2 &#123;</span><br><span class="line">    <span class="comment">// 派生类的成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个例子中，DerivedClass 同时从 BaseClass1 和BaseClass2 继承，成为它们的派生类。</p><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Eating.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 第二个基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Flying.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类(麻雀)，继承自Animal和Bird</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sparrow</span> :</span> public Animal, public Bird &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="comment">//发出声音，模拟麻雀叫声</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">chirp</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Chirping.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Sparrow mySparrow;</span><br><span class="line">    mySparrow.eat(); <span class="comment">// 调用Animal基类的方法</span></span><br><span class="line">    mySparrow.fly(); <span class="comment">// 调用Bird基类的方法</span></span><br><span class="line">    mySparrow.chirp(); <span class="comment">// 调用派生类的方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多重继承允许一个派生类同时继承自多个基类。这是C++提供的一种强大功能，它可以让派生类继承并实现多个基类定义的接口和属性。然而，在使用多重继承时，我们可能会遇到一种特殊情况：菱形继承（也称为钻石继承）问题。</p><p><strong>菱形继承</strong></p><p>假设有这样一个场景：我们有一个基类A，然后有两个类B和C分别继承自A，最后有一个类D同时继承自B和C。这样构成的继承结构形状像一个菱形，因此称为菱形继承。如下图：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">     A</span><br><span class="line">    / \</span><br><span class="line">   B   C</span><br><span class="line">    \ /</span><br><span class="line">     D</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对应的代码示例：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> public A &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> public A &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> public B, public C &#123;</span><br><span class="line">    <span class="comment">// D通过B和C继承了A，可能会导致A的成员在D中存在多份拷贝</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>菱形继承引入的问题是D通过B和C继承了两份A的成员，这导致了数据冗余和不一致性的风险。特别是当试图访问从A继承来的成员时，编译器会因为不知道应该通过B还是C的路径去访问而产生歧义。</p><p><strong>解决菱形继承问题</strong></p><p>C++中通过引入虚继承来解决菱形继承问题。在菱形继承的结构中，将B和C对A的继承声明为虚继承（使用<code>virtual</code>关键字），可以确保D中只有一份A的成员副本。</p><p>这样，无论是通过B还是C，访问到的都是同一份来自A的成员，解决了成员访问歧义的问题，并且保证了数据的一致性。</p><p><strong>虚继承的声明方式</strong>：</p><p>通过在派生类中使用 <strong>virtual</strong> 关键字进行继承。</p><p>使用虚继承来解决菱形继承问题示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// B和C虚继承A</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> virtual public A &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> virtual public A &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// D继承自B和C</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> public B, public C &#123;&#125;;</span><br></pre></td></tr></table></figure><p>在这个例子中，通过将 B 和 C 对 A 的继承声明为虚继承，我们确保了在 D 中只有一份来自 A 的成员 value，无论是通过 B 还是 C 的路径访问 value，访问到的都是相同的成员。</p><h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><p>在C++中，友元（Friend）是一个允许某些外部函数或类访问另一个类的私有（private）和保护（protected）成员的特性。友元关系不受类之间的公有（public）、私有（private）和保护（protected）访问控制的约束，这使得某些特定的函数或类可以直接访问类的内部成员。</p><p>友元机制可以增强程序的灵活性，但同时也可能破坏对象的封装性。</p><p>友元可以是：</p><ul><li>友元函数</li><li>友元类</li><li>友元成员函数</li></ul><h4 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h4><p>友元函数在C++中是一种特殊的函数，它虽然不是类的成员函数，但能够访问类的私有（private）和保护（protected）成员。这允许全局函数访问类的私有成员。</p><p>友元函数的定义包含两个主要步骤：</p><ul><li><p><strong>在类内声明友元函数</strong>：你需要在类定义内部使用 <code>friend</code> 关键字声明该函数为友元，这告诉编译器这个特定的函数可以访问类的私有和保护成员。</p></li><li><p><strong>定义友元函数</strong>：友元函数的定义与普通函数相同，但需要注意的是，友元函数本身不是类的成员函数，因此它不能通过对象或指针来调用，而是像普通函数那样直接调用。</p></li></ul><p>代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">private:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">public:</span><br><span class="line">    MyClass(<span class="type">int</span> val) : value(val) &#123;&#125; <span class="comment">// 构造函数初始化value</span></span><br><span class="line">    <span class="comment">// 声明友元函数</span></span><br><span class="line">    friend <span class="type">void</span> <span class="title function_">friendFunction</span><span class="params">(MyClass&amp; obj)</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 定义友元函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">friendFunction</span><span class="params">(MyClass&amp; obj)</span> &#123;</span><br><span class="line">    <span class="comment">// 友元函数可以访问MyClass的私有成员value</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Accessing private member value: &quot;</span> &lt;&lt; obj.value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    MyClass <span class="title function_">myObj</span><span class="params">(<span class="number">100</span>)</span>;</span><br><span class="line">    <span class="comment">// 调用友元函数，并访问MyClass对象的私有数据</span></span><br><span class="line">    friendFunction(myObj); <span class="comment">// 输出: Accessing private member value: 100</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h4><p>当一个类被声明为另一个类的友元时，这个友元类的所有成员函数都可以访问另一个类的私有和保护成员。</p><p>示例代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span> &#123;</span></span><br><span class="line">    <span class="type">double</span> width;</span><br><span class="line">public:</span><br><span class="line">    Box(<span class="type">double</span> wid) : width(wid) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    friend <span class="class"><span class="keyword">class</span> <span class="title">Printer</span>;</span> <span class="comment">// 声明Printer为友元类</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Printer</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">printWidth</span><span class="params">(Box box)</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Width of box : &quot;</span> &lt;&lt; box.width &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Box <span class="title function_">box</span><span class="params">(<span class="number">10.0</span>)</span>;</span><br><span class="line">    Printer printer;</span><br><span class="line">    printer.printWidth(box);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子中，Printer 类是 Box 类的友元，因此 Printer 的成员函数 printWidth可以访问 Box 的私有成员 width。</p><h4 id="友元成员函数"><a href="#友元成员函数" class="headerlink" title="友元成员函数"></a>友元成员函数</h4><p>一个类的成员函数可以被声明为另一个类的友元。</p><p>示例代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span> &#123;</span></span><br><span class="line">    <span class="type">double</span> width;</span><br><span class="line">public:</span><br><span class="line">    Box(<span class="type">double</span> wid) : width(wid) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    friend <span class="type">void</span> <span class="title function_">Printer::printWidth</span><span class="params">(Box box)</span>; <span class="comment">// 前向声明</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Printer</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">printWidth</span><span class="params">(Box box)</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Width of box : &quot;</span> &lt;&lt; box.width &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Box <span class="title function_">box</span><span class="params">(<span class="number">10.0</span>)</span>;</span><br><span class="line">    Printer printer;</span><br><span class="line">    printer.printWidth(box); <span class="comment">// 使用Printer对象打印Box的宽度</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，Printer类的成员函数printWidth是Box类的友元，因此它可以访问Box的私有成员width。</p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>使用友元时应谨慎，因为它破坏了类的封装性。一个设计良好的类应该尽量隐藏其实现细节，只通过公共接口与外界交互。</li><li>友元关系不能被继承。</li><li>友元关系是单向的，即如果类A是类B的友元，类B不一定是类A的友元。</li></ul><h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><p>运算符重载是 C++ 中一个非常强大的特性，它允许开发者为自定义类型指定运算符操作的行为。这样，我们就可以对自定义类型使用标准的C++运算符，如+、-、&lt;&lt;等。这不仅可以提高代码的直观性，还可以使得自定义类型的操作更加自然。</p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>运算符重载允许开发者为自定义类型重新定义运算符的功能。它可以作为成员函数或非成员函数(友元函数)实现，但必须至少有一个操作数是用户定义的类型。</p><p><strong>使用运算符重载时，需要遵循一些规则</strong>：</p><ul><li>不能改变运算符的优先级。</li><li>不能创造新的运算符。</li><li>有些运算符不能被重载，如<code>.</code>、<code>::</code>、<code>?:</code>和<code>sizeof</code>。其他的内置运算符都是可以重载的，比如常见的算术运算符、比较运算符、逻辑运算符等。</li><li>大多数重载的运算符可以是成员函数，也可以是非成员函数，但有些必须是成员函数，如赋值运算符<code>=</code>。</li></ul><h4 id="运算符重载的分类"><a href="#运算符重载的分类" class="headerlink" title="运算符重载的分类"></a>运算符重载的分类</h4><p>根据运算符作用于的对象，运算符重载可以是成员函数或非成员函数。</p><h5 id="成员函数运算符重载"><a href="#成员函数运算符重载" class="headerlink" title="成员函数运算符重载"></a>成员函数运算符重载</h5><p>当运算符重载作为成员函数时，它的第一个操作数隐式地成为了调用它的对象，这意味着你不能改变操作数的顺序。这通常用于二元运算符，比如加法运算符+，或一元运算符，比如递增运算符++。</p><p>我们先来看个成员函数运算符重载的例子,以重载<code>+</code>运算符为例，定义一个 <code>Point</code> 类，并为它重载 <code>+</code> 运算符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    Point(<span class="type">int</span> x = <span class="number">0</span>, <span class="type">int</span> y = <span class="number">0</span>) : x(x), y(y) &#123;&#125;</span><br><span class="line">    <span class="comment">// 重载+运算符</span></span><br><span class="line">    Point operator+(<span class="type">const</span> Point&amp; rhs) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x + rhs.x, y + rhs.y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Point <span class="title function_">p1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span>, <span class="title function_">p2</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span>;</span><br><span class="line">    Point p3 = p1 + p2;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;p3 = (&quot;</span> &lt;&lt; p3.x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; p3.y &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们定义了 <code>Point</code> 类的对象可以通过<code>+</code>运算符相加，返回两点坐标的和。</p><h5 id="非成员函数运算符重载"><a href="#非成员函数运算符重载" class="headerlink" title="非成员函数运算符重载"></a>非成员函数运算符重载</h5><p>非成员函数运算符重载通常声明为类的友元，这样它们就可以访问类的私有成员。这种方式适用于操作符左侧的对象不是重载运算符所在类的实例的情况，比如<code>输出流运算符&lt;&lt;</code>。</p><p><strong>重载&lt;&lt;运算符</strong></p><p>接下来，我们看下非成员函数运算符重载的例子，重载<code>&lt;&lt;</code>运算符以便能够直接打印 <code>Point</code> 对象。</p><p>由于<code>&lt;&lt;</code>运算符需要操作<code>std::ostream</code>类型的左操作数（如<code>std::cout</code>），它不能作为成员函数重载，而应该是非成员函数(友元函数)。通常，我们会将这样的函数声明为友元，以便它可以访问类的私有成员。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    friend <span class="built_in">std</span>::ostream&amp; operator&lt;&lt;(<span class="built_in">std</span>::ostream&amp; os, <span class="type">const</span> Point&amp; p);</span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    Point(<span class="type">int</span> x = <span class="number">0</span>, <span class="type">int</span> y = <span class="number">0</span>) : x(x), y(y) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 重载&lt;&lt;运算符</span></span><br><span class="line"><span class="built_in">std</span>::ostream&amp; operator&lt;&lt;(<span class="built_in">std</span>::ostream&amp; os, <span class="type">const</span> Point&amp; p) &#123;</span><br><span class="line">    os &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; p.x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; p.y &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Point <span class="title function_">p1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; p1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 现在可以直接打印Point对象了</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这里留个问题</strong>：为什么<code>&lt;&lt;</code>运算符不能作为成员函数重载，而只能是非成员函数？</p><p>这个问题，在我开始学习运算符重载的时候就挺疑惑的，不过现在已经搞清楚了，接下来，我尽可能用易懂的文字及代码示例给大家讲解清楚：</p><p>在 C++ 中，当你使用如 <code>std::cout &lt;&lt; object</code>; 的形式进行输出时，期望的行为是把<code>object</code>的内容发送到输出流<code>std::cout</code>。为了实现这个行为，我们需要重载&lt;&lt;运算符。但这里的挑战在于，<code>std::cout</code>是一个<code>std::ostream</code>类型的对象，而<code>object</code>是另一个用户自定义类型的类对象。</p><p><strong>成员函数的限制</strong>：<br>如果<code>&lt;&lt;</code>运算符是作为用户自定义类型的一个成员函数来重载，它的使用方式将变为<code>object.operator&lt;&lt;(std::cout);</code>。这意味着，从语法上讲，你正在尝试向<code>object</code>发送<code>std::cout</code>，而不是反过来。这与我们通常使用输出流的直觉相违背，因为我们希望<code>std::cout</code>在左边，<code>object</code>在右边，即：<code>std::cout&lt;&lt;object</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    MyClass(<span class="type">int</span> v) : value(v) &#123;&#125;</span><br><span class="line">    <span class="comment">// 假设尝试将 &lt;&lt; 作为成员函数重载</span></span><br><span class="line">    <span class="type">void</span> operator&lt;&lt;(<span class="built_in">std</span>::ostream&amp; os) &#123;</span><br><span class="line">        os &lt;&lt; value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    MyClass <span class="title function_">obj</span><span class="params">(<span class="number">10</span>)</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; obj; <span class="comment">// 这是我们想要的使用方式</span></span><br><span class="line">    obj &lt;&lt; <span class="built_in">std</span>::<span class="built_in">cout</span>; <span class="comment">// 如果&lt;&lt;是成员函数，实际调用将会是这样，这显然不符合我们的预期</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>为什么用非成员函数?</strong></p><p>为了让<code>std::cout &lt;&lt; object;</code>按预期工作，我们需要把<code>&lt;&lt;</code>运算符重载为非成员函数，这样它就可以接受两个参数：左边的<code>std::ostream</code>对象和右边的用户自定义类型对象。这种方式符合我们直观的使用习惯。</p><p><strong>使用友元函数</strong></p><p>此外，由于重载的<code>&lt;&lt;</code>运算符通常需要访问用户自定义类型对象的内部数据（可能包括私有成员），我们一般会把这个重载函数声明为<strong>友元函数</strong>。这样，即使是非成员函数，它也能访问类的私有或受保护成员，从而可以输出对象的内部状态。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    MyClass(<span class="type">int</span> val) : value(val) &#123;&#125;</span><br><span class="line">    <span class="comment">// 注意，这里没有作为成员函数重载&lt;&lt;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载&lt;&lt;运算符作为全局函数，并声明为友元，以便可以访问MyClass的内部数据</span></span><br><span class="line"><span class="built_in">std</span>::ostream&amp; operator&lt;&lt;(<span class="built_in">std</span>::ostream&amp; os, <span class="type">const</span> MyClass&amp; obj) &#123;</span><br><span class="line">    os &lt;&lt; obj.value; <span class="comment">// 假设我们要输出MyClass对象的value成员</span></span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    MyClass <span class="title function_">myObject</span><span class="params">(<span class="number">10</span>)</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; myObject; <span class="comment">// 正确地把myObject的内容输出到std::cout</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>在讲解多态之前，我们先来回顾下继承，因为多态是建立在类的继承关系之上的。</p><p><strong>简单来说</strong>: 继承允许我们基于一个已有的类（称为基类）来创建新的类（称为派生类）。派生类继承了基类的属性和方法，并且可以添加自己的属性和方法，或者重写继承来的方法。这为代码复用提供了一个强大的机制。</p><p>多态，字面意思是“多种形态”。在C++中，它允许我们通过一个共同的接口来操作不同的数据类型。这听起来可能有点抽象，不过别担心，让我们通过一个例子来简化它。</p><p>想象一下，你在动物园里，看到了各种各样的动物。虽然每种动物都有自己独特的叫声，但是你可以通过一个统一的行为“发出声音”来描述它们的共性。在C++中，我们可以将这种“发出声音”的行为抽象成一个共同的接口，然后让每种动物类根据自己的特性来实现这个接口。</p><h4 id="多态的分类："><a href="#多态的分类：" class="headerlink" title="多态的分类："></a>多态的分类：</h4><p>在C++中，多态主要以两种形式出现：<strong>编译时多态和运行时多态。</strong></p><ul><li><p><strong>编译时多态</strong>，也称为静态多态，主要是通过函数重载和模板实现的。函数重载允许你在同一个作用域内创建多个同名函数，只要它们的参数列表不同即可。编译器根据调用函数时提供的参数类型和数量，来决定调用哪个函数。</p></li><li><p><strong>运行时多态</strong>，也称为动态多态，是通过虚函数和继承实现的。这允许你在基类中定义一个接口，并在派生类中以不同的方式实现该接口。运行时多态的关键在于，你在代码运行时才确定调用哪个函数。</p></li></ul><h4 id="运行时多态的实现："><a href="#运行时多态的实现：" class="headerlink" title="运行时多态的实现："></a>运行时多态的实现：</h4><p>要实现C++的运行时多态，你需要掌握两个核心概念：<strong>虚函数和指针或引用</strong>。</p><p><strong>虚函数</strong>：</p><p>虚函数是在基类中使用关键字 <code>virtual</code> 声明的函数，它可以在派生类中被重覆盖，覆盖指的是派生类被重写的函数和基类声明的虚函数具有相同的函数声明。这样当你通过基类的指针或引用调用虚函数时，C++会根据对象的实际类型来决定调用哪个版本的函数。</p><p><strong>简单示例</strong></p><p>让我们回到动物园的例子，如果“动物”是一个基类，“狗”和“猫”是派生类，那么即使我们有一个指向“动物”的指针，我们也可以用它来调用“狗”和“猫”特有的方法。</p><p>代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    virtual <span class="type">void</span> <span class="title function_">speak</span><span class="params">()</span> &#123; </span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Some sound&quot;</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span> public Animal &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">speak</span><span class="params">()</span>  &#123; </span><br><span class="line">          <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Woof&quot;</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span> public Animal &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">speak</span><span class="params">()</span>  &#123; </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Meow&quot;</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Animal* myAnimal = new Dog();</span><br><span class="line">    myAnimal-&gt;speak();  <span class="comment">// Outputs: Woof</span></span><br><span class="line"></span><br><span class="line">    myAnimal = new Cat();</span><br><span class="line">    myAnimal-&gt;speak();  <span class="comment">// Outputs: Meow</span></span><br><span class="line"></span><br><span class="line">    delete myAnimal; <span class="comment">// Assuming myAnimal now points to Cat, delete the Cat object</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们定义了一个基类 Animal 和两个派生类 Dog 和 Cat。每个类都有一个 speak 函数，但实现各不相同。通过基类指针调用 speak 时，C++运行时会根据对象的实际类型来决定调用 Dog 的 speak 还是 Cat 的 speak。</p><p><strong>这里问个问题</strong>：myAnimal是基类指针，为什么调用的是派生类(Cat类和Dog类)的方法？</p><p>其实就是通过多态和虚函数机制来实现的。简单来说：</p><ul><li><p><code>虚函数</code>：在基类中用virtual关键字声明的函数。派生类可以重写这些函数。</p></li><li><p><code>虚表指针</code>：每个包含虚函数的类对象都有一个指针（vptr），指向其类的虚表。</p></li><li><p><code>虚表</code>：每个包含虚函数的类都有一个虚函数表（简称vtable），里面存储了虚函数的地址。</p></li></ul><p><code>注意</code>：虚函数表（vtable）是在编译期间确定的，而虚表指针（vptr）是在每个对象被构造时创建并初始化的。(<strong>这个也是面试常考的点</strong>)</p><p>当通过基类指针调用虚函数时，程序会使用这个指针指向的对象的虚表来确定实际调用哪个函数(这个过程是在运行时做的)。这样，即便是通过基类指针，程序也能调用到派生类中重写的方法，实现了多态。 </p><p>在这个例子中，Animal 类中的 speak 函数被声明为 virtual，这使得 Dog 和 Cat类能够提供自己的speak函数实现。当通过类型为 Animal* 的指针 myAnimal 调用 speak 函数时，C++ 运行时会检查 myAnimal 实际指向的对象类型（Dog或Cat），并调用那个类型的 speak 函数。</p><h4 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h4><p>当我们希望定义一个通用接口，但又不想在基类中提供任何具体实现时，该怎么办。使用纯虚函数和抽象类即可实现。</p><h5 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h5><p>纯虚函数是一种特殊的虚函数，在基类中声明但不提供实现（不定义函数体），并且要求派生类必须提供具体的实现。这通过在函数声明的末尾加上<code>= 0</code>来实现。</p><p>纯虚函数的存在使得基类变成所谓的抽象类，这意味着它不能被直接实例化。这样，抽象类为派生类定义了一个或多个必须实现的接口，从而实现了一个完全抽象的概念层。</p><h5 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h5><p>抽象类是包含至少一个纯虚函数的类。它主要用作其他类的基类，定义了一组接口，派生类通过实现这些接口实现多态性。抽象类提供了一种强制派生类遵守特定设计契约的机制。</p><p>回到我们的动物园例子，假设我们想要强制每种动物都必须实现自己的“发出声音”的方法，但在“动物”这一概念层面，我们无法给出一个具体的实现。这就是纯虚函数和抽象类发挥作用的地方。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象基类Animal</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="comment">// 纯虚函数</span></span><br><span class="line">    virtual <span class="type">void</span> <span class="title function_">speak</span><span class="params">()</span> <span class="type">const</span> = <span class="number">0</span>;</span><br><span class="line">    virtual ~Animal() &#123;&#125; <span class="comment">// 虚析构函数，保证派生类的析构函数被调用</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dog类继承自Animal并实现speak方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span> public Animal &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">speak</span><span class="params">()</span> <span class="type">const</span>  &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Dog says: Woof!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Cat类继承自Animal并实现speak方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span> public Animal &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">speak</span><span class="params">()</span> <span class="type">const</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Cat says: Meow!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">letAnimalSpeak</span><span class="params">(<span class="type">const</span> Animal* animal)</span> &#123;</span><br><span class="line">    animal-&gt;speak(); <span class="comment">// 动态绑定speak方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Dog dog;</span><br><span class="line">    Cat cat;</span><br><span class="line">    letAnimalSpeak(&amp;dog);</span><br><span class="line">    letAnimalSpeak(&amp;cat);</span><br><span class="line">    <span class="comment">// Animal animal; // 错误：不能实例化抽象类</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这个示例中，Animal类成为了一个抽象基类，因为它包含了一个纯虚函数 speak。我们不能直接实例化 Animal 类，但我们可以通过它的派生类 Dog 和 Cat 来实例化对象，并且通过 Animal 类的引用或指针来调用它们各自的 speak 方法。</p><p>通过将 speak 方法定义为纯虚函数，我们确保了所有 Animal 的派生类都必须实现自己的 speak 方法，这样每种动物都有自己独特的发声方式。同时，这也展示了运行时多态的强大之处：即使是通过 Animal 类型的引用或指针，程序在运行时也能正确调用到派生类对象的 speak 方法。</p><p>引入纯虚函数和抽象类后，我们的代码设计变得更加清晰和严格。这种方式不仅强制派生类遵守一定的规则，也提供了一个明确的、可扩展的接口框架。</p><p><strong>使用多态的好处</strong>：<br>多态的使用提供了几个优点：</p><ul><li><strong>代码的可复用性</strong>：可以通过基类接口编写通用的代码，这些代码能够与任何派生类对象协同工作，从而减少代码重复。</li><li><strong>代码的可扩展性</strong>：新增派生类时，不需要修改现有的基类代码或其他派生类代码，只需覆盖基类的虚函数即可。</li><li><strong>接口的一致性</strong>：派生类可以有不同的实现，但是共享相同的基类接口，使得接口一致、清晰。</li></ul><p>在讲解虚函数的时候，我们提到了覆盖，然而在C++中也存在另外一个相似的概念叫隐藏，这两者也是比较容易混淆的，接下来我们来看下覆盖和隐藏是什么？以及它们之间的区别？</p><h3 id="覆盖和隐藏"><a href="#覆盖和隐藏" class="headerlink" title="覆盖和隐藏"></a>覆盖和隐藏</h3><p>在C++中，函数覆盖和函数隐藏是面向对象编程中的两个基本概念，它们都涉及到派生类（子类）与基类（父类）之间方法的关系。</p><h4 id="函数覆盖（Function-Overriding）"><a href="#函数覆盖（Function-Overriding）" class="headerlink" title="函数覆盖（Function Overriding）"></a>函数覆盖（Function Overriding）</h4><p>当派生类中的成员函数与基类中的一个虚函数具有相同的签名（即相同的函数名称、返回类型及参数列表）时，我们说派生类的函数覆盖了（overriding）基类的函数。函数覆盖是实现多态的关键机制之一。</p><ul><li>覆盖发生在派生类与基类之间的虚函数上。</li><li>覆盖的目的是在派生类中提供一个特定实现，替换掉基类中的默认实现。</li></ul><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    virtual <span class="type">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Display of Base&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> public Base &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">display</span><span class="params">()</span> override &#123; <span class="comment">// 覆盖基类的display函数</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Display of Derived&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Base* ptr = new Derived();</span><br><span class="line">    ptr-&gt;display(); <span class="comment">// 调用Derived类的display方法</span></span><br><span class="line">    delete ptr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，Derived 类的 display 函数覆盖了 Base 类的 display 函数。通过基类指针调用 display 时，实际上调用的是 Derived 类的实现。这其实就是所为的多态。</p><h4 id="函数隐藏（Function-Hiding）"><a href="#函数隐藏（Function-Hiding）" class="headerlink" title="函数隐藏（Function Hiding）"></a>函数隐藏（Function Hiding）</h4><p>当派生类中的函数与基类中的某个函数具有相同的名称，但是签名不同，则我们说派生类中的函数隐藏了（hiding）基类中的同名函数。</p><ul><li>隐藏与覆盖不同，它发生在所有同名函数上，无论它们是否为虚函数。</li><li>隐藏的发生仅仅因为函数的名称相同。</li></ul><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Display of Base&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> public Base &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">display</span><span class="params">(<span class="type">int</span>)</span> &#123; <span class="comment">// 隐藏了基类的display函数</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Display of Derived with parameter&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Derived obj;</span><br><span class="line">    obj.display(<span class="number">5</span>); <span class="comment">// 调用Derived类的display方法</span></span><br><span class="line">    <span class="comment">// obj.display(); // 错误：Base类的display方法被隐藏</span></span><br><span class="line">    obj.Base::display(); <span class="comment">// 明确调用Base类的display方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，Derived 类的 display 函数隐藏了 Base 类的 display 函数，因为它们的签名不同。尝试直接调用没有参数的 display() 会导致编译错误，除非我们明确指定要调用 Base 类的版本。</p><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>C++提供了四种类型转换运算符，用于在不同类型之间进行显式转换。这些转换方式比C语言中的传统转换提供了更好的类型安全性和可读性。</p><h4 id="1-静态类型转换（static-cast）"><a href="#1-静态类型转换（static-cast）" class="headerlink" title="1. 静态类型转换（static_cast）"></a>1. 静态类型转换（static_cast）</h4><p>static_cast是用于类型之间转换的最常见形式，它在编译时检查转换的合法性。如果转换不合法，编译时会报错。它主要用于以下场景：</p><ul><li><strong>基本数据类型的转换</strong>：如整型与浮点型之间的转换。</li><li><strong>类层次结构中的向上转换</strong>（从派生类到基类）：这是安全的。</li><li><strong>类层次结构中的向下转换</strong>（从基类到派生类）：可能不安全，因为基类指针可能并不真正指向一个派生类对象。</li><li><strong>void指针的转换</strong>：将void<em>转换为具体类型的指针，或将具体类型的指针转换为void</em>。</li></ul><p>基本数据类型的转换示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> d = <span class="number">10.5</span>;</span><br><span class="line"><span class="type">int</span> i = static_cast&lt;<span class="type">int</span>&gt;(d); <span class="comment">// double转int</span></span><br></pre></td></tr></table></figure><p>类层次结构中的向上转换、向下转换代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">baseMethod</span><span class="params">()</span> &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base method\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> public Base &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">derivedMethod</span><span class="params">()</span> &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Derived method\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向上转换</span></span><br><span class="line">Derived derivedObj;</span><br><span class="line">Base* basePtr = static_cast&lt;Base*&gt;(&amp;derivedObj); <span class="comment">// 安全的向上转换</span></span><br><span class="line">basePtr-&gt;baseMethod(); <span class="comment">// 正常：可以访问基类方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 向下转换</span></span><br><span class="line">Base baseObj;</span><br><span class="line">Derived* derivedPtr = static_cast&lt;Derived*&gt;(&amp;baseObj); <span class="comment">// 不安全的向下转换</span></span><br><span class="line"><span class="comment">// derivedPtr-&gt;derivedMethod(); // 不安全：baseObj不是Derived的实例</span></span><br></pre></td></tr></table></figure><h4 id="2-常量类型转换（const-cast）"><a href="#2-常量类型转换（const-cast）" class="headerlink" title="2. 常量类型转换（const_cast）"></a>2. 常量类型转换（const_cast）</h4><p><code>const_cast</code>主要用于修改类型的<code>const</code>属性，包括：去除<code>const</code>属性：允许修改原本被声明为<code>const</code>的变量。</p><p>代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp; b = const_cast&lt;<span class="type">int</span>&amp;&gt;(a); <span class="comment">// 去除const属性</span></span><br><span class="line">b = <span class="number">20</span>; <span class="comment">// 修改成功，但修改const变量是未定义行为</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; b&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">// 20</span></span><br></pre></td></tr></table></figure><h4 id="3-动态类型转换（dynamic-cast）"><a href="#3-动态类型转换（dynamic-cast）" class="headerlink" title="3. 动态类型转换（dynamic_cast）"></a>3. 动态类型转换（dynamic_cast）</h4><p><code>dynamic_cast</code>是C++中用于在类的继承体系内进行类型转换的操作符，特别适用于执行安全的向下转换。<strong>向下转换是指将基类的指针（或引用）转换为派生类的指针（或引用）</strong>。这种转换在运行时检查对象的实际类型，以确保转换的合法性和安全性.</p><p>dynamic_cast向下转换代码示例：</p><p>假设有一个基类 Base 和一个从 Base 派生的类 Derived：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    virtual <span class="type">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base class&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    virtual ~Base() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> public Base &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">print</span><span class="params">()</span> override &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Derived class&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">specificFunction</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Derived class specific function&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在，如果我们想安全地将基类 Base 的指针转换为派生类 Derived 的指针，并调用派生类的特定函数，我们可以使用dynamic_cast：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Base* basePtr = new Derived();</span><br><span class="line">    basePtr-&gt;print();  <span class="comment">// 输出: Derived class</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 安全的向下转换</span></span><br><span class="line">    Derived* derivedPtr = dynamic_cast&lt;Derived*&gt;(basePtr);</span><br><span class="line">    <span class="keyword">if</span> (derivedPtr != nullptr) &#123;</span><br><span class="line">        derivedPtr-&gt;specificFunction();  <span class="comment">// 输出: Derived class specific function</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Conversion failed.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    delete basePtr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，basePtr 实际上指向一个 Derived 类的对象，因此使用 dynamic_cast 将 basePtr 转换为 Derived* 类型是安全的，并且转换成功。这允许我们安全地调用 Derived 类的 specificFunction 方法。</p><p><code>dynamic_cast</code>类型转换如何使用讲完了，接下来我们来看下 dynamic_cast类型转换的具体过程是怎样的？</p><h5 id="dynamic-cast的工作原理"><a href="#dynamic-cast的工作原理" class="headerlink" title="dynamic_cast的工作原理"></a>dynamic_cast的工作原理</h5><p><code>dynamic_cast</code>利用 C++ 的<code>运行时类型信息（RTTI）</code>机制来检查转换的安全性。它在运行时检查对象的实际类型，以确保所执行的转换是合法的。这种检查使得dynamic_cast比其他类型转换操作符（如static_cast或reinterpret_cast）更安全，但也带来了一定的性能开销。</p><p><strong>RTTI 是什么？</strong></p><p>C++的RTTI（Runtime Type Information，运行时类型信息）是一种机制，它允许C++程序在运行时查询和操作对象的类型信息。这种能力使得dynamic_cast能够在执行类型转换前，检查转换是否安全，从而确保类型转换的正确性和安全性。</p><p>dynamic_cast类型转换的具体过程？</p><p><strong>1. 确定对象的实际类型</strong></p><p><strong>访问虚函数表（vtable）</strong>：在C++中，每个具有虚函数的类的对象都会有一个隐藏的指针（称为虚表指针vptr），指向一个静态的虚函数表（vtable）。vtable主要用于支持多态性，即在运行时决定调用哪个虚函数。</p><p><strong>类型信息（RTTI）在vtable中</strong>：除了虚函数的地址外，vtable还包含了指向特定的类型信息的指针，这里说的类型信息就是RTTI。RTTI的核心是type_info类的对象，它为每个类提供了唯一的类型标识。</p><p><strong>2. 利用RTTI确定实际类型</strong>：</p><ul><li>当使用dynamic_cast进行类型转换时，C++运行时会查找原对象的vtable，通过其中的RTTI信息（即指向type_info对象的指针）来获取对象的实际类型。</li><li>一旦获得了对象的实际类型信息，dynamic_cast接着检查这个类型与目标类型的关系。对于向下转换（基类指针转换为派生类指针），它验证目标派生类是否确实是源对象实际类型的派生类或相同类型。</li></ul><p>在多态的使用场景中，上面提到的原对象指的是一个指向基类的指针或引用指向的对象。<br>目标派生类指的是我们希望将原对象的基类指针或引用转换到的目标类。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Base* basePtr = new Derived();</span><br><span class="line">Derived* derivedPtr = dynamic_cast&lt;Derived*&gt;(basePtr);</span><br></pre></td></tr></table></figure><p>对于上面的代码示例：原对象指的就是 basePtr 基类指针指向的 Derived 对象。目标派生类指的是 Derived 类。</p><p><strong>3.验证转换的合法性并执行转换或失败处理</strong></p><ul><li>如果转换合法，dynamic_cast修改源指针或引用，使其指向正确的目标类型的对象。</li><li>如果转换不合法：对于指针类型，dynamic_cast返回nullptr，表示转换失败。<br>对于引用类型，dynamic_cast 抛出 std::bad_cast 异常，因为引用不能为 nullptr。</li></ul><h4 id="4-重新解释类型转换-reinterpret-cast"><a href="#4-重新解释类型转换-reinterpret-cast" class="headerlink" title="4.重新解释类型转换 reinterpret_cast"></a>4.重新解释类型转换 reinterpret_cast</h4><p>reinterpret_cast是C++中一种强大但需谨慎使用的类型转换操作符。它允许开发者在几乎任何指针类型之间进行转换，也支持指针与足够大的整数类型之间的转换。其基本作用是重新解释数据的位模式，但不改变数据本身。</p><p>由于 reinterpret_cast 不进行类型检查和转换安全性保证，使用时需要特别注意，以防止未定义行为的发生。</p><h5 id="指针类型转换"><a href="#指针类型转换" class="headerlink" title="指针类型转换"></a>指针类型转换</h5><p>reinterpret_cast 可以用来将一个指针类型转换为另一个指针类型，即便这两个类型之间并无直接的关联。这种转换基本上是在告诉编译器：<strong>将内存地址当作另一种类型来解释，但不改变位模式本身</strong>。这种转换不会进行任何类型安全检查，因此非常危险且易于产生错误。因此在解引用转换后的指针之前，你需要确保转换是有意义的。</p><p>指针类型转换示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">char</span>* cp = &amp;c;</span><br><span class="line"><span class="comment">// 将char*转换为int*，虽然不安全，但可以编译通过</span></span><br><span class="line"><span class="type">int</span>* ip = reinterpret_cast&lt;<span class="type">int</span>*&gt;(cp);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;*ip&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 输出随机值</span></span><br></pre></td></tr></table></figure><h5 id="指针与整数类型之间的转换"><a href="#指针与整数类型之间的转换" class="headerlink" title="指针与整数类型之间的转换"></a>指针与整数类型之间的转换</h5><p>reinterpret_cast也可以用于将指针转换为整数类型，或者相反。这在需要在整数和指针之间进行转换，例如，当与需要整数参数的底层系统调用交互时非常有用。为了安全地执行这种转换，整数类型必须足够大以存储指针值，通常使用 uintptr_t 或 intptr_t。</p><p>示例代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdint&gt;</span>  <span class="comment">// 包含uintptr_t定义</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">42</span>;</span><br><span class="line">    <span class="comment">// 将int指针转换为整数</span></span><br><span class="line">    <span class="type">uintptr_t</span> ptrAsInt = reinterpret_cast&lt;<span class="type">uintptr_t</span>&gt;(&amp;a);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The pointer as integer: &quot;</span> &lt;&lt; ptrAsInt &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将整数转换回int指针</span></span><br><span class="line">    <span class="type">int</span>* aPtrAgain = reinterpret_cast&lt;<span class="type">int</span>*&gt;(ptrAsInt);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The integer as pointer: &quot;</span> &lt;&lt; *aPtrAgain &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>指针与整数类型之间的转换的使用场景</strong>：</p><ul><li><p><strong>系统级调用或API</strong>:<br>一些底层的系统调用或API可能要求使用整数类型的“句柄”来代表资源或对象。在这些情况下，如果资源或对象由C++管理，并通过指针访问，我们可以临时将指针转换为整数类型的句柄，进行调用，然后再转换回指针进行操作。</p></li><li><p><strong>回调函数与用户数据</strong>:<br>在使用回调函数时，通常需要提供一个指向用户数据的指针。如果回调函数的接口仅允许传递整数类型的用户数据，我们可以将指针转换为整数进行传递，然后在回调函数中再转换回指针，以访问实际的用户数据。</p></li></ul><p>示例代码：使用回调函数</p><p>假设我们有一个C++库，该库提供了一个设置回调函数的API，但API要求回调函数的用户数据必须是uintptr_t类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdint&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyCallback</span><span class="params">(<span class="type">uintptr_t</span> userData)</span> &#123;</span><br><span class="line">    <span class="comment">// 在回调中将整数还原回指针</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span>* str = reinterpret_cast&lt;<span class="built_in">std</span>::<span class="built_in">string</span>*&gt;(userData);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *str &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">RegisterCallback</span><span class="params">(<span class="type">void</span>(*callback)(<span class="type">uintptr_t</span>), <span class="built_in">std</span>::<span class="built_in">string</span>* userData)</span> &#123;</span><br><span class="line">    <span class="comment">// 调用回调函数，将指针作为整数传递</span></span><br><span class="line">    callback(reinterpret_cast&lt;<span class="type">uintptr_t</span>&gt;(userData));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> myData = <span class="string">&quot;Hello, callback!&quot;</span>;</span><br><span class="line">    RegisterCallback(MyCallback, &amp;myData);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p>C++的模板是一种强大的编程特性，它允许程序员编写与类型无关的代码，也就是所谓的泛型编程。这使得我们可以编写一个通用的代码框架，它可以用于多种数据类型。使用模板可以大大提高代码的复用性和灵活性。</p><p>C++ 模板主要有两种形式：<strong>函数模板和类模板</strong></p><p>在讲解函数模板和类模板之前，我们先来了解下 <strong>模板参数</strong> ？</p><p>在 C++ 模板编程中，模板参数是定义模板时指定的一种占位符，它在模板实例化时被具体的类型或值所替代。模板参数使模板具有泛型，能够适应不同的数据类型或值。C++ 中的模板参数主要分为两类：<strong>类型参数和非类型参数</strong>。</p><h4 id="类型参数"><a href="#类型参数" class="headerlink" title="类型参数"></a>类型参数</h4><p>类型参数允许在模板定义时指定一些<strong>占位符</strong>类型，这些类型在模板实例化时被<strong>具体的类型</strong>所替代。这意味着你可以编写一个通用的模板，然后用不同的类型来实例化它，生成针对那些类型的特化版本。</p><p><strong>类型参数声明方式</strong>：使用关键字 typename 或 class 来声明。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">T <span class="title function_">max</span><span class="params">(T x, T y)</span> &#123;</span><br><span class="line">    <span class="comment">// 函数实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述示例中，<code>T</code>是一个类型参数，表示 max 函数的两个参数可以接受任何类型。</p><h4 id="非类型参数"><a href="#非类型参数" class="headerlink" title="非类型参数"></a>非类型参数</h4><p>非类型参数允许你将<strong>一个或多个常量值</strong>作为参数传递给模板。非类型参数必须是一个<strong>常量表达式</strong>，因为模板在编译时实例化。</p><p>下面来看类模板如何使用非类型参数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">template &lt;  T, <span class="type">size_t</span> N&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FixedArray</span> &#123;</span></span><br><span class="line">    T data[N]; <span class="comment">// N 是一个非类型参数</span></span><br><span class="line">public:</span><br><span class="line">    T&amp; operator[](<span class="type">size_t</span> index) &#123; <span class="keyword">return</span> data[index]; &#125;</span><br><span class="line">    <span class="type">const</span> T&amp; operator[](<span class="type">size_t</span> index) <span class="type">const</span> &#123; <span class="keyword">return</span> data[index]; &#125;</span><br><span class="line">    constexpr <span class="type">size_t</span> <span class="title function_">size</span><span class="params">()</span> <span class="type">const</span> &#123; <span class="keyword">return</span> N; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这个示例中，N是一个非类型参数，它指定了FixedArray的大小。</p><p>非类型参数大多数使用在类模板中，虽然非类型参数在函数模板中的使用不如在类模板中那么频繁，但在某些情况下，它们仍然非常有用，特别是当你需要根据编译时常量来调整函数行为时。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T, <span class="type">int</span> increment&gt;</span><br><span class="line">T <span class="title function_">addIncrement</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value + increment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>addIncrement</code> 函数模板通过非类型参数 <code>increment</code> 允许在编译时确定增加的量，这可以在不同的调用中提供不同的增量值。</p><h4 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h4><p>函数模板允许我们创建一个函数原型，它可以用不同的数据类型来实例化。这意味着我们可以用一个函数模板来创建一系列执行相似操作的函数，而无需为每种数据类型编写重复的代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">T <span class="title function_">max</span><span class="params">(T x, T y)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; y ? x : y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>调用函数模板</strong></p><p><strong>1. 自动类型推导:</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Max of &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; max(a, b) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line"></span><br><span class="line"><span class="type">double</span> c = <span class="number">3.5</span>, d = <span class="number">2.5</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Max of &quot;</span> &lt;&lt; c &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; d &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; max(c, d) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者这样调用：</span></span><br><span class="line">max(<span class="number">3</span>, <span class="number">5</span>)；</span><br></pre></td></tr></table></figure><p><strong>2. 显式指定模板参数类型</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Max of 2 and 3 is &quot;</span> &lt;&lt; max&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">3</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Max of 2.5 and 3.5 is &quot;</span> &lt;&lt; max&lt;<span class="type">double</span>&gt;(<span class="number">2.5</span>, <span class="number">3.5</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>上面整型的调用，函数模板实际上会被实例化为一个接受两个 int 类型参数的函数版本：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; y ? x : y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而对于double类型的调用，函数模板会被实例化为一个接受两个 double 类型参数的函数版本。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">max</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; y ? x : y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h4><p>类模板与函数模板类似，允许我们定义一个类蓝图，用于生成处理不同数据类型的类。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    Box(T value) : value(value) &#123;&#125;</span><br><span class="line">    T <span class="title function_">getValue</span><span class="params">()</span> <span class="type">const</span> &#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">private:</span><br><span class="line">    T value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建类模板实例</span></span><br><span class="line">Box&lt;<span class="type">int</span>&gt; <span class="title function_">intBox</span><span class="params">(<span class="number">123</span>)</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Value in intBox: &quot;</span> &lt;&lt; intBox.getValue() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">Box&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title function_">stringBox</span><span class="params">(<span class="string">&quot;Hello Templates&quot;</span>)</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Value in stringBox: &quot;</span> &lt;&lt; stringBox.getValue() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>通过以上例子，我们了解了模板的基本使用，以及它是如何提高代码的复用性的。</p><p>上面的<code>max</code>函数模板的通用性确保了它可以用于整数、浮点数，甚至是字符串等多种类型，展现了模板编程的灵活性。然而，这种通用性有时候也是一把双刃剑。以指针类型为例，如果我们使用上述<code>max</code>函数比较两个指针，它实际上会比较指针的地址，而不是指针所指向的值，这可能并不是我们期望的行为。</p><p>在这种情况下，C++提供了一种强大的机制来优化和定制模板行为——<strong>模板特化</strong>。模板特化允许我们为特定的类型或值集合提供专门的实现，以此来处理那些需要特殊考虑的特定情况。模板特化分为两大类：<strong>全特化（Explicit Specialization）和偏特化（Partial Specialization）</strong>。</p><h4 id="全特化"><a href="#全特化" class="headerlink" title="全特化"></a>全特化</h4><p>全特化（Explicit Specialization）是为一个已有的模板定义提供一个特定版本的过程，这个特定版本适用于特定的类型或值。全特化意味着为模板的所有参数指定具体的类型或值。全特化不再是模板，而是对模板的一个特定实例提供了一个完全定制的实现。</p><h5 id="类模板全特化："><a href="#类模板全特化：" class="headerlink" title="类模板全特化："></a>类模板全特化：</h5><p>当你想为一个特定类型提供一个完全不同的类模板实现时，可以使用全特化。</p><p><strong>语法</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt;&gt; <span class="comment">// 空尖括号代表全特化的声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span>&lt;</span>Type&gt; &#123;</span><br><span class="line">    <span class="comment">// 特化的实现</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span> <span class="comment">// 通用模板</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">function</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Generic MyClass\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>&lt;</span><span class="type">int</span>&gt; &#123; <span class="comment">// 全特化为int类型</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">function</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Specialized MyClass for int\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="函数模板全特化："><a href="#函数模板全特化：" class="headerlink" title="函数模板全特化："></a>函数模板全特化：</h5><p>与类模板相似，你也可以为特定类型提供特定的函数模板实现。</p><p><strong>语法</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt;&gt;</span><br><span class="line">ReturnType functionName&lt;SpecificType&gt;(parameters) &#123;</span><br><span class="line">    <span class="comment">// 特化的实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举一个函数模板全特化的例子，比如对于前面的<code>max</code>函数，我们想要对指针类型进行特化，使其比较指针所指向的值而不是指针地址：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">T <span class="title function_">max</span><span class="params">(T x, T y)</span> &#123; <span class="comment">// 通用模板</span></span><br><span class="line">    <span class="keyword">return</span> x &gt; y ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;&gt;   <span class="comment">//使用全特化</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* max&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(<span class="type">const</span> <span class="type">char</span>* a, <span class="type">const</span> <span class="type">char</span>* b) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(a, b) &gt; <span class="number">0</span> ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这个例子，展示如何为特定类型（在这里是const char*类型的字符串）提供特化实现。</p><h4 id="偏特化"><a href="#偏特化" class="headerlink" title="偏特化"></a>偏特化</h4><p>偏特化允许你为模板的<strong>一部分参数</strong>提供具体的类型或值，而其余参数仍然保持泛型。<strong>偏特化仅适用于类模板，不能用于函数模板</strong>。通过偏特化，你可以对模板的部分参数施加约束，从而为特定的类型组合提供特定的实现。</p><p><strong>语法示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T, typename U&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span>&#125;; <span class="comment">// 通用模板</span></span><br><span class="line"></span><br><span class="line">template &lt;typename U&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>&lt;</span><span class="type">int</span>, U&gt; &#123;&#125;; <span class="comment">// 对第一个参数为int的偏特化</span></span><br></pre></td></tr></table></figure><p>代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">template&lt;typename T, typename U&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span> <span class="comment">// 原始模板</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">function</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Generic MyClass&lt;T, U&gt;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename U&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>&lt;</span><span class="type">int</span>, U&gt; &#123; <span class="comment">// 偏特化其中一个参数为int</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">function</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Partially Specialized MyClass&lt;int, U&gt;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    MyClass&lt;<span class="type">double</span>, <span class="type">double</span>&gt; myClass1; <span class="comment">// 将使用原始模板</span></span><br><span class="line">    myClass1.function();</span><br><span class="line">    MyClass&lt;<span class="type">int</span>, <span class="type">double</span>&gt; myClass2; <span class="comment">// 将使用偏特化模板</span></span><br><span class="line">    myClass2.function();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p>在C++中，内存管理是一个非常重要的概念，它关系到程序的性能和稳定性。C++提供了多种内存管理方式，包括<strong>自动、静态、动态分配</strong>等。让我们一步一步来了解。</p><p>为了更好地理解这些内存管理方式及其应用场景，我们首先需要了解C&#x2F;C++程序在运行时的内存布局。这里我介绍 Linux C&#x2F;C++ 程序的内存布局，因为大多数 C&#x2F;C++ 程序都是运行在 Linux 操作系统上，因此有必要了解下。</p><h4 id="Linux-C-C-程序的内存布局图示"><a href="#Linux-C-C-程序的内存布局图示" class="headerlink" title="Linux C&#x2F;C++ 程序的内存布局图示"></a>Linux C&#x2F;C++ 程序的内存布局图示</h4><p><img src="https://files.mdnice.com/user/48364/48290d63-a0e4-4242-9393-edb280609e52.png"></p><p>上图中，从下往上，地址是增加的，<code>0-3G</code>属于用户空间，<code>3G-4G</code> 属于内核空间.</p><p>接下来，我们对上面图示的各个区（段）作个详细的说明： </p><h4 id="内核空间（Kernel-Space）"><a href="#内核空间（Kernel-Space）" class="headerlink" title="内核空间（Kernel Space）"></a>内核空间（Kernel Space）</h4><p>Kernel space（内核空间）指的是操作系统内核所占用的内存区域。这部分内存是保留给操作系统内核的，用于执行核心的系统任务和硬件操作。出于安全和稳定性的考虑，用户程序通常无法直接访问这部分内存。在多数操作系统中，内核空间位于内存地址的高区域。在32位Linux系统上，通常最高的1GB内存（如地址从0xC0000000到0xFFFFFFFF）被保留给内核空间，而剩下的下3GB内存用于用户空间。</p><h4 id="用户空间（User-Space）"><a href="#用户空间（User-Space）" class="headerlink" title="用户空间（User Space）"></a>用户空间（User Space）</h4><ul><li><p><strong>栈（Stack）</strong></p><p>栈用于存放函数的局部变量、函数参数和返回地址。栈有着LIFO（后进先出）的特性，每当进入一个新的函数调用时，就会在栈上为其分配空间，函数返回时则释放这些空间。栈的大小通常有限，并且由操作系统预先定义。</p></li><li><p><strong>内存映射段(Memory Mapping Segment)</strong></p><p>内存映射段是一块可以被用来映射文件内容到进程地址空间的内存区域。这不仅包括用于动态库（如libc.so等）的映射，还包括程序运行时可能使用的任何匿名映射或文件映射。</p></li><li><p><strong>堆（Heap）</strong></p><p>堆用于动态内存分配，由new和delete（或malloc和free）控制。不同于栈，堆上的内存分配和释放是不自动的，需要程序员手动管理。堆的大小相对更灵活，受限于系统的可用内存。</p></li><li><p><strong>BSS段（Block Started by Symbol）</strong></p><p>BSS段，全称为“Block Started by Symbol”，主要用于存储程序中未初始化的全局变量和静态变量。与数据段（存放已初始化的全局变量和静态变量）相对，BSS段的特点是在程序启动之前，操作系统会自动将其内容初始化为零。这意味着，如果你在程序中声明了一个未初始化的全局或静态变量，它会被放在BSS段。</p></li><li><p><strong>数据区</strong></p><p>这部分内存用于存放全局变量和静态变量。不同于栈和堆上的变量，全局&#x2F;静态变量的生命周期贯穿整个程序运行期间，从程序开始执行时分配，到程序结束时才被释放。</p></li><li><p><strong>代码区</strong></p><p>存放程序的二进制代码，即编译后的机器指令。这部分内存是只读的。</p></li></ul><p>接下来，我们详细来聊下C++的多种内存管理方式，包括<strong>自动、静态、动态分配</strong>。</p><h4 id="常见的内存管理方式"><a href="#常见的内存管理方式" class="headerlink" title="常见的内存管理方式"></a>常见的内存管理方式</h4><h5 id="自动存储（Stack-Allocation）"><a href="#自动存储（Stack-Allocation）" class="headerlink" title="自动存储（Stack Allocation）"></a>自动存储（Stack Allocation）</h5><p>最简单的内存管理方式是自动存储，也就是在函数内部声明的局部变量。这些变量在函数被调用时自动分配内存（在栈上分配），并在函数返回时自动释放。</p><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">function</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> localVar = <span class="number">5</span>; <span class="comment">// 自动存储，函数结束时自动销毁</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="静态存储（Static-Allocation）"><a href="#静态存储（Static-Allocation）" class="headerlink" title="静态存储（Static Allocation）"></a>静态存储（Static Allocation）</h5><p>静态存储用于全局变量和静态变量，其生命周期贯穿整个程序运行期间。静态变量只被初始化一次，在首次加载时分配内存。</p><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">function</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> staticVar = <span class="number">5</span>; <span class="comment">// 静态存储，整个程序运行期间持续存在</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="动态存储（Dynamic-Allocation）"><a href="#动态存储（Dynamic-Allocation）" class="headerlink" title="动态存储（Dynamic Allocation）"></a>动态存储（Dynamic Allocation）</h5><p>动态存储是C++内存管理的核心，允许在运行时分配任意大小的内存。它使用<code>new</code>和<code>delete</code>操作符来手动管理内存。</p><p><strong>使用new和delete</strong></p><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = new <span class="type">int</span>; <span class="comment">// 动态分配一个int</span></span><br><span class="line">*ptr = <span class="number">5</span>; <span class="comment">// 给分配的int赋值</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *ptr &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 使用分配的内存</span></span><br><span class="line">delete ptr; <span class="comment">// 释放内存</span></span><br></pre></td></tr></table></figure><p><strong>使用new[]和delete[]管理数组</strong></p><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="built_in">array</span> = new <span class="type">int</span>[<span class="number">5</span>]; <span class="comment">// 动态分配一个有5个整数的数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">    <span class="built_in">array</span>[i] = i * i;</span><br><span class="line">&#125;</span><br><span class="line">delete[] <span class="built_in">array</span>; <span class="comment">// 释放数组</span></span><br></pre></td></tr></table></figure><p>现在大家已经了解了C++中的内存管理基础，接下来，我们将探讨如何更安全、更有效地管理资源。C++提供了一个强大的编程范式，称为RAII（资源获取即初始化）。</p><h4 id="RAII"><a href="#RAII" class="headerlink" title="RAII"></a>RAII</h4><p>“Resource Acquisition Is Initialization” (RAII) 是一种在C++中管理资源（如内存、文件句柄等）的编程模式。在RAII模式下，<strong>资源的分配（获取）发生在构造函数中，资源的释放（归还）发生在析构函数中</strong>。这种方式利用了C++自动调用析构函数的特性，确保了资源总是被正确释放，即使在面对异常情况时也不例外。</p><h4 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h4><p>通过<code>RAII</code>的介绍，我们已经认识到构造函数和析构函数在资源管理中的重要性。然而，在现实的编程实践中，尤其是面对复杂的资源管理需求时，单靠构造函数和析构函数可能不足以保证资源的安全和高效管理。这时，智能指针的概念应运而生。</p><p><code>智能指针</code>，实质上是一种行为类似于指针的对象，但它们包裹了原始指针，自动管理指向的资源。智能指针的核心理念正是基于<code>RAII模式</code>——通过对象的生命周期来管理资源。当智能指针的实例被创建时，它获取一个资源（比如动态分配的内存）；当智能指针实例销毁时，它释放那个资源。</p><p>C++11 标准库中提供了几种智能指针，如std::unique_ptr、std::shared_ptr和std::weak_ptr，但是我这里不讲解C++11 标准库的智能指针，而是重点讲解<code>boost</code>库里的智能指针。这两者的实现原理类似。后续会出一篇专门讲解 <code>C++11</code>新特性的文章。</p><p>在C++11之前，C++社区已经有一套成熟的解决方案来处理资源管理问题，那就是boost库提供的智能指针。</p><p>boost库是C++标准的实验田，很多在boost中实现的功能后来都被纳入了C++标准库。例如，C++11标准中的智能指针（std::shared_ptr和std::unique_ptr）、基于范围的for循环、无序容器等，都是从Boost库中借鉴或直接采用的。因此，可以说Boost对C++标准的发展有着重要的贡献。</p><h5 id="boost库智能指针有哪些？"><a href="#boost库智能指针有哪些？" class="headerlink" title="boost库智能指针有哪些？"></a>boost库智能指针有哪些？</h5><p><strong>1. boost::scoped_ptr</strong></p><p><code>boost::scoped_ptr</code>是一种简单的智能指针，用于管理在作用域内分配的对象。它不能传递所有权，即不能从一个<code>scoped_ptr</code>拷贝或赋值给另一个<code>scoped_ptr</code>。当<code>scoped_ptr</code>离开作用域时，它所管理的对象会被自动销毁。</p><p>使用示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/scoped_ptr.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    MyClass() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;MyClass constructed\n&quot;</span>; &#125;</span><br><span class="line">    ~MyClass() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;MyClass destroyed\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    boost::scoped_ptr&lt;MyClass&gt; <span class="title function_">ptr</span><span class="params">(new MyClass)</span>;</span><br><span class="line">    <span class="comment">// ptr在这里可用</span></span><br><span class="line">&#125; <span class="comment">// ptr离开作用域，自动销毁MyClass实例</span></span><br></pre></td></tr></table></figure><p><strong>2. boost::shared_ptr</strong></p><p><code>boost::shared_ptr</code>是一种引用计数的智能指针，也称共享型智能指针，允许多个<code>shared_ptr</code>实例共享同一个对象的所有权。当最后一个引用（shared_ptr实例）被销毁或重新指向另一个对象时，所管理的对象会被自动释放。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/shared_ptr.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    MyClass() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;MyClass constructed\n&quot;</span>; &#125;</span><br><span class="line">    ~MyClass() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;MyClass destroyed\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    boost::<span class="built_in">shared_ptr</span>&lt;MyClass&gt; <span class="title function_">ptr1</span><span class="params">(new MyClass)</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        boost::<span class="built_in">shared_ptr</span>&lt;MyClass&gt; ptr2 = ptr1; <span class="comment">// ptr1和ptr2共享对象</span></span><br><span class="line">    &#125; <span class="comment">// ptr2离开作用域，对象不会被销毁，因为ptr1仍然存在，引用计数不为0</span></span><br><span class="line">&#125; <span class="comment">// ptr1离开作用域，对象被销毁（引用计数为0）</span></span><br></pre></td></tr></table></figure><p>对于上面提到的<code>引用计数</code>，大家可以简单理解为一个<code>非负整型数值</code>.</p><p><strong>3. boost::weak_ptr</strong></p><p><code>boost::weak_ptr</code>专门设计用于与<code>boost::shared_ptr</code>协同工作，解决潜在的循环引用问题。循环引用发生在两个或多个对象通过<code>shared_ptr</code>相互引用时，导致它们的引用计数永远不会归零，进而导致内存泄漏。<code>weak_ptr</code>提供了一种机制，允许对这些对象进行观察，而不增加引用计数。</p><p><strong>weak_ptr的几个特性</strong>：</p><ul><li><strong>观察者</strong>：boost::weak_ptr是对boost::shared_ptr所管理对象的非拥有性引用（观察者）。它允许你访问对象，但不会延长对象的生命周期。</li><li><strong>临时升级</strong>：虽然weak_ptr本身不能直接访问对象，但它可以被临时升级为一个shared_ptr（如果对象仍然存在），以安全地访问对象。</li><li><strong>解决循环引用</strong>：在使用shared_ptr管理相互引用的对象时，容易产生循环引用，导致对象无法被释放。weak_ptr不参与引用计数，因此可以打破这种循环，避免内存泄漏。</li></ul><p><strong>weak_ptr基本用法</strong>：</p><p><strong>1. 创建weak_ptr</strong></p><p>weak_ptr通常通过与一个shared_ptr关联来创建：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">boost::<span class="built_in">shared_ptr</span>&lt;<span class="type">int</span>&gt; <span class="title function_">sp</span><span class="params">(new <span class="type">int</span>(<span class="number">42</span>))</span>; <span class="comment">// 创建shared_ptr</span></span><br><span class="line">boost::weak_ptr&lt;<span class="type">int</span>&gt; <span class="title function_">wp</span><span class="params">(sp)</span>;            <span class="comment">// 通过shared_ptr创建weak_ptr</span></span><br></pre></td></tr></table></figure><p><strong>2. 使用weak_ptr</strong></p><p>要访问 weak_ptr 所观察的对象，需要将它临时升级为shared_ptr，这可以通过调用weak_ptr的lock方法实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">boost::<span class="built_in">shared_ptr</span>&lt;<span class="type">int</span>&gt; sp = wp.lock(); <span class="comment">// 尝试将weak_ptr升级为shared_ptr</span></span><br><span class="line"><span class="keyword">if</span> (sp) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *sp &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 安全使用</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;对象已被销毁&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 解决循环引用示例</strong></p><p>考虑两个类ClassA和ClassB，它们通过shared_ptr相互持有对方：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/shared_ptr.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassB</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassA</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    boost::<span class="built_in">shared_ptr</span>&lt;ClassB&gt; bPtr;</span><br><span class="line">    ~ClassA() &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ClassA destroyed\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassB</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    boost::<span class="built_in">shared_ptr</span>&lt;ClassA&gt; aPtr;</span><br><span class="line">    ~ClassB() &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ClassB destroyed\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    boost::<span class="built_in">shared_ptr</span>&lt;ClassA&gt; <span class="title function_">a</span><span class="params">(new ClassA())</span>;</span><br><span class="line">    boost::<span class="built_in">shared_ptr</span>&lt;ClassB&gt; <span class="title function_">b</span><span class="params">(new ClassB())</span>;</span><br><span class="line"></span><br><span class="line">    a-&gt;bPtr = b; <span class="comment">// a持有b的shared_ptr</span></span><br><span class="line">    b-&gt;aPtr = a; <span class="comment">// b持有a的shared_ptr，形成循环引用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，main 函数中创建了两个shared_ptr对象a和b，分别指向 ClassA 和ClassB 的新实例。然后，我们通过 a-&gt;bPtr &#x3D; b;和b-&gt;aPtr &#x3D; a;让这两个实例相互持有对方，从而创建了循环引用。</p><p>由于存在循环引用，当 main 函数执行完毕，尽管a和b的作用域结束，它们应该被销毁，但 ClassA 和 ClassB 的实例的引用计数并没有降到零（因为它们相互引用），导致析构函数没有被调用，从而引发内存泄漏。</p><p>如何解决？使用<code>weak_ptr</code>可以解决这个问题：</p><p>可以将其中一个类的shared_ptr成员改为weak_ptr。这样做可以打破循环引用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassB</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassA</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="comment">// 使用weak_ptr代替shared_ptr</span></span><br><span class="line">    boost::weak_ptr&lt;ClassB&gt; bPtr;</span><br><span class="line">    ~ClassA() &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ClassA destroyed\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassB</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    boost::<span class="built_in">shared_ptr</span>&lt;ClassA&gt; aPtr;</span><br><span class="line">    ~ClassB() &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ClassB destroyed\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    boost::<span class="built_in">shared_ptr</span>&lt;ClassA&gt; <span class="title function_">a</span><span class="params">(new ClassA())</span>;</span><br><span class="line">    boost::<span class="built_in">shared_ptr</span>&lt;ClassB&gt; <span class="title function_">b</span><span class="params">(new ClassB())</span>;</span><br><span class="line"></span><br><span class="line">    a-&gt;bPtr = b; <span class="comment">// ClassA中持有ClassB的弱引用</span></span><br><span class="line">    b-&gt;aPtr = a; <span class="comment">// ClassB中持有ClassA的强引用，形成非对称的引用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当main结束时，a和b的shared_ptr都会被销毁。</span></span><br><span class="line">    <span class="comment">// b的shared_ptr被销毁时，由于ClassA中持有的是ClassB的weak_ptr，不会阻止ClassB对象的销毁。</span></span><br><span class="line">    <span class="comment">// 因此，ClassB被销毁后，ClassA中的weak_ptr变为悬挂指针，但ClassA对象也会随之被安全销毁。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里大家只需要掌握这几种智能指针的简单使用即可，后面笔者有计划写一篇关于智能指针实现原理的文章，从源码实现的角度来讲解。帮助大家更好的理解智能指针。</p><h4 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h4><p>在C++中，内存泄漏是指程序分配的内存没有被正确释放，导致程序不再能够使用那部分内存。内存泄漏在长时间运行的程序中尤为危险，因为它们会逐渐消耗掉所有可用的内存资源，可能导致程序崩溃或系统变得缓慢。</p><h5 id="内存泄露的原因："><a href="#内存泄露的原因：" class="headerlink" title="内存泄露的原因："></a>内存泄露的原因：</h5><p>在C++中，内存泄露通常由以下几个原因引起：</p><ul><li><strong>动态分配内存未释放</strong>：使用new或malloc等分配内存后，未使用delete或free释放。</li><li><strong>资源未释放</strong>：除了内存外，文件句柄、数据库连接等资源未被关闭或释放也会造成资源泄露。</li><li><strong>循环引用</strong>：使用智能指针（如std::shared_ptr）时，不当的循环引用会导致对象无法被自动销毁。</li><li><strong>异常安全性问题</strong>：<br>当函数或方法在执行过程中抛出异常，而这个函数或方法之前进行了资源分配（如动态内存分配），如果没有正确地处理异常（例如通过异常安全的智能指针或try&#x2F;catch块来确保资源被释放），那么原本应该在函数结束时释放的资源可能会因为异常的抛出而遗漏。</li></ul><h5 id="内存泄露的检测："><a href="#内存泄露的检测：" class="headerlink" title="内存泄露的检测："></a>内存泄露的检测：</h5><p>检测内存泄露通常可以通过以下几种方式：</p><p><strong>1. 代码审查</strong>：通过审查代码逻辑，检查每次new的内存分配是否都有对应的delete释放。</p><p><strong>2. 运行时工具</strong>：</p><ul><li><p>Valgrind：Linux下一个强大的内存检测工具，能够检测出内存泄露、内存越界等问题。Valgrind的优点在于它不需要对程序进行重新编译，适用于几乎所有的二进制文件，但缺点是运行速度较慢，通常会让程序的执行速度降低10倍以上。</p></li><li><p>AddressSanitizer：一个快速的内存错误检测工具，能够检测出包括内存越界访问、使用后释放、堆栈缓冲区溢出等问题。与Valgrind相比，ASan的主要优点是执行速度快（一般只会让程序变慢2倍左右）和提供精确的错误信息，但它需要对程序进行重新编译并链接，并且增加了程序的内存需求。</p></li></ul><h5 id="如何避免内存泄漏？"><a href="#如何避免内存泄漏？" class="headerlink" title="如何避免内存泄漏？"></a>如何避免内存泄漏？</h5><p><strong>1. 限制动态内存的使用</strong></p><p>尽量减少动态内存分配的使用。许多情况下，可以通过使用栈分配的变量或标准容器来代替动态分配的内存。这不仅可以减少内存泄漏的风险，还可以提高程序的性能。</p><p><strong>2. 使用智能指针</strong>：尽量避免在代码中直接使用裸指针管理动态分配的内存。裸指针很容易导致内存泄漏，因为它们不会自动释放所指向的内存。如果确实需要使用指针，考虑使用<code>智能指针</code>来代替。</p><p><strong>3. 使用容器类</strong>：C++标准库提供了多种容器，如std::vector、std::list等，这些容器在内部管理内存，可以减少直接使用动态内存分配的需要。</p><p><strong>4. 使用对象池</strong>：<br>对于频繁创建和销毁的小对象，使用对象池可以是一个有效的解决方案。对象池预先分配一定数量的对象，并在需要时重用它们，从而避免了频繁的动态内存分配和释放。</p><p><strong>5. 定期检查和测试</strong>：使用内存检测工具定期检查程序，及早发现并修复内存泄漏问题。</p><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>C++中的异常处理是通过<code>try</code>、<code>catch</code>、<code>throw</code>关键字实现的，旨在处理程序运行时可能出现的错误和异常情况。使用异常处理可以使错误处理代码和正常业务逻辑分离，使程序结构更清晰，更易于维护。</p><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul><li><strong>throw</strong>：当检测到错误条件时，程序可以通过throw关键字抛出一个异常。抛出的异常可以是预定义的数据类型，也可以是自定义类型。</li><li><strong>try</strong>：try块包含可能抛出异常的代码。如果在try块中的代码抛出了异常，执行将跳转到相应的catch块。</li><li><strong>catch</strong>：catch块用于捕获和处理异常。可以定义多个catch块来捕获不同类型的异常。</li></ul><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><p>下面是一个简单的示例，演示了如何使用C++的异常处理机制：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">divide</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">        throw <span class="string">&quot;Division by zero error&quot;</span>; <span class="comment">// 抛出异常</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; divide(<span class="number">10</span>, <span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 正常情况</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; divide(<span class="number">10</span>, <span class="number">0</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 这里将抛出异常</span></span><br><span class="line">    &#125; catch (<span class="type">const</span> <span class="type">char</span>* msg) &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Error: &quot;</span> &lt;&lt; msg &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 捕获并处理异常</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中，divide函数在除数为零时抛出一个异常，main函数中的 try 块捕获并处理了这个异常。</p><h4 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h4><p>除了使用预定义类型作为异常外，C++还允许定义自定义异常类。通过继承标准的<code>exception</code>类来创建自定义异常更为方便：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义异常类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyException</span> :</span> public exception &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* <span class="title function_">what</span><span class="params">()</span> <span class="type">const</span> <span class="title function_">throw</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Custom error occurred&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        throw MyException();</span><br><span class="line">    &#125; catch (MyException&amp; e) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;MyException caught&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; e.what() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; catch (exception&amp; e) &#123;</span><br><span class="line">        <span class="comment">// 其他所有的异常</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，我们定义了一个名为MyException的自定义异常类，并在main函数中抛出和捕获了这个异常。自定义异常类通过覆写 what 方法提供了异常的描述信息。</p><p>通过合理使用C++的异常处理机制，可以有效地管理程序中的错误情况，提高程序的健壮性和可读性。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章旨在提供一个关于C++语言学习的指南，以帮助初学者系统地掌握C++编程的关键技能和概念。通过深入浅出的方式，我们逐步解析了C++开发的各个方面，从基础的数据类型、函数使用，到高级的面向对象编程技术，如类和对象的操作、封装、继承、以及多态等。</p><ul><li><p><strong>数据类型和函数</strong>：我们探讨了C++的基本数据类型、枚举、复合以及派生数据类型，这为理解C++提供了坚实的基础。同时，函数的定义、声明、调用以及参数传递等知识点，构建了函数编程的框架。</p></li><li><p><strong>面向对象编程</strong>：详细讨论了类和对象的定义、成员变量和函数、构造函数和析构函数等概念，强调了封装、继承和多态这三大面向对象编程的核心特性。特别地，通过this指针、友元、运算符重载的讲解，进一步拓展了面向对象的编程思维。</p></li><li><p><strong>高级特性</strong>：深入到模板编程，介绍了类型参数、非类型参数、函数模板、类模板以及模板的特化，这些内容展现了C++泛型编程的强大能力。同时，对C++中的内存管理、异常处理进行了探讨，了解了怎样编写高效且安全的C++代码。</p></li></ul><p>这篇文章主要是给大家提供一个如何快速学习 C++ 的指南，不知道怎样学习 C++ 的朋友可以 <strong>按照我列的知识点去看书，去实践，掌握 C++ 语言应该会很快的。记住：一定要多敲代码，多实践！！</strong></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>如果单纯去学习C、C++语言是干不了任何事情的，作为与硬件和操作系统打交道的计算机底层语言，要想掌握 C和C++，你还得学习这几门课程：计算机组成原理、操作系统、数据结构。甚至还得了解汇编语言。除此之外，还需要学习 Linux 系统编程以及网络编程相关知识。</p><p>如果你想学习 Linux 编程，包括系统编程和网络编程相关的内容，可以关注我的公众号「<strong>跟着小康学编程</strong>」，微信搜索<strong>跟着小康学编程</strong>或者扫描下方二维码关注 。这里会定时更新 计算机编程 相关的技术文章，感兴趣的读者可以关注一下。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png">   </p><p>另外：C&#x2F;C++、Java、Go语言，计算机组成原理、操作系统、数据结构与算法、计算机网络以及Linux 系统编程和网络编程、数据库等经典书籍的电子档 pdf 我已经为大家整理好了，想要获取的同学可以关注我的公众号「<strong>跟着小康学编程</strong>」，然后后台回复：<strong>pdf</strong>，即可获取。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言学习 </category>
          
          <category> C++ 编程教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++入门 </tag>
            
            <tag> C++教程 </tag>
            
            <tag> C++快速学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入 C++11：从 auto 到 Lambda，解锁现代 C++ 的强大功能</title>
      <link href="/C++11/"/>
      <url>/C++11/</url>
      
        <content type="html"><![CDATA[<p>在介绍 C++11 之前，我们先回顾一下 C++98和C++03。C++98 作为 C++ 的第一个国际标准，奠定了这门语言的基础结构和核心特性，比如<strong>类、继承、模板、异常处理</strong>等。这些特性使得 C++ 成为一门强大的、面向对象的编程语言，广泛应用于系统&#x2F;应用软件、游戏开发、实时系统等领域。C++03 则是对 C++98 进行了修订，主要解决标准的疑义和错误，没有引入新特性。</p><p>然而，随着软件开发的不断进化，C++98和C++03 在表达能力、编程便利性和性能方面显示出了局限性。比如：<strong>对并发编程的支持不够强大，模板编程有时显得过于复杂，资源管理（尤其是内存管理）易于出错等</strong>。这些局限性促使了 C++11 标准的诞生，它被视为 C++ 的一次重大更新，于 2011 年正式发布。这次更新标志着 C++ 进入现代化的重要一步，引入了许多新特性和改进，旨在使 C++ 更易于使用，更灵活，同时提高了代码的安全性和性能。</p><p>另外，学习 C++11 新特性需要你有简单的 C、C++编程基础，还不了解的朋友可以看这两篇文章：<a href="https://mp.weixin.qq.com/s?__biz=MzkyNjQyMTMyOA==&mid=2247487373&idx=1&sn=6304025e2c0a846e97999e765667d866&chksm=c236d7b2f5415ea4b12b87fddf981abcd325d7458885aeade0957db5344da97f1b82d7e65cce&token=733890015&lang=zh_CN#rd">如何学习 C 语言</a>  和 <a href="https://mp.weixin.qq.com/s?__biz=MzkyNjQyMTMyOA==&mid=2247487758&idx=1&sn=1baa05f2c966eaa7623c8e48f152503d&chksm=c236c931f541402711b3130adeb3afc906af6ce954206cfe076e0c477e001d77fd041e802b3b&token=733890015&lang=zh_CN#rd">如何快速学习 C++</a>   ，文章通俗易懂而且有丰富的代码示例帮助理解。非常值得一看！！</p><p><strong>C++11 新增了很多新特性值得我们学习，包含如下</strong>：</p><p><img src="/images/C++11/1.png"></p><h2 id="核心语言增强"><a href="#核心语言增强" class="headerlink" title="核心语言增强"></a>核心语言增强</h2><h3 id="自动类型推断-auto"><a href="#自动类型推断-auto" class="headerlink" title="自动类型推断 (auto)"></a>自动类型推断 (auto)</h3><p>auto 关键字让编译器能够自动推断变量的类型（通过变量初始化时的表达式来确定类型），简化了变量声明的语法。</p><h4 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> variable_name = expression;</span><br></pre></td></tr></table></figure><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = <span class="number">5</span>; <span class="comment">// x 是 int</span></span><br><span class="line"><span class="keyword">auto</span> y = <span class="number">3.14</span>; <span class="comment">// y 是 double</span></span><br></pre></td></tr></table></figure><h3 id="获取表达式的类型（decltype）"><a href="#获取表达式的类型（decltype）" class="headerlink" title="获取表达式的类型（decltype）"></a>获取表达式的类型（decltype）</h3><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">decltype(expression) variableName;</span><br></pre></td></tr></table></figure><p>这里，expression 是你要查询类型的表达式，而 variableName 是使用该表达式类型声明的变量名称。</p><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码:"></a>示例代码:</h4><p><strong>基础示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line">decltype(x) y = x; <span class="comment">// y 的类型是int</span></span><br></pre></td></tr></table></figure><p>在这个例子中，decltype(x)将y的类型推导为x的类型，即<code>int</code>。</p><p><strong>结合 auto 使用</strong>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto x = 1; // x 的类型是int</span><br><span class="line">decltype(x) y = x; // y 的类型也是int</span><br></pre></td></tr></table></figure><p><strong>用于复杂表达式</strong></p><p><code>decltype</code>  特别有用于表达式的类型不明显时：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">decltype(vec.begin()) it = vec.begin(); <span class="comment">// it 的类型是 std::vector&lt;int&gt;::iterator</span></span><br></pre></td></tr></table></figure><h3 id="基于范围的-for-循环"><a href="#基于范围的-for-循环" class="headerlink" title="基于范围的 for 循环"></a>基于范围的 for 循环</h3><p>C++11引入了基于范围的for循环（Range-based for loop），这是一个用于遍历序列（如数组、容器等）的语法糖。它简化了迭代序列中每个元素的代码书写方式，使代码更加简洁易读。</p><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法:"></a>基本语法:</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (declaration : range) &#123;</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>declaration</strong>：用于迭代序列中每个元素的变量声明。这个变量的类型可以是序列元素的类型，也可以是(auto)自动类型推导。</li><li><strong>range</strong>：要迭代的序列，可以是数组、容器（如std::vector、std::list等）或任何支持begin()和end()方法的对象。</li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h4><p><strong>遍历数组</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> element : <span class="built_in">array</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; element &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出: 1 2 3 4 5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>遍历容器（如std::vector）</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> element : vec) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; element &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出: 10 20 30 40 50</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用 auto 自动类型推导</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; words = &#123;<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span>, <span class="string">&quot;!&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> word : words) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; word &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出: Hello World !</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong>:</p><p>如果你需要在循环中修改序列中的元素，请使用引用<code>&amp;</code>来声明变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span>&amp; num : vec) &#123;</span><br><span class="line">    num *= <span class="number">2</span>; <span class="comment">// 修改元素值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不需要修改元素，并且元素类型较大时，考虑使用常量引用<code>const &amp;</code>来避免不必要的拷贝，提高效率。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; word : words) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; word &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>基于范围的for循环</strong>是 C++11 中引入的一项便利特性，通过简化集合的遍历操作，它让代码更加简洁，增强了代码的可读性和易用性。</p><h3 id="统一初始化"><a href="#统一初始化" class="headerlink" title="统一初始化"></a>统一初始化</h3><p>C++11 引入了统一初始化（Uniform Initialization），这是一种使用花括号 <code>&#123;&#125; </code>进行变量初始化的语法。它提供了一种一致的语法来初始化任何对象。</p><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法:"></a>语法:</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Type variable&#123;value1, value2, ...&#125;;</span><br></pre></td></tr></table></figure><p><strong>基本类型的初始化</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a&#123;<span class="number">10</span>&#125;;</span><br><span class="line"><span class="type">double</span> b&#123;<span class="number">3.14</span>&#125;;</span><br></pre></td></tr></table></figure><p><strong>聚合类型（如结构体和数组）的初始化</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line">Point p&#123;<span class="number">10</span>, <span class="number">20</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure><p><strong>容器的初始化</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure><p><strong>类对象的初始化</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    MyClass(<span class="type">int</span> x, <span class="type">double</span> y) : x_(x), y_(y) &#123;&#125;</span><br><span class="line">private:</span><br><span class="line">    <span class="type">int</span> x_;</span><br><span class="line">    <span class="type">double</span> y_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyClass obj&#123;<span class="number">5</span>, <span class="number">3.14</span>&#125;;</span><br></pre></td></tr></table></figure><h3 id="初始器列表（Initializer-Lists）"><a href="#初始器列表（Initializer-Lists）" class="headerlink" title="初始器列表（Initializer Lists）"></a>初始器列表（Initializer Lists）</h3><p>初始器列表是C++11引入的一项特性，它进一步扩展了统一初始化的能力，特别是对于容器和自定义类对象的初始化。它允许构造函数接收一个由花括号<code>&#123;&#125;</code>包围的元素列表，从而提供了一种简洁且强大的初始化方式。</p><h4 id="包含必要头文件"><a href="#包含必要头文件" class="headerlink" title="包含必要头文件"></a>包含必要头文件</h4><p>要使用初始器列表，你需要包含<code>&lt;initializer_list&gt;</code>头文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;initializer_list&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h4><p>初始器列表主要通过在类构造函数中使用<code>std::initializer_list&lt;T&gt;</code>类型的参数来实现，其中<code>T</code>是列表中元素的类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    ClassName(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;T&gt; <span class="built_in">list</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码:"></a>示例代码:</h4><p><strong>自定义类的初始器列表</strong></p><p>假设有一个代表简单整数集合的类，我们希望能够在创建对象时直接用一组整数来初始化这个集合：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntSet</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; elements;</span><br><span class="line">public:</span><br><span class="line">    IntSet(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="type">int</span>&gt; <span class="built_in">list</span>) : elements(<span class="built_in">list</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Initialized with elements: &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> elem : elements) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    IntSet mySet = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出: Initialized with elements: 1 2 3 4 5 </span></span><br></pre></td></tr></table></figure><p><strong>函数参数为初始器列表</strong>:</p><p>函数也可以接受<code>std::initializer_list&lt;T&gt;</code>类型的参数，这在需要传递一组值时非常有用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="type">int</span>&gt; vals)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> val : vals) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    print(&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出: 10 20 30 40 50 </span></span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><code>初始器列表（Initializer Lists）</code>为C++11提供了一种强大的初始化机制，特别是在初始化需要一组值的对象时。通过使用初始器列表，可以极大地简化代码，提高可读性和可维护性。这一特性在自定义类、函数参数传递时尤为有用。</p><h3 id="nullptr-关键字"><a href="#nullptr-关键字" class="headerlink" title="nullptr 关键字"></a>nullptr 关键字</h3><p>在 C++11 中，<code>nullptr</code> 是一个特殊的字面量，用于表示空指针。它是对之前 C++ 版本中使用整数 0 或宏 NULL 来表示空指针的改进。<code>nullptr</code> 的引入提供了一种类型安全的方式来表示没有指向任何对象的指针。</p><h4 id="定义及使用："><a href="#定义及使用：" class="headerlink" title="定义及使用："></a>定义及使用：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = nullptr;</span><br><span class="line"><span class="keyword">if</span> (ptr == nullptr) &#123;</span><br><span class="line">    <span class="comment">// 检查 ptr 是否为空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="为什么需要-nullptr？"><a href="#为什么需要-nullptr？" class="headerlink" title="为什么需要 nullptr？"></a>为什么需要 nullptr？</h4><ul><li><strong>类型安全</strong>：在 C++11 之前，NULL 通常被定义为 0，这意味着它实际上是一个整数。这可能导致类型混淆和错误，特别是在函数重载的情况下。<code>nullptr</code> 明确地表示一个空指针，不会与整数混淆。</li><li><strong>更好的语义</strong>：<code>nullptr</code> 直观地表示指针为空，改善了代码的可读性和意图表达。</li></ul><h4 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h4><p><strong>使用 nullptr 初始化指针</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = nullptr; <span class="comment">// ptr 是一个指向 int 的空指针</span></span><br></pre></td></tr></table></figure><p><strong>函数重载中 nullptr 的优势</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;func(int) called&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span>*)</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;func(int*) called&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    func(<span class="number">0</span>);        <span class="comment">// 调用 func(int)</span></span><br><span class="line">    func(nullptr);  <span class="comment">// 明确调用 func(int*)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，使用 <code>nullptr</code> 可以明确地调用接受指针参数的重载函数版本，避免了潜在的歧义。</p><p>通过引入<code>nullptr</code>，C++11 提高了代码的类型安全性和清晰度，明确区分了整数 0 和空指针的概念。</p><h3 id="长长整形（Long-Long-Int）"><a href="#长长整形（Long-Long-Int）" class="headerlink" title="长长整形（Long Long Int）"></a>长长整形（Long Long Int）</h3><p>在 C++11 之前，整型的最大大小受限于long int，其大小至少为32位。为了支持更大的整数，C++11引入了<code>long long int</code>和<code>unsigned long long int</code>类型，保证至少64位的大小。</p><h4 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="type">int</span> bigNumber = <span class="number">9223372036854775807LL</span>; <span class="comment">// LL 表示这是一个 long long 类型的字面量</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> bigUnsignedNumber = <span class="number">18446744073709551615ULL</span>; <span class="comment">// ULL 表示这是一个 unsigned long long 类型的字面量</span></span><br></pre></td></tr></table></figure><h3 id="无符号字面量"><a href="#无符号字面量" class="headerlink" title="无符号字面量"></a>无符号字面量</h3><p>无符号字面量就是用来表示无符号整数的字面量。在C++中，可以通过在整数后面添加<code>U</code>或<code>u</code>来创建无符号整型字面量。</p><p><strong>注意</strong>：字面量（Literal）是指在源代码中直接表示其值的固定值的表示法。字面量可以是数字、字符、字符串或其他固定值。</p><h4 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> x = <span class="number">123U</span>; <span class="comment">// U 表示无符号整数</span></span><br></pre></td></tr></table></figure><h3 id="用户自定义字面量"><a href="#用户自定义字面量" class="headerlink" title="用户自定义字面量"></a>用户自定义字面量</h3><p>C++11引入了用户自定义字面量（User-Defined Literals, UDL），允许开发者定义自己的字面量操作符，为字面量赋予新的含义。这通过定义一个以<code>_</code>开头的字面量操作符函数实现。</p><h4 id="语法：-1"><a href="#语法：-1" class="headerlink" title="语法："></a>语法：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return_type operator <span class="string">&quot;&quot;</span> _customSuffix(<span class="type">const</span> <span class="type">char</span>*);</span><br></pre></td></tr></table></figure><h4 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h4><p>定义一个将字符串转换为复数的自定义字面量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;complex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义自定义字面量 _i，用于创建复数</span></span><br><span class="line"><span class="built_in">std</span>::<span class="type">complex</span>&lt;<span class="type">double</span>&gt; operator<span class="string">&quot;&quot;</span> _i(<span class="type">long</span> <span class="type">double</span> d) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::<span class="type">complex</span>&lt;<span class="type">double</span>&gt;(<span class="number">0</span>, d); <span class="comment">// 第一个参数表示所构造复数的实部，第二个参数代表虚部。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">auto</span> c = <span class="number">3.14</span>_i; <span class="comment">// 使用自定义字面量创建一个复数，将会调用operator&quot;&quot; _i 函数</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Real part: &quot;</span> &lt;&lt; c.real() &lt;&lt; <span class="string">&quot;, Imaginary part: &quot;</span> &lt;&lt; c.imag() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>_i</code>是自定义的字面量操作符，它将跟随它的数字转换为一个复数。这使得代码更加直观和易于理解。</p><h3 id="强类型枚举-enum-class"><a href="#强类型枚举-enum-class" class="headerlink" title="强类型枚举 (enum class)"></a>强类型枚举 (enum class)</h3><p>C++11 引入了强类型枚举，也称为作用域枚举（scoped enums），使用 <code>enum class </code>关键字定义。与传统的枚举（unscoped enums）相比，强类型枚举具有更好的类型安全性，不会隐式地转换为整型，枚举值必须在作用域内访问，并且可以指定底层类型。</p><h4 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">EnumName</span> :</span> UnderlyingType &#123;</span><br><span class="line">    enumerator1,</span><br><span class="line">    enumerator2,</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>EnumName</strong> 是枚举类型的名称。</li><li><strong>UnderlyingType</strong> 是用来表示枚举值的底层类型，通常是某种整型（如int、unsigned int、short等）。如果没有该字段，则底层类型默认为 int</li></ul><h4 id="强类型枚举定义"><a href="#强类型枚举定义" class="headerlink" title="强类型枚举定义"></a>强类型枚举定义</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">Color</span> :</span> <span class="type">unsigned</span> <span class="type">int</span> &#123;</span><br><span class="line">    Red,</span><br><span class="line">    Green,</span><br><span class="line">    Blue</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">StatusCode</span> :</span> <span class="type">char</span> &#123;</span><br><span class="line">    Ok = <span class="string">&#x27;O&#x27;</span>,</span><br><span class="line">    Error = <span class="string">&#x27;E&#x27;</span>,</span><br><span class="line">    Unknown = <span class="string">&#x27;U&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="简单例子"><a href="#简单例子" class="headerlink" title="简单例子"></a>简单例子</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 传统枚举</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span> &#123;</span> Red, Green, Blue &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 强类型枚举  底层类型为 int</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">StrongColor</span> &#123;</span> Red, Green, Blue &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Color c = Red; <span class="comment">// 直接访问</span></span><br><span class="line">    <span class="comment">// StrongColor sc = Red; // 错误：Red 不在作用域内</span></span><br><span class="line">    StrongColor sc = StrongColor::Red; <span class="comment">// 正确：使用作用域访问</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// int colorInt = sc; // 错误：不能隐式转换为整型</span></span><br><span class="line">    <span class="type">int</span> colorInt = static_cast&lt;<span class="type">int</span>&gt;(sc); <span class="comment">// 正确：需要显式转换</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; colorInt &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出：0，假设 StrongColor::Red 底层对应的整数值为 0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，强类型枚举 StrongColor 的使用增加了类型安全性，避免了与整型之间的隐式转换，并且强制使用枚举类名作为作用域来访问枚举值。这些特性有助于避免命名冲突和提高代码清晰度。</p><h3 id="常量表达式-constexpr"><a href="#常量表达式-constexpr" class="headerlink" title="常量表达式 (constexpr)"></a>常量表达式 (constexpr)</h3><p>C++11 引入了 <code>constexpr</code> 关键字，用于定义常量表达式。这个关键字可以用于变量、函数和构造函数，允许在编译时进行计算，而不是运行时。这对于提高程序的性能非常有用，因为它允许在编译期间执行更多的计算，减少运行时的工作量。</p><h4 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h4><p><strong>定义常量表达式变量</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// type 变量类型</span></span><br><span class="line">constexpr type variable = value;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义常量</span></span><br><span class="line">constexpr <span class="type">int</span> max_size = <span class="number">100</span>; </span><br></pre></td></tr></table></figure><p><strong>定义常量表达式函数</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// type 函数的返回值类型</span></span><br><span class="line">constexpr type <span class="title function_">function_name</span><span class="params">(parameters)</span> &#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">定义常量表达式函数：</span><br><span class="line">constexpr <span class="type">int</span> <span class="title function_">square</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>常量表达式函数必须返回一个常量表达式，函数体中只能有一条返回语句，且不能包含任何形式的循环、分支（除了条件运算符）等。</p><p><strong>声明类构造函数</strong>：允许类类型在编译时被初始化。构造函数体必须为空，所有成员初始化都必须使用常量表达式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    constexpr <span class="title function_">Point</span><span class="params">(<span class="type">double</span> xVal = <span class="number">0</span>, <span class="type">double</span> yVal = <span class="number">0</span>)</span> : <span class="title function_">x</span><span class="params">(xVal)</span>, <span class="title function_">y</span><span class="params">(yVal)</span> &#123;&#125;</span><br><span class="line">    constexpr <span class="type">double</span> <span class="title function_">getX</span><span class="params">()</span> <span class="type">const</span> &#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">    constexpr <span class="type">double</span> <span class="title function_">getY</span><span class="params">()</span> <span class="type">const</span> &#123; <span class="keyword">return</span> y; &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    <span class="type">double</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  constexpr Point <span class="title function_">p</span><span class="params">(<span class="number">9.0</span>, <span class="number">27.0</span>)</span>;</span><br><span class="line">  constexpr <span class="type">double</span> x = p.getX(); <span class="comment">// 在编译时计算</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用-constexpr-的优点包括："><a href="#使用-constexpr-的优点包括：" class="headerlink" title="使用 constexpr 的优点包括："></a>使用 constexpr 的优点包括：</h4><ul><li><strong>性能提升</strong>：通过在编译时而不是运行时计算值，可以提高程序的运行效率。</li><li><strong>类型安全</strong>：与宏相比，<code>constexpr</code> 提供了更强的类型安全。</li><li><strong>更广泛的用途</strong>：<code>constexpr</code> 变量、函数和对象可以用在需要编译时常量的上下文中，如数组大小、模板参数等。</li></ul><h3 id="默认和删除函数"><a href="#默认和删除函数" class="headerlink" title="默认和删除函数"></a>默认和删除函数</h3><p>C++11引入了两个重要的特性：允许显式地声明默认构造函数和析构函数，以及允许删除函数。这些特性提供了对类行为更细致的控制，特别是在管理资源、实现单例模式或防止对象拷贝时非常有用。</p><h4 id="默认函数（-default）"><a href="#默认函数（-default）" class="headerlink" title="默认函数（&#x3D; default）"></a>默认函数（&#x3D; default）</h4><p>在C++11之前，如果你希望类有一个默认的构造函数、拷贝构造函数、拷贝赋值运算符或析构函数，你通常不需要做任何事情；编译器会为你自动生成这些。然而，一旦你定义了任何构造函数，编译器就不会自动生成默认构造函数了。C++11通过<code>= default</code>关键字允许你显式地要求编译器为你生成这些函数，即使你已经定义了其他构造函数。</p><p><strong>语法</strong>: </p><p><strong>使用关键字 <code>= default</code> 来声明</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    ClassName() = <span class="keyword">default</span>; <span class="comment">// 默认构造函数</span></span><br><span class="line">    ClassName(<span class="type">const</span> ClassName&amp;) = <span class="keyword">default</span>; <span class="comment">// 默认拷贝构造函数</span></span><br><span class="line">    ClassName&amp; operator=(<span class="type">const</span> ClassName&amp;) = <span class="keyword">default</span>; <span class="comment">// 默认拷贝赋值运算符</span></span><br><span class="line">    ~ClassName() = <span class="keyword">default</span>; <span class="comment">// 默认析构函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>代码示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    MyClass() = <span class="keyword">default</span>; <span class="comment">// 显式声明使用编译器生成的默认构造函数</span></span><br><span class="line">    MyClass(<span class="type">int</span> value) : data(value) &#123;&#125; <span class="comment">// 自定义构造函数</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">private:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="删除函数（-delete）"><a href="#删除函数（-delete）" class="headerlink" title="删除函数（&#x3D; delete）"></a>删除函数（&#x3D; delete）</h4><p>C++11允许你显式地禁用类的某些函数（比如拷贝构造函数或拷贝赋值运算符），只需将它们声明为<code>= delete</code>。这对于防止对象被无意拷贝或赋值非常有用，尤其在设计只能移动不能拷贝的资源管理类时。</p><p><strong>语法</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    ClassName(<span class="type">const</span> ClassName&amp;) = delete; <span class="comment">// 禁用拷贝构造函数</span></span><br><span class="line">    ClassName&amp; operator=(<span class="type">const</span> ClassName&amp;) = delete; <span class="comment">// 禁用拷贝赋值运算符</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>代码示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NonCopyable</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    NonCopyable() = <span class="keyword">default</span>;</span><br><span class="line">    NonCopyable(<span class="type">const</span> NonCopyable&amp;) = delete; <span class="comment">// 禁止拷贝</span></span><br><span class="line">    NonCopyable&amp; operator=(<span class="type">const</span> NonCopyable&amp;) = delete; <span class="comment">// 禁止赋值</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结:"></a>总结:</h4><p><code>= default</code>和<code>= delete</code>是C++11中引入的两个关键特性，它们提供了对类默认行为的显式控制。通过<code>= default</code>，你可以明确地告诉编译器为类生成默认的构造函数、析构函数或拷贝&#x2F;赋值运算符，即使定义了其他构造函数。通过<code>= delete</code>，你可以防止类的拷贝或赋值，这在设计不可拷贝的资源管理类或单例类时特别有用。这两个特性让类的设计意图更加清晰，同时也有助于避免潜在的错误。</p><h3 id="委托构造函数"><a href="#委托构造函数" class="headerlink" title="委托构造函数"></a>委托构造函数</h3><p>在 C++11 中，委托构造函数（Delegating Constructors）是一种允许一个构造函数在同一个类中调用另一个构造函数的功能，目的是为了减少代码重复，提高代码复用性。这允许构造函数之间的代码共享，从而避免在每个构造函数中重复相同的初始化代码。</p><h4 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h4><p>委托构造函数的语法相当直接，就是在构造函数的初始化列表中调用同一个类的另一个构造函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    ClassName(参数列表) : ClassName(其他参数列表) &#123;</span><br><span class="line">        <span class="comment">// 构造函数体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里，构造函数通过在其初始化列表中调用另一个构造函数（即委托给另一个构造函数），实现对对象的初始化。</p><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><p>考虑一个简单的 Rectangle 类，它有两个成员变量：长度和宽度。我们可以使用委托构造函数来确保所有的构造逻辑都通过一个主要的构造函数来执行，避免代码的重复。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="comment">// 主构造函数</span></span><br><span class="line">    Rectangle(<span class="type">double</span> width, <span class="type">double</span> height) : width(width), height(height) &#123;</span><br><span class="line">        <span class="comment">// 这里可以包含一些特定的初始化逻辑</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Rectangle(double, double)&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 委托构造函数，委托给主构造函数</span></span><br><span class="line">    Rectangle(<span class="type">double</span> side) : Rectangle(side, side) &#123;</span><br><span class="line">        <span class="comment">// 注意：这里的初始化逻辑会在主构造函数之后执行</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Rectangle(double)&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">area</span><span class="params">()</span> <span class="type">const</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Area: &quot;</span> &lt;&lt; width * height &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    <span class="type">double</span> width, height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Rectangle <span class="title function_">square</span><span class="params">(<span class="number">5</span>)</span>; <span class="comment">// 使用委托构造函数</span></span><br><span class="line">    square.area(); <span class="comment">// 输出: Area: 25</span></span><br><span class="line">    </span><br><span class="line">    Rectangle <span class="title function_">rectangle</span><span class="params">(<span class="number">4</span>, <span class="number">5</span>)</span>; <span class="comment">// 使用主构造函数</span></span><br><span class="line">    rectangle.area(); <span class="comment">// 输出: Area: 20</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，Rectangle类有三个构造函数：</p><ul><li>一个是接受两个参数（宽度和高度）的主构造函数。</li><li>另外两个是委托构造函数，一个不带参数，默认构造一个宽度和高度都为0的矩形；另一个只带一个参数，构造一个正方形。</li></ul><p>这样的设计让构造函数的初始化逻辑更加集中，如果需要修改初始化逻辑，只需要修改主构造函数即可，提高了代码的可维护性。</p><h3 id="继承构造函数"><a href="#继承构造函数" class="headerlink" title="继承构造函数"></a>继承构造函数</h3><p>在C++11中，引入了<strong>继承构造函数</strong>的概念，这允许派生类继承并直接使用基类的构造函数，而不需要在派生类中重新定义相同的构造函数。这个特性通过简化代码，避免不必要的重复，提高了代码的可维护性。</p><h4 id="语法-6"><a href="#语法-6" class="headerlink" title="语法"></a>语法</h4><p>要在派生类中继承基类的构造函数，你可以使用<code>using</code> 声明。基本语法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> public Base &#123;</span><br><span class="line">public:</span><br><span class="line">    using Base::Base;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里，Derived 类通过 <code>using Base::Base;</code>声明，继承了 Base 类所有的构造函数。</p><h4 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h4><p>考虑以下基类Person，它有一个构造函数，接受一个表示人名的字符串参数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    Person(<span class="built_in">std</span>::<span class="built_in">string</span> n) : name(n) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Person(&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在，我们定义一个 Employee 类，它是 Person 的派生类，并且我们想让 Employee 类能够直接使用 Person 类的构造函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> :</span> public Person &#123;</span><br><span class="line">public:</span><br><span class="line">    using Person::Person; <span class="comment">// 继承构造函数</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">printName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Employee Name: &quot;</span> &lt;&lt; name &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接着，我们可以这样使用 Employee 类：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Employee <span class="title function_">emp</span><span class="params">(<span class="string">&quot;John Doe&quot;</span>)</span>;</span><br><span class="line">    emp.printName(); <span class="comment">// 输出：Employee Name: John Doe</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，Employee 类继承了 Person 类的构造函数，所以我们可以直接使用一个字符串参数来构造 Employee 对象。这就避免了在 Employee 类中重新定义一个接受相同参数的构造函数。</p><h3 id="显式虚函数重载-override"><a href="#显式虚函数重载-override" class="headerlink" title="显式虚函数重载(override)"></a>显式虚函数重载(override)</h3><p>C++11引入了一种新的方式来控制虚函数的重载，称为“显式虚函数重载”(Explicit Virtual Function Override)。这通过在派生类中的成员函数声明时使用<code>override</code>关键字实现。这个关键字明确指出一个成员函数意图重写一个基类的虚函数。使用<code>override</code>可以提高代码的可读性，并且帮助编译器检查派生类是否真正重载了基类中的虚函数，避免因拼写错误或函数签名不匹配而导致的问题。</p><h4 id="语法：-2"><a href="#语法：-2" class="headerlink" title="语法："></a>语法：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    virtual <span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> public Base &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">func</span><span class="params">()</span> override; <span class="comment">// 明确指明重载基类的虚函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    virtual <span class="type">void</span> <span class="title function_">sayHello</span><span class="params">()</span>  &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hello from Base&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> public Base &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">sayHello</span><span class="params">()</span>  override &#123; <span class="comment">// 正确重载 Base 的 sayHello</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hello from Derived&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Base* base = new Derived();</span><br><span class="line">    base-&gt;sayHello(); <span class="comment">// 输出: Hello from Derived</span></span><br><span class="line">    delete base;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，Derived 类通过 <code>override</code> 关键字明确表示 sayHello 函数重写了 Base 类中的虚函数。如果签名不匹配，编译器将报错。</p><h3 id="final-关键字"><a href="#final-关键字" class="headerlink" title="final 关键字"></a>final 关键字</h3><p>在C++11中，<code>final</code>关键字被引入作为类和虚函数的新修饰符。当<code>final</code>用于类时，它阻止该类被继承。当用于虚函数时，它阻止该函数在派生类中被进一步重写。这提供了一种明确表达设计意图的方式，并能够避免不必要的运行时错误。</p><h4 id="用于类"><a href="#用于类" class="headerlink" title="用于类"></a>用于类</h4><p>当 <code>final</code> 用于一个类时，任何尝试继承该类的行为都将导致编译错误。</p><p><strong>语法</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> <span class="keyword">final</span> &#123;</span> </span><br><span class="line">  <span class="comment">/* 类定义实现 */</span>  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>代码示例</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> <span class="keyword">final</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> public Base &#123; <span class="comment">// 这将导致编译错误</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个示例中，尝试从 Base 类派生 Derived 类会导致编译错误，因为 Base 类被标记为 final。</p><h4 id="用于虚函数"><a href="#用于虚函数" class="headerlink" title="用于虚函数"></a>用于虚函数</h4><p>当 <code>final</code> 用于虚函数时，它表示该函数不能在任何派生类中被重写。</p><p><strong>语法</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virtual <span class="type">void</span> <span class="title function_">function</span><span class="params">()</span> final;</span><br></pre></td></tr></table></figure><p><strong>示例</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    virtual <span class="type">void</span> <span class="title function_">show</span><span class="params">()</span> final &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base show&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> public Base &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">show</span><span class="params">()</span> override &#123; <span class="comment">// 这将导致编译错误</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Derived show&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个示例中，Derived 类尝试重写 Base 类中的 show 函数会导致编译错误，因为 show 函数在 Base 类中被标记为 final。</p><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景:"></a>使用场景:</h4><p>final关键字的使用场景主要包括：</p><ul><li><strong>性能优化</strong>：防止类的继承或虚函数的重写可以让编译器进行更多的优化，因为编译器知道没有更多的派生类或重写的函数需要考虑。</li><li><strong>设计安全</strong>：当你的设计不希望或不需要继承或重写时，使用final可以防止其他开发者不小心破坏你的设计意图。</li></ul><p>final关键字的引入增强了C++的类型安全性和性能优化能力，同时也提供了更明确的类设计意图表达方式。</p><h3 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h3><p>C++11 引入了 Lambda 表达式，为 C++ 程序员提供了一种方便的匿名函数对象创建方式。Lambda 表达式广泛用于简化代码，尤其是在需要小段函数逻辑作为参数传递给算法或线程时。</p><h4 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h4><p><strong>Lambda 表达式的基本语法如下</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[ capture ] ( parameters ) -&gt; return_type &#123;</span><br><span class="line">    <span class="comment">// Function body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>capture</strong>：捕获列表，定义了 Lambda 函数体外部变量的访问方式。可以是值捕获、引用捕获或隐式捕获等。</li><li><strong>parameters</strong>：参数列表，与普通函数的参数列表相同。可以为空。</li><li><strong>return_type</strong>：返回类型，可以省略，编译器会自动推导返回类型。</li><li><strong>Function body</strong>：函数体，包含了 Lambda 表达式的逻辑。</li></ul><p><strong>示例</strong>:</p><p><strong>1. 基本Lambda表达式</strong></p><p>不带参数，自动推导返回类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> greet = []() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hello, World!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;;</span><br><span class="line">greet();  <span class="comment">// 调用Lambda表达式</span></span><br></pre></td></tr></table></figure><p><strong>2. 带参数的Lambda表达式</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> add = [](<span class="type">int</span> x, <span class="type">int</span> y) &#123; <span class="keyword">return</span> x + y; &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;3 + 4 = &quot;</span> &lt;&lt; add(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p><strong>3. 指定返回类型的Lambda表达式</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> divide = [](<span class="type">double</span> x, <span class="type">double</span> y) -&gt; <span class="type">double</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (y == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 防止除以0</span></span><br><span class="line">    <span class="keyword">return</span> x / y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;5.0 / 2.0 = &quot;</span> &lt;&lt; divide(<span class="number">5.0</span>, <span class="number">2.0</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p><strong>4. 捕获外部变量</strong></p><p>值捕获：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">4</span>;</span><br><span class="line"><span class="comment">// [x] 以值的方式捕获变量x</span></span><br><span class="line"><span class="keyword">auto</span> square = [x]() &#123; <span class="keyword">return</span> x * x; &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Square of 4 is &quot;</span> &lt;&lt; square() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>引用捕获：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::for_each(numbers.begin(), numbers.end(), [&amp;total](<span class="type">int</span> x) &#123;</span><br><span class="line">    total += x;  <span class="comment">// &#x27;total&#x27;通过引用捕获，可以修改其值</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Total: &quot;</span> &lt;&lt; total &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p><strong>5. 捕获所有外部变量</strong></p><p>使用<code>[=]</code>捕获所有外部变量（通过值），使用<code>[&amp;]</code>捕获所有外部变量（通过引用）。</p><p><strong>总结</strong>:</p><p>Lambda表达式是C++11中引入的强大特性，它提供了一种便捷的方式来定义和使用匿名函数。通过捕获列表，Lambda表达式可以捕获并使用定义它们的作用域中的变量。Lambda表达式广泛应用于标准库算法、异步编程和事件处理等场景。</p><h3 id="尾返回类型"><a href="#尾返回类型" class="headerlink" title="尾返回类型"></a>尾返回类型</h3><p>C++11引入了尾返回类型（Trailing Return Type）的概念，允许开发者将函数的返回类型声明在函数参数列表之后。这在某些情况下，尤其是当返回类型依赖于函数参数类型的时候，变得非常有用。使用尾返回类型，你可以利用<code>auto</code>关键字和<code>-&gt;</code>运算符来指定返回类型。</p><h4 id="尾返回类型的基本语法"><a href="#尾返回类型的基本语法" class="headerlink" title="尾返回类型的基本语法"></a>尾返回类型的基本语法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> <span class="title function_">functionName</span><span class="params">(parameters)</span> -&gt; returnType;</span><br></pre></td></tr></table></figure><p>这里，<code>returnType</code>是一个类型表达式，它描述了函数的返回类型，并且它可以使用函数参数。</p><h4 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码:"></a>示例代码:</h4><p><strong>简单示例</strong>:</p><p>在最简单的形式中，尾返回类型让函数的声明更清晰：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> -&gt; <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管在这个简单例子中使用尾返回类型可能看起来没有必要，它展示了基本的语法结构。</p><p><strong>依赖于模板参数的返回类型</strong>:</p><p>尾返回类型特别有用于模板编程中，当函数的返回类型依赖于其模板参数时：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T, typename U&gt;</span><br><span class="line"><span class="keyword">auto</span> <span class="title function_">add</span><span class="params">(T x, U y)</span> -&gt; <span class="title function_">decltype</span><span class="params">(x + y)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，add 函数的返回类型是 T 和 U 类型相加的结果类型。使用 decltype 关键字和尾返回类型，我们可以精确地指定这个返回类型。</p><p><strong>使用于lambda表达式</strong>:</p><p>尾返回类型同样适用于C++11中的 lambda 表达式，允许在更复杂的场景下指定返回类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> getLambda = []() -&gt; <span class="built_in">std</span>::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> [](<span class="type">int</span> x, <span class="type">int</span> y) -&gt; <span class="type">int</span> &#123; <span class="keyword">return</span> x + y; &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个例子中，getLambda是一个返回类型为std::function&lt;int(int, int)&gt;的 lambda 表达式，它本身返回另一个计算两个整数和的 lambda 表达式。</p><p><strong>为什么需要尾返回类型</strong>?</p><p>在C++11之前，函数的返回类型必须在函数名之前声明，这在大多数情况下工作得很好。然而，对于返回类型依赖于函数参数的情况（特别是模板编程中），这种方法就显得力不从心了。尾返回类型提供了一种灵活的方式来声明这些依赖于参数的返回类型，使得函数签名更加清晰和灵活。</p><p>尾返回类型是现代C++（C++11及以后版本）中推荐的一种高级特性，它在编写泛型代码和lambda表达式时特别有用。通过这种方式，C++程序员可以编写出更清晰、更灵活、更安全的代码。</p><h3 id="内联命名空间（Inline-Namespaces）"><a href="#内联命名空间（Inline-Namespaces）" class="headerlink" title="内联命名空间（Inline Namespaces）"></a>内联命名空间（Inline Namespaces）</h3><p>C++11引入了内联命名空间（Inline Namespaces）的概念，这是一种特殊的命名空间，其成员在外层命名空间中也可以直接访问，无需通过内联命名空间的名称。这个特性主要用于版本控制和兼容性，允许库开发者在不破坏现有代码基础上引入新版本的API。</p><h4 id="语法-7"><a href="#语法-7" class="headerlink" title="语法"></a>语法</h4><p>使用<code>inline</code>关键字来定义内联命名空间：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">namespace outer &#123;</span><br><span class="line">    <span class="keyword">inline</span> namespace inner &#123;</span><br><span class="line">        <span class="comment">// void func() &#123;&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，inner是一个内联命名空间，outer是它的外层命名空间。由于inner被声明为内联的，所以outer命名空间中的代码可以直接访问 inner 中的成员，无需显式地通过 inner 命名空间的名称。</p><h4 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a>代码示例</h4><p>假设我们有一个库，该库提供了一个函数 foo。随着时间的推移，库的版本更新，我们添加了一个新的实现，但我们想保持对旧版本的兼容。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">namespace Library &#123;</span><br><span class="line">    <span class="comment">// 旧版本</span></span><br><span class="line">    namespace Version1 &#123;</span><br><span class="line">        <span class="type">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Version 1 of foo\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新版本</span></span><br><span class="line">    <span class="keyword">inline</span> namespace Version2 &#123;</span><br><span class="line">        <span class="type">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Version 2 of foo\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Library::foo(); <span class="comment">// 直接访问最新版本</span></span><br><span class="line">    Library::Version1::foo(); <span class="comment">// 显式访问旧版本</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，Version2 是一个内联命名空间。当我们调用 Library::foo() 时，由于 Version2 是内联的，编译器会直接在 Library 的内联命名空间中查找 foo 函数，因此调用的是 Version2 中的 foo。如果需要显式调用旧版本的 foo 函数，可以通过完整的命名空间路径 Library::Version1::foo() 来实现。</p><h4 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h4><p>内联命名空间的一个典型应用场景是库版本管理。通过将最新版本的定义放在内联命名空间中，库的用户可以不做任何修改地自动使用最新版本的功能。同时，如果需要引用特定版本的定义，也可以通过指定命名空间的名称来实现。</p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项:"></a>注意事项:</h4><ul><li>一个命名空间内只能有一个内联命名空间是活跃的，也就是说，如果有多个内联命名空间，只有最后一个声明为内联的命名空间才会被视为活跃的。</li><li>内联命名空间主要用于版本控制和向后兼容性，不推荐在日常编程中过度使用。</li></ul><p>内联命名空间提供了一种优雅的方式来处理库和应用程序在不同版本间的平滑过渡和兼容性问题，是 C++11 中对库设计者非常有用的一个特性。</p><h3 id="静态断言（static-assert）"><a href="#静态断言（static-assert）" class="headerlink" title="静态断言（static_assert）"></a>静态断言（static_assert）</h3><p>C++11 引入了<strong>静态断言（static_assert）</strong>，这是一种在编译时进行断言检查的机制。静态断言让开发者能够在编译期间检查表达式是否为真，如果表达式结果为假，则编译器会产生一个编译错误并显示开发者提供的消息。这个特性特别适合用于检查模板参数、常量表达式、等编译时信息，以确保代码的正确性和类型安全。</p><h4 id="语法-8"><a href="#语法-8" class="headerlink" title="语法"></a>语法</h4><p>static_assert 的基本语法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static_assert</span>(常量表达式, 错误消息);</span><br></pre></td></tr></table></figure><ul><li><strong>常量表达式</strong>：需要在编译时求值的表达式，结果为布尔值。如果表达式的结果为 false，则编译器会产生一个错误。</li><li><strong>错误消息</strong>：这是一个字符串字面量，用于在常量表达式的求值结果为 false 时提供错误信息。</li></ul><h4 id="示例代码-3"><a href="#示例代码-3" class="headerlink" title="示例代码:"></a>示例代码:</h4><p><strong>检查类型大小</strong> : 使用 <code>static_assert</code> 来确保特定类型的大小符合预期：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static_assert</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) == <span class="number">4</span>, <span class="string">&quot;int类型必须是4字节大小&quot;</span>);</span><br></pre></td></tr></table></figure><p>这个static_assert会检查 int 类型是否是4字节（32位）大小。如果在某些平台上 int 不是4字节大小，编译器将会报错。</p><p><strong>模板参数约束</strong>:<br>在模板编程中，static_assert 可以用来约束模板参数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> &#123;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    std::is_arithmetic&lt;T&gt;::value 用于在编译时检查一个类型是否为算术类型（即整数类型和浮点类型）。</span></span><br><span class="line"><span class="comment">    如果类型是算术类型，std::is_arithmetic&lt;T&gt;::value会是true，否则是false。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">static_assert</span>(<span class="built_in">std</span>::is_arithmetic&lt;T&gt;::value, <span class="string">&quot;MyArray只能用于算术类型&quot;</span>);</span><br><span class="line">    <span class="comment">// 类实现...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个例子中，static_assert用来确保MyArray模板只能用于算术类型（如int、float等）。如果尝试用非算术类型实例化MyArray，编译器将报错。</p><p><strong>验证编译时条件</strong>:<br>static_assert 也可以用于验证其他编译时能够确定的条件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">constexpr <span class="type">int</span> <span class="title function_">getNumber</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="number">5</span>; &#125;</span><br><span class="line"><span class="keyword">static_assert</span>(getNumber() == <span class="number">5</span>, <span class="string">&quot;函数getNumber必须返回5&quot;</span>);</span><br></pre></td></tr></table></figure><p>这里，static_assert验证getNumber函数是否总是返回5。由于getNumber被声明为constexpr，它的返回值可以在编译时确定，因此适合用于static_assert。</p><h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><p>C++11引入了<code>右值引用</code>，这是一个指向临时对象（即右值）的引用，允许开发者安全地从临时对象中移动数据，而不仅仅是复制。这个特性是实现<code>移动语义</code>（Move Semantics）和<code>完美转发</code>（Perfect Forwarding）的基础，对于提高程序性能尤其在涉及大量数据操作时非常关键。</p><h4 id="语法-9"><a href="#语法-9" class="headerlink" title="语法:"></a>语法:</h4><p>右值引用使用<code>&amp;&amp;</code>符号来声明。与左值引用（使用<code>&amp;</code>）不同，右值引用绑定到临时对象上。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Type&amp;&amp; name = expression;</span><br></pre></td></tr></table></figure><ul><li><strong>Type</strong>：变量的类型。</li><li><strong>name</strong>：变量的名称。</li><li><strong>expression</strong>：必须是一个右值表达式，通常是一个临时对象或者是通过<code>std::move</code>转换的。</li></ul><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><p><strong>简单的右值引用示例</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp;&amp; rref = <span class="number">5</span>; <span class="comment">// 5 是一个整数字面量，是右值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 std::move 转换左值为右值引用</span></span><br><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp;&amp; moved_x = <span class="built_in">std</span>::move(x);</span><br></pre></td></tr></table></figure><p>右值引用主要用于实现<code>移动语义和完美转发</code>。</p><h3 id="移动语义（Move-Semantics）"><a href="#移动语义（Move-Semantics）" class="headerlink" title="移动语义（Move Semantics）"></a>移动语义（Move Semantics）</h3><p>移动语义是 C++11 引入的一项重要特性，它允许资源（如动态分配的内存）在对象之间转移，而不是复制。这一特性显著提高了性能，尤其是在处理大型数据对象时，因为它避免了不必要的复制操作。移动语义主要通过两个新的构造函数实现：<strong>移动构造函数和移动赋值操作符</strong>，它们都使用了右值引用这一特性。</p><h4 id="移动构造函数"><a href="#移动构造函数" class="headerlink" title="移动构造函数"></a>移动构造函数</h4><p>移动构造函数允许从一个即将被销毁的对象中“窃取”资源。它的参数是该对象类型的右值引用。</p><p><strong>语法</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ClassName 表示类名</span></span><br><span class="line">ClassName(ClassName&amp;&amp; other) ;</span><br></pre></td></tr></table></figure><h4 id="移动赋值操作符"><a href="#移动赋值操作符" class="headerlink" title="移动赋值操作符"></a>移动赋值操作符</h4><p>移动赋值操作符允许将一个即将被销毁的对象的资源赋值给另一个对象。它的参数也是该对象类型的右值引用。</p><p><strong>语法</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassName&amp; operator=(ClassName&amp;&amp; other) ;</span><br></pre></td></tr></table></figure><h4 id="示例代码-4"><a href="#示例代码-4" class="headerlink" title="示例代码"></a>示例代码</h4><p>假设有一个简单的 Buffer 类，它管理一块动态分配的内存：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Buffer</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    Buffer(<span class="type">size_t</span> size) : size(size), data(new <span class="type">int</span>[size]) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 移动构造函数</span></span><br><span class="line">    Buffer(Buffer&amp;&amp; other) noexcept : size(other.size), data(other.data) &#123;</span><br><span class="line">        other.data = nullptr; <span class="comment">// 防止析构时释放内存</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 移动赋值操作符</span></span><br><span class="line">    Buffer&amp; operator=(Buffer&amp;&amp; other) noexcept &#123;</span><br><span class="line">        <span class="keyword">if</span> (this != &amp;other) &#123;</span><br><span class="line">            delete[] data; <span class="comment">// 释放原来的资源</span></span><br><span class="line">            data = other.data; <span class="comment">// 窃取资源</span></span><br><span class="line">            size = other.size;</span><br><span class="line">            other.data = nullptr; <span class="comment">// 防止析构时释放内存</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *this;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~Buffer() &#123; delete[] data; &#125;</span><br><span class="line">    </span><br><span class="line">private:</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">    <span class="type">int</span>* data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个例子中，Buffer 类定义了一个移动构造函数和一个移动赋值操作符。当一个 Buffer 对象通过移动构造函数或移动赋值操作符与另一个 Buffer 对象交互时，它实际上是从源对象窃取了资源（这里是指针 data），而不是复制资源。这样可以避免不必要的复制开销，并提高性能。</p><h4 id="使用-std-move-触发移动语义"><a href="#使用-std-move-触发移动语义" class="headerlink" title="使用 std::move 触发移动语义:"></a>使用 std::move 触发移动语义:</h4><p>要触发移动操作，通常需要使用 <code>std::move</code> 函数将对象显式转换为<code>右值引用</code>，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Buffer <span class="title function_">buffer1</span><span class="params">(<span class="number">1024</span>)</span>; <span class="comment">// 创建一个Buffer对象</span></span><br><span class="line">Buffer <span class="title function_">buffer2</span><span class="params">(<span class="built_in">std</span>::move(buffer1))</span>; <span class="comment">// 使用移动构造函数</span></span><br></pre></td></tr></table></figure><p>在这个示例中，std::move(buffer1) 将 buffer1 转换为右值引用，从而允许使用移动构造函数来初始化 buffer2。这意味着 buffer1 的资源被转移到了 buffer2，并且 buffer1 不再拥有这些资源。</p><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p>移动语义通过引入移动构造函数和移动赋值操作符，以及配合右值引用，为 C++ 提供了一种高效的资源管理方式。这改善了 C++ 程序的性能，特别是在涉及到大量数据处理的场景中。通过减少不必要的数据复制，移动语义使得资源的转移变得更加高效和直接。</p><h3 id="完美转发（Perfect-Forwarding）"><a href="#完美转发（Perfect-Forwarding）" class="headerlink" title="完美转发（Perfect Forwarding）"></a>完美转发（Perfect Forwarding）</h3><p>C++11 引入的完美转发是一种技术，允许函数将其接收到的参数以完全不变的形式转发给另一个函数。这意味着参数的左值、右值特性和类型都被保持不变。完美转发非常有用，尤其是在<strong>模板编程和泛型编程</strong>中，它可以帮助我们编写能够接受任意参数并将其正确转发的代码。</p><h4 id="使用-std-forward"><a href="#使用-std-forward" class="headerlink" title="使用 std::forward"></a>使用 std::forward</h4><p>完美转发通常通过 <code>std::forward</code> 实现，它允许你根据模板参数的类型来保持参数的左值或右值特性。</p><p><strong>语法</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line"><span class="type">void</span> <span class="title function_">wrapper</span><span class="params">(T&amp;&amp; arg)</span> &#123;</span><br><span class="line">    <span class="comment">// 使用 std::forward&lt;T&gt; 来完美转发 arg</span></span><br><span class="line">    callee(<span class="built_in">std</span>::forward&lt;T&gt;(arg));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>T&amp;&amp;</code> 表示一个通用引用（universal reference），它可以绑定到左值或右值。</li><li><code>std::forward&lt;T&gt;(arg)</code> 负责保持 arg 的原始类型，确保参数 arg 的值类别（左值或右值）被保持不变地转发。</li></ul><p><strong>示例代码</strong>:</p><p>假设我们有以下 callee 函数，它有两个重载，分别处理左值和右值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">callee</span><span class="params">(<span class="type">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; arg)</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;callee called with a left value: &quot;</span> &lt;&lt; arg &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">callee</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>&amp;&amp; arg)</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;callee called with a right value: &quot;</span> &lt;&lt; arg &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们使用完美转发来实现 wrapper 函数，它可以将其接收到的参数以原样转发给 callee：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line"><span class="type">void</span> <span class="title function_">wrapper</span><span class="params">(T&amp;&amp; arg)</span> &#123;</span><br><span class="line">    callee(<span class="built_in">std</span>::forward&lt;T&gt;(arg));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> lv = <span class="string">&quot;left value&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    wrapper(lv);  <span class="comment">// 调用 callee(const std::string&amp;)</span></span><br><span class="line">    waapper(<span class="built_in">std</span>::move(lv)); <span class="comment">// 调用 callee(std::string&amp;&amp;)</span></span><br><span class="line">    wrapper(<span class="string">&quot;right value&quot;</span>);  <span class="comment">// 调用 callee(std::string&amp;&amp;)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 main 函数中，wrapper 首先以一个左值字符串调用，接着使用std::move(lv)调用，然后以一个右值字符串字面量调用。由于使用了 std::forward，wrapper 能够保持参数的原始值类别（左值或右值），因此能够触发 callee 的正确重载。</p><h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结:"></a>总结:</h4><p>完美转发是一个非常有用的技术，它使得模板函数能够接受任意类型的参数，并将这些参数以其原始的左值或右值状态传递给其他函数。这在编写泛型代码或模板库时尤其重要，因为它允许代码以一种类型安全且效率高的方式处理各种调用场景。通过结合使用<code>通用引用（T&amp;&amp;）</code>和 <code>std::forward</code>，开发者可以编写出既灵活又高效的模板函数。</p><h2 id="标准库增强"><a href="#标准库增强" class="headerlink" title="标准库增强"></a>标准库增强</h2><h3 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h3><h4 id="线程（std-thread）"><a href="#线程（std-thread）" class="headerlink" title="线程（std::thread）"></a>线程（std::thread）</h4><p>C++11 引入了原生线程支持，通过 <code>&lt;thread&gt;</code> 头文件提供了 std::thread 类，使得创建和管理线程变得直接且易于使用。这是对 C++ 标准库的重要扩展，允许直接在 C++ 代码中实现多线程编程，而不再依赖于操作系统特定的线程库。</p><p><strong>基本使用</strong>:</p><p>要使用 <code>std::thread</code>，你需要创建一个 <code>std::thread</code> 对象并向其传递一个函数，这个函数将在新线程中执行。</p><p><strong>示例代码</strong>：创建并启动一个线程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程执行的函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">threadTask</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hello, Thread!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建并启动新线程</span></span><br><span class="line">    <span class="built_in">std</span>::thread <span class="title function_">t</span><span class="params">(threadTask)</span>;</span><br><span class="line">    <span class="comment">// 等待线程完成任务</span></span><br><span class="line">    t.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>传递参数</strong>:</p><p>如果你需要向线程函数传递参数，可以直接将它们作为 std::thread 构造函数的参数传递。</p><p><strong>示例代码</strong>：向线程函数传递参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printMessage</span><span class="params">(<span class="type">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; message)</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; message &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> message = <span class="string">&quot;Hello from the thread with arguments!&quot;</span>;</span><br><span class="line">    <span class="comment">// message作为参数传递给线程函数</span></span><br><span class="line">    <span class="built_in">std</span>::thread <span class="title function_">t</span><span class="params">(printMessage, message)</span>;</span><br><span class="line">    t.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>线程管理</strong>:</p><p><strong>加入线程</strong> : 当你创建一个线程时，你需要决定程序何时等待这个线程完成其工作。调用 <code>std::thread</code> 对象的 <code>join()</code> 方法，会使当前线程（通常是主线程或创建该子线程的线程）暂停执行，直到被 <code>join()</code> 的那个线程完成执行。<strong>这保证了两个重要的事项</strong>：</p><ul><li><strong>线程同步</strong>：确保所有必要的线程操作在程序继续之前完成。</li><li><strong>资源回收</strong>：一旦子线程完成执行，系统会回收它使用的所有资源。</li></ul><p><strong>使用方法</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t.join();</span><br></pre></td></tr></table></figure><p><strong>分离线程</strong> : 有时，你可能希望线程“独立”执行，而不是等待它结束。通过调用线程对象的 <code>detach()</code> 方法，你可以实现这一点。分离线程意味着：</p><ul><li><strong>线程的自主性</strong>：分离的线程会在自己的执行流中独立运行，主线程（或任何其他线程）不会等待它结束。</li><li><strong>资源管理</strong>：一旦分离的线程完成其任务，它占用的资源将由操作系统自动回收。你不需要（也不能）对其调用 join()。</li></ul><p><strong>使用方法</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t.detach();</span><br></pre></td></tr></table></figure><p><strong>获取线程ID</strong>:<br>每个线程都有一个唯一的 <code>ID</code>，可以通过 <code>get_id()</code> 方法获取。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Thread ID: &quot;</span> &lt;&lt; t.get_id() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p><strong>当前线程的 ID</strong></p><p>可以使用 <code>std::this_thread::get_id()</code> 获取当前线程的 ID。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Current thread ID: &quot;</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p><strong>线程休眠</strong>:</p><p><code>std::this_thread::sleep_for()</code> 函数可以使当前线程暂停执行指定的时间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="comment">// 使当前线程休眠 1 秒</span></span><br><span class="line"><span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>));</span><br></pre></td></tr></table></figure><h4 id="多线程同步"><a href="#多线程同步" class="headerlink" title="多线程同步"></a>多线程同步</h4><p>C++11 引入了多线程同步的机制，来帮助程序员控制并发执行的线程之间的执行顺序，确保数据的一致性和防止竞态条件。这包括了<code>互斥锁（mutexes）</code>、<code>条件变量（condition variables）</code>、以及<code>原子操作（atomic operations）</code>等。下面是这些同步机制的基本介绍和示例。</p><p><strong>1. 互斥锁（Mutex）</strong></p><p>互斥锁（mutex）是用于管理对共享资源的访问的同步原语。当多个线程尝试同时访问同一个资源时，互斥锁确保每次只有一个线程能够访问该资源，从而防止数据竞争和保证数据的一致性。</p><p>C++11 在 <code>&lt;mutex&gt;</code> 头文件中提供了几种类型的互斥锁：</p><p><strong>std::mutex</strong></p><p><code>std::mutex</code> 提供了基本的互斥锁功能。</p><p><strong>基本语法</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::mutex mtx;</span><br><span class="line">mtx.lock();   <span class="comment">// 加锁</span></span><br><span class="line"><span class="comment">// 临界区代码</span></span><br><span class="line">mtx.unlock(); <span class="comment">// 解锁</span></span><br></pre></td></tr></table></figure><p><strong>主要成员函数</strong>:</p><ul><li><strong>lock()</strong>    : 锁定互斥锁。如果互斥锁已被其他线程锁定，则调用线程将阻塞，直到互斥锁变为可用。</li><li><strong>unlock()</strong>  : 解锁互斥锁，使其变为可用状态。</li><li><strong>try_lock()</strong>: 尝试锁定互斥锁而不阻塞。如果互斥锁已经被其他线程锁定，则立即返回 false；如果成功锁定，则返回 true。</li></ul><p><strong>示例代码</strong>：使用 <code>std::mutex</code> 保护共享数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::mutex mtx; <span class="comment">// 创建互斥锁</span></span><br><span class="line"><span class="type">int</span> shared_data = <span class="number">0</span>; <span class="comment">// 共享数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">incrementSharedData</span><span class="params">()</span> &#123;</span><br><span class="line">    mtx.lock(); <span class="comment">// 加锁</span></span><br><span class="line">    ++shared_data;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">&quot; incremented shared_data to &quot;</span> &lt;&lt; shared_data &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    mtx.unlock(); <span class="comment">// 解锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::thread <span class="title function_">t1</span><span class="params">(incrementSharedData)</span>;</span><br><span class="line">    <span class="built_in">std</span>::thread <span class="title function_">t2</span><span class="params">(incrementSharedData)</span>;</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>std::recursive_mutex</strong></p><p><code>std::recursive_mutex</code>是可递归的互斥锁，允许同一个线程多次对同一个互斥锁对象加锁。它维护了一个锁计数和拥有线程的标识，当计数降到 0 时锁被释放。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::recursive_mutex rec_mtx;</span><br><span class="line">rec_mtx.lock();   <span class="comment">// 第一次加锁</span></span><br><span class="line">rec_mtx.lock();   <span class="comment">// 第二次加锁，合法</span></span><br><span class="line"><span class="comment">// 临界区代码</span></span><br><span class="line">rec_mtx.unlock(); <span class="comment">// 第一次解锁</span></span><br><span class="line">rec_mtx.unlock(); <span class="comment">// 第二次解锁，锁被完全释放</span></span><br></pre></td></tr></table></figure><p><strong>std::timed_mutex</strong></p><p><code>std::timed_mutex</code>提供了基本的互斥锁功能，并支持尝试加锁一段时间。如果在指定时间内没有获取到锁，操作会失败并返回。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::timed_mutex tm_mtx;</span><br><span class="line"><span class="keyword">if</span> (tm_mtx.try_lock_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>))) &#123;</span><br><span class="line">    <span class="comment">// 临界区代码</span></span><br><span class="line">    tm_mtx.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>std::recursive_timed_mutex</strong></p><p><code>std::recursive_timed_mutex</code>结合了<code>std::recursive_mutex</code>的可递归特性和<code>std::timed_mutex</code>的定时尝试加锁功能。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::recursive_timed_mutex rt_mtx;</span><br><span class="line"><span class="keyword">if</span> (rt_mtx.try_lock_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>))) &#123;</span><br><span class="line">    <span class="comment">// 临界区代码，可以多次加锁</span></span><br><span class="line">    rt_mtx.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用注意</strong>:</p><ul><li><p>在使用互斥锁时，推荐使用<code>std::lock_guard</code>或<code>std::unique_lock</code>等 RAII（Resource Acquisition Is Initialization）封装，以自动管理锁的加锁和解锁过程，避免因异常而导致的死锁问题。</p></li><li><p>根据具体需求选择合适的互斥锁类型。比如，如果不需要递归加锁或定时尝试加锁的功能，使用最简单的std::mutex即可。</p></li></ul><p>C++11的互斥锁类型提供了灵活的同步机制，帮助开发者在多线程程序中安全地管理对共享数据的访问。</p><p><strong>2. 条件变量（Condition Variable）</strong></p><p>C++11中的条件变量也是线程同步的一种机制，用于在某些条件发生变化时通知一个或多个正在等待的线程。条件变量通常与互斥量（mutex）一起使用，以确保线程安全地访问共享数据。条件变量主要通过<code>std::condition_variable</code>类提供。</p><p><strong>条件变量常见接口</strong>：</p><p><strong>1. wait</strong></p><p>该函数用于等待一个条件成立。它会原子地释放锁并使当前线程挂起，直到被其他线程通过 notify_one 或 notify_all 唤醒。一旦当前线程被唤醒，wait 会再次获取锁。</p><p><strong>语法</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv.wait(unique_lock&lt;<span class="built_in">std</span>::mutex&gt;&amp; lock);</span><br></pre></td></tr></table></figure><p><strong>2. wait_for</strong></p><p>等待条件变量被通知一段时间。如果在指定的时间内条件变量没有被通知，则超时并返回。</p><p><strong>语法</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv.wait_for(unique_lock&lt;<span class="built_in">std</span>::mutex&gt;&amp; lock, duration);</span><br></pre></td></tr></table></figure><p><strong>3. wait_until</strong><br>等待直到某个时间点，如果条件变量在这个时间点之前没有被通知，则超时并返回。</p><p><strong>语法</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv.wait_until(unique_lock&lt;<span class="built_in">std</span>::mutex&gt;&amp; lock, time_point);</span><br></pre></td></tr></table></figure><p><strong>4. notify_one</strong><br>用于唤醒一个等待（挂起）在条件变量上的线程。如果有多个线程在等待，只有一个会被随机唤醒。</p><p><strong>语法</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv.notify_one();</span><br></pre></td></tr></table></figure><p><strong>5. notify_all</strong></p><p>该函数用于唤醒所有等待（挂起）在条件变量上的线程。</p><p><strong>语法</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv.notify_all();</span><br></pre></td></tr></table></figure><p><strong>示例代码</strong>：使用 <code>std::condition_variable</code> 实现线程同步</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::mutex mtx;</span><br><span class="line"><span class="built_in">std</span>::condition_variable cv;</span><br><span class="line"><span class="type">bool</span> ready = <span class="literal">false</span>; <span class="comment">// 条件变量关联的条件</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">doPrint</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// std::unique_lock :锁管理工具，自动管理互斥锁的锁定与解锁。</span></span><br><span class="line">    <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title function_">lck</span><span class="params">(mtx)</span>;</span><br><span class="line">    <span class="keyword">while</span> (!ready) </span><br><span class="line">        cv.wait(lck); <span class="comment">// 等待条件成立，即：ready 变为true</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">&quot; is running\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">go</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title function_">lck</span><span class="params">(mtx)</span>;</span><br><span class="line">    ready = <span class="literal">true</span>;</span><br><span class="line">    cv.notify_all(); <span class="comment">// 通知所有等待的线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::thread threads[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">        threads[i] = <span class="built_in">std</span>::thread(doPrint);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;10 threads ready to race...\n&quot;</span>;</span><br><span class="line">    go(); <span class="comment">// 让所有线程开始执行</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; th : threads) th.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 原子操作（Atomic）</strong></p><p>原子操作是指不可分割的操作，这些操作要么完全执行，要么完全不执行，不会出现部分执行的情况。这对于多线程编程至关重要，因为它们可以用来保护在多线程环境中共享的数据，而无需使用互斥锁。C++11 通过 <code>&lt;atomic&gt;</code> 头文件引入了原子类型和操作。</p><p><strong>原子类型</strong>:</p><p>C++11 提供了一系列原子类型，如 <code>std::atomic_int</code>, <code>std::atomic_long</code>, <code>std::atomic_bool</code> 等，以及一个模板类 <code>std::atomic&lt;T&gt;</code>，允许创建任意类型 <code>T</code> 的原子对象。</p><p><strong>基本用法</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="type">int</span>&gt; <span class="title function_">count</span><span class="params">(<span class="number">0</span>)</span>;  <span class="comment">// 原子整型变量</span></span><br></pre></td></tr></table></figure><p><strong>主要成员函数</strong>:</p><ul><li><strong>store()</strong>: 存储（赋值）一个值到原子对象。</li><li><strong>load()</strong>: 从原子对象加载（获取）一个值。</li><li><strong>exchange()</strong>: 原子地替换原子对象的值。</li><li><strong>compare_exchange_weak() 和 compare_exchange_strong()</strong>: 比较原子对象的值，如果与期望值相同，则替换为新值。</li><li><strong>fetch_add(), fetch_sub(), fetch_or(), fetch_and(), fetch_xor()</strong>: 原子地执行加、减、或、与、异或操作。</li></ul><p><strong>示例代码</strong>:</p><p><strong>简单原子操作</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="type">int</span>&gt; <span class="title function_">count</span><span class="params">(<span class="number">0</span>)</span>;  <span class="comment">// 原子计数器</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i) &#123;</span><br><span class="line">        count.fetch_add(<span class="number">1</span>);  <span class="comment">// 原子地增加计数器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt; threads;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        threads.push_back(<span class="built_in">std</span>::thread(increment));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; th : threads) &#123;</span><br><span class="line">        th.join();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Final count: &quot;</span> &lt;&lt; count.load() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子创建了 10 个线程，每个线程都对一个原子计数器执行 10000 次增加操作。因为 count 是原子类型，所以即使多个线程同时修改它，最终的结果也是准确的，不会发生数据竞争。</p><p><strong>比较并交换</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="type">int</span>&gt; <span class="title function_">value</span><span class="params">(<span class="number">10</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">check_and_increase</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> oldValue = value.load();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!value.compare_exchange_weak(oldValue, oldValue + <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="comment">// 循环直到成功更新</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    check_and_increase();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子展示了如何使用 <code>compare_exchange_weak</code> 来原子地更新一个值，只有当当前值等于期望的旧值时，才将其更新为新值，否则重试操作。</p><p><code>value.compare_exchange_weak(oldValue, oldValue + 1)</code><br>这是一个原子的比较并交换操作，它尝试将 value 的当前值与 oldValue 比较：</p><ul><li><p><strong>如果相等</strong>（说明期间 value 的值未被其他线程改变），则将 value 更新为 oldValue + 1。</p></li><li><p><strong>如果不相等</strong>（说明期间 value 的值被其他线程改变了），操作失败，oldValue 被更新为 value 的新值，然后循环再尝试。</p><p><code>compare_exchange_weak</code>方法返回 true 表示成功更新，false 表示更新失败。</p></li></ul><p>通过使用原子操作，可以在多线程环境中安全地操作共享数据，而无需引入可能导致性能下降的互斥锁。</p><h4 id="std-once-flag-和-std-call-once"><a href="#std-once-flag-和-std-call-once" class="headerlink" title="std::once_flag 和 std::call_once"></a>std::once_flag 和 std::call_once</h4><p>在C++11中，<code>std::once_flag</code>和<code>std::call_once</code>共同提供了一种线程安全的方式来执行一次性初始化。这种机制尤其用于延迟初始化和单例模式中，确保某个函数或某段初始化代码在多线程环境下仅被执行一次，无论有多少线程尝试。</p><p><strong>std::once_flag</strong>:</p><p><code>std::once_flag</code>是一个不能被复制的类型，用来与 std::call_once 一起标记某个函数或初始化代码是否已经被执行。每个<code>std::once_flag</code>对象通常与一次性初始化任务相关联。</p><p><strong>std::call_once</strong>:</p><p><code>std::call_once</code>函数接受一个 std::once_flag 对象和一个要执行的函数，保证无论有多少线程尝试调用<code>std::call_once</code>，该函数仅被执行一次。</p><p><strong>语法</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">call_once</span><span class="params">(<span class="built_in">std</span>::once_flag&amp; flag, Callable&amp;&amp; func, Args&amp;&amp;... args)</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>flag</strong>：一个std::once_flag对象，标记func是否被执行过。</li><li><strong>func</strong>：要执行的函数或可调用对象。</li><li><strong>args</strong>：传递给func的参数列表。</li></ul><p><strong>示例代码</strong>:</p><p>下面是一个使用<code>std::once_flag</code>和<code>std::call_once</code>实现的线程安全的延迟初始化示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::once_flag flag; <span class="comment">// 用于标记延迟初始化是否执行</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_once</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Called once&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_work</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 尝试执行do_once，由于使用了std::once_flag，</span></span><br><span class="line">    <span class="comment">// 即使有多个线程调用do_work，do_once也只会执行一次</span></span><br><span class="line">    <span class="built_in">std</span>::call_once(flag, do_once);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::thread <span class="title function_">t1</span><span class="params">(do_work)</span>;</span><br><span class="line">    <span class="built_in">std</span>::thread <span class="title function_">t2</span><span class="params">(do_work)</span>;</span><br><span class="line">    <span class="built_in">std</span>::thread <span class="title function_">t3</span><span class="params">(do_work)</span>;</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">    t3.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，do_work 函数尝试执行 do_once 函数，但由于 do_once 与一个 std::once_flag 对象 flag 相关联，并通过 std::call_once 来调用，因此无论有多少线程调用 do_work，do_once 只会被执行一次。这种模式对于资源的延迟初始化非常有用，尤其是在资源初始化开销较大或只有在真正需要时才应被初始化的情况下。</p><h4 id="std-future和std-promise"><a href="#std-future和std-promise" class="headerlink" title="std::future和std::promise"></a>std::future和std::promise</h4><p>在C++11中，<code>std::future</code>和<code>std::promise</code>是处理异步操作的两个重要类。它们协同工作，提供了一种从异步操作中获取结果的机制。</p><p><strong>std::promise</strong>:</p><p><code>std::promise</code>对象可以存储某一类型的值，该值可以在将来某个时刻被获取。通过 std::promise，你可以在一个线程中设置一个值，然后在另一个线程中通过与之关联的 std::future 对象来获取这个值。</p><p><strong>语法</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  T：存储的值的类型。</span></span><br><span class="line"><span class="built_in">std</span>::promise&lt;T&gt; promise;</span><br></pre></td></tr></table></figure><p><strong>主要接口</strong>:</p><ul><li>set_value(const T&amp;)：设置一个值，该值可以通过关联的 std::future 对象来获取。</li><li>get_future()：返回一个<code>std::future&lt;T&gt;</code>对象，用于获取通过 set_value 设置的值。</li></ul><p><strong>std::future</strong>:</p><p><code>std::future</code> 对象持有一个异步操作的结果。它从关联的 std::promise 对象获取值或异常。</p><p><strong>语法</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  T：存储的值的类型。</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">future</span>&lt;T&gt; <span class="built_in">future</span> = promise.get_future();</span><br><span class="line"></span><br><span class="line">value = <span class="built_in">future</span>.get();</span><br></pre></td></tr></table></figure><p><strong>主要接口</strong>:</p><ul><li>get()：获取由 std::promise 设置的值。调用get()会阻塞，直到值被设置。</li><li>wait()：等待异步操作完成，但不获取结果。</li></ul><p><strong>示例代码</strong>:</p><p>下面是一个使用<code>std::promise</code>和<code>std::future</code>来传递异步操作结果的简单示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步任务：计算一个数的平方</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">compute</span><span class="params">(<span class="built_in">std</span>::promise&lt;<span class="type">int</span>&gt;&amp;&amp; prom, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="type">int</span> result = x * x;</span><br><span class="line">    prom.set_value(result);  <span class="comment">// 在子线程中设置结果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::promise&lt;<span class="type">int</span>&gt; prom;  <span class="comment">// 创建一个std::promise&lt;int&gt;对象</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="type">int</span>&gt; fut = prom.get_future();  <span class="comment">// 获取与promise关联的future</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::thread <span class="title function_">th</span><span class="params">(compute, <span class="built_in">std</span>::move(prom), <span class="number">10</span>)</span>;  <span class="comment">// 创建一个线程执行异步任务</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取异步操作的结果</span></span><br><span class="line">    <span class="type">int</span> value = fut.get();  <span class="comment">// 阻塞，直到异步操作完成并设置了结果</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The square of 10 is &quot;</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    th.join();  <span class="comment">// 等待子线程完成</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，compute 函数在一个新线程中执行，并计算一个数的平方，然后通过传入的 std::promise 对象设置结果。主线程通过与 promise 对象关联的 future 对象等待并获取这个结果。</p><p><strong>总结</strong>:</p><p><code>std::promise</code>和<code>std::future</code>为 C++11 引入的异步编程提供了强大的支持，允许在不同线程之间传递数据和状态信息。它们使得编写并发程序变得更加简洁和安全，尤其是在需要从异步操作中获取结果时。</p><h4 id="打包任务（packaged-task）"><a href="#打包任务（packaged-task）" class="headerlink" title="打包任务（packaged_task）"></a>打包任务（packaged_task）</h4><p>C++11引入了<code>std::packaged_task</code>，它是一个模板类，用于封装任何可以调用的目标（比如函数、lambda表达式、绑定表达式或其他函数对象），以便异步调用。<code>std::packaged_task</code>将调用的结果存储为一个<code>std::future</code>对象，这样就可以在未来某个时刻获取该结果。这使得<code>std::packaged_task</code>成为实现任务异步执行并获取其结果的强大工具。</p><p><strong>语法</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::packaged_task&lt;ReturnType(ArgsTypes...)&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>ReturnType</strong>：调用的返回类型。</li><li><strong>ArgsTypes</strong>：调用的参数类型列表。</li></ul><p><strong>主要接口</strong>:</p><ul><li>operator()(Args…)：执行封装的任务。</li><li>get_future()：返回一个<code>std::future&lt;ReturnType&gt;</code>对象，用于获取任务的结果。</li></ul><p><strong>示例代码</strong>:</p><p>假设我们有一个函数，计算两个整数的和，并希望异步执行这个函数并获取结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个简单的函数，计算两个整数的和</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 封装sum函数到packaged_task中</span></span><br><span class="line">    <span class="built_in">std</span>::packaged_task&lt;<span class="title function_">int</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>&gt; <span class="title function_">task</span><span class="params">(sum)</span>;</span><br><span class="line">    <span class="comment">// 获取与packaged_task关联的future对象，以便之后获取结果</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="type">int</span>&gt; result = task.get_future();</span><br><span class="line">    <span class="comment">// 在一个新线程中执行任务</span></span><br><span class="line">    <span class="built_in">std</span>::thread <span class="title function_">th</span><span class="params">(<span class="built_in">std</span>::move(task), <span class="number">2</span>, <span class="number">3</span>)</span>; <span class="comment">// 传递参数2和3给sum函数</span></span><br><span class="line">    <span class="comment">// 等待任务完成并获取结果</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The sum is: &quot;</span> &lt;&lt; result.get() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出：The sum is: 5 </span></span><br><span class="line">    <span class="comment">// 等待线程完成</span></span><br><span class="line">    th.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们创建了一个 std::packaged_task 对象 task，它封装了 sum 函数。通过调用 task.get_future()，我们获得了一个std::future对象，它将在task执行完成后包含 sum 函数的返回值。然后，我们创建了一个线程th，并将task（通过std::move移动）和sum函数需要的参数传递给这个线程，以异步执行task。通过result.get()，我们阻塞等待任务完成，并获取sum函数的结果。</p><p><strong>总结</strong>:</p><p><code>std::packaged_task</code> 是C++11中处理异步任务的强大工具。它允许程序员封装任何可调用的目标，以便异步执行，同时通过<code>std::future</code>提供了一种机制来获取异步操作的结果。这种模式非常适用于需要将计算密集型任务移出主线程以避免阻塞主执行流的场景。</p><h4 id="异步（Async）"><a href="#异步（Async）" class="headerlink" title="异步（Async）"></a>异步（Async）</h4><p>C++11 通过引入 <code>std::async</code> 函数提供了一种更简洁、更高层的方式来创建异步任务。<code>std::async</code> 会启动一个异步任务，该任务可以在新线程中执行或延迟执行，具体取决于给定的策略参数，并返回一个 <code>std::future</code> 对象，用于访问异步操作的结果。</p><p><strong>函数声明</strong>:</p><p><strong>普通版本的函数声明</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template &lt;<span class="class"><span class="keyword">class</span> <span class="title">F</span>, <span class="title">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">future</span>&lt;typename <span class="built_in">std</span>::result_of&lt;F(Args...)&gt;::type&gt; async(F&amp;&amp; f, Args&amp;&amp;... args);</span><br></pre></td></tr></table></figure><p><strong>指定启动策略的重载版本的函数声明</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template &lt;<span class="class"><span class="keyword">class</span> <span class="title">F</span>, <span class="title">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">future</span>&lt;typename <span class="built_in">std</span>::result_of&lt;F(Args...)&gt;::type&gt; async(<span class="built_in">std</span>::launch policy, F&amp;&amp; f, Args&amp;&amp;... args);</span><br></pre></td></tr></table></figure><ul><li><strong>policy</strong>：指定执行策略，可以是 std::launch::async（强制在新线程中执行任务）、std::launch::deferred（延迟执行任务，直到调用 std::future::get 或 std::future::wait）、或者这两者的位或组合。</li><li><strong>f</strong>：要异步执行的函数或可调用对象。</li><li><strong>args</strong>：传递给 f 的参数。</li></ul><p><strong>返回值是</strong>： <code>std::future</code> 类型的对象，它持有异步任务的结果。</p><p><strong>示例代码</strong>:</p><p><strong>异步执行任务</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">compute</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 启动异步任务，自动选择执行策略</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="type">int</span>&gt; result = <span class="built_in">std</span>::async(compute, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 做一些其他的事情...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取异步任务的结果，如果任务尚未完成，则这里会阻塞等待</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The result is: &quot;</span> &lt;&lt; result.get() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用执行策略</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Task runs in a thread.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 强制在新线程中启动异步任务</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="type">void</span>&gt; f1 = <span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::async, task);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 延迟执行任务，直到调用 get() 或 wait()</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="type">void</span>&gt; f2 = <span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::deferred, task);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此时，第一个任务已经在新线程中执行</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第二个任务将在调用 get() 或 wait() 时在当前线程(主线程)中执行</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 等待第一个任务完成</span></span><br><span class="line">    f1.get();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 启动第二个任务，并等待它完成</span></span><br><span class="line">    f2.get();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结</strong>:</p><p><code>std::async</code> 提供了一种便捷的方式来执行异步任务，无需直接处理线程的创建和管理。通过返回一个 <code>std::future</code> 对象，它允许以线程安全的方式访问异步任务的结果。使用 <code>std::async</code> 可以使并发编程变得更简单、更直观。</p><h4 id="线程局部存储（Thread-Local-Storage，TLS）"><a href="#线程局部存储（Thread-Local-Storage，TLS）" class="headerlink" title="线程局部存储（Thread Local Storage，TLS）"></a>线程局部存储（Thread Local Storage，TLS）</h4><p>C++11 引入了线程局部存储（Thread Local Storage，TLS），允许数据在每个线程中都有自己的独立实例。这意味着每个线程都有自己的数据副本，修改一个线程中的数据不会影响到其他线程中的相同数据。这是通过<code>thread_local</code>关键字来实现的，它指定了变量的存储期为线程的生命周期。</p><p><strong>语法</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">thread_local</span> Type variableName = initialValue;</span><br></pre></td></tr></table></figure><ul><li><strong>thread_local</strong>：关键字，用于声明线程局部存储变量。</li><li><strong>Type</strong>：变量的类型。</li><li><strong>variableName</strong>：变量的名称。</li><li><strong>initialValue</strong>（可选）：变量的初始值。</li></ul><p><strong>示例代码</strong>：</p><p>以下是一个展示如何使用<code>thread_local</code>关键字的简单示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个线程局部变量</span></span><br><span class="line"><span class="keyword">thread_local</span> <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">incrementCounter</span><span class="params">(<span class="type">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; threadName)</span> &#123;</span><br><span class="line">    ++counter; <span class="comment">// 访问和修改线程局部变量</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Counter in &quot;</span> &lt;&lt; threadName &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; counter &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::thread <span class="title function_">t1</span><span class="params">([&amp;]() &#123;</span></span><br><span class="line"><span class="params">        incrementCounter(<span class="string">&quot;t1&quot;</span>);</span></span><br><span class="line"><span class="params">        incrementCounter(<span class="string">&quot;t1&quot;</span>);</span></span><br><span class="line"><span class="params">    &#125;)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::thread <span class="title function_">t2</span><span class="params">([&amp;]() &#123;</span></span><br><span class="line"><span class="params">        incrementCounter(<span class="string">&quot;t2&quot;</span>);</span></span><br><span class="line"><span class="params">        incrementCounter(<span class="string">&quot;t2&quot;</span>);</span></span><br><span class="line"><span class="params">    &#125;)</span>;</span><br><span class="line"></span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，counter是一个线程局部存储变量，因为它前面有<code>thread_local</code>关键字。这意味着每个线程调用 incrementCounter 函数时，都会修改它自己的 counter 副本，而不是共享一个全局 counter。因此，尽管 incrementCounter 函数在两个不同的线程中都被调用了两次，每个线程的输出将独立地显示 counter 从1递增到2，证明每个线程都有自己的 counter 副本。</p><p><strong>总结</strong>:</p><p>使用 <code>thread_local</code> 声明的变量为每个线程提供了一个独立的变量副本，这有助于减少对全局状态的依赖，从而使代码在并发环境中更安全、更容易理解。线程局部存储特别适用于保持线程的状态或避免不必要的锁争用，提高程序的效率和性能。</p><h3 id="函数包装器（function-wrapper）"><a href="#函数包装器（function-wrapper）" class="headerlink" title="函数包装器（function wrapper）"></a>函数包装器（function wrapper）</h3><p>在C++11中，<code>std::function</code>是一个函数包装器（function wrapper），它提供了一种通用、类型安全的方式来存储和调用任何可调用对象，包括普通函数、Lambda 表达式、函数指针、以及具有 operator() 成员函数的对象（如函数对象或类实例）。</p><h4 id="语法-10"><a href="#语法-10" class="headerlink" title="语法"></a>语法</h4><p><code>std::function</code> 的语法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::function&lt;ReturnType(ArgumentTypes...)&gt;</span><br></pre></td></tr></table></figure><p>其中 <code>ReturnType</code> 是可调用对象返回的类型，<code>ArgumentTypes...</code> 是可调用对象接受的参数类型列表。</p><p><strong>示例代码</strong>:</p><p><strong>1. 存储和调用普通函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; func = print;</span><br><span class="line">    func(<span class="number">10</span>);  <span class="comment">// 输出：10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 存储和调用Lambda表达式</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; add = [](<span class="type">int</span> a, <span class="type">int</span> b) &#123; <span class="keyword">return</span> a + b; &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;3 + 4 = &quot;</span> &lt;&lt; add(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出：3 + 4 = 7</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 存储和调用成员函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">triple</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span> * x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    MyClass obj;</span><br><span class="line">    <span class="built_in">std</span>::function&lt;<span class="type">int</span>(MyClass&amp;, <span class="type">int</span>)&gt; func = &amp;MyClass::triple;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;3 tripled is &quot;</span> &lt;&lt; func(obj, <span class="number">3</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出：3 tripled is 9</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4. 存储和调用函数对象</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Adder</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; func = Adder();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;1 + 2 = &quot;</span> &lt;&lt; func(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出：1 + 2 = 3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h4><p><code>std::function</code> 是 C++11 提供的一个非常灵活的机制，它使得函数的存储、传递和调用变得非常简单和统一。无论是普通函数、成员函数、Lambda 表达式还是函数对象，都可以用 <code>std::function</code> 来处理。这种统一的接口使得编写接受函数作为参数的泛型代码变得更加容易和直观。</p><h3 id="绑定器（std-bind）"><a href="#绑定器（std-bind）" class="headerlink" title="绑定器（std::bind）"></a>绑定器（std::bind）</h3><p>C++11标准引入了<code>std::bind</code>，这是一个非常有用的函数适配器，它位于<code>&lt;functional&gt;</code>头文件中。<code>std::bind</code>可以被用来将一个函数或可调用对象（如函数指针、成员函数指针、Lambda表达式、函数对象等）与其参数绑定，生成一个新的可调用对象。这意味着你可以预设某些参数的值，创建一个新的函数版本，这个新版本只需要剩余的参数即可被调用。</p><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> newCallable = <span class="built_in">std</span>::bind(callable, arg1, arg2, ..., argN);</span><br></pre></td></tr></table></figure><ul><li>callable：原始的可调用对象，可以是函数指针、成员函数指针、Lambda 表达式或其他函数对象。</li><li>arg1, arg2, …, argN：要绑定的参数列表，可以是具体的值或引用，也可以是 <code>std::placeholders::_1</code>, <code>std::placeholders::_2</code>, … 来占位，这表示该位置的参数将在新生成的可调用对象被调用时指定。</li></ul><p><strong>示例</strong>:</p><p><strong>1. 绑定普通函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> n1, <span class="type">int</span> n2, <span class="type">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; str)</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n1 &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; n2 &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; str &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">auto</span> f = <span class="built_in">std</span>::bind(print, <span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    f(); <span class="comment">// 输出：1, 2, Hello</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 使用占位符</strong></p><p>使用 <code>std::placeholders</code> 中的占位符，可以在绑定时留下未指定的参数，这些参数需要在新可调用对象被调用时提供：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> n1, <span class="type">int</span> n2, <span class="type">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; str)</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n1 &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; n2 &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; str &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    using namespace <span class="built_in">std</span>::placeholders; <span class="comment">// 对于 _1, _2, _3...</span></span><br><span class="line">    <span class="keyword">auto</span> f = <span class="built_in">std</span>::bind(print, _2, _1, <span class="string">&quot;Bound&quot;</span>);</span><br><span class="line">    f(<span class="number">3</span>, <span class="number">5</span>); <span class="comment">// 输出：5, 3, Bound</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 绑定类的成员函数</strong></p><p>对于类的成员函数，<code>std::bind</code> 也能够被用来绑定，但需要提供<strong>成员函数的地址</strong>作为第一个参数，而第二个参数是<strong>要绑定的对象的指针或引用</strong>，之后的参数则是成员函数的参数，这些参数可以是具体的值，也可以是占位符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">memberFunc</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Member function called with &quot;</span> &lt;&lt; x &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    MyClass obj;</span><br><span class="line">    <span class="keyword">auto</span> f = <span class="built_in">std</span>::bind(&amp;MyClass::memberFunc, &amp;obj, <span class="number">100</span>);</span><br><span class="line">    f(); <span class="comment">// 输出：Member function called with 100</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结-5"><a href="#总结-5" class="headerlink" title="总结:"></a>总结:</h4><p><code>std::bind</code> 是 C++11 引入的一个功能强大的工具，它使得函数调用更加灵活，允许预先绑定参数，创建新的可调用对象。但在 C++11 以后，<code>Lambda 表达式</code>因其更简洁的语法和更好的性能，通常被推荐为更好的替代方案。</p><h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><p>C++11 引入了几种智能指针类型，这些智能指针主要存在于 <code>&lt;memory&gt;</code> 头文件中，它们自动管理内存，帮助避免内存泄露，使得资源管理更加安全和容易。智能指针的类型包括 <code>std::unique_ptr</code>、<code>std::shared_ptr</code> 和 <code>std::weak_ptr</code>。</p><h4 id="std-unique-ptr"><a href="#std-unique-ptr" class="headerlink" title="std::unique_ptr"></a>std::unique_ptr</h4><p><code>std::unique_ptr</code>是一种独占所有权的智能指针，确保同一时刻只有一个智能指针实例可以指向一个给定的对象。当<code>std::unique_ptr</code>被销毁时，它所指向的对象也会被销毁。</p><p><strong>语法</strong>：</p><p>创建 <code>std::unique_ptr</code> 的基本语法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Type&gt; <span class="title function_">ptr</span><span class="params">(new Type(arguments))</span>;</span><br></pre></td></tr></table></figure><p><strong>主要特性</strong>:</p><ul><li><strong>独占所有权</strong>：一个 std::unique_ptr 同时只能拥有一个对象的所有权。</li><li><strong>自动资源管理</strong>：std::unique_ptr 负责自动释放其所拥有的对象。</li><li><strong>不可复制</strong>：为保证资源独占性，std::unique_ptr 不能被复制，但可以被移动，从而转移资源所有权。</li></ul><p><strong>示例代码</strong>:</p><p>创建和使用 <code>std::unique_ptr</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    MyClass() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;MyClass created\n&quot;</span>; &#125;</span><br><span class="line">    ~MyClass() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;MyClass destroyed\n&quot;</span>; &#125;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Doing something\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;MyClass&gt; <span class="title function_">myPtr</span><span class="params">(new MyClass())</span>;</span><br><span class="line">    myPtr-&gt;doSomething();</span><br><span class="line">    <span class="comment">// 当 myPtr 离开作用域时，MyClass 的实例会自动被销毁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这个例子中，我们通过 new MyClass() 显式地创建了一个 MyClass 的实例，并将其传递给 <code>std::unique_ptr&lt;MyClass&gt;</code> 的构造函数来初始化 myPtr。</p><p>转移 <code>std::unique_ptr</code> 的所有权:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;MyClass&gt; <span class="title function_">ptr1</span><span class="params">(new MyClass())</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;MyClass&gt; ptr2 = <span class="built_in">std</span>::move(ptr1);</span><br><span class="line"><span class="comment">// 现在 ptr2 拥有 MyClass 实例的所有权，而 ptr1 为空（nullptr）</span></span><br></pre></td></tr></table></figure><p>在这个例子中，使用 std::move 将 ptr1 的所有权转移给 ptr2。之后，ptr1 变为 nullptr。</p><p>从 <code>C++14</code> 开始，推荐使用 <code>std::make_unique</code> 函数来创建 <code>std::unique_ptr</code>，因为这种方式更安全，可以防止潜在的内存泄漏：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> ptr = <span class="built_in">std</span>::make_unique&lt;Type&gt;(arguments);</span><br></pre></td></tr></table></figure><h4 id="std-shared-ptr"><a href="#std-shared-ptr" class="headerlink" title="std::shared_ptr"></a>std::shared_ptr</h4><p><code>std::shared_ptr</code> 是一种引用计数的智能指针，也称共享型智能指针，它允许多个 std::shared_ptr 实例共享同一个对象的所有权。当最后一个拥有对象的 std::shared_ptr 被销毁或重置时，对象会被自动删除。</p><p><strong>语法</strong>：</p><p>使用构造函数创建 <code>std::shared_ptr</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Type&gt; <span class="title function_">ptr</span><span class="params">(new Type(args...))</span>;</span><br></pre></td></tr></table></figure><p>也可以使用 <code>std::make_shared</code> 模板函数来创建<code>std::shared_ptr</code>， <code>std::make_shared</code>函数在C++11 引入的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> ptr = <span class="built_in">std</span>::make_shared&lt;Type&gt;(args...);</span><br></pre></td></tr></table></figure><ul><li><strong>Type</strong>：要创建的对象的类型。</li><li><strong>args</strong>：传递给对象构造函数的参数列表。</li></ul><p><strong>代码示例</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    MyClass() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;MyClass created\n&quot;</span>; &#125;</span><br><span class="line">    ~MyClass() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;MyClass destroyed\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// std::shared_ptr&lt;MyClass&gt; sharedPtr1(new MyClass());</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;MyClass&gt; sharedPtr1 = <span class="built_in">std</span>::make_shared&lt;MyClass&gt;();</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;MyClass&gt; sharedPtr2 = sharedPtr1; <span class="comment">// 共享所有权</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Inside block\n&quot;</span>;</span><br><span class="line">    &#125; <span class="comment">// sharedPtr2 被销毁，对象不会被删除，因为 sharedPtr1 仍然存在</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Outside block\n&quot;</span>;</span><br><span class="line">&#125; <span class="comment">// sharedPtr1 被销毁，对象现在被删除</span></span><br></pre></td></tr></table></figure><h4 id="std-weak-ptr"><a href="#std-weak-ptr" class="headerlink" title="std::weak_ptr"></a>std::weak_ptr</h4><p><code>std::weak_ptr</code>是一种非拥有（弱）引用计数的智能指针，它指向由某个 <code>std::shared_ptr</code> 所管理的对象。它不会增加对象的引用计数，这样就避免了潜在的循环引用问题。</p><p><strong>语法</strong>：</p><p>你可以通过从一个 std::shared_ptr 或另一个 std::weak_ptr 创建一个 std::weak_ptr：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::weak_ptr&lt;Type&gt; <span class="title function_">weakPtr</span><span class="params">(sharedPtr)</span>;</span><br></pre></td></tr></table></figure><p><strong>示例代码</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span> <span class="comment">// 前向声明</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;B&gt; bPtr;</span><br><span class="line">    ~A() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;A destroyed\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">std</span>::weak_ptr&lt;A&gt; aPtr; <span class="comment">// 使用 weak_ptr 解决循环引用</span></span><br><span class="line">    ~B() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;B destroyed\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;A&gt; <span class="title function_">a</span><span class="params">(new A())</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;B&gt; <span class="title function_">b</span><span class="params">(new B())</span>;</span><br><span class="line">    a-&gt;bPtr = b;</span><br><span class="line">    b-&gt;aPtr = a; <span class="comment">// B 持有 A 的弱引用，不增加引用计数</span></span><br><span class="line">&#125; <span class="comment">// a 和 b 能够正确被销毁，避免了循环引用导致的内存泄露</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这个示例中，A 和 B 相互引用。如果它们都使用 std::shared_ptr 进行引用，则会创建循环引用，导致对象无法被正确销毁。通过让 B 中的 A 引用成为 std::weak_ptr，我们打破了循环引用，使对象能够在不再被需要时正确地被销毁。</p><h4 id="总结-6"><a href="#总结-6" class="headerlink" title="总结:"></a>总结:</h4><p><code>std::shared_ptr 和 std::weak_ptr</code> 提供了强大的内存管理功能，帮助避免了内存泄露和循环引用问题。std::shared_ptr 通过引用计数机制管理对象生命周期，而 std::weak_ptr 允许对这些对象进行弱引用，这对于实现如缓存、观察者模式等功能非常有用。</p><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><h4 id="noexcept-关键字"><a href="#noexcept-关键字" class="headerlink" title="noexcept 关键字"></a>noexcept 关键字</h4><p><code>noexcept</code> 是 C++11 引入的一个关键字，用于指定函数不会抛出异常。它有两种主要用法：<strong>一种是作为异常规范</strong>，用来标明函数不会抛出任何异常；<strong>另一种是作为运算符</strong>，用来检查表达式是否可能抛出异常。</p><p><strong>作为异常规范</strong></p><p>当 <code>noexcept</code> 用作异常规范时，它直接跟在函数声明的参数列表之后。这表明函数保证不抛出任何异常。如果函数违反了这一保证，即它抛出了异常，程序将调用 <code>std::terminate</code>，通常会导致程序终止。</p><p><strong>语法</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">function</span><span class="params">()</span> noexcept;</span><br></pre></td></tr></table></figure><p><strong>示例</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">noThrow</span><span class="params">()</span> noexcept &#123;</span><br><span class="line">    <span class="comment">// 这个函数保证不会抛出异常</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        noThrow(); <span class="comment">// 安全调用，不会抛出异常</span></span><br><span class="line">    &#125; catch (...) &#123;</span><br><span class="line">        <span class="comment">// 这里不会被执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>作为运算符</strong></p><p><code>noexcept</code> 运算符用来检查一个表达式是否保证不抛出异常。它的结果是一个编译时的布尔值，如果表达式保证不抛出异常，结果为 <code>true</code>，否则为 <code>false</code>。</p><p><strong>语法</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">noexcept(expression)</span><br></pre></td></tr></table></figure><p><strong>示例</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mayThrow</span><span class="params">()</span> &#123;</span><br><span class="line">    throw <span class="built_in">std</span>::runtime_error(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">noThrow</span><span class="params">()</span> noexcept &#123;</span><br><span class="line">    <span class="comment">// 不会抛出异常</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::boolalpha;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;mayThrow() noexcept? &quot;</span> &lt;&lt; noexcept(mayThrow()) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: false</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;noThrow() noexcept? &quot;</span> &lt;&lt; noexcept(noThrow()) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  <span class="comment">// 输出: true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>noexcept 规范和 noexcept 运算符的区别</strong>:</p><ul><li><strong>noexcept 规范</strong>：用来标明一个函数不会抛出任何异常。如果函数声明为 noexcept 但抛出了异常，程序将调用 std::terminate。</li><li><strong>noexcept 运算符</strong>：用来检查一个表达式是否保证不抛出异常。这对于模板编程和泛型编程中根据是否可能抛出异常来进行不同的代码路径优化特别有用。</li></ul><p>使用 noexcept 的优势:</p><ul><li><strong>性能优化</strong>：编译器可以对标记为 noexcept 的函数进行更多优化，因为它知道这些函数不会抛出异常。</li><li><strong>异常安全保证</strong>：通过明确指出哪些函数是不会抛出异常的，可以帮助编写更清晰、更健壮的代码。</li></ul><p>总之，<code>noexcept</code>是 C++11 引入的一个重要特性，它提高了异常安全性，并且在编写需要异常保证的函数时提供了更多的灵活性。</p><h4 id="异常传递工具"><a href="#异常传递工具" class="headerlink" title="异常传递工具"></a>异常传递工具</h4><p>在 C++11 中，引入了一组异常传递工具，允许在程序的不同部分之间传递异常信息。这些工具主要包括 <code>std::exception_ptr</code>、<code>std::current_exception</code> 和 <code>std::rethrow_exception</code>，它们定义在 <code>&lt;exception&gt; </code>头文件中。这些机制特别适用于多线程编程，其中异常可能在一个线程中抛出并需要在另一个线程中被捕获和处理。</p><p><strong>std::exception_ptr</strong></p><p><code>std::exception_ptr</code> 是一个智能指针，用于存储和传递异常对象的信息。它可以捕获任何抛出的异常，并允许在稍后的时间点重新抛出该异常，无论异常的类型如何。</p><p><strong>std::current_exception</strong></p><p><code>std::current_exception</code> 用于捕获当前抛出的异常，并返回一个 std::exception_ptr，指向该异常对象的拷贝。如果当前没有异常被抛出，它返回一个空的 std::exception_ptr。</p><p><strong>std::rethrow_exception</strong></p><p><code>std::rethrow_exception</code> 接受一个 std::exception_ptr 作为参数，并重新抛出由该指针所指向的异常。这允许在异常被捕获后的任何时间点重新抛出相同的异常。</p><p><strong>示例代码</strong>：</p><p>下面的代码演示了如何使用这些异常传递工具来捕获、存储、传递和重新抛出异常：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">processException</span><span class="params">(<span class="built_in">std</span>::exception_ptr eptr)</span> &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        <span class="keyword">if</span> (eptr) &#123;</span><br><span class="line">            <span class="built_in">std</span>::rethrow_exception(eptr); <span class="comment">// 重新抛出异常</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (<span class="type">const</span> <span class="built_in">std</span>::exception&amp; e) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Handled exception: &quot;</span> &lt;&lt; e.what() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::exception_ptr eptr;</span><br><span class="line">    </span><br><span class="line">    try &#123;</span><br><span class="line">        throw <span class="built_in">std</span>::runtime_error(<span class="string">&quot;A runtime error occurred&quot;</span>);</span><br><span class="line">    &#125; catch (...) &#123;</span><br><span class="line">        eptr = <span class="built_in">std</span>::current_exception(); <span class="comment">// 捕获并存储当前异常</span></span><br><span class="line">    &#125;</span><br><span class="line">    processException(eptr); <span class="comment">// 处理存储的异常</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在这个示例中</strong>：</p><ul><li>首先，在 main 函数中，一个 std::runtime_error 异常被抛出。</li><li>接着使用 catch (…) 捕获这个异常，并通过调用 std::current_exception 将其存储在 std::exception_ptr 中。</li><li>然后，将这个 std::exception_ptr 传递给 processException 函数。</li><li>在 processException 函数中，使用 std::rethrow_exception 重新抛出异常，然后在另一个 catch 块中捕获并处理它。</li></ul><p>重新抛出异常而不是直接处理，主要是为了：</p><ul><li><strong>保持灵活性</strong>：可以在更合适的地方或时间处理异常。</li><li><strong>保存信息</strong>：保留完整的异常信息，便于后续调试和诊断。</li><li><strong>统一处理</strong>：方便在程序的一个集中地点处理所有异常。</li></ul><p>这套异常传递工具为异常的传递和处理提供了极大的灵活性，尤其是在复杂的程序结构或多线程环境中。</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>本篇文章旨在为热衷于掌握 C++11 新特性的朋友们提供一份实用的学习指南。通过介绍各项新特性并辅以实际代码示例，希望初学者能够不仅理解这些特性背后的概念，还能<strong>学会如何在实际项目中应用它们</strong>。</p><p>C++11 的新特性覆盖了<strong>语言核心和标准库</strong>的方方面面，从简化代码书写、提高性能，到增强代码的安全性和可读性，接下来我们简单来回顾下上面所讲的。</p><ul><li>自动类型推断 (auto 和 decltype) 使得变量声明更加简洁，让编译器为我们做更多的工作。</li><li>基于范围的 for 循环 让遍历容器和序列变得更加直观。</li><li>统一的初始化方式 和 初始器列表 为各种对象和容器的初始化提供了一致的语法。</li><li>智能指针（如 std::unique_ptr, std::shared_ptr 和 std::weak_ptr）管理动态分配的内存，使得资源管理更加安全和方便。</li><li>并发编程 特性（包括 std::thread, std::async 等）允许我们更好地利用现代多核处理器的计算能力。</li><li>异常处理 得到增强，noexcept 关键字和新的异常传递工具让异常的处理和传递更加灵活和安全。</li><li>Lambda 表达式 和 函数对象 让编写匿名函数变得简单，为 STL 算法等的使用提供了巨大的便利。</li></ul><h3 id="最后："><a href="#最后：" class="headerlink" title="最后："></a>最后：</h3><p>如果你对 C&#x2F;C++&#x2F;Go 语言学习 + 计算机基础 + Linux编程 + 容器技术等内容感兴趣，不妨关注我的公众号—「跟着小康学编程」。这里会定时更新相关的技术文章，感兴趣的读者可以关注一下：</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png">   </p><p>另外，小康最近新创建了一个技术交流群，大家如果在阅读的过程中有遇到问题或者有不理解的地方，欢迎大家加群询问或者评论区询问，我能解决的都尽可能给大家回复。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程语言学习 </category>
          
          <category> C++ 编程教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11 新特性 </tag>
            
            <tag> Modern C++ </tag>
            
            <tag> auto 关键字 </tag>
            
            <tag> Lambda 表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何快速学习 C 语言？</title>
      <link href="/how-to-learn-C/"/>
      <url>/how-to-learn-C/</url>
      
        <content type="html"><![CDATA[<p>大家好，我是小康，今天我们来聊下如何学习 C 语言。</p><p>C 语言，强大而灵活，是许多现代编程语言的基石。本文将带你快速了解 C语言 的基础知识，无论你是编程新手还是希望回顾基础，这里都有你需要的。</p><p>初学者在开始学习 C 语言的时候，往往不知道怎样高效的学习这门课，网上很多人都会推荐去看各种 C 语言书籍，我觉得没必要去看那么多，贪多嚼不烂！为了让更多初学的朋友快速入门 C 语言，我这里将 C 的各个知识点进行了汇总，并附有代码示例，以便大家理解，掌握这些就可以啦。如果你时间比较充足，可以看<strong>丹尼斯·里奇的《C程序设计语言》</strong> 这本书，再搭配浙大<strong>翁恺</strong>的 C 语言课程：<a href="https://www.bilibili.com/video/BV1Ls411w7rx/?spm_id_from=333.337.search-card.all.click&vd_source=404f52a7ebbf2477ea859f9609a15c65">C语言程序设计 浙江大学：翁恺_哔哩哔哩_bilibili</a></p><p><strong>最佳的学习方法就是</strong>：根据<strong>我的知识点</strong>来看丹尼斯·里奇的《C程序设计语言》，再加上翁恺的 C 语言课程，搭配学习，效果最好。如果你认为自己自学能力很好或者时间有限，那么完全不需要看视频，本篇文章已经囊括了全部的知识点。</p><p>废话不多说了，直接带你快速入门 C 语言编程。</p><p><img src="/images/C%E8%AF%AD%E8%A8%80/1.png"></p><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h3 id="1-标识符和关键字"><a href="#1-标识符和关键字" class="headerlink" title="1.标识符和关键字"></a>1.标识符和关键字</h3><p>标识符用于<strong>变量、函数</strong>的名称。规则：由字母、数字、下划线组成，但不以数字开头。</p><p>关键字是 C 语言中已定义的特殊单词，如 <strong>int、return</strong> 等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line"><span class="type">int</span> variable; <span class="comment">// &#x27;int&#x27; 是关键字, &#x27;variable&#x27; 是标识符</span></span><br></pre></td></tr></table></figure><h3 id="2-变量和常量"><a href="#2-变量和常量" class="headerlink" title="2.变量和常量"></a>2.变量和常量</h3><p>变量是可以改变值的标识符。</p><p>常量是一旦定义，其值不可改变的标识符。常量使用 <code>const</code>来定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line"><span class="type">int</span> age = <span class="number">25</span>;       <span class="comment">// 定义变量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_AGE = <span class="number">99</span>; <span class="comment">// 定义常量</span></span><br></pre></td></tr></table></figure><h3 id="3-运算符和表达式"><a href="#3-运算符和表达式" class="headerlink" title="3.运算符和表达式"></a>3.运算符和表达式</h3><p>在 C 语言中，运算符是用于执行特定数学和逻辑计算的符号。运算符可以根据它们的功能和操作数的数量被分为几个不同的类别。</p><h4 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h4><p>这些运算符用于执行基本的数学计算。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ 加法</span><br><span class="line">- 减法</span><br><span class="line">* 乘法</span><br><span class="line">/ 除法</span><br><span class="line">% 取余（模运算，只适用于整数）</span><br></pre></td></tr></table></figure><h4 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h4><p>关系运算符用于比较两个值之间的大小关系。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">== 等于</span><br><span class="line">!= 不等于</span><br><span class="line">&gt; 大于</span><br><span class="line">&lt; 小于</span><br><span class="line">&gt;= 大于等于</span><br><span class="line">&lt;= 小于等于</span><br></pre></td></tr></table></figure><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><p>逻辑运算符用于连接多个条件（布尔值）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;&amp; 逻辑与</span><br><span class="line">|| 逻辑或</span><br><span class="line">! 逻辑非</span><br></pre></td></tr></table></figure><h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h4><p>赋值运算符用于将值分配给变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">= 简单赋值</span><br><span class="line">+= 加后赋值</span><br><span class="line">-= 减后赋值</span><br><span class="line">*= 乘后赋值</span><br><span class="line">/= 除后赋值</span><br><span class="line">%= 取余后赋值</span><br></pre></td></tr></table></figure><h4 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h4><p>位运算符对整数的二进制表示进行操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&amp; 位与</span><br><span class="line">| 位或</span><br><span class="line">^ 位异或</span><br><span class="line">~ 位非</span><br><span class="line">&lt;&lt; 左移</span><br><span class="line">&gt;&gt; 右移</span><br></pre></td></tr></table></figure><h4 id="递增和递减运算符"><a href="#递增和递减运算符" class="headerlink" title="递增和递减运算符"></a>递增和递减运算符</h4><p>这些运算符用于增加或减少变量的值。此类运算符都只作用于一个操作数，因此也被称之为一元运算符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">++ 递增运算符</span><br><span class="line">-- 递减运算符</span><br></pre></td></tr></table></figure><h4 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h4><p>C 语言提供了一个三元运算符用于基于条件选择两个值之一。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">? : 条件运算符</span><br></pre></td></tr></table></figure><p>下面是一些使用这些运算符的简单示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> result;</span><br><span class="line"></span><br><span class="line">result = a + b; <span class="comment">// 加法</span></span><br><span class="line">result = a &gt; b ? a : b; <span class="comment">// 条件运算符，选择a和b之间的较大者</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line">flag = !flag; <span class="comment">// 逻辑非，flag的值变为0</span></span><br><span class="line"></span><br><span class="line">result = a &amp; b; <span class="comment">// 位与运算</span></span><br><span class="line"></span><br><span class="line">a++; <span class="comment">// 递增a的值</span></span><br></pre></td></tr></table></figure><p>表达式是<strong>运算符和操作数</strong>组合成的序列。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line"><span class="type">int</span> sum = <span class="number">10</span> + <span class="number">5</span>; <span class="comment">// &#x27;+&#x27; 是运算符, &#x27;10 + 5&#x27; 是表达式,10，5 是操作数</span></span><br></pre></td></tr></table></figure><h3 id="4-语句"><a href="#4-语句" class="headerlink" title="4.语句"></a>4.语句</h3><p>C语言中的<strong>语句</strong>是构成程序的<strong>基本单位</strong>，用于表达特定的操作或逻辑。它们可以控制程序的流程、执行计算、调用函数等。语句以分号（;）结束，形成了程序的执行步骤。</p><p> C 语言的语句可以分为以下几类：</p><h4 id="表达式语句："><a href="#表达式语句：" class="headerlink" title="表达式语句："></a>表达式语句：</h4><p>最常见的语句，执行一个操作，如赋值、函数调用等，并以分号结束。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = b + c;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello, World!\n&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="复合语句（块）"><a href="#复合语句（块）" class="headerlink" title="复合语句（块）"></a>复合语句（块）</h4><p>由花括号{}包围的一系列语句和声明，允许将多个语句视为单个语句序列。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h4><p>根据表达式的真假来执行不同的代码块。</p><ul><li><p>if语句：是最基本的条件语句，根据条件的真假来执行相应的代码块。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    <span class="comment">// 条件为真时执行</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 条件为假时执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>switch语句</strong>：根据表达式的值选择多个代码块之一执行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(expression) &#123;</span><br><span class="line">    <span class="keyword">case</span> constant1:</span><br><span class="line">        <span class="comment">// 表达式等于 constant1 时执行</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> constant2:</span><br><span class="line">        <span class="comment">// 表达式等于 constant2 时执行</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// 无匹配时执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h4><p>重复执行一段代码直到给定的条件不满足。</p><ul><li><p><strong>while循环</strong>：先判断条件，条件满足则执行循环体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (condition) &#123;</span><br><span class="line">    <span class="comment">// 条件为真时执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>do-while循环</strong>：先执行一次循环体，然后判断条件。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// 至少执行一次</span></span><br><span class="line">&#125; <span class="keyword">while</span> (condition);</span><br></pre></td></tr></table></figure><ul><li><strong>for循环</strong>：在循环开始时初始化变量，然后判断条件，最后在每次循环结束时执行更新表达式。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (initialization; condition; increment) &#123;</span><br><span class="line">         <span class="comment">// 条件为真时执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 示例：</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="跳转语句"><a href="#跳转语句" class="headerlink" title="跳转语句"></a>跳转语句</h4><p>提供了改变代码执行顺序的能力。</p><ul><li><strong>break语句</strong>：用于立即退出最近的<code>switch</code>或循环（<code>while</code>、<code>do-while</code>、<code>for</code>）语句。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">5</span>) </span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// 当 i 等于5时退出循环 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>continue语句</strong>：跳过当前循环的剩余部分，并继续下一次循环的执行（仅适用于<code>while</code>、<code>do-while</code>、<code>for</code>循环）。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">5</span>) <span class="keyword">continue</span>; <span class="comment">// 当i等于5时，跳过当前循环的剩余部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong><code>goto</code>语句</strong>：将控制转移到程序中标记的位置。尽管存在，但建议避免使用<code>goto</code>，因为它使得程序的流程变得难以追踪和理解。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">label:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This is a label.&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">goto</span> label;     </span><br></pre></td></tr></table></figure></li></ul><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>数据类型的一个常见用途就是：<strong>定义变量</strong>。常见的数据类型可以大致分为以下几个类别：</p><h4 id="1-基本类型"><a href="#1-基本类型" class="headerlink" title="1.基本类型"></a>1.基本类型</h4><p><strong>整型</strong>：</p><p>整数类型用于存储整数值，可以是有符号的（可以表示负数）或无符号的（仅表示非负数）。其中 int 是最常用的整数类型。为了适应不同的精度需求和内存大小限制，C语言提供了几种不同大小的整数类型。</p><p><strong>有符号整型</strong>：</p><ul><li>short int 或简写为short，用于存储较小范围的整数。它至少占用16位（2个字节）的存储空间。</li><li>int 是最基本的整数类型，用于存储标准整数。在大多数现代编译器和平台上，它占用32位（4个字节）。</li><li>long int 或简写为 long，用于存储比int更大范围的整数。它至少占用32位，但在一些平台上可能会占用64位（8个字节）。</li><li>long long int 或简写为 long long，是C99标准引入的，用于提供更大范围的整数存储。它保证至少占用64位（8个字节）。</li></ul><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>;         <span class="comment">// 定义一个整形变量，初始值为5</span></span><br><span class="line"><span class="type">long</span> b = <span class="number">100000L</span>;  <span class="comment">// 定义一个长整形变量，初始值为100000</span></span><br></pre></td></tr></table></figure><p><strong>无符号整型</strong>：</p><ul><li><p>unsigned short int 或简写为 unsigned short，专门用于存储较小范围的正整数或零。这种类型至少占用16位（2个字节）的存储空间。</p></li><li><p>unsigned int 是用于存储标准大小的非负整数的基本类型。在大多数现代编译器和平台上，它占用32位（4个字节）。</p></li><li><p>unsigned long int 或简写为 unsigned long，用于存储大范围的非负整数。这种类型至少占用32位，在其他平台上可能占用64位（8个字节）</p></li><li><p>unsigned long long int 或简写为 unsigned long long，是为了在需要非常大范围的正整数时使用的。按照C99标准规定，它至少占用64位（8个字节）。</p></li></ul><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> x = <span class="number">150</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> y = <span class="number">100000UL</span>;</span><br></pre></td></tr></table></figure><p><strong>浮点型:</strong></p><p>浮点类型用于存储实数（小数点数字），包括 float 和 double。</p><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> f = <span class="number">5.25f</span>;</span><br><span class="line"><span class="type">double</span> d = <span class="number">10.75</span>;</span><br></pre></td></tr></table></figure><p><strong>浮点型使用场景</strong>：float 和 double：用于需要表示小数的场景，如科学计算、金融计算等。float 提供了足够的精度，适合大多数应用，而 double 提供了更高的精度，适用于需要非常精确的计算结果的场景。</p><p><strong>布尔类型:</strong><br>布尔类型 bool 用于表示真（true）或假（false）。</p><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> flag = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p><strong>布尔类型使用场景</strong>：bool 类型一般用于逻辑判断，表示条件是否满足。常用于控制语句（如if、while）的条件表达式，或表示函数返回的成功、失败状态。</p><p><strong>枚举类型:</strong><br>枚举（enum）允许定义一组命名的整数常量。使用关键字<code>enum</code>定义枚举类型变量。</p><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">day</span> &#123;</span>sun, mon, tue, wed, thu, fri, sat&#125;;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">day</span> <span class="title">today</span> =</span> mon;</span><br></pre></td></tr></table></figure><p><strong>枚举类型使用场景</strong>：<br>枚举类型 enum 用于定义一组命名的整数常量，使程序更易于阅读和维护。常用于表示状态、选项、配置等固定的集合。</p><h4 id="2-复合类型"><a href="#2-复合类型" class="headerlink" title="2.复合类型:"></a>2.复合类型:</h4><p><strong>结构体</strong></p><p>结构体（struct）允许将多个不同类型的数据项组合成一个类型。使用关键字<code>struct</code>定义结构体。</p><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义 Person 结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义结构体变量 person1</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">person1</span>;</span></span><br></pre></td></tr></table></figure><p><strong>结构体类型使用场景</strong>：用于组合不同类型的数据项，表示具有结构的数据。</p><ul><li><p><strong>表示实体或对象</strong>：用于封装和表示具有多个属性的复杂实体，如人、书籍、产品等。</p></li><li><p><strong>数据记录</strong>：组织和管理具有多个相关字段的数据记录，适用于数据库记录、日志条目等。</p></li><li><p><strong>网络编程</strong>：构造和解析网络协议的数据包，适用于客户端和服务器之间的通信。</p></li><li><p><strong>创建复杂的数据结构</strong>：作为链表、树、图等复杂数据结构的基本构建块，通过指针连接结构体实现。</p></li></ul><p><strong>联合体</strong></p><p>联合体（union）在 C 语言中是一个用于优化内存使用的特殊数据类型，允许在同一内存位置存储不同的数据类型，但任一时刻只能使用其中一个成员。联合体变量使用关键字<code>union</code> 来定义。</p><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Data</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">float</span> f;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Data</span> <span class="title">data</span>;</span></span><br></pre></td></tr></table></figure><p><strong>联合体类型使用场景</strong>：</p><ul><li><p><strong>节省内存</strong>：当程序中的变量可能代表不同类型的数据，但不会同时使用时，联合体能有效减少内存占用。</p></li><li><p><strong>底层编程</strong>：在需要直接与硬件交互，或需要精确控制数据如何存储和解读时，联合体提供了直接访问内存表示的能力。</p></li><li><p><strong>网络通信</strong>：用于根据不同的协议或消息类型解析同一段网络数据。</p></li><li><p><strong>类型转换</strong>：允许以一种数据类型写入联合体，然后以另一种类型读取，实现不同类型之间的快速转换。</p></li></ul><h4 id="3-派生类型："><a href="#3-派生类型：" class="headerlink" title="3.派生类型："></a>3.派生类型：</h4><p><strong>数组</strong></p><p>数组是一种派生类型，它允许存储固定数量的同类型元素。当然，类型可以是多种，整形，浮点型，结构体等类型。在内存中，数组的元素按顺序紧密排列。数组的使用使得数据管理更加方便，尤其是当你需要处理大量<strong>同质数据</strong>时。</p><blockquote><p><strong>同质数据</strong>:具有相同数据类型的元素或值</p></blockquote><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, numbers[<span class="number">0</span>]); <span class="comment">// 输出数组的第一个元素</span></span><br></pre></td></tr></table></figure><p>数组的索引从<code>0</code>开始，<code>numbers[0]</code>表示数组中的第一个元素。</p><p><strong>指针</strong></p><p>指针是存储另一个变量地址的变量。指针在C语言中非常重要，它提供了直接访问内存的能力，使得程序可以通过地址来操作变量。</p><p><strong>声明和使用指针</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> var = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *ptr = &amp;var; <span class="comment">// 声明一个指针 ptr，并将其初始化为 var 的地址</span></span><br></pre></td></tr></table></figure><p>通过指针访问值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;Value of var: %d\n&quot;, *ptr); // 使用解引用操作符*来访问指针指向的值</span><br></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>上面有提到过数组的概念，接下来让我们来详细讲解下数组：</p><p>数组是一种存储固定数量同类型元素的线性集合。在C语言中，这意味着如果你<strong>有一组相同类型的数据</strong>要存储，比如一周内每天的温度，那数组就是你的首选。</p><h3 id="声明与初始化"><a href="#声明与初始化" class="headerlink" title="声明与初始化"></a>声明与初始化</h3><p>声明数组的语法相当直观。比如，你想存储5个整数，可以这样声明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> days[len];</span><br></pre></td></tr></table></figure><p>这里，int表明了数组中元素的类型，days是数组的名称，而[len]则指定了数组可以存储元素的个数，len 必须是数值常量。</p><p>初始化数组可以在声明的同时进行，确保数组中的每个元素都有一个明确的起始值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> days[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure><p>如果数组的大小在初始化时已知，你甚至可以省略大小声明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> days[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure><h3 id="访问与遍历"><a href="#访问与遍历" class="headerlink" title="访问与遍历"></a>访问与遍历</h3><p>数组的元素可以通过索引（或下标）进行访问，索引从<code>0</code>开始，这意味着在上面的 days 数组中，第一个元素是<code>days[0]</code>，最后一个元素是<code>days[4]</code>。</p><p>遍历数组，即访问数组中的每个元素，通常使用循环结构，如for循环：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, days[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><p>多维数组是一种直接在类型声明时定义多个维度的数组。它们通常用于存储具有多个维度的数据，如矩阵或数据表。</p><h4 id="定义和初始化"><a href="#定义和初始化" class="headerlink" title="定义和初始化"></a>定义和初始化</h4><p>多维数组的定义遵循这样的格式：类型 名称[维度1大小][维度2大小]…[维度N大小];</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> matrix[<span class="number">2</span>][<span class="number">3</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这定义了一个2x3的整型矩阵，并进行了初始化。</p><h4 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h4><p>访问多维数组的元素需要提供每一个维度的索引：数组名[索引1][索引2]…[索引N];</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> value = matrix[<span class="number">1</span>][<span class="number">2</span>]; <span class="comment">// 访问第二行第三列的元素</span></span><br></pre></td></tr></table></figure><h3 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h3><p>动态数组提供了一种在运行时确定数组大小的能力，通过动态内存分配函数来实现。</p><h4 id="动态一维数组"><a href="#动态一维数组" class="headerlink" title="动态一维数组:"></a>动态一维数组:</h4><p>动态一维数组通常通过指针和 malloc 或 calloc 函数创建：</p><p>malloc 分配的内存是未初始化的，而 calloc 会将内存初始化为零。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *arr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">10</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 分配10个整数的空间</span></span><br></pre></td></tr></table></figure><h4 id="动态多维数组"><a href="#动态多维数组" class="headerlink" title="动态多维数组:"></a>动态多维数组:</h4><p>动态多维数组的创建稍微复杂，因为需要为每个维度分别进行内存分配：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> **matrix = (<span class="type">int</span>**)<span class="built_in">malloc</span>(<span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>*)); <span class="comment">// 创建2个指针的数组，对应2行</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">    matrix[i] = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 为每行分配3个整数的空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用完动态数组后，必须<strong>手动释放其内存以避免内存泄漏</strong>：</p><h4 id="动态一维数组内存的释放："><a href="#动态一维数组内存的释放：" class="headerlink" title="动态一维数组内存的释放："></a>动态一维数组内存的释放：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">free</span>(arr)</span><br></pre></td></tr></table></figure><h4 id="动态多维数组内存的释放："><a href="#动态多维数组内存的释放：" class="headerlink" title="动态多维数组内存的释放："></a>动态多维数组内存的释放：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">free</span>(matrix[i]); <span class="comment">// 释放每一行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(matrix); <span class="comment">// 最后释放指针数组</span></span><br></pre></td></tr></table></figure><h3 id="数组与函数"><a href="#数组与函数" class="headerlink" title="数组与函数"></a>数组与函数</h3><p>在 C 语言中，数组可以作为参数传递给函数。不过，由于数组在传递时会退化为指向其首元素的指针，我们需要另外传递数组的大小：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="built_in">array</span>[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line"><span class="type">int</span> len = <span class="keyword">sizeof</span>(<span class="built_in">array</span>)/<span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>]); <span class="comment">//计算数组的长度</span></span><br><span class="line">printArray(<span class="built_in">array</span>,len);</span><br><span class="line"><span class="comment">//printArray(array,len) 被调用时，printArray函数形参arr会退化成 int*</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printArray</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组使用场景："><a href="#数组使用场景：" class="headerlink" title="数组使用场景："></a>数组使用场景：</h3><ul><li><strong>固定大小集合</strong>：适用于存储已知数量的数据元素。</li><li><strong>顺序访问和高效索引</strong>：数组元素存储在连续的内存地址中，可以通过索引快速访问。</li><li><strong>多维数据表示</strong>：可以方便地表示多维数据结构，如二维数组表示矩阵。</li></ul><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>在 C 语言中，指针是一种特殊的变量类型，它的值是内存中另一个变量的地址。指针提供了一种方式来间接访问和操作内存中的数据。</p><p>可以把指针想象成一个指向内存中某个位置的箭头。每个变量都占用内存中的一定空间，指针的作用就是记录那个空间的起始地址。</p><h3 id="定义指针"><a href="#定义指针" class="headerlink" title="定义指针"></a>定义指针</h3><p>指针的定义需要指定指针类型，它表明了指针所指向的数据的类型。定义指针的一般形式是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type* pointerName;</span><br></pre></td></tr></table></figure><p>其中 type 是指针所指向的数据的类型，*表示这是一个指针变量，pointerName 是指针变量的名称。</p><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* ptr; <span class="comment">// 定义一个指向int类型数据的指针</span></span><br></pre></td></tr></table></figure><p>这个声明创建了一个名为ptr的指针，它可以指向int类型的数据。开始时，ptr未被初始化，它可能包含任意值（即任意地址）。在使用指针之前，通常会将其初始化为某个变量的地址，或者通过动态内存分配函数分配的内存块的地址。</p><h3 id="指针的初始化"><a href="#指针的初始化" class="headerlink" title="指针的初始化"></a>指针的初始化</h3><p>指针可以通过使用地址运算符 &amp; 来获取变量的地址进行初始化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> var = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* ptr = &amp;var; <span class="comment">// ptr现在指向var</span></span><br></pre></td></tr></table></figure><p>或者，指针也可以被初始化为动态分配的内存地址：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// ptr指向一块新分配的int大小的内存</span></span><br></pre></td></tr></table></figure><h3 id="使用指针"><a href="#使用指针" class="headerlink" title="使用指针"></a>使用指针</h3><h4 id="解引用（Dereferencing）"><a href="#解引用（Dereferencing）" class="headerlink" title="解引用（Dereferencing）"></a>解引用（Dereferencing）</h4><p>通过解引用操作*，可以访问或修改指针所指向的内存位置中存储的数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*ptr = <span class="number">20</span>; <span class="comment">// 修改ptr所指向的内存中的值为20</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,*ptr); <span class="comment">// 输出指针指向的数据</span></span><br></pre></td></tr></table></figure><h4 id="指针运算"><a href="#指针运算" class="headerlink" title="指针运算"></a>指针运算</h4><p>指针的真正强大之处在于它能进行算术运算，这使得通过指针遍历数组和访问数据变得非常高效。</p><ul><li><strong>递增（++）</strong>：指针递增，其值增加了指向类型的大小（如int是4字节）。</li><li><strong>递减（–）</strong>：与递增相反，指针递减会减去指向类型的大小。</li><li><strong>指针的加减</strong>：可以将指针与整数相加或相减，改变其指向。</li></ul><p>指针递增（++）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">10</span>, <span class="number">20</span>&#125;;</span><br><span class="line"><span class="type">int</span> *ptr = arr;</span><br><span class="line">ptr++; <span class="comment">// 现在指向arr[1]</span></span><br></pre></td></tr></table></figure><p>指针递减（–）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptr--; <span class="comment">// 回到arr[0]</span></span><br></pre></td></tr></table></figure><p>指针的加减</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ptr += <span class="number">1</span>; <span class="comment">// 移动到arr[1]</span></span><br><span class="line">ptr -= <span class="number">1</span>; <span class="comment">// 回到arr[0]</span></span><br></pre></td></tr></table></figure><h3 id="指针与数组"><a href="#指针与数组" class="headerlink" title="指针与数组"></a>指针与数组</h3><p>数组名在表达式中会被当作指向其首元素的指针。这意味着数组和指针在很多情况下可以互换使用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> *p = arr; <span class="comment">// 指向数组首元素的指针</span></span><br></pre></td></tr></table></figure><h3 id="指针与函数"><a href="#指针与函数" class="headerlink" title="指针与函数"></a>指针与函数</h3><p>函数参数为指针，通过传递指针给函数，可以让函数直接修改变量的值，而不是在副本上操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">addTen</span><span class="params">(<span class="type">int</span> *p)</span> &#123;</span><br><span class="line">    *p += <span class="number">10</span>; <span class="comment">// 直接修改原始值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="返回指针的函数"><a href="#返回指针的函数" class="headerlink" title="返回指针的函数"></a>返回指针的函数</h3><p>函数也可以返回指针，但要确保指针指向的是静态内存或者是动态分配的内存，避免悬挂指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回静态内存地址</span></span><br><span class="line"><span class="type">int</span>* <span class="title function_">getStaticValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> value = <span class="number">10</span>; <span class="comment">// 静态局部变量</span></span><br><span class="line">    <span class="keyword">return</span> &amp;value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回动态分配内存地址</span></span><br><span class="line"><span class="type">int</span>* <span class="title function_">getDynamicArray</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>*)<span class="built_in">malloc</span>(size * <span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 动态分配内存</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>避免悬挂指针</strong>：</p><p>悬挂指针是指向已经释放或无效内存的指针。如果函数返回了指向局部非静态变量的指针，就会导致悬挂指针的问题，因为局部变量的内存在函数返回后不再有效。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="title function_">getLocalValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">10</span>; <span class="comment">// 局部变量</span></span><br><span class="line">    <span class="keyword">return</span> &amp;value; <span class="comment">// 错误：返回指向局部变量的指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是错误的做法，因为 value 是局部变量，在函数结束时被销毁，返回的指针指向一个已经不存在的内存位置。</p><h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><p>函数指针存储了函数的地址，可以用来动态调用函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数原型</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">greet</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, World!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数指针声明</span></span><br><span class="line"><span class="type">void</span> (*funcPtr)(<span class="type">void</span>) = &amp;greet;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过函数指针调用函数</span></span><br><span class="line">funcPtr();</span><br></pre></td></tr></table></figure><h3 id="指针数组与函数"><a href="#指针数组与函数" class="headerlink" title="指针数组与函数"></a>指针数组与函数</h3><p>指针数组可以用来存储函数指针，实现函数的动态调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义两个简单的函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">world</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;World\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个函数指针数组并初始化</span></span><br><span class="line">    <span class="type">void</span> (*funcPtrs[<span class="number">2</span>])() = &#123;hello, world&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 动态调用函数</span></span><br><span class="line">    funcPtrs[<span class="number">0</span>](); <span class="comment">// 调用hello函数</span></span><br><span class="line">    funcPtrs[<span class="number">1</span>](); <span class="comment">// 调用world函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个示例中，funcPtrs是一个存储函数指针的数组。通过指定索引，我们可以动态地调用hello或world函数。</p><h3 id="多级指针"><a href="#多级指针" class="headerlink" title="多级指针"></a>多级指针</h3><p>多级指针，例如二级指针，是指针的指针。它们在处理多维数组、动态分配的多维数据结构等场景中非常有用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> var = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> *ptr = &amp;var;</span><br><span class="line"><span class="type">int</span> **pptr = &amp;ptr; <span class="comment">// 二级指针</span></span><br></pre></td></tr></table></figure><h3 id="指针使用场景："><a href="#指针使用场景：" class="headerlink" title="指针使用场景："></a>指针使用场景：</h3><ul><li><strong>动态内存管理</strong>：配合malloc、realloc、calloc等函数，实现运行时的内存分配和释放。</li><li><strong>函数参数传递</strong>：允许函数通过指针参数修改调用者中的变量值。</li><li><strong>数组和字符串操作</strong>：通过指针算术运算灵活地遍历和操作数组和字符串。</li><li><strong>构建数据结构</strong>：是实现链表、树、图等复杂数据结构的基础。</li></ul><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>在 C 语言中，字符串是以字符数组的形式存在的，以空字符 <code>\0</code>（ASCII码为<code>0</code>的字符）结尾。这意味着，当 C 语言处理字符串时，它会一直处理直到遇到这个空字符。理解这一点对于正确操作 C 语言中的字符串至关重要。</p><h3 id="声明和初始化字符串"><a href="#声明和初始化字符串" class="headerlink" title="声明和初始化字符串"></a>声明和初始化字符串</h3><p>在 C 语言中，可以使用字符数组来声明和初始化字符串：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> greeting[<span class="number">6</span>] = &#123;<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure><p>更简单的方式是使用<strong>字符串字面量</strong>，编译器会自动在字符串末尾加上\0：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> greeting[] = <span class="string">&quot;Hello&quot;</span>;</span><br></pre></td></tr></table></figure><p>字符串除了使用字符数组来表示还可以用字符指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *greeting = <span class="string">&quot;Hello&quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="字符串的输入和输出"><a href="#字符串的输入和输出" class="headerlink" title="字符串的输入和输出"></a>字符串的输入和输出</h3><p>使用 <code>printf</code> 函数输出字符串，使用%s格式指定符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, greeting);</span><br></pre></td></tr></table></figure><p>使用 <code>scanf</code> 函数读取字符串（注意，scanf在读取字符串时会因空格、制表符或换行符而停止读取）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> var;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;var); <span class="comment">// 输入整型值</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, name); <span class="comment">// 输入字符串</span></span><br><span class="line"><span class="comment">// 不需要&amp;符号，因为数组名本身就是地址</span></span><br></pre></td></tr></table></figure><h3 id="字符串操作函数"><a href="#字符串操作函数" class="headerlink" title="字符串操作函数"></a>字符串操作函数</h3><p>C 标准库（string.h）提供了一系列操作字符串的函数，包括字符串连接、复制、长度计算等。</p><h4 id="字符串复制"><a href="#字符串复制" class="headerlink" title="字符串复制"></a>字符串复制</h4><ul><li>strcpy(destination, source)：复制source字符串到destination。</li><li>strncpy(destination, source, n)：复制最多n个字符从source到destination。</li></ul><h4 id="字符串连接"><a href="#字符串连接" class="headerlink" title="字符串连接"></a>字符串连接</h4><ul><li>strcat(destination, source)：将source字符串追加到destination字符串的末尾。</li><li>strncat(destination, source, n)：将最多n个字符从source字符串追加到destination字符串的末尾。</li></ul><h4 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h4><ul><li>strcmp(str1, str2)：比较两个字符串。如果str1与str2相同，返回<code>0</code>。</li><li>strncmp(str1, str2, n)：比较两个字符串的前n个字符。</li></ul><h4 id="字符串长度"><a href="#字符串长度" class="headerlink" title="字符串长度"></a>字符串长度</h4><ul><li>strlen(str)：返回str的长度，不包括结尾的<code>\0</code>。</li></ul><h4 id="字符串查找"><a href="#字符串查找" class="headerlink" title="字符串查找"></a>字符串查找</h4><ul><li>strchr(str, c)：查找字符c在str中首次出现的位置。</li><li>strrchr(str, c)：查找字符c在str中最后一次出现的位置。</li><li>strstr(haystack, needle)：查找字符串needle在haystack中首次出现的位置。</li><li>strspn(str1, str2)：返回str1中包含的仅由str2中字符组成的最长子串的长度。</li><li>strcspn(str1, str2)：返回str1中不含有str2中任何字符的最长子串的长度。</li><li>strpbrk(str1, str2)：搜索str1中的任何字符是否在str2中出现，返回第一个匹配字符的位置。</li></ul><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li>strdup(str)：复制str字符串，使用malloc动态分配内存（非标准函数，但常见）。</li><li>memset(ptr, value, num)：将ptr开始的前num个字节都用value填充。</li><li>memcpy(destination, source, num)：从source复制num个字节到destination。</li><li>memmove(destination, source, num)：与memcpy相似，但正确处理重叠的内存区域。</li></ul><p>下面是一个简单的示例，展示如何使用部分字符串函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> str1[<span class="number">20</span>] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="type">char</span> str2[<span class="number">20</span>] = <span class="string">&quot;World&quot;</span>;</span><br><span class="line">    <span class="type">char</span> str3[<span class="number">40</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 字符串连接</span></span><br><span class="line">    <span class="built_in">strcpy</span>(str3, str1);</span><br><span class="line">    <span class="built_in">strcat</span>(str3, <span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="built_in">strcat</span>(str3, str2);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str3); <span class="comment">// 输出 &quot;Hello World&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字符串比较</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(str1, str2) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\&quot;%s\&quot; is less than \&quot;%s\&quot;\n&quot;</span>, str1, str2);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 字符串查找</span></span><br><span class="line">    <span class="type">char</span> *p = <span class="built_in">strstr</span>(str3, <span class="string">&quot;World&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (p) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Found \&quot;World\&quot; in \&quot;%s\&quot;\n&quot;</span>, str3);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数是一种让程序结构化的重要方式，允许代码的重用、模块化设计和简化复杂问题。<br>C 语言支持自定义函数和标准库函数。</p><h3 id="函数定义与声明"><a href="#函数定义与声明" class="headerlink" title="函数定义与声明:"></a>函数定义与声明:</h3><p>定义指明了函数的实际代码体（即函数做什么和如何做）。</p><p>声明告诉编译器函数的名称、返回类型和参数（类型和数量），但不定义具体的操作。</p><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">函数声明</span></span><br><span class="line"><span class="comment">int ：函数返回类型， add ： 函数名</span></span><br><span class="line"><span class="comment">int x, int y ：参数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数参数传递"><a href="#函数参数传递" class="headerlink" title="函数参数传递"></a>函数参数传递</h3><ul><li><strong>按值传递</strong>：函数收到参数值的副本。在函数内部对参数的修改不会影响原始数据。</li><li><strong>按指针（地址）传递</strong>：通过传递参数的地址（使用指针），函数内的变化可以影响原始数据。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按值传递</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">changeValue</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    num = <span class="number">100</span>; <span class="comment">// 尝试修改，实际不会影响原始值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">// x的副本被传递</span></span><br><span class="line">    changeValue(x);  <span class="comment">// 函数调用：执行函数</span></span><br><span class="line">    <span class="comment">// x的值不变，仍然是5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按指针（地址）传递</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">changeReference</span><span class="params">(<span class="type">int</span> *num)</span> &#123;</span><br><span class="line">    *num = <span class="number">100</span>; <span class="comment">// 通过指针修改原始值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line">    change(x); <span class="comment">// 传递x的地址</span></span><br><span class="line">    <span class="comment">// x的值现在变成了100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数调用："><a href="#函数调用：" class="headerlink" title="函数调用："></a>函数调用：</h3><p>函数调用是 C 语言中一个核心概念，它允许在程序的任何地方执行一个函数。函数调用的基本过程包括将控制权从调用函数（caller）转移到被调用函数（callee），执行被调用函数的代码体，然后返回控制权给调用函数。</p><h4 id="函数调用过程："><a href="#函数调用过程：" class="headerlink" title="函数调用过程："></a>函数调用过程：</h4><p><strong>1. 参数传递</strong>：当调用函数时，会按照函数定义的参数列表，将实际参数的值（按值传递）或地址（按指针传递）传递给函数。</p><p><strong>2. 执行函数体</strong>：一旦参数被传递，控制权转移到被调用函数，开始执行函数体内的代码。</p><p><strong>3. 返回值</strong>：函数完成其任务后，可以通过 return 语句返回一个值给调用者。如果函数类型为 void，则不返回任何值。</p><p><strong>4. 控制权返回</strong>：函数执行完毕后，控制权返回到调用函数的位置，程序继续执行下一条语句。</p><h3 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h3><p>递归函数是一种直接或间接调用自身的函数。它通常用于解决可以分解为相似子问题的问题。</p><p><strong>示例</strong>：计算阶乘：n！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">factorial</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用场景</strong>：递归在算法领域非常有用，尤其适合处理分治法、快速排序、二叉树遍历等问题。</p><h3 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h3><p>使用 inline 关键字声明的函数，在编译时会将函数体的代码直接插入每个调用点，而不是进行常规的函数调用。这可以减少函数调用的开销，但增加了编译后的代码大小。</p><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; y ? x : y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用场景</strong>：对于那些体积小、调用频繁的函数，使用inline可以减少函数调用的开销，如简单的数学运算和逻辑判断函数。</p><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>函数指针使得 C 语言支持回调函数，即将函数作为参数传递给另一个函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">greet</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, World!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">repeat</span><span class="params">(<span class="type">void</span> (*callbackFunc)(), <span class="type">int</span> times)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; times; i++) &#123;</span><br><span class="line">        callbackFunc(); <span class="comment">// 调用回调函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    repeat(greet, <span class="number">3</span>); <span class="comment">// 将greet函数作为参数传递给repeat函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用场景</strong>：<br>允许库或框架的用户提供自定义代码片段，根据需要在框架内部调用，以实现特定功能。例如，自定义排序函数中的比较操作。</p><h3 id="函数的分类"><a href="#函数的分类" class="headerlink" title="函数的分类:"></a>函数的分类:</h3><ul><li><p><strong>用户定义函数</strong>：由程序员定义的函数，用于执行特定任务。</p></li><li><p><strong>标准库函数</strong>：C 语言标准库提供的函数，常见的标准库函数包括以下几类：</p><p><strong>1. 输入和输出</strong>（stdio.h）：用于格式化输入和输出，如printf和scanf，以及文件操作的fgets和fputs。</p><p><strong>2. 字符串处理</strong>（string.h）：提供字符串操作的基本函数，包括复制(strcpy)、连接(strcat)、长度计算(strlen)和比较(strcmp)。</p><p><strong>3. 数学计算</strong>（math.h）：包括幂函数(pow)、平方根(sqrt)和三角函数(sin, cos, tan)等数学运算。</p><p><strong>4. 内存管理</strong>（stdlib.h）：用于动态内存分配和释放，包括malloc、free和realloc等函数。</p></li></ul><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>在 C 语言中，内存管理是一个核心概念，涉及到动态内存分配、使用和释放。理解如何在C语言中管理内存对于编写高效、可靠的程序至关重要。</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>C语言中的内存大致可以分为两大部分：<strong>静态&#x2F;自动内存分配和动态内存分配</strong>。</p><h4 id="静态内存分配："><a href="#静态内存分配：" class="headerlink" title="静态内存分配："></a>静态内存分配：</h4><p>静态内存分配发生在程序编译时，它为全局变量和静态变量分配固定大小的内存。这些变量在程序启动时被创建，在程序结束时才被销毁。例如，全局变量、static 静态变量都属于这一类。它的生命周期贯穿整个程序执行过程。</p><h4 id="自动内存分配："><a href="#自动内存分配：" class="headerlink" title="自动内存分配："></a>自动内存分配：</h4><p>自动内存分配是指在函数调用时为其局部变量分配栈上的内存。这些局部变量只在函数执行期间存在，函数返回时它们的内存自动被释放。自动内存分配的变量的生命周期仅限于它们所在的函数调用栈帧内。</p><p>简而言之，静态内存分配涉及到整个程序运行期间都存在的变量，而自动内存分配涉及到只在特定函数调用期间存在的局部变量。</p><h4 id="动态内存分配："><a href="#动态内存分配：" class="headerlink" title="动态内存分配："></a>动态内存分配：</h4><p>C语言中的动态内存分配是一种在程序运行时（而不是在编译时）分配和释放内存的机制。这允许程序根据需要分配任意大小的内存块，使得内存使用更加灵活。C 提供了几个标准库函数来管理动态内存，主要包括malloc、calloc、realloc和free。</p><p>下面让我们来看下这几个内存分配函数如何使用？</p><p><code>malloc :</code><br>malloc函数用来分配一块指定大小的内存区域。分配的内存未初始化，可能包含任意数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：size 是要分配的字节大小。</span></span><br><span class="line"><span class="comment">返回值：成功时返回指向分配的内存的指针；如果分配失败，则返回NULL。</span></span><br><span class="line"><span class="comment">注意：malloc 分配的内存内容是未初始化的，数据可能是未知的。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> size)</span>; <span class="comment">// 函数原型</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> *ptr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">5</span>); <span class="comment">// 分配一个5个整数大小的内存块</span></span><br><span class="line"><span class="keyword">if</span> (ptr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">// 使用ptr</span></span><br><span class="line">    <span class="built_in">free</span>(ptr); <span class="comment">// 释放内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>释放内存</strong></p><p>使用 free 函数来释放之前通过malloc、calloc或realloc分配的内存。释放后的内存不能再被访问，否则会导致未定义行为（如程序崩溃）。</p><p>释放内存后，已释放内存的指针称为<strong>悬挂指针</strong>。尝试访问已释放的内存将导致未定义行为。为了避免这种情况，释放内存后应将指针设置为 NULL。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">free</span>(ptr);</span><br><span class="line">ptr = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><p>如果忘记释放已分配的动态内存，这部分内存将无法被再次利用，导致内存泄漏。长时间运行的程序如果频繁泄漏内存，可能会耗尽系统资源。 </p><h4 id="检测和避免"><a href="#检测和避免" class="headerlink" title="检测和避免"></a>检测和避免</h4><p><strong>检测工具</strong>：</p><ul><li><strong>Valgrind</strong>：Linux下一个广泛使用的内存调试工具，可以帮助开发者发现内存泄漏、使用未初始化的内存、访问已释放的内存等问题。</li><li><strong>Visual Leak Detector</strong> (VLD)：专为 Windows 平台开发的内存泄露检测工具，集成于Visual Studio，用于检测基于C&#x2F;C++的应用程序。</li></ul><p><strong>避免策略</strong>：<br>及时释放内存：确保每次malloc或calloc后，相应的内存不再需要时使用 free 释放。</p><h2 id="预处理指令"><a href="#预处理指令" class="headerlink" title="预处理指令"></a>预处理指令</h2><p>C 语言中的预处理指令是在编译之前由预处理器执行的指令。它们不是 C 语言的一部分，而是在编译过程中的一个步骤，用于文本替换、条件编译等。预处理指令以井号（#）开头。</p><p>下面是一些常见的预处理指令及其使用示例：</p><h3 id="include-指令"><a href="#include-指令" class="headerlink" title="#include 指令"></a>#include 指令</h3><p>#include指令用于包含一个源代码文件或标准库头文件。它告诉预处理器在实际编译之前，将指定的文件内容插入当前位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> <span class="comment">// 包含标准输入输出头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myheader.h&quot;</span> <span class="comment">// 包含用户定义的头文件</span></span></span><br></pre></td></tr></table></figure><h3 id="define-指令"><a href="#define-指令" class="headerlink" title="#define 指令"></a>#define 指令</h3><p>#define用于定义宏。它告诉预处理器，将后续代码中所有的宏名称替换为定义的内容。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQUARE(x) ((x) * (x))</span></span><br></pre></td></tr></table></figure><h3 id="undef-指令"><a href="#undef-指令" class="headerlink" title="#undef 指令"></a>#undef 指令</h3><p>#undef 用于取消宏的定义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TABLE_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> TABLE_SIZE <span class="comment">// 取消 TABLE_SIZE 的定义</span></span></span><br></pre></td></tr></table></figure><h3 id="if-else-elif-endif-指令"><a href="#if-else-elif-endif-指令" class="headerlink" title="#if, #else, #elif, #endif 指令"></a>#if, #else, #elif, #endif 指令</h3><p>这些指令用于条件编译。只有当给定的条件为真时，编译器才会编译这部分代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DEBUG</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Debug information\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>#ifdef 和 #ifndef 指令</p><p>#ifdef检查一个宏是否被定义，#ifndef检查一个宏是否未被定义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义宏 DEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Debug mode is on.\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DEBUG</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Debug mode is off.\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="error-和-pragma-指令"><a href="#error-和-pragma-指令" class="headerlink" title="#error 和 #pragma 指令"></a>#error 和 #pragma 指令</h3><p>#error 指令允许程序员在代码中插入一个编译时错误。当预处理器遇到#error指令时，它会停止编译过程，并显示紧跟在#error后面的文本消息。这对于指出代码中的问题、配置错误或不支持的编译环境非常有用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined(_WIN64) || defined(__x86_64__)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> SUPPORTED_PLATFORM</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SUPPORTED_PLATFORM</span></span><br><span class="line">    <span class="meta">#<span class="keyword">error</span> <span class="string">&quot;This code must be compiled on a supported platform.&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>_WIN64和__x86_64__是预定义的宏，它们通常在编译器层面被定义，用于指示特定的平台或架构。<br>这些宏不是在用户的源代码中定义的，而是由编译器根据目标编译平台自动定义。</p><p>#pragma 指令用于提供编译器特定的指令，其行为依赖于使用的编译器。它通常用于控制编译器的特定行为，如禁用警告、优化设置或其他编译器特定的特性。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once  <span class="comment">// 防止头文件内容被多次包含</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize (<span class="string">&quot;O3&quot;</span>) <span class="comment">// 指示GCC编译器使用O3级别的优化</span></span></span><br></pre></td></tr></table></figure><p>下面是一个简单的示例，展示了如何使用预处理指令来控制代码的编译。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG 1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Debugging is enabled.\n&quot;</span>);</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Program is running.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，如果DEBUG被定义，则程序会打印调试信息。这是通过条件编译指令#ifdef实现的。</p><p>C 语言的预处理指令是编写灵活和高效代码的强大工具。通过合理使用预处理指令，可以实现<strong>条件编译、调试开关</strong>等功能，从而提升代码的可维护性和性能。</p><h2 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h2><p>在C语言中，输入和输出（I&#x2F;O）是基于数据流的概念。数据流可以是输入流或输出流，用于从源（如键盘、文件）读取数据或向目标（如屏幕、文件）写入数据。C标准库stdio.h提供了丰富的I&#x2F;O处理函数。</p><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><h4 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h4><p><strong>1. 输入流</strong>：数据从输入源（如键盘、文件）流向程序。</p><p><strong>2. 输出流</strong>：数据从程序流向输出目标（如显示器、文件）。</p><p><strong>3. 标准流</strong></p><ul><li><strong>stdin</strong>：标准输入流，通常对应于键盘输入。</li><li><strong>stdout</strong>：标准输出流，通常对应于屏幕输出。</li><li><strong>stderr</strong>：标准错误流，用于输出错误消息，即使在标准输出被重定向的情况下，错误信息通常也会显示在屏幕上。</li></ul><p><strong>4. 文件流</strong></p><p>  除了标准的输入和输出流，C语言允许操作文件流，即直接从文件读取数据或向文件写入数据。</p><h4 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h4><p>缓冲区是临时存储数据的内存区域，在数据在源和目标之间传输时使用。</p><p><strong>分类</strong>：</p><ul><li><strong>全缓冲</strong>：当缓冲区满时，数据才会被实际地写入目的地。例如，向文件写入数据通常是全缓冲的。</li><li><strong>行缓冲</strong>：当遇到换行符时，数据才会被实际地写入目的地。例如，标准输出stdout（通常是终端或屏幕）就是行缓冲的。</li><li><strong>无缓冲</strong>：数据立即被写入目的地，不经过缓冲区。例如，标准错误 stderr 通常是无缓冲的</li></ul><h3 id="格式化输入、输出函数"><a href="#格式化输入、输出函数" class="headerlink" title="格式化输入、输出函数"></a>格式化输入、输出函数</h3><h4 id="scanf和printf"><a href="#scanf和printf" class="headerlink" title="scanf和printf:"></a>scanf和printf:</h4><p>printf 函数用于向标准输出（通常是屏幕）打印格式化的字符串。</p><p>scanf 函数用于从标准输入（通常是键盘）读取格式化的输入。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Enter your age: &quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;age);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;You are %d years old.\n&quot;</span>, age);</span><br></pre></td></tr></table></figure><h4 id="getchar和putchar-字符输入、输出"><a href="#getchar和putchar-字符输入、输出" class="headerlink" title="getchar和putchar: 字符输入、输出"></a>getchar和putchar: 字符输入、输出</h4><p>getchar 函数用于读取下一个可用的字符从标准输入，并返回它。</p><p>putchar 函数用于写一个字符到标准输出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> ch;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Enter a character: &quot;</span>);</span><br><span class="line">ch = getchar();</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">&#x27;You entered: &#x27;</span>);</span><br><span class="line"><span class="built_in">putchar</span>(ch);</span><br></pre></td></tr></table></figure><h4 id="gets和puts-字符串输入、输出"><a href="#gets和puts-字符串输入、输出" class="headerlink" title="gets和puts : 字符串输入、输出"></a>gets和puts : 字符串输入、输出</h4><p>gets 函数用于从标准输入读取一行字符串直到遇到换行符。gets函数已经被废弃，因为它存在缓冲区溢出的风险，推荐使用fgets。</p><p>puts 函数用于输出一个字符串到标准输出，并在末尾自动添加换行符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Enter a string: &quot;</span>);</span><br><span class="line">fgets(str, <span class="number">100</span>, <span class="built_in">stdin</span>); <span class="comment">// 使用fgets代替gets</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;You entered: &quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(str);</span><br></pre></td></tr></table></figure><h4 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h4><p><strong>fopen、fclose、fgetc、fputc、fscanf、fprintf、feof、fseek、ftell、rewind</strong></p><p>fopen 和 fclose 函数用于打开和关闭文件。</p><p>fgetc 和 fputc 用于读写单个字符到文件。</p><p>fscanf 和 fprintf 用于读写格式化的数据到文件。</p><p>feof 用于检测文件结束。</p><p>fseek 设置文件位置指针到指定位置。</p><p>ftell 返回当前文件位置。</p><p>rewind 重置文件位置指针到文件开始。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FILE *file = fopen(<span class="string">&quot;example.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;Error opening file&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">fprintf</span>(file, <span class="string">&quot;Hello, file!\n&quot;</span>);</span><br><span class="line">fclose(file);</span><br></pre></td></tr></table></figure><h4 id="错误处理-perror"><a href="#错误处理-perror" class="headerlink" title="错误处理: perror"></a>错误处理: perror</h4><p>perror 函数用于打印一个错误消息到标准错误。它将根据全局变量 errno 的值输出一个描述当前错误的字符串。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FILE *file = fopen(<span class="string">&quot;nonexistent.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">fclose(file);</span><br></pre></td></tr></table></figure><h2 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h2><p>C语言的标准库提供了一系列广泛使用的函数，使得处理输入输出、字符串操作、内存管理、数学计算和时间操作等任务变得简单。下面是一些基本的标准库及其常用函数的简单介绍：</p><h3 id="stdio-h"><a href="#stdio-h" class="headerlink" title="stdio.h"></a>stdio.h</h3><p><strong>用途</strong>：输入和输出</p><p><strong>常用函数</strong>：printf()（输出格式化文本），scanf()（输入格式化文本）</p><h3 id="stdlib-h"><a href="#stdlib-h" class="headerlink" title="stdlib.h"></a>stdlib.h</h3><p><strong>用途</strong>：通用工具，如内存管理、程序控制</p><p><strong>常用函数</strong>：malloc()（分配内存），free()（释放内存），atoi()（字符串转整数）</p><h3 id="string-h"><a href="#string-h" class="headerlink" title="string.h"></a>string.h</h3><p><strong>用途</strong>：字符串处理</p><p><strong>常用函数</strong>：strcpy()（复制字符串），strlen()（计算字符串长度）</p><h3 id="math-h"><a href="#math-h" class="headerlink" title="math.h"></a>math.h</h3><p><strong>用途</strong>：数学计算</p><p><strong>常用函数</strong>：pow()（幂运算），sqrt()（平方根）</p><h3 id="time-h"><a href="#time-h" class="headerlink" title="time.h"></a>time.h</h3><p><strong>用途</strong>：时间和日期处理</p><p><strong>常用函数</strong>：time()（获取当前时间），localtime()（转换为本地时间）</p><h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h2><h3 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h3><p>typedef 是一种关键字，用于为现有的数据类型创建一个新的名称（别名）。这在提高代码的可读性和简化复杂类型定义方面非常有用。</p><h4 id="用途"><a href="#用途" class="headerlink" title="用途:"></a>用途:</h4><ul><li><strong>定义复杂的数据结构</strong>：当你有一个复杂的结构体或联合体时，可以使用 typedef 给它一个更简单的名字。</li><li><strong>提高代码的可移植性</strong>：通过 typedef 定义平台相关的类型，使得代码更容易在不同平台间移植。</li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> ulong;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125; Point;</span><br></pre></td></tr></table></figure><p>在这个例子中，ulong   现在可以用作 unsigned long 类型的别名，而 Point 可以用作上述结构体的类型名称。</p><h3 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h3><p>命令行参数允许用户在程序启动时向程序传递信息。C 程序的 main 函数可以接受命令行参数，这是通过 main 函数的参数实现的：<code>int argc, char *argv[]</code>。</p><h4 id="用途-1"><a href="#用途-1" class="headerlink" title="用途"></a>用途</h4><ul><li>参数个数（argc）：表示传递给程序的命令行参数的数量。</li><li>参数值（argv）：是一个指针数组，每个元素指向一个参数的字符串表示。</li></ul><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Program name: %s\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Arguments: \n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; argc; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, argv[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No additional arguments were passed.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，程序首先打印出程序自己的名字（<code>argv[0]</code>），然后检查是否有其他命令行参数传递给程序，并打印它们。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章主要是提供一个 C 语言入门的学习指南，帮助初学者快速入门 C 语言。</p><p>下面，让我们简短回顾下上文提到的知识点：</p><ul><li><strong>基础语法</strong>：我们介绍了 C 语言的基本构建块，包括变量声明、数据类型和控制流结构，这是编写任何 C 程序的基础。</li><li><strong>数组和指针</strong>：这两个概念是 C 语言中管理数据集的核心工具。我们学习了如何通过它们高效地访问和操作数据。</li><li><strong>字符串处理</strong>：学习了 C 语言中字符串的操作和处理方法，包括字符串的基本操作如连接、比较和搜索。</li><li><strong>函数</strong>：介绍了函数的定义和使用，强调了封装和模块化代码的重要性，以提高程序的可读性和可维护性。</li><li><strong>内存管理</strong>：了解了C语言如何与计算机内存直接交互，包括动态分配、使用和释放内存的方法。</li><li><strong>预处理指令</strong>：讨论了预处理器如何在编译之前处理源代码，以及如何使用预处理指令来增强程序的可配置性和灵活性。</li><li><strong>输入和输出</strong>：我们学习了标准输入输出库的基本使用，理解了如何实现程序与用户之间的交互。</li><li><strong>标准库</strong>：介绍了C语言提供的强大标准库，它包括了一系列实用的函数和工具，用于处理字符串、数学计算、时间日期等。</li></ul><h2 id="最后："><a href="#最后：" class="headerlink" title="最后："></a>最后：</h2><p>当然，学习 C 语言只是学习编程的第一步，作为一门直接与硬件和操作系统打交道的计算机底层语言，要想掌握 C，你还得学习这两门课程：计算机组成原理、操作系统。甚至，你还得学习汇编语言。除此之外，学会在 Linux 环境下进行 C 编程也是必须要掌握的。 如果你想学习 Linux 编程，包括系统编程和网络编程相关的内容，可以关注我的公众号「<strong>跟着小康学编程</strong>」，这里会定时更新计算机编程相关的技术文章，感兴趣的读者可以关注一下：</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>另外，我最近新创建了一个技术交流群，大家如果在阅读的过程中有遇到问题或者有不理解的地方，欢迎大家加群询问或者评论区询问，我能解决的都尽可能给大家回复。微信扫下下方的二维码，备注「<strong>加群</strong>」即可。 </p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程语言学习 </category>
          
          <category> C 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言入门 </tag>
            
            <tag> C语言基础 </tag>
            
            <tag> C快速学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 网络编程从入门到进阶 学习指南</title>
      <link href="/netprog/"/>
      <url>/netprog/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>大家好，我是小康。在上一篇文章中，我们探讨了 Linux 系统编程的诸多基础构件，包括文件操作、进程管理和线程同步等，接下来，我们将视野扩展到网络世界。在这个新篇章里，我们要让应用跳出单机限制，学会在网络上跨机器交流信息。</p><p>接下来，我们要深入套接字（sockets）和 TCP&#x2F;IP 协议，揭示如何在 Linux 下构建通信和网络服务。我们会从基础说起，逐步深入。目标是为初学者提供一个 <strong>Linux 网络编程从入门到进阶</strong>的学习指南！</p><h1 id="网络通信基础"><a href="#网络通信基础" class="headerlink" title="网络通信基础"></a>网络通信基础</h1><p>思考一下，如果计算机想要“交朋友”，它们需要怎样互相沟通？正如人们交流需要使用语言一样，计算机通信也必须遵守一套规则 — 这就是<strong>网络协议</strong>。</p><p>协议确保信息可以在不同的设备和平台之间清晰、准确地传递。要深入理解协议，我们首先要熟悉两个基础的通信模型：OSI 和 TCP&#x2F;IP 模型。</p><h2 id="OSI-模型和-TCP-IP-模型"><a href="#OSI-模型和-TCP-IP-模型" class="headerlink" title="OSI 模型和 TCP&#x2F;IP 模型"></a>OSI 模型和 TCP&#x2F;IP 模型</h2><p>在网络通信的世界里，OSI（开放式系统互联通信参考模型）和 TCP&#x2F;IP（传输控制协议&#x2F;网际协议）模型扮演着基础框架的角色。它们各自描述了网络通信的多个层次和阶段，但以不同的方式来分类和处理数据传输的细节。</p><ul><li><p><strong>OSI模型</strong> </p><p>OSI（Open Systems Interconnection）模型是一个概念性框架，用于描述网络中不同操作层次的功能。由七层组成，从物理硬件的电气信号（物理层），到应用层（如网页浏览器），每一层都有其独特的功能和协议。</p></li><li><p><strong>TCP&#x2F;IP模型</strong></p><p>TCP&#x2F;IP 模型，则更加贴近实际网络中的运作。Linux 的网络协议栈就是基于该模型实现的。它是基于四层架构，将网络通信过程简化并集中在协议族上，如传输控制协议（TCP）和互联网协议（IP），这两种协议是现代网络通信中最为核心的部分。</p></li></ul><h3 id="简单图示："><a href="#简单图示：" class="headerlink" title="简单图示："></a>简单图示：</h3><p><img src="/images/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/1.png"></p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="地址簿：IP地址和MAC地址"><a href="#地址簿：IP地址和MAC地址" class="headerlink" title="地址簿：IP地址和MAC地址"></a>地址簿：IP地址和MAC地址</h3><p>想象一下，互联网是一个巨大的数字城市，而每台计算机或网络设备就像是住在这个城市里的居民。</p><p><strong>IP地址：数字世界的“家庭住址”</strong></p><p>每台设备的 IP 地址就像是它在这个数字城市里的家庭住址。当计算机需要发送信息或访问网络资源时，它会使用目的地设备的 IP 地址来确保信息正确地送达。这个地址有点像是我们现实世界中的邮寄地址，可以根据网络环境的变化而变化（例如，当设备从家庭网络移动到办公室网络时）。</p><p><strong>MAC地址：网络中的“身份证”</strong></p><p>然后，我们有 MAC 地址，这是网络设备的另一个关键标识。每台设备的 MAC 地址都是独一无二的，类似于每个人的身份证号码。它是在设备制造时就被分配的，并且在大多数情况下，这个地址是固定不变的。MAC 地址在本地网络（如家庭或办公室网络）内起着重要作用，它帮助确保信息被准确地送达到特定设备，就像邮递员需要知道收件人的详细身份信息才能将包裹准确递交。</p><p><strong>总结一下</strong>：ip 地址可以让数据包找到目的主机所在的网络，而 MAC 地址确保数据包能准确送到目的主机上。</p><h4 id="导航路线：子网掩码和网关"><a href="#导航路线：子网掩码和网关" class="headerlink" title="导航路线：子网掩码和网关"></a>导航路线：子网掩码和网关</h4><p><strong>子网掩码：定位网络的“区域地图”</strong></p><p>子网掩码可以被视为定位网络内部和外部地址的“区域地图”。就像在一个大城市中，你需要知道哪些街道属于你的社区，哪些通往城市的其他部分。子网掩码帮助计算机确定一个 IP 地址是属于本地网络（即同一个子网）还是位于外部网络。</p><ul><li><strong>内部导航</strong>：如果目的地IP地址与计算机所在的子网相匹配（根据子网掩码判断），则数据包在本地网络内传送。</li><li><strong>外部导航</strong>：如果目的地不在本地子网内，计算机知道它需要将数据发送到更远的目的地。</li></ul><p><strong>网关：网络间的“中转站”</strong></p><p>网关在网络通信中扮演中转站的角色。当你的数据包需要从一个网络（比如你的家庭网络）发送到另一个网络（比如你的工作地点的网络）时，网关是这个旅程的第一站。</p><ul><li><strong>路由决策</strong>：网关检查数据包的目的 IP 地址，然后使用它的路由表来决定最佳的路径将数据包发送到目标网络。</li></ul><p><strong>总结：</strong> 子网掩码和网关共同协作，帮助数据包在复杂的网络结构中找到最有效的路径。子网掩码确定数据包是否在本地网络内，而网关指导跨网络的数据传输。</p><h4 id="端口-：确保数据到达正确的“应用程序门牌号”"><a href="#端口-：确保数据到达正确的“应用程序门牌号”" class="headerlink" title="端口 ：确保数据到达正确的“应用程序门牌号”"></a>端口 ：确保数据到达正确的“应用程序门牌号”</h4><p>好了，现在我们的数据包已经知道了去哪里，但它如何确保被正确的程序接收呢？这就是端口登场的时候了。端口号就像是收件人的门牌号，确保数据不只是送到了正确的地址，而且被正确的应用程序接收。</p><h2 id="Linux-套接字编程"><a href="#Linux-套接字编程" class="headerlink" title="Linux 套接字编程"></a>Linux 套接字编程</h2><p><img src="/images/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/2.png"></p><h3 id="套接字是什么"><a href="#套接字是什么" class="headerlink" title="套接字是什么"></a>套接字是什么</h3><p>在网络编程中，<strong>套接字</strong>就像是网络世界的<strong>通信端口</strong>。每一个联网的应用程序，为了能够互发消息，都会使用到这样一个端口。这个端口允许数据从一个程序流向另一个程序。简而言之，套接字是应用程序用来在网络上交流的桥梁。</p><p>想象一下，你要用手机给朋友发一条信息。你只需要知道他们的手机号码，这样信息就可以直接发送到他们的手机上。在网络编程中，套接字的作用类似。它使用IP地址 （类似于手机号码） 来确定数据发送的目标位置，而端口号则像是确定信息应该送达到对方手机中的哪个应用程序。这样，套接字（使用 ip 地址和端口）确保了数据能够准确地发送给正在监听那个特定端口的程序。</p><p><strong>套接字的工作原理</strong>：</p><p>套接字的工作原理就像是电话通话的过程。首先，你需要拨打一个号码（即IP地址+端口号）来建立连接。一旦连接建立，电话线（网络连接）就激活了，你的声音（数据）就可以通过它传送。</p><p>在这个过程中：</p><p><strong>拨号</strong>对应于网络编程中的<strong>连接建立</strong>，这是通过调用套接字API来完成的，比如 connect( )函数。</p><p><strong>通话</strong>对应于<strong>数据传输</strong>，你可以通过套接字发送 send( ) 和接收 recv( )数据。</p><p><strong>挂断</strong>对应于<strong>结束连接</strong>，完成通信后，你需要关闭套接字 close( )函数，以结束会话并清理资源。</p><p>在整个通信过程中，套接字保证了数据从一个程序准确地传送到另一个程序，无论这两个程序是在同一台计算机上还是跨越了广阔的互联网。</p><p>在 Linux 中，套接字其实就是一系列的编程接口，Linux 提供了很多特定的 API 来创建和使用套接字，接下来，让我们学习如何使用 Linux 套接字 api 来编写各种网络服务程序。</p><h3 id="套接字类型"><a href="#套接字类型" class="headerlink" title="套接字类型"></a>套接字类型</h3><p>在 Linux 中，有三种套接字类型，<strong>前两种是重点掌握的</strong>，第三种了解即可。</p><p><strong>TCP套接字 (SOCK_STREAM):</strong> </p><ul><li>这是一种可靠的套接字连接，保证数据传输的完整性和顺序。</li><li>必须先建立连接，才能传输数据。</li><li>常用于需要准确数据传输的应用，如网页浏览和文件传输。</li></ul><p><strong>UDP套接字 (SOCK_DGRAM):</strong></p><ul><li>不需要建立连接，但是数据传输可能会丢失，没有先后顺序。</li><li>适用于视频流和在线游戏，这些应用可以容忍一定的数据丢失。</li></ul><p><strong>原始套接字 (SOCK_RAW):</strong></p><ul><li>允许直接对较低层次的协议如 IP 或 ICMP 进行访问和操作，它绕过了 TCP 和 UDP 的处理。</li><li>开发者可以使用原始套接字来构建自定义的协议或直接处理来自网络的数据包。</li><li>通常用于需要进行网络诊断或网络安全应用，如自定义的ping实现，或者网络嗅探器。</li></ul><p>选择哪种类型取决于你的应用需求—是否需要可靠传输（TCP），还是速度更快但可能丢失数据也没关系（UDP）。</p><p>选择使用原始套接字通常意味着你需要对网络协议有深入的理解，因为你将直接与网络层面的数据交互。这比处理 TCP 和 UDP 套接字更复杂，通常只在特殊情况下使用，例如网络工具的开发或定制协议的实现。</p><h3 id="套接字常用-API"><a href="#套接字常用-API" class="headerlink" title="套接字常用 API"></a>套接字常用 API</h3><p>接下来，看下常用的套接字 API：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">socket()                    : 创建套接字</span><br><span class="line">bind()                      : 绑定套接字到本地地址</span><br><span class="line">listen()                    : 监听网络连接</span><br><span class="line">accept()                    : 接受网络连接</span><br><span class="line">connect()                   : 连接到远程主机</span><br><span class="line">send(), recv()              : 发送和接收数据（面向连接的套接字）</span><br><span class="line">sendto(), recvfrom()        : 发送和接收数据（无连接的套接字）</span><br><span class="line">close() ,shutdown()         : 关闭套接字</span><br><span class="line">getsockopt(), setsockopt()  : 获取和设置套接字选项</span><br></pre></td></tr></table></figure><h3 id="套接字地址结构以及地址转换-API"><a href="#套接字地址结构以及地址转换-API" class="headerlink" title="套接字地址结构以及地址转换 API"></a>套接字地址结构以及地址转换 API</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sockaddr 是一个通用的套接字地址结构，它通常与特定的地址族结构（如 sockaddr_in ）一起使用。</span></span><br><span class="line"><span class="comment"> 这是因为多数套接字函数，如 bind(), connect(), 和 accept()，需要使用指向 sockaddr 结构的指针的参数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">   <span class="type">sa_family_t</span>     sa_family;      <span class="comment">/* Address family */</span></span><br><span class="line">   <span class="type">char</span>            sa_data[];      <span class="comment">/* Socket address */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 套接字地址结构（适用于IPv4网络通信的地址结构）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">sa_family_t</span>    sin_family; <span class="meta"># address family: AF_INET </span></span><br><span class="line">    <span class="type">in_port_t</span>      sin_port;   <span class="meta"># port in network byte order </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>   <span class="meta"># ip address </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     <span class="type">uint32_t</span>       s_addr;    <span class="meta"># address in network byte order </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">网络地址转换函数 (用于将IP地址在可打印的格式和二进制结构之间转换)</span></span><br><span class="line"><span class="comment">将点分十进制的IP地址（如&quot;192.168.1.1&quot;）转换成网络字节顺序的二进制形式</span></span><br><span class="line"><span class="comment">inet_pton()   </span></span><br><span class="line"><span class="comment">将网络字节顺序的二进制IP地址转换为点分十进制字符串格式</span></span><br><span class="line"><span class="comment">inet_ntop()   </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># demo 示例:</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INET_ADDRSTRLEN 16；</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str[INET_ADDRSTRLEN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">ipv4addr</span>;</span></span><br><span class="line">inet_pton(AF_INET, <span class="string">&quot;192.168.1.1&quot;</span>, &amp;ipv4addr);</span><br><span class="line">inet_ntop(AF_INET, &amp;ipv4addr, str, INET_ADDRSTRLEN);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The IPv4 address is: %s\n&quot;</span>, str);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="字节序转换-API"><a href="#字节序转换-API" class="headerlink" title="字节序转换 API"></a>字节序转换 API</h3><p>在网络编程中，字节序（也称为端序）指的是数值在内存中保存的顺序。不同的计算机体系结构可能会采用不同的字节序来表示数据。最常见的两种字节序是<strong>大端字节序</strong>（Big-Endian）和<strong>小端字节序</strong>（Little-Endian）。在网络通信中，为了确保数据在不同的系统间正确传输和解释，定义了一个统一的字节序，即：<strong>网络字节序</strong>，它采用<strong>大端字节序</strong>。</p><p>由于主机字节序与网络字节序可能不同，因此在发送数据前，发送方需要将其主机字节序的数值转换为网络字节序；接收方收到数据后，需要将网络字节序的数值转换回主机字节序。</p><p>Linux 提供了一组 API 来处理字节序的转换：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将无符号长整型数/无符号短整型数从主机字节顺序转换为网络字节顺序。</span></span><br><span class="line">htonl() 和 htons()  </span><br><span class="line"><span class="comment">// 将一个无符号长整型数/无符号短整型数从网络字节顺序转换为主机字节顺序。</span></span><br><span class="line">ntohl() 和 ntohs()  </span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">为了方便记忆，大家可以这样理解：h 代表 host(主机)，n 代表 network(网络)，</span></span><br><span class="line"><span class="comment">l 代表 long(四字节：代表ip)，s 代表 short（两字节：代表端口） 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">以 htons() 举例，host to network short 即：将端口从主机字节序转成网络字节序。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>注意：htonl 和 ntohl 一般处理的是 IP 地址，而 htons 和 ntohs 一般处理的是端口。</strong></p><h3 id="Linux-常见的-IO-模型"><a href="#Linux-常见的-IO-模型" class="headerlink" title="Linux 常见的 IO 模型"></a>Linux 常见的 IO 模型</h3><p>前面我们已经学习了 Linux 基础的 socket API，这样我们便可以编写简单的网络服务程序。但现在，我们面临一个新挑战：如何利用有限的服务器资源，来同时高效处理大量的并发请求呢？</p><p>传统的单线程处理方式在现代网络服务中已不合时宜，因为它无法同时处理多个请求，导致效率低下。为了突破这一限制，我们需探究 Linux 提供的各种 I&#x2F;O 模型。这些模型提供了从阻塞到非阻塞，从多路复用到完全异步的不同解决方案，以适应各种网络应用场景，确保服务器在面对大量请求时也能保持高效运行。</p><p><strong>在讨论这些 IO 模型之前，我们先简单回顾一下 I&#x2F;O 是什么</strong>：</p><p>在计算机中，“I&#x2F;O”就是输入和输出的简称，它描述了数据在计算机系统和外部世界之间的流动。具体来说：</p><ul><li><p><strong>输入</strong>：数据进入计算机，比如你在键盘上敲击字母时，字母被读入计算机。</p></li><li><p><strong>输出</strong>：数据离开计算机，例如屏幕上显示信息。</p></li></ul><p>当提到网络时，“I&#x2F;O”扩展了含义：</p><ul><li><p><strong>网络输入</strong>：从外部网络接收数据到你的本地计算机，如通过网络下载文件到你的计算机。</p></li><li><p><strong>网络输出</strong>：这是指将数据从你的本地计算机发送到外部网络，比如通过计算机发送文件给你的好友。</p></li></ul><p>简而言之，I&#x2F;O 是数据在计算机和其他设备或网络之间传递的方式。</p><p><strong>用户进程如何进行 IO 操作？</strong></p><p>让我们通过一个示意图来直观展示用户进程如何从网络获取数据并将其存储到磁盘的整个过程：</p><p><img src="/images/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/3.png"></p><p>从上图我们也能够清楚的看到，进程进行一次 I&#x2F;O 操作需要经过两个步骤:</p><p>以 read 读操作为例：</p><p><strong>第一步：等待网络数据的到来</strong></p><p>当网络数据到达时，网络接口卡（NIC）首先通过直接内存访问（DMA）将数据传输到内核空间分配的 socket 接收缓冲区中，无需 CPU 参与。</p><p><strong>第二步：CPU 复制数据至用户空间</strong></p><p>一旦数据通过 DMA 传输到内核的 socket 接收缓冲区，用户进程的 read 系统调用会被唤醒（如果它在等待数据的话）。接下来，CPU 会介入，将数据从内核缓冲区复制到用户空间提供的缓冲区中。</p><p>也就是说，在 I&#x2F;O 操作的过程中，<strong>存在两个潜在的等待时间点 ：一个是等待网络数据到达 socket 接收缓冲区，另一个是等待 CPU 复制数据至用户空间。</strong></p><p>为了减少这些等待时间对应用程序性能的影响，Linux 提供了五种 I&#x2F;O 模型，它们分别针对这两个步骤的效率问题提供不同的解决方案。</p><p><strong>接下来，我们将深入了解 Linux 支持的五种 I&#x2F;O 模型:</strong></p><h4 id="阻塞IO（Blocking-I-O）"><a href="#阻塞IO（Blocking-I-O）" class="headerlink" title="阻塞IO（Blocking I&#x2F;O）"></a>阻塞IO（Blocking I&#x2F;O）</h4><p><strong>简单图示</strong>：</p><p><img src="/images/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/4.png"></p><p>在阻塞 I&#x2F;O 中，<strong>进程在等待网络数据到达和内核复制数据到用户空间这两个步骤中都需要等待</strong>。当一个进程发起 I&#x2F;O 请求时，它会一直等待直到数据被复制到它的应用层缓冲区中，然后才继续执行。</p><h4 id="非阻塞I-O（Non-blocking-I-O）"><a href="#非阻塞I-O（Non-blocking-I-O）" class="headerlink" title="非阻塞I&#x2F;O（Non-blocking I&#x2F;O）"></a>非阻塞I&#x2F;O（Non-blocking I&#x2F;O）</h4><p><strong>简单图示</strong>：</p><p><img src="/images/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/5.png"></p><p>在非阻塞 I&#x2F;O 模型中，当进程尝试从 socket 读取数据时，如果数据尚未到达，read调用不会阻塞进程。相反，它会立即返回一个 EWOULDBLOCK 或 EAGAIN 错误。也就是说，进程不需要等待网络数据到达 socket 接收缓冲区就可以返回继续执行其他任务。</p><p>一旦数据到达并存储在内核缓冲区中，而当进程尝试再次读取，这次 read 操作将成功，并将数据从内核空间复制到用户空间，但这里的数据复制过程是需要等待的。</p><p><strong>总结一下</strong>：<strong>在非阻塞 I&#x2F;O 模型中，进程需要等待 socket 数据从内核空间复制到用户空间。</strong> 而在等待网络数据到达 socket 接收缓冲区这个时间点是不需要等待的。但是进程需要不断地“轮询”文件描述符，检查 socket 接收缓冲区是否有数据，频繁的轮询可能会导致 CPU 资源的浪费。</p><h4 id="I-O多路复用（I-O-Multiplexing）"><a href="#I-O多路复用（I-O-Multiplexing）" class="headerlink" title="I&#x2F;O多路复用（I&#x2F;O Multiplexing）"></a>I&#x2F;O多路复用（I&#x2F;O Multiplexing）</h4><p><strong>简单图示</strong>：</p><p><img src="/images/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/6.png"></p><p><strong>工作原理：</strong></p><p>I&#x2F;O 多路复用允许一个进程或线程同时监控多个网络 sockets 的状态。它通过单个系统调用（select）来检查多个 sockets 是否有数据可读、可写或是否有异常。Linux 提供了多种 I&#x2F;O 复用技术，包括上面提到的 select、以及 poll、epoll。</p><p><strong>那 I&#x2F;O 多路复用是如何减少上述提到的两个潜在的等待时间的？</strong></p><p><strong>等待网络数据到达</strong></p><ul><li><p>在 I&#x2F;O 多路复用模式下，进程不会在单个 socket 上阻塞等待数据到达。相反，当任何一个被监控的 socket 接收到数据，系统调用（如select）会返回。当 select 返回时，它指示一个或多个 sockets 已接收到数据。这意味着数据已经被网络接口卡（NIC）通过 DMA 操作传输到相应的 socket 接收缓冲区中。</p></li><li><p>这样，进程不必在每个 socket 上分别等待，而是在多个sockets上集中等待，提高了效率。</p></li></ul><p><strong>但是，在 I&#x2F;O 多路复用中， select、poll 或 epoll 系统调用依然会阻塞等待网络数据的到达</strong></p><p><strong>等待CPU复制数据至用户空间</strong></p><p>进程随后可以立即对准备就绪的 socket fd 进行 read 操作。因为数据已经在内核的缓冲区中，CPU 只需要将数据从内核空间复制到用户空间。但这个拷贝数据的完成</p><p>也就是说在 I&#x2F;O 多路复用中，<strong>select、poll 或 epoll 系统调用依然会阻塞等待网络数据的到达</strong>，但是他的<strong>优势在于可以监控多个 sockets 的接收缓冲区是否有数据到来</strong>。当多个 sockets 的接收缓冲区有数据到来，<strong>进程会一直等待 CPU 复制数据至用户空间才能干其他任务</strong>。</p><h4 id="信号驱动I-O（Signal-driven-I-O）"><a href="#信号驱动I-O（Signal-driven-I-O）" class="headerlink" title="信号驱动I&#x2F;O（Signal-driven I&#x2F;O）"></a>信号驱动I&#x2F;O（Signal-driven I&#x2F;O）</h4><p><strong>简单图示</strong>：</p><p><img src="/images/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/7.png"></p><p>信号驱动 I&#x2F;O 也是属于Linux 中的一种 IO 模型，它允许应用程序在不阻塞等待 I&#x2F;O 操作完成的情况下继续执行其他任务。当 I&#x2F;O 操作（如数据的读取或写入）准备就绪时，操作系统会向应用程序发送一个信号，通知它可以开始执行 I&#x2F;O 操作了。这种模式主要通过使用信号（如 SIGIO）来实现。</p><p><strong>两个等待时间点对信号驱动 I&#x2F;O 的影响</strong> :</p><p><strong>等待网络数据到达</strong>：在信号驱动 I&#x2F;O 模型中，应用程序在等待数据到达时<strong>不需要阻塞等待</strong>。它可以继续执行其他任务或处于休眠状态，直到操作系统发出数据已准备就绪的信号（如 SIGIO）。</p><p><strong>等待内核复制数据到用户空间</strong>：当应用程序收到信号并开始实际的 I&#x2F;O 操作（如 read）时，<strong>它仍然需要等待操作系统将数据从内核空间复制到用户空间</strong>。</p><p>尽管信号驱动 I&#x2F;O 提供了一种异步通知机制，使得应用程序能够在I&#x2F;O事件准备好时接收通知，但它在实践中不如其他模型（如IO复用）那么广泛使用，原因包括：</p><ul><li><p><strong>编程复杂性</strong>：使用信号驱动I&#x2F;O要求程序员熟悉信号处理和非阻塞I&#x2F;O操作，这增加了编程的复杂性。</p></li><li><p><strong>信号合并和丢失</strong><br>Linux 信号处理机制通常不会为同一类型的信号排队。这意味着如果在处理一个信号时另一个相同类型的信号发生，后者可能不会触发额外的信号处理调用，导致应用程序可能错过一些I&#x2F;O事件的通知。这种信号的合并行为限制了信号驱动I&#x2F;O模型在高并发场景下准确响应每个I&#x2F;O事件的能力。</p></li><li><p><strong>更好的替代方案</strong>：对于需要处理多个并发I&#x2F;O操作的应用程序，I&#x2F;O复用（特别是epoll）提供了更高的效率和更好的控制。epoll特别适用于高并发场景，并且相对于信号驱动I&#x2F;O更易于管理和使用。</p></li></ul><h4 id="异步I-O（Asynchronous-I-O）"><a href="#异步I-O（Asynchronous-I-O）" class="headerlink" title="异步I&#x2F;O（Asynchronous I&#x2F;O）"></a>异步I&#x2F;O（Asynchronous I&#x2F;O）</h4><p><strong>简单图示</strong>：</p><p><img src="/images/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/8.png"></p><p>aio_read 是 POSIX 异步 I&#x2F;O 接口的一部分，它专门用于执行异步文件读取操作。不太适用于网络 I&#x2F;O 。因此上面的图示是基于文件读取对异步 IO 的工作过程进行说明的。</p><p><strong>工作原理：</strong></p><p>在异步 I&#x2F;O 模型中，当应用程序发起一个I&#x2F;O操作（例如 aio_read 读取）时，它不需要等待操作完成就可以继续执行其他任务。应用程序仅仅是向操作系统发出 I&#x2F;O 请求，并且当 I&#x2F;O 操作真正完成时，操作系统会通知应用程序。这种方式允许应用程序更有效地利用 CPU 时间，因为它不需要在 I&#x2F;O 操作完成前空闲等待。</p><p>那前面提到的两个潜在等待时间对异步 IO 是否会有影响呢？</p><p><strong>等待内核 PageCache 数据准备好：</strong></p><p>在异步 I&#x2F;O 中，应用程序在发出读写请求后立即返回，不需要等待数据在内核中准备好。这意味着应用程序可以继续执行其他任务，而内核会异步的从磁盘读取数据至内核缓存 PageCache 中。</p><p><strong>注意：</strong> 上面我是通过 aio_read 系统调用来说明异步 I&#x2F;O 的工作原理的，aio_read 是 Linux 的 POSIX 异步 I&#x2F;O (AIO) 库提供的接口，主要设计用于文件和块设备的异步读写操作，而不支持网络 I&#x2F;O。因此这里是等待内核的 PageCache 数据准备好而不是等待网络数据准备好，但都可以归纳为等待数据准备好。</p><p><strong>等待CPU复制数据至用户空间</strong>：</p><p> 一旦数据在 pagecache 中准备好，操作系统负责将这些数据从内核空间复制到用户空间指定的缓冲区。<strong>这个复制过程是由内核自动执行的，而不是由用户进程主动复制的。</strong> 用户程序不需要等待这一过程的完成，可以继续进行其他工作。只有在数据完全复制到用户空间后，应用程序才会收到一个完成的信号或通知。进而处理拷贝至用户空间的数据。</p><p><strong>也就是说：在异步 IO 中，不管是等待数据准备好还是等待 CPU 复制数据至用户空间，用户进程都不需要等待。</strong></p><h4 id="Linux-网络-I-O-性能优化"><a href="#Linux-网络-I-O-性能优化" class="headerlink" title="Linux 网络 I&#x2F;O 性能优化"></a>Linux 网络 I&#x2F;O 性能优化</h4><p>在前面的部分，我们探讨了 Linux的 各种I&#x2F;O模型。每种模型都有其独特的使用场景和性能特点。特别是在网络编程中，选择合适的I&#x2F;O模型对于提高服务器的处理能力至关重要。但是，仅仅选择合适的I&#x2F;O模型并不足以确保最佳性能。实际上，网络I&#x2F;O性能还受到许多其他因素的影响，比如<strong>网卡配置、带宽、服务器的并发处理能力</strong>等。因此，我们需要进一步优化 Linux 网络 I&#x2F;O 性能，以确保我们的应用可以充分利用服务器资源，提供更快、更可靠的服务。</p><p><strong>那么，如何优化 Linux 网络 I&#x2F;O 性能呢？</strong></p><p>网络 I&#x2F;O 性能优化主要就是从硬件和软件两个方面来进行：</p><p><strong>首先来看下硬件优化：</strong><br>硬件优化无非就是提升服务器硬件性能，包括 CPU、网卡配置升级、内存配置升级等。</p><ul><li><strong>使用多核 CPU</strong> ：确保服务器有足够的CPU核心来处理高网络负载。</li><li><strong>内存升级</strong>：增加足够的内存以支持高速网络操作，特别是对于需要大量内存缓存的应用。</li><li><strong>网络接口卡</strong>：升级NIC：使用更高速率的NIC，例如从1Gbps升级到10Gbps或更高。<br>或者使用 NIC 多队列（Multi-queue）：使用支持多队列的NIC，以便分散处理负载到多个CPU核心。</li></ul><p><strong>接下来来看下软件优化：</strong></p><p> <strong>1.首先来看下应用程序设计，应用程序本身的设计对网络 I&#x2F;O 性能有着重大影响：</strong></p><ul><li><p><strong>选择合适的 I&#x2F;O 模型</strong>：<br>选择合适的 I&#x2F;O 模型，根据应用的特点和需求选择合适的 I&#x2F;O 模型。对于高并发的网络服务，I&#x2F;O 多路复用（如 epoll、kqueue）通常是最佳选择。它们允许单个线程高效地监控和处理多个网络连接，减少了线程切换的开销。而对于 I&#x2F;O 密集型的应用，异步 I&#x2F;O模型可能会更高效，异步 I&#x2F;O （如 io_uring、libaio）提供了一种不阻塞应用程序主逻辑的方式来处理 I&#x2F;O 请求。这种模型允许应用程序在 I&#x2F;O 请求正在处理时继续执行其他任务。</p></li><li><p><strong>使用零拷贝技术</strong>：<br>传统的数据传输过程涉及多次数据拷贝，包括从内核缓冲区到用户缓冲区。零拷贝技术（如 sendfile）可以减少这些拷贝操作，直接在内核中处理数据，从而减少 CPU 使用和提高效率。</p></li><li><p><strong>批量处理和缓冲</strong> : 聚集数据，以减少网络交互和磁盘操作的次数。</p><p> <strong>a:聚集数据</strong>：通过累积数据到达一定量后再进行处理，而不是每次接收到数据就立即处理。以读取网络数据下载至本地磁盘为例：可以等待数据积累到一定量的时候在写入磁盘，这样可以减少磁盘 I&#x2F;O 次数。</p><p><strong>b.缓冲区管理</strong>：需要合理管理缓冲区，以避免溢出，并在适当的时候重置或清空缓冲区。</p><p><strong>c.适用场景</strong>：这种模式适合于数据量大、数据频繁到达的场景，如日志收集、批量数据处理等。</p></li><li><p><strong>并发和并行处理</strong>：利用多核处理器的优势，通过多线程或多进程来提高并发处理能力。</p></li></ul><p> <strong>2. 接下来看下关于操作系统方面的调整，操作系统级别的调整对于优化网络 I&#x2F;O 也是至关重要的</strong></p><ul><li><p><strong>增加文件描述符限制</strong>：对于高并发的网络服务器，提高文件描述符的限制是必要的，以避免因达到文件描述符上限而无法接受新连接。你可以通过 ulimit -n 命令或修改 &#x2F;etc&#x2F;security&#x2F;limits.conf 文件来增加这个限制。</p></li><li><p><strong>调整 TCP 协议栈参数</strong>：常见的 TCP协议栈参数有如下的几类：</p><p><strong>a：缓冲区大小和资源管理</strong>：<br>这些参数控制 TCP 缓冲区的大小和整体 TCP 缓冲区的资源管理，以优化数据传输性能和内存使用。</p><p><strong>tcp_rmem 和 tcp_wmem</strong> ：分别控制 TCP 接收和发送缓冲区的大小。</p><p><strong>tcp_mem</strong> ：控制整体 TCP 缓冲区在系统范围内的使用情况。</p><p><strong>b: 连接建立和终止：</strong><br>这类参数涉及 TCP 连接的建立过程和连接终止时的行为。</p><p><strong>tcp_syn_retries 和 tcp_synack_retries</strong> : 分别控制 TCP SYN 连接请求和 SYN-ACK 包的重试次数。</p><p> <strong>tcp_fin_timeout</strong> ： tcp_fin_timeout 参数设置了 TCP 连接在 FIN-WAIT-2 状态下的超时时间。这个参数定义了在一个 TCP 连接被本地端关闭后，系统等待对方发送 FIN 包以完成连接终止过程的最长时间。如果在这个超时时间内没有收到对方的 FIN 包，连接将被强制关闭。</p><p><strong>c :连接保活和状态管理：</strong><br>这些参数用于检测和维持空闲连接，以及管理连接状态。</p><p><strong>tcp_keepalive_time</strong> ：设置在开始发送 keepalive 探测之前，一个 TCP 连接必须处于空闲状态的时间。</p><p><strong>tcp_keepalive_probes</strong> ：设置在断开连接之前，最多发送多少个 keepalive 探测包。</p><p><strong>tcp_keepalive_intvl</strong> ： 设置两个连续 keepalive 探测包之间的时间间隔。</p><p><strong>tcp_tw_reuse</strong> :  设置允许在 TIME_WAIT 状态的套接字上的端口被重新用于新的连接。</p><p><strong>d:性能优化 :</strong> 这些参数用于提升网络性能，减少延迟。</p><p><strong>tcp_nodelay</strong> : 禁用 Nagle 算法，减少发送小块数据的延迟。（Nagle 算法是一种为了减少网络上小数据包数量而设计的 TCP 特性。它通过累积较小的数据包并将它们组合成更大的数据块来发送，从而减少了网络上的总数据包数量）。</p><p><strong>tcp_max_syn_backlog</strong> : 设置 SYN 接收队列的最大长度，优化高并发连接的接收。</p><p>除了 SYN 接收队列，TCP 连接还涉及到一个“已连接队列”（也称为 accept 队列），该队列用于存储已经完成三次握手、等待应用程序 accept 的连接。</p><p><strong>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;somaxconn</strong>： 该参数控制着已连接队列的最大长度。 </p><p><strong>调整方法:</strong><br>这些参数通常通过修改 &#x2F;etc&#x2F;sysctl.conf 文件或使用 sysctl 命令进行调整。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sysctl -w net.ipv4.tcp_rmem=&#x27;4096 87380 6291456&#x27;</span><br><span class="line">sysctl -w net.ipv4.tcp_wmem=&#x27;4096 16384 4194304&#x27;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 调整这些参数时，应谨慎考虑系统的整体资源和应用的具体需求。不恰当的设置可能导致性能下降或系统资源耗尽。在生产环境中应用更改前，最好在测试环境中进行充分的测试。</p></li></ul><h3 id="Linux-常见的服务器模型"><a href="#Linux-常见的服务器模型" class="headerlink" title="Linux 常见的服务器模型"></a>Linux 常见的服务器模型</h3><p>服务器模型是网络服务器程序设计的基石，它决定了服务器如何管理多个客户端的连接和请求。接下来，让我们来看看 <strong>Linux</strong> 下的几种常见的服务器模型是怎样工作的？</p><h4 id="单进程服务器：一对一服务"><a href="#单进程服务器：一对一服务" class="headerlink" title="单进程服务器：一对一服务"></a>单进程服务器：一对一服务</h4><p>在单进程服务器模型中。服务器使用一个主进程来逐个处理客户端的连接请求。这意味着，当服务器正在服务一个客户端时，其他客户端必须等待直到当前客户端服务结束。</p><p><strong>图示</strong>：</p><p><img src="/images/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/9.png"></p><p><strong>单进程回射服务器示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">server_fd = socket();</span><br><span class="line">bind();</span><br><span class="line">listen();</span><br><span class="line"><span class="comment">// The main server loop</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    newsockfd = accept(server_fd，...);</span><br><span class="line">    <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="number">256</span>);</span><br><span class="line">    <span class="comment">// Read and write to the connection in a loop</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        n = read(newsockfd, buffer, <span class="number">255</span>);</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">// If read returns 0, the client has closed the connection</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// printf(&quot;Client: %s\n&quot;, buffer);</span></span><br><span class="line">        write(newsockfd, buffer, <span class="built_in">strlen</span>(buffer));</span><br><span class="line">    &#125;</span><br><span class="line">    close(newsockfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>缺点</strong>：</p><ul><li><p><strong>无法实现并发</strong>： 单进程服务器在任何时刻只能处理一个客户端的请求。这意味着如果有多个客户端同时请求服务，除了第一个之外的所有请求都必须等待，这限制了服务器的并发处理能力。</p></li><li><p><strong>性能瓶颈</strong>： 由于服务器在处理当前请求时无法接受新的连接，这会导致服务器对其他客户端的响应时间延长，特别是在高流量的情况下，效率低下。</p></li><li><p><strong>资源利用不充分</strong>： 在多核心处理器上，单进程模型无法充分利用多核的优势，因为它只在一个核心上运行，没有并行处理能力。</p></li></ul><h4 id="多进程服务器"><a href="#多进程服务器" class="headerlink" title="多进程服务器"></a>多进程服务器</h4><p>了解了单进程服务器模型的缺点后，我们自然会寻求更高效的方案来处理多客户端并发的情况。这就引出了多进程服务器模型，它是解决单进程模型限制的常见方案。</p><p>在多进程模型中，服务器为每个新的客户端连接创建一个独立的进程。这允许服务器同时处理多个客户端请求，极大地提高了并发处理能力和资源利用率。</p><p><strong>图示</strong>：</p><p><img src="/images/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/10.png"></p><p><strong>多进程回射服务器示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">server_fd = socket();</span><br><span class="line">bind();</span><br><span class="line">listen();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="type">int</span> new_socket =accept(server_fd, ...);    </span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        close(new_socket);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">      close(server_fd); <span class="comment">// Child does not need the listener</span></span><br><span class="line">      handle_client(new_socket);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        close(new_socket); <span class="comment">// Parent does not need this socket</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">handle_client</span><span class="params">(<span class="type">int</span> new_socket)</span> &#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> bytes_read;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        bytes_read = read(new_socket, buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">        <span class="keyword">if</span> (bytes_read &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// Break the loop if read error or end of file</span></span><br><span class="line">        &#125;</span><br><span class="line">        write(new_socket, buffer, bytes_read);</span><br><span class="line">    &#125;</span><br><span class="line">    close(new_socket);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>多进程服务器优点</strong>：</p><ul><li><p><strong>稳定性</strong>: 多进程服务器中，每个进程是独立的。如果一个进程崩溃，通常不会影响到其他进程，从而提高了服务器的整体稳定性。</p></li><li><p><strong>隔离性</strong>: 每个进程有自己的地址空间，这意味着进程之间的内存是隔离的。这样可以防止某个进程的错误操作影响到其他进程。</p></li><li><p><strong>利用多核优势</strong>: 多进程模型能够在多核处理器上运行，每个进程可以被操作系统调度到不同的CPU核心上，充分利用硬件资源。</p></li></ul><p><strong>缺点</strong>：</p><ul><li><p><strong>资源消耗</strong>: 每个进程都需要一定量的内存和系统资源，如果进程数过多，会占用大量的系统资源，这可能导致服务器的性能下降。</p></li><li><p><strong>上下文切换开销</strong>: 多进程意味着操作系统需要频繁地在进程之间进行上下文切换，这个过程涉及到保存和加载寄存器、更新各种表等操作，会消耗一定的CPU时间。</p></li></ul><h4 id="多线程服务器"><a href="#多线程服务器" class="headerlink" title="多线程服务器"></a>多线程服务器</h4><p>虽然多进程模型提高了服务器的稳定性和隔离性，但它也带来了<strong>资源消耗、上下文切换开销</strong>等限制。针对多进程模型的这些限制，多线程服务器模型提供了一个更为高效的解决方案。</p><p>多线程服务器模型在同一个进程内创建多个线程来处理客户端请求，每个线程能够独立执行，<strong>它们共享进程的资源，如内存空间等资源。而且上下文切换也更快。</strong></p><p><strong>图示</strong>：<br><img src="/images/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/11.png"></p><p><strong>多线程回射服务器的示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">server_fd = socket();</span><br><span class="line">bind(server_fd, ...);</span><br><span class="line">listen(server_fd, ...);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="type">int</span> new_socket = accept(server_fd, ...);</span><br><span class="line">    <span class="type">pthread_t</span> thread_id;</span><br><span class="line">    <span class="keyword">if</span> (pthread_create(&amp;thread_id, <span class="literal">NULL</span>, handle_client, (<span class="type">void</span>*)&amp;new_socket) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Handle error</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">handle_client</span><span class="params">(<span class="type">void</span>* socket)</span> &#123;</span><br><span class="line">    <span class="type">int</span> new_socket = *(<span class="type">int</span>*)socket;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> bytes_read;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        bytes_read = read(new_socket, buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">        <span class="keyword">if</span> (bytes_read &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// Break the loop if read error or end of file</span></span><br><span class="line">        &#125;</span><br><span class="line">        write(new_socket, buffer, bytes_read);</span><br><span class="line">    &#125;</span><br><span class="line">    close(new_socket);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>多线程服务器优缺点</strong>：</p><ul><li><strong>资源效率</strong>: 线程共享进程的内存空间，相较于多进程模型，多线程服务器在内存和资源上的开销更小。</li><li><strong>上下文切换效率</strong>: 线程间的上下文切换比进程间的切换要快，因为线程共享许多资源，切换时所需的资源较少（<strong>线程切换一般只需要切换各自寄存器和栈上的数据</strong>）。</li><li><strong>利用多核优势</strong>: 线程可以分布在多个 CPU 核心上运行，这使得多线程服务器能够充分利用多核 CPU 的计算能力。</li></ul><p><strong>缺点</strong>：</p><ul><li><strong>同步复杂性</strong>: 因为线程共享内存和资源，所以必须仔细设计同步机制来避免竞态条件和其他并发问题。</li><li><strong>稳定性风险</strong>: 一个线程的错误可能影响整个进程，因为它们共享同一内存空间。这可能导致整个服务器程序崩溃。</li><li><strong>资源限制</strong>: 虽然线程比进程轻量，但大量线程仍然会消耗大量系统资源，尤其是在高并发情况下。</li><li><strong>调试困难</strong>: 多线程程序的调试较为复杂，尤其是当出现了线程安全问题时，这些问题可能难以重现和定位。</li></ul><h4 id="线程池模型"><a href="#线程池模型" class="headerlink" title="线程池模型"></a>线程池模型</h4><p>在多线程服务器模型中，每个客户端请求都由一个新的线程来处理。这种方法虽然有效，<strong>但在面对大量并发请求时，频繁地创建和销毁线程会导致服务器的性能下降。</strong> 特别是在请求数量剧增的情况下，线程创建和销毁的开销会变得显著，同时过多的活跃线程也会竞争有限的CPU和内存资源，进一步影响服务的响应时间和吞吐量。</p><p>而在线程池模型中，服务器启动时会预先创建一定数量的线程，这些线程存放在池中，并不立即执行任务。当客户端请求到达时，请求会被分配给线程池中的一个空闲线程，该线程负责处理整个请求过程。处理完毕后，线程并不销毁，而是返回到池中等待处理下一个请求。</p><p><strong>图示</strong>：</p><p><img src="/images/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/12.png"></p><p><strong>说明</strong>：</p><p><strong>服务器（Server）</strong>：这是整个流程开始的地方。服务器初始化一个线程池，并不断监听客户端的连接请求。当一个客户端连接请求到来时，服务器接受这个连接（accept()），然后把相应的任务（job：一般是读写客户端数据的逻辑）添加到线程池的任务队列中去。最终，当服务器不再需要线程池时，会销毁它。</p><p><strong>线程池（ThreadPool</strong>）：线程池是预先创建的线程集合，用于执行多个任务。它分为两个主要部分：</p><ul><li><strong>任务队列（Job Queue）</strong>：这里存放所有待处理的任务（jobs）。当服务器接受一个客户端的连接，它会创建一个任务，并将其添加到这个队列中。</li><li><strong>线程队列（Thread Queue）</strong>：这里存放的是线程池中所有可用的线程。当任务队列中有任务时，线程池会分配一个线程去执行这个任务。</li></ul><p><strong>客户端（Clients）</strong>：客户端通过网络连接与服务器进行通信。</p><h4 id="I-O多路复用服务器"><a href="#I-O多路复用服务器" class="headerlink" title="I&#x2F;O多路复用服务器"></a>I&#x2F;O多路复用服务器</h4><p><strong>什么是 I&#x2F;O 多路复用？</strong></p><p>在 Linux 中，I&#x2F;O 多路复用是一种允许<strong>单个进程或线程同时监控多个文件描述符</strong>（通常是网络套接字）上的读写就绪状态的技术。这使得程序能够在一个或多个文件描述符上发生 I&#x2F;O 事件时被通知，从而对这些事件作出响应（比如进行读写操作）。这种机制极大地提高了处理多个并发网络连接的效率，因为它允许使用较少的系统资源（如进程和线程）来管理大量的连接。</p><p>上面我们在讲解 I&#x2F;O 模型的时候，提到了 IO 多路复用，而在讲解服务器模型我们又再次提到了IO 多路复用。<strong>可能大家会有疑问：IO 多路复用到底属于 I&#x2F;O 模型还是服务器模型？</strong></p><p>其实 I&#x2F;O 多路复用技术是两者之间的桥梁：它是一种有效的 I&#x2F;O 处理方式，同时也是构建服务器模型的基础。</p><ul><li>I&#x2F;O 多路复用作为 I&#x2F;O 模型，关注的是如何有效地管理和执行 I&#x2F;O 操作，特别是在涉及多个 I&#x2F;O 源（如网络套接字）时。</li><li>I&#x2F;O 多路复用作为服务器模型，则是在这种 I&#x2F;O 操作的管理方式基础上构建整个服务器的架构，决定如何接收和处理多个客户端请求，如何分配处理程序来响应这些请求，以及如何利用系统资源。</li></ul><p><strong>简单来说，I&#x2F;O 模型是关于”如何执行 I&#x2F;O”的，而服务器模型是基于某种 I&#x2F;O 模型来构建服务的，以及如何组织服务器程序以响应客户端请求。</strong></p><p><strong>常见的 I&#x2F;O 多路复用技术</strong>：</p><p>Linux 提供了多种 I&#x2F;O 多路复用的机制，如 select, poll, 和 epoll。这些技术的主要区别在于它们处理大量文件描述符的方式和效率。</p><p><strong>IO 复用之 Select</strong>：</p><p><strong>基本概念</strong>：<br>Linux 中的 select 函数是一种常用的 I&#x2F;O 复用技术。它允许程序监视多个文件描述符（FDs），以检测是否有任何一个或多个 FD 准备好进行读取、写入或是否有异常发生。这种技术特别适用于同时处理多个网络连接或其他类型的 I&#x2F;O 操作（如：文件I&#x2F;O）。</p><p><strong>函数声明</strong></p><p>select 函数的基本声明如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, <span class="keyword">struct</span> timeval *timeout)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数结构</span></span><br><span class="line"><span class="comment">nfds：监视的文件描述符集合中最大的文件描述符加一。</span></span><br><span class="line"><span class="comment">readfds：一个指向 fd_set 结构的指针，用于监视哪些 FD 准备好进行读操作。</span></span><br><span class="line"><span class="comment">writefds：一个指向 fd_set 结构的指针，用于监视哪些 FD 准备好进行写操作。</span></span><br><span class="line"><span class="comment">exceptfds：一个指向 fd_set 结构的指针，用于监视哪些 FD 有异常发生。</span></span><br><span class="line"><span class="comment">timeout：指定 select 等待准备就绪的 FD 的最长时间。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>fd_set 结构图解展示</strong>：</p><p>fd_set 是一个文件描述符数组，用于指示 select 函数应该监视的 FDs。</p><p><strong>fd_set 结构图解展示</strong>：</p><p><img src="/images/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/13.jpg"></p><p><strong>说明</strong>：</p><p>参数 readfds、writefds、exceptfds 从用户空间传入内核空间和从内核空间返回用户空间，文件描述符数组中的值代表的含义不同：</p><p><strong>以可读事件 readfds 为例</strong>：</p><p><strong>从用户空间传入内核空间</strong>：数组值为 0 代表不监控该文件描述符（fd），数组值为 1 代表要监控该文件描述符（fd）。</p><p><strong>从内核空间返回用户空间</strong>：数组值为 0 代表该文件描述符数据未准备就绪，数组值为 1 代表该文件描述符数据准备就绪。用户进程可以进行读操作了。</p><p><strong>select 并发回射服务器程序示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 8080</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_CLIENTS 30</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> server_fd, new_socket, client_socket[MAX_CLIENTS];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    <span class="type">int</span> addrlen = <span class="keyword">sizeof</span>(address);</span><br><span class="line">    fd_set readfds;</span><br><span class="line">    <span class="type">int</span> max_sd, sd, activity, i, valread;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">1025</span>];  <span class="comment">// 数据缓冲区</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化所有客户端套接字</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_CLIENTS; i++) &#123;</span><br><span class="line">        client_socket[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建套接字</span></span><br><span class="line">    server_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 绑定套接字</span></span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    address.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    address.sin_port = htons(PORT);</span><br><span class="line">    bind(server_fd, (<span class="keyword">struct</span> sockaddr *)&amp;address, <span class="keyword">sizeof</span>(address))&lt;<span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听套接字</span></span><br><span class="line">    listen(server_fd, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        FD_ZERO(&amp;readfds);<span class="comment">// 清空 fd_set</span></span><br><span class="line">        FD_SET(server_fd, &amp;readfds); <span class="comment">// 添加 server_fd 到 fd_set</span></span><br><span class="line">        max_sd = server_fd;</span><br><span class="line">        <span class="comment">// 添加客户端套接字到 fd_set</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_CLIENTS; i++) &#123;</span><br><span class="line">            sd = client_socket[i];</span><br><span class="line">            <span class="keyword">if</span> (sd &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                FD_SET(sd, &amp;readfds);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sd &gt; max_sd) &#123;</span><br><span class="line">                max_sd = sd;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 select 监听套接字</span></span><br><span class="line">        activity = select(max_sd + <span class="number">1</span>, &amp;readfds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接受新连接</span></span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(server_fd, &amp;readfds)) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((new_socket = accept(server_fd, (<span class="keyword">struct</span> sockaddr *)&amp;address, (<span class="type">socklen_t</span>*)&amp;addrlen))&lt;<span class="number">0</span>) &#123;</span><br><span class="line">              <span class="comment">// 错误处理并退出</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将新套接字添加到数组</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_CLIENTS; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (client_socket[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                    client_socket[i] = new_socket;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     <span class="comment">// 其他套接字的数据处理</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_CLIENTS; i++) &#123;</span><br><span class="line">        sd = client_socket[i];</span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(sd, &amp;readfds)) &#123;</span><br><span class="line">            <span class="comment">// 检查是否是断开连接，否则接收数据</span></span><br><span class="line">            <span class="keyword">if</span> ((valread = read(sd, buffer, <span class="number">1024</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">                close(sd);</span><br><span class="line">                client_socket[i] = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                buffer[valread] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                <span class="comment">// 将接收到的数据发送回客户端</span></span><br><span class="line">                send(sd, buffer, <span class="built_in">strlen</span>(buffer), <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>select优缺点</strong>：</p><p><strong>优点</strong>:</p><ul><li><p><strong>能够同时监视多个套接字</strong>:  select 允许服务器以单线程的方式监视多个套接字，来检测它们是否有可读、可写或异常条件发生。</p></li><li><p><strong>无需多线程或多进程</strong>：select 采用单线程的处理方式，使用 select 可以避免复杂的多线程或多进程管理，减少了上下文切换的开销，简化了并发处理。</p></li><li><p><strong>适用于小到中等规模的负载</strong>：对于不是很高的并发连接数（几百的连接数），select 通常可以满足需求，且效率不错。</p></li></ul><p><strong>缺点</strong>:</p><ul><li><p><strong>文件描述符限制</strong>：select 可以监视的文件描述符数量是有限的，通常由 <strong>FD_SETSIZE</strong> 常量决定，这在很多系统上默认是1024。这限制了服务器可以处理的最大并发连接数。当然 select 也会受限于系统级别的文件描述符数量限制。</p></li><li><p><strong>效率问题</strong>：随着文件描述符数量的增加，select 的性能会线性下降。每次调用select时，都需要重新传入整个文件描述符集合，内核需要遍历这个集合来更新状态，这在文件描述符很多时会成为瓶颈。</p></li><li><p><strong>响应时间变长</strong>：在 select 返回的文件描述符列表集合中，如果有多个文件描述符同时变为活跃状态，服务器通常会按顺序处理它们。这可能导致对列表前面的连接有偏见，使得后面的连接等待时间较长。</p></li></ul><p><strong>IO 复用之 Poll</strong>：</p><p><strong>基本概念</strong>：<br>poll 也是一种 IO 复用技术，用于监视多个文件描述符（通常是网络套接字）的可读性、可写性和异常状态。与 select 类似，poll 允许您的程序监视多个文件描述符，直到一个或多个文件描述符准备好进行 IO 操作。这使得您可以同时管理多个网络连接，而不是逐个阻塞地处理它们。</p><p><strong>函数声明</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span>;</span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">fds：指向一个 pollfd 结构数组的指针，该数组包含要监视的文件描述符及其请求的事件（如 POLLIN 表示可读，POLLOUT 表示可写）。</span></span><br><span class="line"><span class="comment">nfds：指定数组 fds 中的元素数量。</span></span><br><span class="line"><span class="comment">timeout：指定等待时间（毫秒）。特殊值有：0 立即返回（非阻塞），-1 无限等待直到某个事件发生。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>pollfd 结构</strong></p><p>poll 函数使用 pollfd 结构来指定要监视的文件描述符和事件类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> fd;         <span class="comment">// 文件描述符</span></span><br><span class="line">    <span class="type">short</span> events;   <span class="comment">// 请求的事件</span></span><br><span class="line">    <span class="type">short</span> revents;  <span class="comment">// 实际发生的事件</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">fd：文件描述符</span><br><span class="line">events：要监视的事件，如 POLLIN、POLLOUT</span><br><span class="line">revents：由 poll 函数设置，表明哪些事件实际发生了</span><br></pre></td></tr></table></figure><p><strong>Poll 底层采用的数据结构图解</strong></p><p><img src="/images/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/14.jpg"></p><p><strong>底层数据结构：</strong></p><p><strong>用户空间数组</strong>：用户空间程序使用数组（类型为 struct pollfd）来提供要监视的文件描述符及其感兴趣的事件</p><p>但在内核中，为了有效地处理这些文件描述符，poll 的实现转而使用链表。</p><p><strong>内核空间链表</strong>：</p><ul><li>当 poll 系统调用被执行时，内核首先将这个数组中的数据复制到内核空间。</li><li>在内核中，为了更灵活地处理可能的大量文件描述符，这些 pollfd 结构被组织成链表形式。</li><li>链表的每个节点可能包含一个或多个 pollfd 结构，具体取决于可用的内存和文件描述符的数量。</li></ul><p><strong>poll 优缺点</strong>：</p><p><strong>优点</strong>：</p><p><strong>无内置文件描述符限制</strong>：与 select 不同，poll 不受文件描述符数量的限制。select 通常受限于 FD_SETSIZE，这在处理大量并发连接时可能成为瓶颈。<strong>但它仍然受限于系统级别的文件描述符限制。</strong></p><p><strong>简化的接口</strong>：poll 使用单个结构体数组来表示所有监视的文件描述符和相关事件，相比 select 需要使用三个文件描述符集（读、写、异常），接口更为简洁。</p><p><strong>更直观的事件模型</strong>：poll 使用位字段来表示不同的事件类型，这使得事件模型比 select 的方式更直观和易于理解。</p><p><strong>缺点</strong>：</p><p><strong>线性扫描开销</strong>：poll 在处理文件描述符时，需要对整个数组进行线性扫描。当监视的文件描述符数量非常大时，这可能导致性能下降。</p><p>总的来说，poll 是 select 的一种改进，特别是在可处理的文件描述符数量上没有限制，但在高性能和大规模并发处理方面，epoll 在现代 Linux 系统上通常是更佳的选择。</p><p><strong>poll 并发回射服务器程序示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 8080</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_CLIENTS 30</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> listen_fd, new_socket, valread;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    <span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> addrlen = <span class="keyword">sizeof</span>(address);</span><br><span class="line">    <span class="type">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">client_fds</span>[<span class="title">MAX_CLIENTS</span>];</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建监听套接字</span></span><br><span class="line">   listen_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)；</span><br><span class="line">    <span class="comment">// 绑定套接字</span></span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    address.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    address.sin_port = htons(PORT);</span><br><span class="line"></span><br><span class="line">    bind(listen_fd, (<span class="keyword">struct</span> sockaddr *)&amp;address, <span class="keyword">sizeof</span>(address)</span><br><span class="line">    listen(listen_fd, <span class="number">3</span>); <span class="comment">// 开始监听</span></span><br><span class="line">    <span class="comment">// 初始化 pollfd 结构</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_CLIENTS; i++) &#123;</span><br><span class="line">        client_fds[i].fd = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    client_fds[<span class="number">0</span>].fd = listen_fd;</span><br><span class="line">    client_fds[<span class="number">0</span>].events = POLLIN;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主循环</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> activity = poll(client_fds, MAX_CLIENTS, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (activity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">//出错处理并退出</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查是否有新的连接</span></span><br><span class="line">        <span class="keyword">if</span> (client_fds[<span class="number">0</span>].revents &amp; POLLIN) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((new_socket = accept(listen_fd, (<span class="keyword">struct</span> sockaddr *)&amp;address, (<span class="type">socklen_t</span>*)&amp;addrlen)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="comment">//出错处理并退出</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加新的套接字到数组</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; MAX_CLIENTS; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (client_fds[i].fd == <span class="number">-1</span>) &#123;</span><br><span class="line">                    client_fds[i].fd = new_socket;</span><br><span class="line">                    client_fds[i].events = POLLIN;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查客户端活动</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; MAX_CLIENTS; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (client_fds[i].fd &gt; <span class="number">0</span> &amp;&amp; (client_fds[i].revents &amp; POLLIN)) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((valread = read(client_fds[i].fd, buffer, BUFFER_SIZE)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    buffer[valread] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                    send(client_fds[i].fd, buffer, valread, <span class="number">0</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    close(client_fds[i].fd);</span><br><span class="line">                    client_fds[i].fd = <span class="number">-1</span>; <span class="comment">// 标记为可用</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>IO 复用之 Epoll</strong></p><p><strong>基本概念</strong>：<br>epoll 是 Linux 系统中一种高效的 I&#x2F;O 事件通知机制，特别适用于处理大量并发网络连接。与传统的 select 或 poll 方法相比，epoll 的独特之处在于其对活跃连接的高效处理能力。它通过维护一个活跃事件集合，避免了对所有文件描述符的遍历，显著提升了性能。这使得 epoll 成为构建高性能网络应用程序的理想选择。</p><p><strong>函数声明</strong></p><p>epoll 主要涉及三个系统调用：epoll_create、epoll_ctl 和 epoll_wait。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// epoll_create：创建一个 epoll 实例。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>;</span><br><span class="line"><span class="comment">// poll_ctl：管理（添加、修改或删除）监视的文件描述符。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">epfd：由 epoll_create 返回的 epoll 实例文件描述符。</span></span><br><span class="line"><span class="comment">op：要执行的操作，如 EPOLL_CTL_ADD（添加）、EPOLL_CTL_MOD（修改）、EPOLL_CTL_DEL（删除）。</span></span><br><span class="line"><span class="comment">fd：关联的文件描述符。</span></span><br><span class="line"><span class="comment">event：指向 epoll_event 结构的指针，指定感兴趣的事件和任何关联的用户数据。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 待在 epoll 文件描述符上注册的事件发生</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event *events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">epfd：epoll 实例的文件描述符。</span></span><br><span class="line"><span class="comment">events：用于从内核获取事件的 epoll_event 结构数组。</span></span><br><span class="line"><span class="comment">maxevents：指示数组中可以返回的最大事件数。</span></span><br><span class="line"><span class="comment">timeout：等待事件的最大时间（毫秒），-1 表示无限等待。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>epoll_event 结构</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span>     events;    <span class="comment">/* Epoll events */</span></span><br><span class="line">    <span class="type">epoll_data_t</span> data;      <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">events 字段用于指定感兴趣的事件类型，例如 EPOLLIN（可读）、EPOLLOUT（可写）等。</span></span><br><span class="line"><span class="comment">data 字段通常用于存储用户定义的数据，如文件描述符、指向对象的指针等。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//epoll_data_t 是一个联合（union），它用于存储用户定义的数据，可以是文件描述符、指针或任何其他用户需要的数据类型。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *ptr;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">uint32_t</span> u32;</span><br><span class="line">    <span class="type">uint64_t</span> u64;</span><br><span class="line">&#125; <span class="type">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">例如，您可以在 epoll_ctl 调用时，使用 epoll_data_t 的 fd 字段来存储正在监视的文件描述符，</span></span><br><span class="line"><span class="comment">或者使用 ptr 字段来存储指向某个对象或结构的指针。这样，在事件发生时，您可以快速访问与该事件相关联的数据。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>Epoll 的两种触发模式</strong>：</p><p>在 Linux 中，epoll 提供了两种触发模式：<strong>水平触发（Level-Triggered, LT）和边缘触发（Edge-Triggered, ET）</strong>。理解这两种模式对于使用 epoll 来说非常关键，因为它们决定了在文件描述符（FD）上发生事件时，epoll 如何通知应用程序。</p><p><strong>水平触发（Level-Triggered, LT）</strong></p><p><strong>触发条件</strong>：只要文件描述符关联的 socket 缓冲区上有数据可读或有空间可写，epoll_wait 就会返回该文件描述符。这意味着，只要有未处理的数据（如缓冲区中还有数据未读），epoll_wait 会不断地通知应用程序去读数据至用户空间缓存，从而进行处理。</p><p><strong>处理方式</strong>：这种模式更加容易处理，因为即使应用程序没有一次性处理所有的可用数据，epoll_wait 会再次通知你该文件描述符上仍有待处理的数据。</p><p><strong>水平触发的优点</strong>：</p><ul><li><p><strong>简单易懂</strong>：水平触发的行为更直观，容易理解和实现，尤其是对于那些不太熟悉非阻塞 I&#x2F;O 编程的开发者。</p></li><li><p><strong>容错性高</strong>：在水平触发模式下，只要文件描述符的状态仍满足条件（如有数据可读），epoll_wait 会持续通知应用程序，减少了因遗漏事件处理导致的错误。</p></li></ul><p><strong>水平触发的缺点</strong>：</p><ul><li><p><strong>可能的性能开销</strong>：在高负载或大量并发连接的情况下，水平触发可能导致频繁的 epoll_wait 响应。因为只要文件描述符仍然处于活跃状态（例如，仍有数据可读），它就会不断地触发事件。</p></li><li><p><strong>资源使用效率</strong>：由于频繁的事件触发，水平触发模式可能导致更高的CPU使用率，尤其是当有大量活跃的文件描述符时。</p></li></ul><p><strong>水平触发示例代码：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line"><span class="type">int</span> epoll_fd, fd;</span><br><span class="line"></span><br><span class="line">event.events = EPOLLIN; <span class="comment">// LT 是默认模式</span></span><br><span class="line">event.data.fd = fd;</span><br><span class="line">epoll_ctl(epoll_fd, EPOLL_CTL_ADD, fd, &amp;event);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件循环</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[<span class="title">MAX_EVENTS</span>];</span></span><br><span class="line">    <span class="type">int</span> n = epoll_wait(epoll_fd, events, MAX_EVENTS, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (events[i].data.fd == fd) &#123;</span><br><span class="line">            <span class="comment">// 可以读取部分数据，即使不全部读取完，该 FD 仍然会再次报告</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>边缘触发（Edge-Triggered, ET）</strong></p><p><strong>触发条件</strong>：只有文件描述符的状态发生改变时，epoll_wait 才会通知应用进程来读写数据（只通知一次），直到文件描述符的状态再次发生变化。</p><p><strong>那什么才是文件描述符的状态发生改变呢？</strong></p><p>文件描述符的状态发生改变指的是 <strong>fd 从不可读的状态改变成可读的状态或者fd 从不可写的状态改变成可写的状态。</strong></p><p><strong>对于 socket 可读事件来说</strong>：</p><p>fd 从不可读的状态改变成可读的状态，简单理解就是：<strong>fd 对应的 socket 接收缓冲区从无数据到有数据。</strong> </p><p><strong>具体点</strong>：就是当数据首次到达一个空的 socket 接收缓冲区时，epoll_wait 会通知应用程序一次。此时，缓冲区状态从“无数据可读”变为“有数据可读”。又或者应用程序开始读取数据，并将缓冲区中的数据读完（读操作返回 EAGAIN），然后又有新数据到达。这两种情况都是属于 socket 接收缓冲区从无数据到有数据的例子。</p><p><strong>再来看个特殊情况：</strong></p><p>在 ET 模式下，一旦应用程序开始读取数据，如果没有一次性将缓冲区中的所有数据都读取完（即仍有未读取的数据留在缓冲区中），此时不会触发新的 epoll_wait 通知。但是如果此时接收缓冲区又来了新数据，即使文件描述符的状态并没有发生改变，但也会触发新的 epoll_wait 通知的。</p><p><strong>对于 socket 可写事件来说</strong>：</p><p>文件描述符的状态发生改变指的是：fd 从不可写的状态改变成可写的状态。简单理解就是：<strong>fd 对应的 socket 发送缓冲区从满到不满。</strong> 对于可写事件，存在以下两个场景：</p><h4 id="场景一：持续有空间"><a href="#场景一：持续有空间" class="headerlink" title="场景一：持续有空间"></a>场景一：持续有空间</h4><p>假设你有一个socket连接，你正在向它发送数据。在边缘触发（ET）模式下：</p><ul><li><strong>初始状态</strong>：连接建立后，发送缓冲区为空，所以你可以开始发送数据。</li><li><strong>持续发送</strong>：只要发送缓冲区有空间，你可以继续发送数据。在这个过程中，如果缓冲区从未真正变满过（即，你的发送速度不超过网络层处理和发送数据的速度），epoll_wait不会因为缓冲区有空间而特别通知你，因为从epoll的角度看，这不是一个“状态变化”。</li></ul><h4 id="场景二：缓冲区满后又有空间"><a href="#场景二：缓冲区满后又有空间" class="headerlink" title="场景二：缓冲区满后又有空间"></a>场景二：缓冲区满后又有空间</h4><p>现在，让我们看一个缓冲区实际变满的情况：</p><p><strong>1.发送直至满</strong>：你继续发送数据，直到达到一个点，发送缓冲区满了，这时，尝试再发送数据会失败（通常返回EAGAIN或EWOULDBLOCK）。</p><p><strong>2.等待可写</strong>：这时，你应该停止发送数据，等待 epoll_wait 通知你 socket 再次可写。</p><p><strong>3.缓冲区部分清空</strong>：随着时间的推移，网络层将缓冲区中的数据发送出去，缓冲区从“满”变为“有空间”（即，部分数据被发送出去，为新数据腾出了空间）。</p><p><strong>4.收到通知</strong>：因为缓冲区的状态从“满”变为“有空间”，这是一个状态变化，epoll_wait 会通知你 socket 现在可写。</p><p><strong>处理方式</strong>：ET 模式要求你必须一次性处理所有可用的数据。如果处理不完全，epoll_wait 不会再次通知你该文件描述符上的事件，除非新的数据到达或再次变为可写。</p><p><strong>边缘触发示例代码：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line"><span class="type">int</span> epoll_fd, fd;</span><br><span class="line"></span><br><span class="line">event.events = EPOLLIN | EPOLLET; <span class="comment">// 启用 ET 模式</span></span><br><span class="line">event.data.fd = fd;</span><br><span class="line">epoll_ctl(epoll_fd, EPOLL_CTL_ADD, fd, &amp;event);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件循环</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[<span class="title">MAX_EVENTS</span>];</span></span><br><span class="line">    <span class="type">int</span> n = epoll_wait(epoll_fd, events, MAX_EVENTS, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (events[i].data.fd == fd) &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">ssize_t</span> count = read(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                <span class="keyword">if</span> (count == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (errno != EAGAIN) &#123;</span><br><span class="line">                        <span class="comment">// 处理非 EAGAIN 错误</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>; <span class="comment">// 没有更多数据可读</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 处理读取的数据</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>边缘触发的优缺点：</strong></p><p><strong>优点：</strong></p><p><strong>减少通知频率：</strong></p><p>在 ET 模式中，epoll_wait 只在文件描述符（如套接字）的状态发生变化时通知一次（例如，从不可读变为可读）。这减少了系统不断检查状态的需要，尤其在管理大量连接时非常有效。</p><p><strong>提高事件处理效率：</strong></p><p>由于减少了频繁的事件通知，应用程序可以更集中地处理每次通知的事件。这在同时处理许多连接时提升了效率。每次事件都得到了充分的处理，而不是浪费资源在重复或不必要的检查上，从而整体提高了处理大量并发连接的效率。</p><p><strong>降低资源占用：</strong></p><p>ET 模式通过减少频繁的事件检查和处理，有助于减少 CPU 和内存的使用，尤其在高负载下。</p><p><strong>更好的扩展性：</strong></p><p>对于需要处理大量并发连接的高性能服务器，ET 模式能够更高效地利用资源，使服务器能够承载更多的连接，从而提升整体的扩展能力。</p><p><strong>缺点：</strong></p><p><strong>处理逻辑更加复杂：</strong></p><p>在 ET 模式下，必须在每次通知时尽可能完整地处理 I&#x2F;O 事件（读取或写入所有数据），因为相同条件下不会再次收到通知。这要求程序能够有效地一次性处理大量数据。</p><p><strong>可能会错过一些数据：</strong></p><p>如果在处理通知时没有完全读取或写入所有数据，剩余的数据可能不会触发新的通知，导致程序错过一些重要数据。</p><p><strong>依赖于非阻塞 I&#x2F;O：</strong></p><p>ET 模式通常和非阻塞 I&#x2F;O 结合使用。在这种模式下，编程变得更复杂，因为需要处理非阻塞调用可能遇到的特殊情况，如 EAGAIN 或 EWOULDBLOCK。</p><p><strong>总结：</strong></p><p><strong>水平触发</strong>：更易于使用和理解，但可能会导致更多的 epoll_wait 调用，尤其是在高负载下。</p><p><strong>边缘触发</strong>：更高的性能潜力，减少了 epoll_wait 调用的次数，但需要更谨慎的缓冲区管理和错误处理。</p><p><strong>Epoll 优缺点</strong></p><p><strong>优点：</strong></p><p><strong>1.高效的文件描述符管理</strong></p><p>在 epoll 中，高效的文件描述符管理首先依赖于高效的数据结构（红黑树和链表）以及回调函数。epoll 使用红黑树来组织所有监控的文件描述符，提供快速的查找、插入和删除操作。链表则用于存储准备就绪的事件，使得 epoll_wait 能迅速返回这些事件。每当监控的文件描述符发生状态变化（例如，socket 上有数据到来）时，与之关联的回调函数被内核自动触发。这些回调函数直接将就绪的文件描述符事件添加到 epoll 的就绪链表中。使得 epoll_wait 快速返回，这种集成了回调机制和高效数据结构的方法，使 epoll 在处理大量并发连接时比传统的 select 和 poll 方法更高效。</p><p>  相比之下，select 和 poll 每次调用时都需要遍历整个文件描述符集合，以检查每个描述符的状态。当文件描述符数量很大时，这种方法的效率显著降低。</p><p><strong>2.更好的可扩展性</strong></p><p>epoll 能够处理的文件描述符数量远超过 select 的 FD_SETSIZE 限制（通常为1024），使其能够更有效地处理成千上万的并发连接。这使 epoll 成为高并发网络应用的理想选择，例如大型网站的服务器。</p><p><strong>3.减少复制操作</strong></p><p>在传统的 select 和 poll 方法中，应用程序需要在每次调用时将整个文件描述符集合从用户空间复制到内核空间，内核处理完后再将结果复制回用户空间。这种来回复制操作效率比较低。</p><p>而在 epoll 中，只需要将就绪事件从内核空间的就绪链表复制到用户空间，而非整个被监控的文件描述符集合。这种机制大大减少了数据在用户空间和内核空间之间频繁来回复制的需求，特别是在只有少数文件描述符就绪的大规模并发连接场景中，显著降低了上下文切换和数据复制的开销，从而提高了整体的效率和性能。</p><p><strong>4.支持边缘触发（ET）和水平触发（LT）</strong></p><ul><li><strong>两种触发模式</strong>：epoll 提供了边缘触发（ET）和水平触发（LT）两种模式。边缘触发仅在文件描述符状态发生变化时通知一次，而水平触发则在描述符保持某状态时持续通知。</li><li><strong>适应不同的使用场景</strong>：<br>这种灵活性使得开发者可以根据具体的应用需求和行为特点选择最合适的模式，以优化性能。</li></ul><p><strong>缺点：</strong></p><p><strong>平台依赖性：</strong> epoll 是 Linux 特有的，不具备 select 和 poll 那样的跨平台特性。这意味着基于 epoll 的应用程序不能在非 Linux 系统上直接运行，限制了其可移植性。</p><p><strong>边缘触发模式的挑战</strong></p><p>在边缘触发（ET）模式下，epoll 只在状态变化时通知一次。这意味着应用程序必须正确处理所有的数据，否则可能会丢失未处理的事件。 </p><p><strong>Epoll 并发回射服务器程序示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_EVENTS 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> READ_BUF_SIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 8080</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> listen_fd, conn_fd, epoll_fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>, <span class="title">events</span>[<span class="title">MAX_EVENTS</span>];</span></span><br><span class="line">    <span class="type">int</span> event_count, i;</span><br><span class="line">    <span class="type">char</span> read_buf[READ_BUF_SIZE];</span><br><span class="line"></span><br><span class="line">    socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    server_addr.sin_port = htons(PORT);</span><br><span class="line">    bind(listen_fd, (<span class="keyword">struct</span> sockaddr *)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr))</span><br><span class="line">    listen(listen_fd, SOMAXCONN)</span><br><span class="line"></span><br><span class="line">    epoll_fd = epoll_create1(<span class="number">0</span>);</span><br><span class="line">    event.events = EPOLLIN;</span><br><span class="line">    event.data.fd = listen_fd;</span><br><span class="line"></span><br><span class="line">    epoll_ctl(epoll_fd, EPOLL_CTL_ADD, listen_fd, &amp;event)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        event_count = epoll_wait(epoll_fd, events, MAX_EVENTS, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; event_count; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (events[i].data.fd == listen_fd) &#123;</span><br><span class="line">                conn_fd = accept(listen_fd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">                <span class="keyword">if</span> (conn_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">                    perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                event.events = EPOLLIN | EPOLLET;</span><br><span class="line">                event.data.fd = conn_fd;</span><br><span class="line">                <span class="keyword">if</span> (epoll_ctl(epoll_fd, EPOLL_CTL_ADD, conn_fd, &amp;event) == <span class="number">-1</span>) &#123;</span><br><span class="line">                    perror(<span class="string">&quot;epoll_ctl&quot;</span>);</span><br><span class="line">                    close(conn_fd);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> nbytes = read(events[i].data.fd, read_buf, READ_BUF_SIZE);</span><br><span class="line">                <span class="keyword">if</span> (nbytes &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    close(events[i].data.fd);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    write(events[i].data.fd, read_buf, nbytes);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(listen_fd);</span><br><span class="line">    close(epoll_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="异步I-O服务器模型"><a href="#异步I-O服务器模型" class="headerlink" title="异步I&#x2F;O服务器模型"></a>异步I&#x2F;O服务器模型</h4><p>在讲述了 I&#x2F;O 多路复用服务器模型后，我们看到它如何使单个进程能够有效地管理多个网络连接。通过 select、poll 或 epoll，进程可以在多个连接上同时等待数据，而无需为每个连接阻塞等待。这种方法提升了并发处理的效率，<strong>但它有一个局限性：一旦某个连接的 I&#x2F;O 操作开始，该进程必须等待该操作完成才能继续处理下一个连接。</strong> 简单理解就是：处理各个连接的 IO 读写是同步的，是串行的。</p><p>为了解决这一问题，引入了异步I&#x2F;O服务器模型。这种模型极大提升了服务器的任务处理能力，它允许进程在发起I&#x2F;O操作后立即转而执行其他工作，而无需等待I&#x2F;O操作的完成。这一过程由操作系统在后台管理，一旦I&#x2F;O操作完成，进程便会收到通知。进程只需要去处理已被拷贝至应用层缓冲区的数据。</p><p><strong>Linux中的异步I&#x2F;O实现</strong>：</p><p>在Linux中，异步 IO 模型主要由 <strong>Linux aio</strong>（通过libaio库）和 <strong>io_uring</strong> 两种技术来实现。</p><p><strong>Linux aio(libaio)</strong></p><p>Linux aio 是 Linux 系统中较早支持的异步I&#x2F;O机制。它通过 libaio 库提供了一系列的API，允许应用程序非阻塞地启动和管理I&#x2F;O操作。当一个I&#x2F;O请求被提交后，libaio负责将其发送到操作系统，应用程序可以继续执行而无需等待。一旦I&#x2F;O操作完成，应用程序将通过回调函数或其他机制得到通知。</p><p><strong>libaio提供的 API</strong> :</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">io_setup       ：创建一个异步I/O上下文。</span><br><span class="line">io_submit      ：向异步I/O上下文提交一个或多个I/O请求。</span><br><span class="line">io_getevents   ：从异步I/O上下文中获取已完成的事件。</span><br><span class="line">io_destroy     ：销毁一个异步I/O上下文。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>尽管 libaio 为异步 I&#x2F;O 提供了基础支持，但它有一定的局限性，<strong>比如：它只适用于文件 I&#x2F;O，并不适合用于网络 I&#x2F;O。</strong></p><p>以下是一个简洁的 libaio 使用示例，演示了如何在 Linux 系统中以异步方式进行文件读取。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libaio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/eventfd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FILE_PATH <span class="string">&quot;example_file.txt&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">io_context_t</span> ctx;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iocb</span> <span class="title">cb</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iocb</span> *<span class="title">cbs</span>[1];</span></span><br><span class="line">    <span class="type">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">    <span class="type">int</span> file_fd, efd, ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_event</span> <span class="title">events</span>[1];</span></span><br><span class="line">    <span class="type">uint64_t</span> u;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;ctx, <span class="number">0</span>, <span class="keyword">sizeof</span>(ctx));</span><br><span class="line">    io_setup(<span class="number">10</span>, &amp;ctx);</span><br><span class="line">    file_fd = open(FILE_PATH, O_RDWR | O_CREAT, <span class="number">0644</span>);</span><br><span class="line">    <span class="comment">// 创建eventfd用于通知</span></span><br><span class="line">    efd = eventfd(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 准备异步读请求</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;cb, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> iocb));</span><br><span class="line">    io_prep_pread(&amp;cb, file_fd, buffer, BUFFER_SIZE, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 设置eventfd作为完成事件的通知</span></span><br><span class="line">    cb.data = (<span class="type">void</span> *)(<span class="type">uintptr_t</span>)efd;</span><br><span class="line">    cbs[<span class="number">0</span>] = &amp;cb;</span><br><span class="line">    <span class="comment">// 提交异步I/O请求</span></span><br><span class="line">    io_submit(ctx, <span class="number">1</span>, cbs)</span><br><span class="line">    <span class="comment">// 在这里，主线程可以执行其他业务逻辑</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    read(efd, &amp;u, <span class="keyword">sizeof</span>(<span class="type">uint64_t</span>));  <span class="comment">// 在主线程中等待通知</span></span><br><span class="line">    io_getevents(ctx, <span class="number">1</span>, <span class="number">1</span>, events, <span class="literal">NULL</span>);  <span class="comment">// 读取异步I/O事件</span></span><br><span class="line">    <span class="comment">// 处理完成的I/O事件</span></span><br><span class="line">    <span class="keyword">if</span>(events[<span class="number">0</span>].data == (<span class="type">void</span> *)(<span class="type">uintptr_t</span>)efd) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Read %zd bytes: %.*s\n&quot;</span>, events[<span class="number">0</span>].res, (<span class="type">int</span>)events[<span class="number">0</span>].res, buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    close(file_fd);</span><br><span class="line">    io_destroy(ctx);</span><br><span class="line">    close(efd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>io_uring</strong>：</p><p>io_uring 是 Linux 内核 5.1 版本引入的全新异步 I&#x2F;O 框架，io_uring 旨在提供一种高效、灵活且功能丰富的方式来执行异步 I&#x2F;O 操作。与 libaio 相比，io_uring 提供了更低的系统调用开销，更简单的接口，以及更好的性能。</p><p><strong>如何工作</strong>：</p><p>io_uring 的核心思想是通过两个队列来管理异步 I&#x2F;O 请求。一个叫做提交队列（SQ），另一个叫完成队列（CQ）。</p><p>1.<strong>提交请求</strong>：当你的程序想要执行一个 I&#x2F;O 操作，比如读取网络数据，它会创建一个请求并把它放到提交队列（SQ）中。</p><p>2.<strong>内核处理</strong>：Linux 内核会查看提交队列，取出请求并处理它们。你的程序不需要等待内核完成这个操作，它可以继续做其他事情。</p><p>3.<strong>完成通知</strong>：一旦内核完成了一个请求，它会把结果放入完成队列（CQ）中。这样程序就知道该操作已经完成，可以继续处理结果了。</p><p><strong>io_uring 的优势：</strong></p><ul><li><strong>性能</strong>：它允许应用程序一次性地批量提交多个 I&#x2F;O 请求，减少了系统调用的数量，所以 io_uring 能够提供比传统的异步 I&#x2F;O 更好的性能。</li><li><strong>减少等待</strong>：应用程序不需要每次提交一个请求就等待结果，它可以继续执行其他任务，同时内核在背后处理这些 I&#x2F;O 请求。</li><li><strong>功能丰富</strong>：io_uring 支持各种类型的 I&#x2F;O 操作，包括但不限于文件读写、网络操作等。</li><li><strong>易用性</strong>：io_uring 提供了一个更为简洁和一致的接口，相比于旧的异步 I&#x2F;O 接口，它更易于使用和理解。</li></ul><p>关于异步 IO 服务器模型的学习，大家只需要理解异步IO的工作方式，以及了解在 Linux 中可以通过 libaio 和 io_uring 技术可以构建异步 IO 服务器模型。如果想深入学习 io_uring 的底层原理，则可以去官网或者谷歌搜索相关资料去深入学习。</p><p><strong>这篇文章，大家可以去了解：</strong><br><a href="https://cloud.tencent.com/developer/article/2187655">https://cloud.tencent.com/developer/article/2187655</a> </p><p><strong>关于具体的代码示例，则可以去了解 liburing 这个库的 example 代码示例</strong>：<a href="https://github.com/axboe/liburing">https://github.com/axboe/liburing</a></p><h3 id="服务器架构模式"><a href="#服务器架构模式" class="headerlink" title="服务器架构模式"></a>服务器架构模式</h3><p>在前面的介绍中，我们了解了常见的服务器模型，但是这些模型在应对高并发场景都会遇到一些挑战，特别是在处理大量并发连接和高效率 I&#x2F;O 操作方面。尽管模型如多线程、线程池和 I&#x2F;O 多路复用提供了并发处理的基础架构，但它们各自都有局限性，特别是在高并发和低延迟要求的场景中。</p><p>这些挑战促使了对一种更高效、更可扩展的并发处理模式的需求— 这就是 Reactor 模式。Reactor 模式采用事件驱动的方法，结合同步 I&#x2F;O 多路复用技术，如 select、poll 或 epoll，提供了一种不同于传统线程模型的并发处理机制。</p><p><strong>为什么需要 Reactor 模式？</strong></p><p><strong>并发和 I&#x2F;O 效率</strong>：传统的多线程和多进程模型在处理成千上万的并发连接时可能会遇到性能瓶颈。这些模型往往涉及重的上下文切换和资源分配，特别是在频繁的 I&#x2F;O 操作下。</p><p><strong>简化事件处理</strong>：在 I&#x2F;O 多路复用模型中，虽然可以高效地监控多个 I&#x2F;O 流，但在事件分发和处理方面往往缺乏组织和结构。Reactor 模式提供了一种清晰的框架来处理多个并发 I&#x2F;O 事件，简化了事件驱动程序的开发。</p><h4 id="Reactor-模式详解"><a href="#Reactor-模式详解" class="headerlink" title="Reactor 模式详解"></a>Reactor 模式详解</h4><p><strong>Reactor 是什么？</strong></p><p>Reactor 模式可以理解为一种在网络编程中常用的设计模式，用于高效地处理多个并发 I&#x2F;O 事件，如用户请求或网络通信。它的核心概念是使用一个中心化的处理器（称为 Reactor）来监控所有的 I&#x2F;O 请求。当一个 I&#x2F;O 事件发生时（例如，新的客户端连接或者数据到达），Reactor 会捕获这个事件，并将其分派给相应的处理程序进行处理。</p><p><strong>核心组件：</strong></p><p><strong>1.Handles (句柄)：</strong></p><p><strong>定义</strong>：句柄是对操作系统资源的引用，通常是<strong>文件描述符</strong>（file descriptor）。在网络编程中，这通常是指代网络套接字（sockets）。</p><p><strong>用途</strong>：它用于标识一个特定的网络连接或其他 I&#x2F;O 资源，如打开的文件、管道等。</p><p><strong>示例</strong>：当一个客户端连接到服务器，服务器会为这个连接创建一个套接字，并为其分配一个文件描述符，这个文件描述符就是一个句柄。</p><p><strong>2.Synchronous Event Demultiplexer (事件多路分发器)：</strong></p><p><strong>定义</strong>：事件多路分发器是负责等待多个句柄上事件发生的组件。它可以同时监控多个句柄，如网络套接字上的可读或可写事件。</p><p><strong>实现</strong>：在 Linux 中，这通常通过系统调用如 select, poll 或 epoll 实现。</p><p><strong>功能</strong>：当一个或多个句柄上发生事件时（例如，新的客户端连接、数据到达等），事件多路分发器通知 Reactor。</p><p><strong>3.Event Handler (事件处理器)：</strong></p><p><strong>定义：</strong> 它是一个定义了处理不同类型事件所需接口或协议的抽象概念。通常包含一系列的方法或函数，用于处理各种事件，如读取数据（可读事件）、写入数据（可写事件）或处理错误（错误事件）。事件处理器定义了在发生特定事件时应当调用哪些方法，但不涉及这些方法的具体实现。</p><p><strong>例如：</strong> 一个事件处理器接口可能有一个 handle_read 方法用于处理可读事件，但它并不实现该方法。</p><p><strong>4.Concrete Event Handlers (具体事件处理器)：</strong></p><p><strong>定义：</strong> 具体事件处理器实现了定义在事件处理器接口中的所有方法，提供了如何处理特定事件的具体逻辑。</p><p>例如，一个具体事件处理器可能实现 handle_read 方法来从套接字中读取数据并处理这些数据。又或者实现 handle_accept 方法来处理客户端的连接请求。</p><p>具体事件处理器是实际工作的组件，每个具体的事件处理器实例通常与应用程序中的一个特定资源（一个socket 文件描述符）关联。</p><p><strong>5.Initiation Dispatcher (初始化分发器)：</strong></p><p><strong>定义</strong>：初始化分发器是 Reactor 模式的核心组件，负责管理事件循环、监听事件并将它们分发到相应的具体事件处理器。</p><p><strong>职责</strong>：它初始化事件多路分发器，注册事件处理器，并在事件发生时调用相应的具体事件处理器。</p><p><strong>事件循环</strong>：在整个应用程序的生命周期内，初始化分发器运行一个循环，等待和分发事件。</p><p><strong>select 实现的 Reactor 网络服务器程序</strong></p><p>这里只是提供一个简单示例，但以上的5个组件都包含。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 8080</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_CLIENTS 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">handler_t</span> handlers[MAX_CLIENTS];</span><br><span class="line"><span class="type">int</span> num_clients = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">handler_t</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> handle; <span class="comment">//句柄：在我们的上下文中就是套接字描述符。</span></span><br><span class="line">    <span class="type">void</span> (*handle_func)(<span class="type">int</span> handle, <span class="type">void</span> *arg);  <span class="comment">//事件处理器</span></span><br><span class="line">&#125; <span class="type">handler_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体事件处理器 ： 处理客户端的连接请求</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">acceptor_handler_func</span><span class="params">(<span class="type">int</span> handle, <span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> client_len = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line">    <span class="type">int</span> client_fd = accept(handle, (<span class="keyword">struct</span> sockaddr*)&amp;client_addr, &amp;client_len);</span><br><span class="line">    <span class="keyword">if</span> (client_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Accepted connection from %s\n&quot;</span>, inet_ntoa(client_addr.sin_addr));</span><br><span class="line">    <span class="comment">// 将新客户端加入到 handlers 中</span></span><br><span class="line">    handlers[num_clients].handle = client_fd;</span><br><span class="line">    handlers[num_clients].handle_func = client_handler_func;</span><br><span class="line">    num_clients++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体事件处理器：处理客户端的数据处理请求</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">client_handler_func</span><span class="params">(<span class="type">int</span> handle, <span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="type">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">    <span class="type">int</span> nbytes = recv(handle, buffer, <span class="keyword">sizeof</span>(buffer), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nbytes &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        close(handle);</span><br><span class="line">        <span class="comment">// 将handle从handlers数组中移除</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_clients; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (handlers[i].handle == handle) &#123;</span><br><span class="line">                handlers[i] = handlers[num_clients - <span class="number">1</span>];</span><br><span class="line">                num_clients--;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        send(handle, buffer, nbytes, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">event_demultiplexer</span><span class="params">()</span> &#123;</span><br><span class="line">    fd_set read_fds;</span><br><span class="line">    <span class="type">int</span> fd_max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    FD_ZERO(&amp;read_fds);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_clients; i++) &#123;</span><br><span class="line">        FD_SET(handlers[i].handle, &amp;read_fds);</span><br><span class="line">        <span class="keyword">if</span> (handlers[i].handle &gt; fd_max) &#123;</span><br><span class="line">            fd_max = handlers[i].handle;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待 socket 上的可读事件</span></span><br><span class="line">    <span class="keyword">if</span> (select(fd_max + <span class="number">1</span>, &amp;read_fds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;select&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分发事件</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_clients; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(handlers[i].handle, &amp;read_fds)) &#123;</span><br><span class="line">            handlers[i].handle_func(handlers[i].handle, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Initiation Dispatcher (初始化分发器)</span></span><br><span class="line"><span class="comment">Initiation Dispatcher 是 Reactor 模式的核心，允许应用程序注册事件、注销事件。并且它负责启动事件循环，等待事件并分发事件。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">run_reactor</span><span class="params">(<span class="type">int</span> listen_fd)</span> &#123;</span><br><span class="line">    <span class="comment">// 注册事件</span></span><br><span class="line">    handlers[num_clients].handle = listen_fd;</span><br><span class="line">    handlers[num_clients].handle_func = acceptor_handler_func;</span><br><span class="line">    num_clients++;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 启动事件循环</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        event_demultiplexer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> listen_fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    listen_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_port = htons(PORT);</span><br><span class="line">    server_addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    bind(listen_fd, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr);</span><br><span class="line">    listen(listen_fd, <span class="number">10</span>);</span><br><span class="line">  </span><br><span class="line">    run_reactor(listen_fd);</span><br><span class="line">    close(listen_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于 <strong>epoll</strong> 的高效性，我们一般会基于 epoll 去实现 reactor。<strong>具体实现可参考这篇文章：</strong><br><a href="https://zhuanlan.zhihu.com/p/539556726">https://zhuanlan.zhihu.com/p/539556726</a></p><p><strong>Reactor 事件处理流程</strong></p><p>下面通过时序图来图示上述代码的执行过程，方便大家理解：</p><p><img src="/images/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/15.png"></p><h4 id="Reactor-模式的优势和应用场景"><a href="#Reactor-模式的优势和应用场景" class="headerlink" title="Reactor 模式的优势和应用场景"></a>Reactor 模式的优势和应用场景</h4><p><strong>Reactor 模式的主要优势包括：</strong></p><ul><li><strong>高效的资源利用</strong>：<br>通过单线程或少量线程来管理多个并发连接，减少了线程上下文切换和资源消耗，提高了资源利用效率。</li><li><strong>快速响应能力</strong>：<br>非阻塞和事件驱动机制确保了快速响应外部事件，提高了程序的响应速度。</li><li><strong>更好的可扩展性</strong>：<br>能够处理成千上万的并发连接，而不会遇到传统多线程或多进程模型中线程资源限制的问题。</li></ul><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>这种模式特别适合于需要高并发处理的网络服务器，如 Web 服务器、数据库服务器等。</p><p><strong>结论：</strong><br>Reactor 模式是现代高性能网络编程的基石之一。它通过事件驱动和非阻塞 I&#x2F;O 机制有效地解决了传统并发模型在高并发环境下的限制，为构建可扩展的网络应用提供了强大的工具。</p><h4 id="Proactor-模式详解"><a href="#Proactor-模式详解" class="headerlink" title="Proactor 模式详解"></a>Proactor 模式详解</h4><p>在前面的讲解中，我们探讨了 Reactor 模式。该模式主要依赖于同步 I&#x2F;O，然而，随着并发需求的增加，尤其在高负载环境下，同步 I&#x2F;O 的局限性逐渐凸显。</p><p>应对这一挑战，异步编程模型的 <strong>Proactor 模式</strong>提供了一种全新的解决方案。它区别于 Reactor 的同步等待，转而采用<strong>完全异步的 I&#x2F;O 操作</strong>。在这个模式下，应用程序无需在 I&#x2F;O 完成前等待，而是在 I&#x2F;O 完成后接收通知。Proactor 模式有效减少了等待时间，提高了对并发连接的处理效率，尤其适合于构建<strong>高性能</strong>、<strong>I&#x2F;O 密集型</strong>的网络应用。这一模式不仅提升了性能，也代表了网络编程范式的一次重要转变，为开发高效和可扩展的网络服务提供了新思路。</p><p><strong>Proactor 是什么？</strong></p><p>Proactor 模式是一种高级的异步编程模型，用于处理 I&#x2F;O 操作。与传统的同步 I&#x2F;O 操作（如 Reactor 模式）不同，Proactor 模式允许应用程序在不阻塞主执行线程的情况下执行 I&#x2F;O 操作。应用程序发起异步 I&#x2F;O 请求后可以继续执行其他任务，而无需阻塞等待 I&#x2F;O 操作的完成。当 I&#x2F;O 操作实际完成时，操作系统会通知应用程序，并触发预定义的回调函数或事件处理程序来处理 I&#x2F;O 操作的结果。</p><p><strong>核心组件</strong></p><p><strong>异步操作对象：</strong> 该对象代表了单个的异步 I&#x2F;O 操作，如异步读取或写入。它 们通常封装了操作的细节，如操作类型、目标资源(文件描述符)、缓冲区地址等。</p><p><strong>异步操作对象的定义</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    ADD_TYPE_ACCEPT,</span><br><span class="line">    ADD_TYPE_READ,</span><br><span class="line">    ADD_TYPE_WRITE</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_data</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> type; <span class="comment">// ADD_TYPE_ACCEPT, ADD_TYPE_READ, ADD_TYPE_WRITE 等</span></span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">size_t</span> bytes_read;</span><br><span class="line">    <span class="type">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p><strong>Proactor 初始器（Proactor Initiator）</strong> ：<br>Proactor 初始器是负责启动和配置异步 I&#x2F;O 操作流程的组件。它通常由用户空间的代码执行，负责准备和提交异步 I&#x2F;O 请求到内核。</p><p>在 io_uring 中，Proactor 初始器 对应的是用户空间代码，特别是负责初始化 io_uring 实例、以及提交异步 I&#x2F;O 请求到内核的逻辑。</p><p><strong>来看下在 io_uring 中， Proactor Initiator 的代码示例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化 io_uring实例</span></span><br><span class="line"><span class="type">int</span> ret = io_uring_queue_init(<span class="number">256</span>, &amp;ring, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交一个异步读取请求</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">submit_async_read</span><span class="params">(<span class="keyword">struct</span> io_uring *ring, <span class="type">int</span> fd)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_data</span> *<span class="title">data</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span>  io_data));</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> *<span class="title">sqe</span>  =</span> io_uring_get_sqe(ring); </span><br><span class="line">    data-&gt;fd = fd;</span><br><span class="line">    data-&gt;type = ADD_TYPE_READ;</span><br><span class="line">    io_uring_prep_read(sqe, fd, data-&gt;buffer, BUFFER_SIZE, <span class="number">0</span>);      <span class="comment">// 准备读取请求</span></span><br><span class="line">    io_uring_sqe_set_data(sqe, data); <span class="comment">// 设置用户数据</span></span><br><span class="line">    io_uring_submit(ring);  <span class="comment">// 提交请求</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>异步操作处理器（Asynchronous Operation Processor）</strong>：<br>异步操作处理器是 Proactor 模式的核心，在内核中执行，负责启动异步 I&#x2F;O 操作并在操作完成时通知用户空间的 Proactor 实例。</p><p>在 io_uring 中，异步操作处理器 实际上是 io_uring 的内核组件。这包括提交队列（SQ）和完成队列（CQ），以及内核中负责处理这些队列的逻辑。</p><p><strong>完成处理器（Completion Handler）</strong></p><p>完成处理器是由应用程序定义的回调函数，它们在异步 I&#x2F;O 操作完成时被调用以处理 I&#x2F;O 操作的结果。</p><p>在 io_uring 中，完成处理器 对应于那些被提交到 io_uring 并在 I&#x2F;O 操作完成后执行的回调函数。这些回调函数处理 io_uring 从完成队列中获取的 CQEs(多个完成队列条目)。</p><p><strong>异步读取回调函数代码示例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">handle_read</span><span class="params">(<span class="keyword">struct</span> io_uring *ring, <span class="keyword">struct</span> io_uring_cqe *cqe)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_data</span> *<span class="title">data</span> =</span> io_uring_cqe_get_data(cqe);</span><br><span class="line">    <span class="keyword">if</span> (!data) &#123;</span><br><span class="line">        <span class="keyword">return</span>;  <span class="comment">// 数据为空则直接返回</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cqe-&gt;res &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 客户端断开连接或读取错误</span></span><br><span class="line">        close(data-&gt;fd);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 读取数据，准备回写(data-&gt;buffer缓冲区已经有数据了)</span></span><br><span class="line">        data-&gt;bytes_read = cqe-&gt;res;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Received: %.*s\n&quot;</span>, (<span class="type">int</span>)data-&gt;bytes_read, data-&gt;buffer);</span><br><span class="line">        <span class="comment">// 可以在这里添加写回逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(data);  <span class="comment">// 释放内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Proactor 实例</strong>：<br>Proactor 实例是负责管理整个异步 I&#x2F;O 流程的组件，它管理着异步操作处理器和完成处理器，调度完成处理器，并处理所有的异步事件。</p><p>在 io_uring 中，Proactor 实例 对应的是用户空间中维护 io_uring 接口和逻辑的部分，<strong>其实就是一个事件循环</strong>，它负责监控完成队列（CQ），确定哪些 I&#x2F;O 操作已经完成，并触发相应的完成处理器。</p><p><strong>Proactor 实例代码示例：</strong></p><pre><code class="c">// 运行事件循环以处理异步 I/O 操作void run_io_uring_loop(struct io_uring *ring) &#123;    struct io_uring_cqe *cqe;    unsigned head;    while (1) &#123;        // 提交所有挂起的请求并等待至少一个请求完成        io_uring_submit_and_wait(ring, 1);        // 处理所有已完成的事件        io_uring_for_each_cqe(ring, head, cqe) &#123;            if (cqe-&gt;res &lt; 0) &#123;                fprintf(stderr, &quot;IO operation failed: %s\n&quot;, strerror(-cqe-&gt;res));            &#125; else &#123;                handle_read(ring, cqe); // 调用完成处理器            &#125;            // 标记该事件已处理            io_uring_cqe_seen(ring, cqe);        &#125;    &#125;&#125;</code></pre><p><strong>Proactor 事件处理流程</strong></p><p><strong>启动异步操作（Proactor 初始器）</strong>：</p><p>你的程序（通过 Proactor 初始器）准备一个异步 I&#x2F;O 操作，比如说读取文件或接收网络数据。这个准备过程涉及指定要进行的操作类型（例如读取或写入）、哪个文件或网络连接，以及数据存放的位置。</p><p>一旦准备好，这个异步操作被提交给操作系统。如果使用 io_uring，这意味着将操作请求放入 io_uring 的提交队列（SQ）。操作系统内核处理异步操作（由异步操作处理器执行）。</p><p>一旦异步操作被提交，操作系统接管这个任务。在 io_uring 中，内核会处理这些 I&#x2F;O 请求。<strong>与此同时，你的程序可以继续执行其他任务，不必等待 I&#x2F;O 操作完成。</strong></p><p><strong>通知 Proactor实例</strong> ：</p><p>当操作系统完成了一个异步 I&#x2F;O 操作，它会将此操作的结果放入完成队列（CQ）。</p><p>你的程序中的 Proactor 实例会定期检查这个完成队列，看看是否有任何操作已经完成。</p><p><strong>处理完成的操作（完成处理器）：</strong></p><p>对于每一个已经完成的操作，Proactor 实例会调用相应的完成处理器。完成处理器是你事先定义好的，专门用来处理异步操作完成后的数据的函数。比如说，如果操作对象是网络套接字，处理器可能会处理读取到的数据。</p><p><strong>清理和准备下一步操作</strong>：</p><p>一旦完成处理器运行完毕，Proactor 实例会进行必要的清理工作，并准备接收和处理更多的完成事件。</p><p><strong>总结一下</strong>：Proactor 模式允许你的程序异步地执行 I&#x2F;O 操作，同时继续进行其他任务。操作系统在后台处理这些 I&#x2F;O 请求，当它们完成时，你的程序会得到通知，并调用相应的回调函数来处理结果。这个过程优化了资源的使用，提高了应用程序的响应性和效率。</p><h4 id="Proactor-模式的优势"><a href="#Proactor-模式的优势" class="headerlink" title="Proactor 模式的优势"></a>Proactor 模式的优势</h4><p><strong>完全的异步处理：</strong></p><p>Proactor 模式实现了真正的异步 I&#x2F;O。在 Proactor 模式中，所有的 I&#x2F;O 操作（包括读写）都是异步完成的。这意味着应用程序可以在 I&#x2F;O 操作进行时继续执行其他任务，而无需等待 I&#x2F;O 操作的完成。<br>相比之下，Reactor 模式通常只能异步地处理 I&#x2F;O 请求的准备阶段（例如等待数据到达或可发送状态），而实际的读写操作仍然是同步进行的。</p><p><strong>减少线程阻塞：</strong></p><p>在 Proactor 模式中，由于 I&#x2F;O 操作完全异步，应用程序线程不会因等待 I&#x2F;O 操作而阻塞，这对于保持高性能和响应性是非常重要的。<br>Reactor 模式虽然减少了直接的 I&#x2F;O 等待（例如等待数据到达），但在处理数据时仍然可能出现阻塞（如：数据处理操作耗时较长）。</p><p><strong>简化编程模型：</strong></p><p>Proactor 模式通过预定义的回调或事件处理器简化了异步 I&#x2F;O 的编程模型，使得代码更加清晰和易于维护。<br>在 Reactor 模式中，编程者需要显式处理 I&#x2F;O 事件的分发和响应，可能导致更复杂的事件处理逻辑。</p><h4 id="Proactor-模式的应用场景"><a href="#Proactor-模式的应用场景" class="headerlink" title="Proactor 模式的应用场景"></a>Proactor 模式的应用场景</h4><p><strong>高性能网络服务器</strong>：</p><p>如 Web 服务器、数据库服务器等，特别是在需要处理大量并发网络请求的场景。</p><p><strong>文件 I&#x2F;O 密集型应用</strong>：</p><p>例如日志处理、大数据分析，以及任何需要频繁读写大型文件的应用。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在本系列文章中，我们深入探讨了Linux下的套接字编程，一个在网络通信中不可或缺的核心技术-<strong>套接字</strong>。套接字作为网络通信的基石，使得不同主机间的数据交换变得可能。</p><p><strong>套接字的本质</strong></p><p>我们首先解析了套接字的概念，它是支持TCP&#x2F;IP网络通信的基础API，为应用层与网络层之间提供了一个抽象层。通过套接字，应用程序可以不用关心底层的网络细节，就能进行网络通信。</p><p><strong>套接字类型</strong></p><p>接着，我们探讨了<strong>套接字的三种基本类型</strong>：</p><ul><li><strong>流式套接字（SOCK_STREAM</strong>）：提供序列化的、可靠的、双向的连接通信。</li><li><strong>数据报套接字（SOCK_DGRAM）</strong>：提供非连接的、不可靠的通信。</li><li><strong>原始套接字（SOCK_RAW）</strong>：允许直接访问底层协议，用于需要细粒度控制的场景。</li></ul><p><strong>关键API与结构</strong></p><p>我们详细介绍了套接字编程中的关键API，如 <strong>socket、bind、listen、accept、connect以及send和recv函数</strong>，以及套接字地址结构（如sockaddr）和地址转换API，这些是进行套接字编程的基础。</p><p><strong>数据处理</strong></p><p>字节序转换API的讨论，帮助我们处理跨平台的数据一致性问题。</p><p><strong>Linux的IO模型</strong></p><p>本系列文章还覆盖了Linux系统中的多种IO模型，包括阻塞IO、非阻塞IO、I&#x2F;O多路复用、信号驱动IO和异步IO，它们各有优势，适用于不同的场景。</p><p><strong>网络I&#x2F;O性能优化</strong></p><p>在网络I&#x2F;O性能优化部分，我们讨论了<strong>硬件优化和软件优化</strong>策略，强调了应用程序设计的重要性和内核参数调整的作用。</p><p><strong>服务器模型</strong></p><p>最后，我们探讨了 Linux 环境下常见的服务器模型，包括单进程、多进程、多线程、线程池和I&#x2F;O多路复用模型以及异步I&#x2F;O服务器模型，每种模型都有其应用场景和优缺点。</p><p><strong>架构模式</strong></p><p>服务器架构模式，如 <strong>Reactor</strong> 和 <strong>Proactor</strong>，提供了高效处理并发网络事件的方法，是构建高性能网络应用的关键。</p><p><strong>至此：</strong> 我们已经探索了 Linux 网络编程的核心领域，涵盖了从基本套接字类型与 API 的使用，到复杂的 I&#x2F;O 模型和服务器架构设计等关键知识点。这些内容构成了搭建高可用网络服务的基础框架。本篇文章主要是帮助大家提供一个清晰的 Linux 网络编程学习指南，希望这篇文章能够为你们学习编程提供帮助。</p><p>如果你对 <strong>Linux 网络编程</strong>有更深的兴趣，或者<strong>想要探索更多关于Linux编程、以及计算机基础相关的知识，不妨关注我的公众号「跟着小康学编程」</strong>。这里不仅有丰富的学习资源，还有持续更新的技术文章。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>另外，小康最近创建了一个技术交流群，专门用来探讨技术相关或者解答读者的问题。大家在阅读这篇文章的时候，如果觉得有问题的或者有不理解的知识点，欢迎大家加群或者评论区询问。我能够解决的，尽量给大家回复。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> Linux网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux网络编程 </tag>
            
            <tag> Linux 网络I/O模型 </tag>
            
            <tag> Linux 服务器模型 </tag>
            
            <tag> Linux 网络IO性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 系统编程从入门到进阶 学习指南</title>
      <link href="/systemprog/"/>
      <url>/systemprog/</url>
      
        <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>大家好，我是小康 ，今天我们来学习一下 Linux 系统编程相关的知识。Linux 系统编程是连接高级语言和硬件的桥梁，它对深入理解计算机系统至关重要。无论你是打算构建高性能服务器还是开发嵌入式设备，掌握 Linux 系统编程是 C 和 C++ 开发者的基本技能。</p><p>本文旨在为初学者提供一个清晰的 Linux 系统编程入门指南，带你步入 Linux 系统编程的世界，从基本概念到实用技能，一步步建立起您的知识体系。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>什么是系统编程？</strong></p><p>系统编程，指的是开发那些直接与计算机硬件或操作系统进行交互的程序。这些程序负责管理和控制计算机系统的资源，包括但不限于进程、内存、文件系统和设备驱动。确保为应用程序提供一个稳定、高效的运行环境。</p><p><strong>系统编程与应用编程的主要区别</strong>：</p><ul><li><strong>目的性</strong>：系统编程旨在为计算机或操作系统本身提供功能和服务，而应用编程是为了满足最终用户的特定需求。</li><li><strong>交互对象</strong>：系统编程直接与硬件或操作系统交互，而应用编程与操作系统或其他应用交互。</li><li><strong>复杂性</strong>：由于系统编程需要管理和控制计算机的底层资源，因此通常比应用编程更为复杂。</li><li><strong>开发工具</strong>：系统编程通常使用低级语言，如 C 或汇编，因为这些语言提供了直接访问硬件的能力。而应用编程可能使用更高级的语言，如 Python 或 Java，以提高开发效率。</li></ul><h2 id="Linux系统编程核心技术概览"><a href="#Linux系统编程核心技术概览" class="headerlink" title="Linux系统编程核心技术概览"></a>Linux系统编程核心技术概览</h2><p>在电脑的世界中，操作系统起到桥梁的作用，连接用户与计算机硬件。其中，Linux 由于其开源、稳定和安全的特点，成为了许多工程师的首选。为了更深入地理解它，我们首先需要了解其系统架构的神秘面纱。</p><p><img src="/images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/1.jpg"></p><h3 id="Linux-系统架构解析"><a href="#Linux-系统架构解析" class="headerlink" title="Linux 系统架构解析"></a>Linux 系统架构解析</h3><h4 id="用户空间和内核空间的布局"><a href="#用户空间和内核空间的布局" class="headerlink" title="用户空间和内核空间的布局"></a>用户空间和内核空间的布局</h4><p><img src="/images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/2.jpg"></p><p><strong>各个内核组件说明</strong>:</p><ul><li><p><strong>系统调用 （Syscalls）</strong>：</p><p>当应用程序需要访问硬件资源时，它们使用系统调用来与内核通信。</p></li><li><p><strong>进程管理</strong>：</p><p>负责处理进程创建、调度和终止。确保系统中的进程公平、有效地获得 CPU 时间，并管理进程间的通信和同步。</p></li><li><p><strong>内存管理</strong>：</p><p>管理物理内存，提供虚拟内存和分页功能。确保每个进程都有它自己的地址空间，同时保护进程间的内存不被非法访问。</p></li><li><p><strong>文件系统</strong>：</p><p>提供文件和目录的创建、读取、写入和删除功能。它抽象了物理存储设备，为用户和应用程序提供了一个统一的文件访问接口。</p></li><li><p><strong>虚拟文件系统（VFS）</strong>：</p><p>用户和应用程序不直接与各种文件系统交互。而是通过 VFS（虚拟文件系统）进行操作。VFS为各种不同的文件系统（如EXT4, FAT, NFS等）提供一个统一的接口。这样，无论底层使用的是哪种文件系统，用户和应用的文件访问方式都保持一致，实现在 Linux 中的无缝集成。</p></li><li><p><strong>网络协议栈</strong>：</p><p>负责处理计算机之间的通信，使设备能够在网络上发送和接收数据。它包含了多层协议，如 <strong>TCP&#x2F;IP</strong>，使计算机能够连接到互联网和其他网络，并与其他计算机进行数据交换。</p></li><li><p><strong>设备驱动</strong>：</p><p>设备驱动是一种特殊的软件程序，它允许 Linux 内核和计算机的硬件组件进行交互。这些硬件组件可以是任何物理设备，如显卡、声卡、网络适配器、硬盘或其他输入&#x2F;输出设备。设备驱动为硬件设备提供了一个抽象层，使得内核和应用程序不需要知道硬件的具体细节，就能与其进行通信和控制。<strong>简而言之，设备驱动是硬件和操作系统之间通信的桥梁。</strong></p></li></ul><h4 id="用户空间-User-Space"><a href="#用户空间-User-Space" class="headerlink" title="用户空间 (User Space)"></a>用户空间 (User Space)</h4><p>所有的应用程序，如浏览器、文档编辑器或音乐播放器都运行在这个空间。</p><ul><li><strong>安全性</strong>：用户空间的程序运行在受限的环境中，它们只能访问分配给它们的资源，不能直接访问硬件或其他程序的数据。</li><li><strong>稳定性</strong>：如果一个应用程序崩溃，它不会影响其他应用程序或系统的核心功能。</li></ul><h4 id="内核空间-Kernel-Space"><a href="#内核空间-Kernel-Space" class="headerlink" title="内核空间 (Kernel Space)"></a>内核空间 (Kernel Space)</h4><p>内核空间是操作系统的核心。</p><ul><li><strong>权限</strong>：内核可以直接访问硬件，并有权执行任何命令。</li><li><strong>安全性</strong>：虽然内核拥有广泛的权限，但只有那些已知且经过严格测试和验证的代码才被允许在内核空间执行。</li><li><strong>稳定性</strong>：如果内核遇到问题，整个系统可能会崩溃。</li></ul><h3 id="系统调用与库函数"><a href="#系统调用与库函数" class="headerlink" title="系统调用与库函数"></a>系统调用与库函数</h3><p>在 <strong>Linux</strong> 编程中，我们经常听到“系统调用”和“库函数”这两个词，但你知道它们之间的区别吗？接下来就让我们来详细了解一下。</p><h4 id="什么是系统调用？"><a href="#什么是系统调用？" class="headerlink" title="什么是系统调用？"></a>什么是系统调用？</h4><p>系统调用是一个程序向操作系统发出的请求。当应用程序需要访问某些资源（如磁盘、网络或其他硬件设备）或执行某些特定的操作（如创建进程或线程）时，它通常会通过系统调用来完成。</p><p><strong>工作原理</strong></p><ul><li><strong>模式切换</strong>：应用程序在用户空间运行，而操作系统内核在内核空间运行。系统调用涉及从用户空间切换到内核空间。</li><li><strong>参数传递</strong>：程序将参数传递给系统调用，通常通过特定的寄存器。</li><li><strong>执行</strong>：内核根据传递的参数执行相应的操作。</li><li><strong>返回结果</strong>：操作完成后，内核将结果返回给应用程序，并将控制权返回给应用程序。</li></ul><p><strong>常见的系统调用函数：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">read() 和 write()：分别用于读取和写入文件。</span><br><span class="line">open() 和 close()：打开和关闭文件。</span><br><span class="line">fork()：创建一个新的进程。</span><br><span class="line">wait()：等待进程结束。</span><br><span class="line">exec()：执行一个新程序。</span><br></pre></td></tr></table></figure><p>这只是系统调用的冰山一角。<strong>Linux</strong> 提供了上百个系统调用，每个都有其特定的功能。</p><h4 id="什么是库函数？"><a href="#什么是库函数？" class="headerlink" title="什么是库函数？"></a>什么是库函数？</h4><p>库函数是预编写的代码，存储在库文件中，供程序员使用。它们通过系统调用和操作系统的内核通信。例如，printf（） 是 C 语言的一个库函数，它内部使用 write（） 系统调用来和内核进行交互。</p><h3 id="文件-IO"><a href="#文件-IO" class="headerlink" title="文件 IO"></a>文件 IO</h3><p>文件IO（输入&#x2F;输出）是计算机程序与文件系统交互的基本方式，允许程序读取和写入文件。要深入理解和使用文件IO，首先需要了解一些关键概念和操作。</p><p><img src="/images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/20.jpg"></p><h4 id="文件描述符是什么？"><a href="#文件描述符是什么？" class="headerlink" title="文件描述符是什么？"></a>文件描述符是什么？</h4><p>文件描述符「 fd 」是一个整数，它代表了一个打开的文件。在 Linux 中，每次我们打开或创建一个文件时，系统都会返回一个文件描述符。而应用程序正是通过这个文件描述符「 fd 」来进行文件的读写的。</p><p><strong>特殊的文件描述符</strong>:</p><ul><li>标准输入<strong>「stdin」</strong> 是 0</li><li>标准输出<strong>「stdout」</strong> 是 1</li><li>标准错误 <strong>「stderr」</strong> 是 2</li></ul><h4 id="常见的文件操作"><a href="#常见的文件操作" class="headerlink" title="常见的文件操作"></a>常见的文件操作</h4><p>当应用程序要与文件交互时，最基本的操作包括打开、读取、写入和关闭文件。这可以通过以下函数来实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">打开文件：open()</span><br><span class="line">读取文件：read()</span><br><span class="line">写入文件：write()</span><br><span class="line">关闭文件：close()</span><br><span class="line"></span><br><span class="line"><span class="meta"># demo</span></span><br><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;example.txt&quot;</span>, O_RDWR | O_CREAT);</span><br><span class="line">write(fd, <span class="string">&quot;Hello, File!&quot;</span>, <span class="number">12</span>);</span><br><span class="line">close(fd);</span><br></pre></td></tr></table></figure><h4 id="文件位置与移动"><a href="#文件位置与移动" class="headerlink" title="文件位置与移动"></a>文件位置与移动</h4><p>有时，我们可能需要移动到文件的特定位置进行读写。使用 lseek（） 可以实现这一点。举个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">假设我们有一个名为 &quot;data.txt&quot; 的文件，内容为：Hello World!</span></span><br><span class="line"><span class="comment"> 现在我们有一个简单需求：我们想将文件中的&quot;World&quot;替换为&quot;Linux&quot;，但不想重写整个文件。 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># demo 展示：</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buffer[<span class="number">6</span>];  <span class="comment">// 存放从文件中读取的数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;data.txt&quot;</span>, O_RDWR);  # 以读写模式打开文件</span><br><span class="line">lseek(fd, <span class="number">6</span>, SEEK_SET);  <span class="comment">// 使用 lseek() 移动到&quot;World&quot;的开头位置</span></span><br><span class="line">read(fd, buffer, <span class="number">5</span>);     <span class="comment">// 读取5个字符（&quot;World&quot;的长度）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(buffer, <span class="string">&quot;World&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 重新定位文件指针以替换&quot;World&quot;,这里需要重新定位的原因是：上面 read 操作使得文件指针已经指向文件末尾了，因此需要重新定位。</span></span><br><span class="line">    lseek(fd, <span class="number">6</span>, SEEK_SET);</span><br><span class="line">    write(fd, <span class="string">&quot;Linux&quot;</span>, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line">close(fd) ; </span><br></pre></td></tr></table></figure><h4 id="高级文件-I-O"><a href="#高级文件-I-O" class="headerlink" title="高级文件 I&#x2F;O"></a>高级文件 I&#x2F;O</h4><p>有时，简单的读写操作无法满足我们的需求，尤其当我们追求高效率或特殊功能时。为了更优雅、高效地处理文件数据，我们引入了一些高级文件 I&#x2F;O 技巧。</p><p><strong>分散读取和集中写入</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 读取操作</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">readv</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec *iov, <span class="type">int</span> iovcnt)</span>;</span><br><span class="line"><span class="comment">// 写入操作</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">writev</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec *iov, <span class="type">int</span> iovcnt)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta"># iovec 结构的定义如下：</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> &#123;</span></span><br><span class="line">    <span class="type">void</span>  *iov_base;  </span><br><span class="line">    <span class="type">size_t</span> iov_len; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">iov_base 是指向缓冲区起始地址的指针。</span><br><span class="line">iov_len 是缓冲区的大小。</span><br></pre></td></tr></table></figure><p>这两个函数主要用于多缓冲区的输入&#x2F;输出操作，允许您在单次系统调用中，从文件读取到多个缓冲区或从多个缓冲区写入文件。</p><p>它们的主要目的是提高效率，因为常规的读&#x2F;写函数每次只能在一个缓冲区进行操作。</p><p><strong>内存映射文件I&#x2F;O</strong></p><p>内存映射文件 I&#x2F;O 允许程序员将文件的一部分直接映射到进程的内存中。这样，程序可以通过直接访问这块内存来访问文件的内容，而不是使用传统的 read 、write 系统调用。这可以提高效率，特别是对于大文件的访问。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 相关函数声明</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">mmap</span><span class="params">(<span class="type">void</span>* addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span>* addr, <span class="type">size_t</span> length)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// demo 举例:</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;example.txt&quot;</span>, O_RDWR);</span><br><span class="line"><span class="comment">// 获取文件的大小</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sb</span>;</span></span><br><span class="line"><span class="keyword">if</span> (fstat(fd, &amp;sb) == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;fstat&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> *mapped = mmap(<span class="literal">NULL</span>, sb.st_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后续的所有对文件的操作就可以通过 mapped 指针来进行。</span></span><br><span class="line"><span class="comment">// 例如：将第一个字符改为 &#x27;J&#x27;）</span></span><br><span class="line">mapped[<span class="number">0</span>] = <span class="string">&#x27;J&#x27;</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>使用 mmap ，你可以直接在内存中访问文件内容，如同访问数组或其他数据结构一样。</p><p><strong>同步文件操作</strong></p><p>当您向文件写入数据时，操作系统可能会缓存这些数据，而不是立即写入磁盘,这样可以提高效率。 但在某些情况下，您可能需要确保数据确实已经写入磁盘。这就是同步文件操作的用处。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">msync</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fsync</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fdatasync</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sync</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><ul><li>msync  用于同步内存映射（通过 mmap 函数创建）文件的内容。它将内存中的更改写回到映射的文件中。</li><li>fsync 函数用于将指定文件描述符（fd）关联的文件的所有修改（包括数据和元数据）同步到磁盘</li><li>fdatasync 函数类似于 fsync，但它只同步文件的数据部分，而不同步元数据。</li><li>sync 同步整个文件系统的所有修改的数据到磁盘，包括所有打开的文件。</li></ul><h4 id="文件锁定"><a href="#文件锁定" class="headerlink" title="文件锁定"></a>文件锁定</h4><p><strong>什么是文件锁定？</strong></p><p>文件锁定是一个在多个进程或线程之间协调对共享资源访问的机制。在这里，这个”共享资源”指的是文件。简单说，<strong>文件锁</strong>就是确保当一个进程正在使用一个文件时，其他进程不能修改它。</p><p><strong>为什么需要文件锁定？</strong></p><p>考虑这样一个场景：两个程序同时写入一个文件。不锁定文件可能会导致数据混乱。例如，一个进程可能会覆盖另一个进程的更改。所以，文件锁定是确保数据完整性的关键。</p><p><strong>文件锁的两种模式</strong>：</p><ul><li><p><strong>共享锁（Shared Locks）</strong>：也被称为读锁。当一个进程持有共享锁时，其他进程可以获得该文件的共享锁以进行读取，但不能获得独占锁进行写入。</p></li><li><p><strong>独占锁（Exclusive Locks）</strong>：也被称为写锁。当一个进程持有独占锁时，其他进程不能获得该文件的任何类型的锁。这意味着其他进程不可以读取或写入该文件。</p></li></ul><p><strong>如何实现文件锁定？</strong></p><p>在 Linux  编程中，文件锁定可以使用以下函数实现：</p><p><code>fcntl()</code> : 允许对文件中的特定部分进行锁定。</p><p><code>flock()</code> ：提供了一个简化的锁定机制，直接锁定整个文件。</p><h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><p><strong>什么是重定向？</strong></p><p><strong>重定向</strong>，顾名思义，指的是改变数据流的方向。在 <strong>Linux</strong> 系统编程中，程序通常与三种标准I&#x2F;O 流进行交互：标准输入（stdin）、标准输出（stdout）、和标准错误输出（stderr）。</p><ul><li>标准输入（stdin）         : 来自键盘的输入。</li><li>标准输出（stdout）        : 显示到屏幕上。</li><li>标准错误输出（stderr)     : 也显示到屏幕上。</li></ul><p><strong>重定向的核心是将这些标准的 I&#x2F;O 流改变到其他地方，如文件或其他程序。</strong></p><p>例如，当我们在命令行中执行命令并将结果保存到文件中，或者从文件中获取命令的输入而不是从键盘中获取，我们都是在使用重定向。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 将 ls -l 命令的输出（即当前目录的详细列表）重定向到 filelist.txt 文件中</span><br><span class="line">ls -l &gt; filelist.txt   </span><br></pre></td></tr></table></figure><p>重定向不仅局限于命令行界面，它在程序中也很有用，允许我们动态地更改程序的输入和输出来源，为构建更复杂、灵活的应用程序提供了基础。</p><p>在 <strong>Linux</strong> 系统编程中，实现重定向的一个核心函数是 <strong>dup2</strong> 函数。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup2</span><span class="params">(<span class="type">int</span> oldfd, <span class="type">int</span> newfd)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">其中：</span></span><br><span class="line"><span class="comment">oldfd 是原始文件描述符。</span></span><br><span class="line"><span class="comment">newfd 是要复制到的目标文件描述符。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># demo 举例:</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 打开一个文件用于写入</span></span><br><span class="line">    <span class="type">int</span> file_fd = open(<span class="string">&quot;output.txt&quot;</span>, O_WRONLY | O_CREAT | O_TRUNC, <span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span> (file_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 错误处理</span></span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 dup2 将标准输出重定向到文件</span></span><br><span class="line">    <span class="keyword">if</span> (dup2(file_fd, STDOUT_FILENO) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="comment">// 错误处理</span></span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在，所有标准输出都会被写入文件</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This will be written to the file &#x27;output.txt&#x27;\n&quot;</span>);</span><br><span class="line">    close(file_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Linux-进程"><a href="#Linux-进程" class="headerlink" title="Linux 进程"></a>Linux 进程</h3><p>你有没有想过，当你在 <strong>Linux</strong> 操作系统上运行一个程序时，都发生了哪些神奇的事情？接下来，我们将一步一步地深入探讨 Linux 进程的世界。</p><p><img src="/images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/3.jpg"></p><h4 id="进程究竟是什么？"><a href="#进程究竟是什么？" class="headerlink" title="进程究竟是什么？"></a>进程究竟是什么？</h4><p>每当你启动一个程序，<strong>Linux</strong> 系统都会创建一个新的进程。这个进程有它自己的内存地址、系统资源和状态。简而言之，进程是程序的一个运行实例。</p><h4 id="进程的创建和终止"><a href="#进程的创建和终止" class="headerlink" title="进程的创建和终止"></a>进程的创建和终止</h4><p><code>fork()</code>：当调用 fork 函数时，它会创建一个新的子进程。这个子进程几乎是父进程的复制品，包括父进程的内存、程序计数器等。</p><p><code>wait() &amp; waitpid()</code>：这些函数允许父进程等待子进程的结束，并收集子进程的退出状态。防止出现僵尸进程。</p><p><code>exec() 系列函数</code>：<strong>exec</strong> 系列函数 允许一个进程运行另一个程序，它实际上替换了当前进程的内容。</p><h4 id="进程的状态转换图"><a href="#进程的状态转换图" class="headerlink" title="进程的状态转换图"></a>进程的状态转换图</h4><p><img src="/images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/4.jpg"></p><p><strong>五态简要说明</strong>:</p><ul><li><p><strong>新建状态</strong>: 这是进程刚被创建时的状态。在这个状态下，操作系统为进程分配了一个唯一的进程标识符（PID）和必要的资源。但进程还没有开始执行任何代码。新建状态通常非常短暂，用户很难观察到，因为进程很快就会转移到 <strong>「就绪状态」</strong>。</p></li><li><p><strong>就绪状态</strong> : 进程已准备好运行并等待操作系统的调度器分配 CPU 时间片。在这个状态下，进程已经加载了所有必要的代码和数据到内存中，且已准备好执行。</p></li><li><p><strong>运行状态</strong> : 进程正在 CPU 上执行。一个进程只有在运行状态时才能执行其指令。</p></li><li><p><strong>阻塞状态</strong> : 进程不能执行，因为它在等待一些事件发生，例如 I&#x2F;O 操作的完成、信号的接收等。在此状态下，即使 CPU 空闲，进程也不能执行。</p></li><li><p><strong>终止状态</strong> : 进程已完成执行或被终止。在这个状态下，进程的资源通常被回收，进程退出。</p></li></ul><h4 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h4><p>在 Linux 的世界里，进程是操作系统进行资源分配的基本单位。但是，进程并不是孤立的存在。当你的应用分成多个独立运行的进程时，这些进程之间如何有效地交换信息呢？这正是通过进程间通信的方式来实现的。</p><p><strong>Linux 提供了以下几种进程间通信的方式</strong>：</p><p>1.管道 （Pipe）</p><p>管道是 Linux 中用于进程间通信的一种机制。它们分为两种类型：<strong>匿名管道</strong>和<strong>有名管道</strong>。</p><p><strong>匿名管道</strong>   : </p><p>  <strong>概念</strong>：匿名管道是一种在有亲缘关系的进程间（如父子进程）进行单向数据传输的通信机制，存在于内存中，通常用于临时通信。如果需要双向通信，则一般需要两个管道。</p><p>  <strong>简单图解：</strong></p><p>  <img src="/images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/5.jpg"></p><p>  <strong>使用场景</strong>：适用于有亲缘关系的进程间的简单数据传输。</p><p>  <strong>简单示例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">  pipe(pipefd); <span class="comment">// 创建匿名管道</span></span><br><span class="line">  <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123; <span class="comment">// 子进程</span></span><br><span class="line">      close(pipefd[<span class="number">1</span>]); <span class="comment">// 关闭写端</span></span><br><span class="line">      <span class="comment">//读取数据</span></span><br><span class="line">      read(pipefd[<span class="number">0</span>],buf,<span class="number">5</span>);</span><br><span class="line">      <span class="comment">// ... </span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 父进程</span></span><br><span class="line">      close(pipefd[<span class="number">0</span>]); <span class="comment">// 关闭读端</span></span><br><span class="line">      <span class="comment">// 写入数据</span></span><br><span class="line">      write(pipefd[<span class="number">1</span>],<span class="string">&quot;hello&quot;</span>,<span class="number">5</span>);</span><br><span class="line">      <span class="comment">// ... </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>有名管道</strong>   ：</p><p><strong>概念：</strong> <strong>有名管道（FIFO，First-In-First-Out）</strong> 是一种特殊类型的文件，用于在不相关的进程之间实现通信。与匿名管道不同，有名管道在文件系统中具有一个实际的路径名。这允许任何具有适当权限的进程打开和使用它，而不仅限于有亲缘关系的进程。</p><p><strong>简单图解：</strong></p><p><img src="/images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/6.jpg"></p><p><strong>简单说明</strong>：</p><p>有名管道是 Linux 中一种特殊的文件，它允许不同的进程通过读写这个文件来相互通信。</p><p><strong>使用场景</strong>：用于本机任何两个进程间的通信，特别是当这些进程没有血缘关系时。</p><p><strong>简单示例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *fifoPath = <span class="string">&quot;/tmp/my_fifo&quot;</span>;</span><br><span class="line">    mkfifo(fifoPath, <span class="number">0666</span>); <span class="comment">// 创建有名管道</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="comment">// 永久循环，持续监听有名管道</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        fd = open(fifoPath, O_RDONLY); <span class="comment">// 打开管道进行读取</span></span><br><span class="line">        read(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印接收到的消息</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Received: %s\n&quot;</span>, buf);</span><br><span class="line">        close(fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// client.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *fifoPath = <span class="string">&quot;/tmp/my_fifo&quot;</span>;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter message: &quot;</span>);    <span class="comment">// 获取要发送的消息</span></span><br><span class="line">    fgets(buf, <span class="keyword">sizeof</span>(buf), <span class="built_in">stdin</span>);</span><br><span class="line">    fd = open(fifoPath, O_WRONLY); <span class="comment">// 打开管道进行写入</span></span><br><span class="line">    write(fd, buf, <span class="built_in">strlen</span>(buf) + <span class="number">1</span>);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.信号 (Signals)</strong></p><p><strong>概念</strong>：<br>在 Linux 中，信号是一种用于进程间通信（IPC）的机制，允许操作系统或一个进程向另一个进程发送简单的消息。信号主要用于传递关于系统事件的通知，例如中断请求、程序异常、或其他重要事件。每个信号代表了一个特定类型的事件，并且进程可以根据收到的信号执行相应的动作。</p><p>信号是异步的，意味着它们可以在任何时间点被发送到进程，通常与进程的正常控制流无关。信号的使用为进程提供了一种处理外部事件和错误的方式。</p><p>可以使用命令 <code>kill -l</code> 来查看 Linux 系统支持的信号有哪些？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">~$ kill -l</span><br><span class="line"> 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP</span><br><span class="line"> 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1</span><br><span class="line">11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>使用场景</strong>：</p><ul><li><strong>异常处理</strong>：当程序遇到运行时错误，比如除以零、非法内存访问等，操作系统会向该进程发送一个适当的信号，如SIGFPE（浮点异常）、SIGSEGV（段错误）。默认情况下：都会使程序终止。</li><li><strong>外部中断</strong>：用户可以通过特定的键盘输入（最常见的是Ctrl+C）来中断正在终端上运行的进程。这会生成 SIGINT 信号，通常导致程序终止。</li><li><strong>进程控制</strong>：如使用 kill 命令发送信号来终止或暂停某个进程。</li><li><strong>定时器和超时</strong>： 程序可以设置定时器，当定时器到期时，会收到 SIGALRM 信号。这常用于限制某些操作的执行时间，确保它们不会占用过多时间。</li><li><strong>子进程状态变化</strong>：当一个子进程结束或停止时，它的父进程会收到 SIGCHLD 信号。这使得父进程可以监控其子进程的状态变化（从运行到正常退出）。</li></ul><p><strong>简单示例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">signal_handler</span><span class="params">(<span class="type">int</span> signal_num)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Received signal: %d\n&quot;</span>, signal_num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    signal(SIGINT, signal_handler);  <span class="comment">// 注册信号处理函数</span></span><br><span class="line">    <span class="comment">// 无限循环，等待信号</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        sleep(<span class="number">1</span>); <span class="comment">// 暂停一秒</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，程序设置了一个信号处理函数来处理 SIGINT 信号（通常由 Ctrl+C 产生）。当收到该信号时，signal_handler 函数会被调用。</p><p><strong>以下是对上述代码执行流程的简单图解说明，方便大家理解</strong>：</p><p><img src="/images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/7.jpg"></p><p><strong>3.文件(Files)</strong></p><p><strong>概念</strong>：</p><p>文件在 Linux 系统中是一种基本的持久化存储机制，可用于<strong>进程间通信</strong>。多个进程可以通过对同一个文件的读取和写入来共享信息。</p><p><strong>简单图解：</strong></p><p><img src="/images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/8.jpg"></p><p><strong>使用场景：</strong></p><ul><li><p><strong>数据交换：</strong></p><p>进程之间可以通过读写同一文件来交换数据。例如，一个进程写入结果数据，另一个进程读取这些数据进行进一步处理。</p></li><li><p><strong>持久化存储：</strong></p><p>文件用于保存需要在应用程序重启后依然保留的数据，例如用户数据、应用状态等。</p></li></ul><p><strong>简单示例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写进程: 向文件中写入数据</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *file = <span class="string">&quot;/tmp/ipc_file&quot;</span>;</span><br><span class="line">    <span class="type">int</span> fd = open(file, O_RDWR | O_CREAT, <span class="number">0666</span>);</span><br><span class="line">    write(fd, <span class="string">&quot;Hello from Process A&quot;</span>, <span class="number">20</span>);  <span class="comment">// 向文件写入数据</span></span><br><span class="line">    close(fd);     <span class="comment">// 关闭文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 读进程: 从文件中读取数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *file = <span class="string">&quot;/tmp/ipc_file&quot;</span>;</span><br><span class="line">    <span class="type">int</span> fd = open(file, O_RDWR | O_CREAT, <span class="number">0666</span>);</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">50</span>];</span><br><span class="line">    read(fd, buf, <span class="number">20</span>);  <span class="comment">// 从文件中读取数据</span></span><br><span class="line">    close(fd);     <span class="comment">// 关闭文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> <strong>注意：</strong><br>  如果存在多个写进程同时操作同一个文件，那么会引发数据竞态和一致性问题。为了解决这个问题，可以使用文件锁或其他同步机制来协调对文件的访问，确保数据的完整性和一致性。</p></blockquote><p><strong>文件锁的作用:</strong></p><ul><li><p><strong>防止数据覆盖</strong>：<br>当一个进程正在写文件时，文件锁可以防止其他进程同时写入，从而避免数据被覆盖。</p></li><li><p><strong>保证写操作的完整性</strong>：</p><p>通过锁定文件，确保每次只有一个进程能够执行写操作，这有助于保持写入数据的完整性。</p></li></ul><p><strong>实现文件锁:</strong></p><p>在 Linux 中，可以使用 fcntl 或 flock 系统调用来实现文件锁。</p><p><strong>示例代码</strong> </p><p>使用 fcntl 实现文件锁，从而保证多个进程在操作同一文件时不会相互干扰，维护数据的一致性和完整性。以下是一个具体的示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *file = <span class="string">&quot;/tmp/ipc_file&quot;</span>;</span><br><span class="line">    <span class="type">int</span> fd = open(file, O_RDWR | O_CREAT, <span class="number">0666</span>);</span><br><span class="line">    <span class="comment">// 设置文件锁</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">flock</span> <span class="title">fl</span>;</span></span><br><span class="line">    fl.l_type = F_WRLCK;  <span class="comment">// 设置写锁</span></span><br><span class="line">    fl.l_whence = SEEK_SET;</span><br><span class="line">    fl.l_start = <span class="number">0</span>;</span><br><span class="line">    fl.l_len = <span class="number">0</span>;  <span class="comment">// 锁定整个文件</span></span><br><span class="line">    <span class="keyword">if</span> (fcntl(fd, F_SETLKW, &amp;fl) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Error locking file&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    write(fd, <span class="string">&quot;Hello from Process A&quot;</span>, <span class="number">20</span>); <span class="comment">// 执行写操作</span></span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    fl.l_type = F_UNLCK;</span><br><span class="line">    fcntl(fd, F_SETLK, &amp;fl);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>4.信号量(Semaphores)</strong></p><p><strong>概念</strong>:<br>信号量是一种在进程间或同一进程的不同线程间提供同步的机制。它是一个计数器，用于控制对共享资源的访问。当计数器值大于0时，表示资源可用；当值为0时，表示资源被占用。进程在访问共享资源前必须减少（wait）信号量，访问后必须增加（post）信号量。</p><p>信号量有两种，一种是 POSIX 信号量，另一种是 System V 信号量。由于 POSIX 信号量提供了更简洁、更易于理解和使用的 API，并且在现代操作系统中得到了广泛支持和优化，所以这里我重点讲解 POSIX 信号量。</p><p>  <strong>简单图解：</strong></p><p><img src="/images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/9.jpg"></p><p>  <strong>分类：</strong></p><p> <strong>匿名信号量</strong></p><p><strong>概念:</strong></p><p> 匿名信号量是内存中的信号量，不与任何文件系统的名称关联。它们通常用于单一进程内不同线程间的同步，或在具有共同祖先的进程之间进行同步。</p><p> <strong>特点：</strong></p><ul><li><strong>作用域</strong>：限于创建它的进程内部或其子进程之间。</li><li><strong>生命周期</strong>：与创建它们的进程的生命周期相同，进程终止时信号量也会消失。</li></ul><p><strong>使用场景</strong>：</p><ul><li><strong>互斥访问</strong>：在多线程程序中，确保同一时刻只有一个线程可以访问某个共享资源。</li><li><strong>同步操作</strong>：协调多个线程的执行顺序，一个线程在另一个线程完成其任务之后再开始执行。如：线程池中的任务队列没任务时，线程必须等待，而当有有线程向队列添加任务时，需要唤醒其他线程来进行消费任务。</li></ul><p> <strong>有名信号量</strong></p><p> <strong>概念:</strong>  有名信号量在文件系统中具有一个唯一的名称，允许不同的独立进程通过这个名称访问同一个信号量，实现进程间同步。</p><p> <strong>特点：</strong></p><ul><li><strong>作用域</strong>：可以跨不同的进程使用。它们在文件系统中具有一个全局唯一的名称，任何知道这个名称的进程都可以访问同一个信号量。</li><li><strong>生命周期</strong>：生命周期可以超过创建它们的进程。即使创建它们的进程已经结束，只要有名信号量的名称存在于文件系统中，它们就继续存在。</li></ul><p><strong>使用场景</strong>：</p><ul><li><strong>进程间互斥：</strong> 多个独立进程共享资源，如文件或内存映射区域，需要互斥访问以避免冲突。</li><li><strong>同步操作</strong>：协调多个进程的执行顺序，一个进程在另一个进程完成其任务之后再开始执行。如：在生产者消费者模型中，只要当生产者向队列添加数据，队列不为空的时候，消费者才能消费数据，否则只能等待。</li></ul><p><strong>来看一个进程互斥的例子：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设日志文件已经打开</span></span><br><span class="line">FILE* logFile;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">writeToLog</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span> &#123;</span><br><span class="line">    <span class="type">sem_t</span>* sem = sem_open(<span class="string">&quot;/log_semaphore&quot;</span>, O_CREAT, <span class="number">0644</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    sem_wait(sem);  <span class="comment">// 获取信号量</span></span><br><span class="line">    <span class="built_in">fprintf</span>(logFile, <span class="string">&quot;%s\n&quot;</span>, message);  <span class="comment">// 写入日志</span></span><br><span class="line">    fflush(logFile);</span><br><span class="line">    sem_post(sem);  <span class="comment">// 释放信号量</span></span><br><span class="line"></span><br><span class="line">    sem_close(sem);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ... 进程的其它操作 ...</span></span><br><span class="line">    writeToLog(<span class="string">&quot;Log message from Process&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>匿名信号量和有名信号量 API 接口区别：</strong></p><p><img src="/images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/10.jpg"></p><p><strong>5.共享内存(Shared Memory)</strong></p><p><strong>概念</strong>：<br>在 Linux 中，共享内存是进程间通信（IPC）的一种形式。当多个进程需要访问相同的数据时，使用共享内存是一种高效的方式。它允许两个或多个进程访问同一个物理内存区域，这使得数据传输不需要通过内核空间，从而提高了通信效率。</p><p>在讲解共享内存前，我们需要了解内存映射技术？</p><p><strong>内存映射技术（Memory Mapping）</strong> 是一种将文件或设备的数据映射到进程内存地址空间的技术，它允许进程直接对这部分内存进行读写操作，就像访问普通内存一样。这种技术不仅可以用于文件I&#x2F;O操作，提高文件访问效率，而且是实现共享内存的基础。</p><p>在 Linux 系统中，内存映射可以通过 <strong>mmap</strong> 系统调用来实现。<strong>mmap</strong> 允许将文件映射到进程的地址空间，也可以用来创建匿名映射（即不基于任何文件的共享内存区域）。</p><p>在 Linux 中，共享内存可以分为如下几类。</p><p><strong>匿名共享内存</strong></p><p><strong>工作原理</strong>：</p><p>匿名共享内存不与任何具体的文件系统文件直接关联，其内容仅在内存中存在。这意味着当所有使用它的进程都结束时，该内存区域的数据就会消失。这种特性使得匿名共享内存非常适合于那些需要临时共享数据但又不需要将数据持久存储到磁盘的场景。</p><p><strong>简单图解：</strong></p><p><img src="/images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/11.jpg"></p><p><strong>注意</strong>：在 Linux 中，<strong>匿名共享内存主要被设计用于有亲缘关系的进程间通信，如父子进程间</strong>。这是因为匿名共享内存的引用（例如，通过 mmap 创建时返回的内存地址）不会自动出现在其他进程中，而是需要通过某种进程间通信的方式（如Unix域套接字）传递给相关的进程。而通过 Unix 域套接字来实现又稍显复杂，所以我们一般推荐匿名共享内存适用于有亲缘关系的进程间通信。</p><p><strong>创建和使用</strong>：</p><p>在 Linux 系统中，匿名共享内存通常是通过 mmap()函数创建的，调用时需指定MAP_ANONYMOUS标志。此外，还需要设置 PROT_READ 和 PROT_WRITE 权限，以确保内存区域可读写。创建时也可以选择 MAP_SHARED 标志，以便在多个进程间共享这块内存。</p><p><strong>示例代码片段如下：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="type">void</span>* shared_memory = mmap(<span class="literal">NULL</span>, size, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOU</span><br></pre></td></tr></table></figure><p>在这里，size是希望映射的内存区域大小，mmap()调用成功后，返回指向共享内存区域的指针。</p><p><strong>使用场景</strong>：</p><p><strong>大量数据交换</strong> ：当两个或多个进程需要交换大量数据时，使用共享内存比传统的进程间通信方法（如管道或消息队列）更有效率。</p><p><strong>而谈到共享内存，又不得不探讨下关于共享内存的同步问题？</strong></p><p>在使用共享内存时，由于多个进程可以直接并且同时访问同一个物理内存区域，不加以适当控制就可能引起数据竞态和一致性问题。</p><p><strong>数据竞态</strong>：当多个进程尝试同时修改共享内存中的同一数据项时，最终结果可能依赖于各进程操作的具体顺序，可能导致不符合预期的结果。</p><p><strong>一致性问题</strong>：在没有合适同步机制的情况下，一个进程可能在另一个进程写入数据的同时读取共享内存，导致获取到不完整或不一致的数据。</p><p><strong>解决策略：使用信号量</strong></p><p>信号量是一种常用的同步机制，用于控制对共享资源的并发访问。通过增加（释放资源）或减少（占用资源）信号量的值，可以有效地控制对共享内存区域的访问，防止数据竞态和确保数据一致性。</p><p><strong>使用信号量来解决匿名共享内存同步问题的简单示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建或打开有名信号量</span></span><br><span class="line">    <span class="type">sem_t</span> *sem = sem_open(<span class="string">&quot;/mysemaphore&quot;</span>, O_CREAT, <span class="number">0666</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (sem == SEM_FAILED) &#123;</span><br><span class="line">        <span class="comment">// 错误处理，退出程序</span></span><br><span class="line">        perror(<span class="string">&quot;sem_open failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建匿名共享内存</span></span><br><span class="line">    <span class="type">void</span>* shared_memory = mmap(<span class="literal">NULL</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>), PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (shared_memory == MAP_FAILED) &#123;</span><br><span class="line">      <span class="comment">// 错误处理，退出程序</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>* counter = (<span class="type">int</span>*)shared_memory;</span><br><span class="line">    *counter = <span class="number">0</span>; <span class="comment">// 初始化计数器</span></span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">            sem_wait(sem); <span class="comment">// 等待信号量</span></span><br><span class="line">            (*counter)++;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Child process increments counter to %d\n&quot;</span>, *counter);</span><br><span class="line">            sem_post(sem); <span class="comment">// 释放信号量</span></span><br><span class="line">            sleep(<span class="number">1</span>); <span class="comment">// 暂停一段时间，模拟工作负载</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">            sem_wait(sem);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Parent process reads counter as %d\n&quot;</span>, *counter);</span><br><span class="line">            sem_post(sem);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// fork失败</span></span><br><span class="line">        perror(<span class="string">&quot;fork failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理资源</span></span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123; <span class="comment">// 父进程等待子进程完成</span></span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        sem_close(sem);</span><br><span class="line">        sem_unlink(<span class="string">&quot;/mysemaphore&quot;</span>);</span><br><span class="line">        munmap(shared_memory, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>基于文件的共享内存</strong></p><p><strong>工作原理:</strong></p><p>基于文件的共享内存通过将磁盘上的实际文件映射到一个或多个进程的地址空间中来实现。当文件被映射到内存后，进程就可以像访问普通内存一样直接读写文件内容，操作系统负责同步内存修改回磁盘文件。这种机制既提高了数据访问的效率，也实现了数据的持久化存储。</p><p>相比匿名共享内存只能适合有亲缘关系的进程，<strong>基于文件的共享内存特别适合于实现非亲缘关系进程间的数据共享</strong>。</p><p><strong>简单图解：</strong></p><p><img src="/images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/12.jpg"></p><p><strong>创建和使用:</strong></p><p>要创建基于文件的共享内存，首先需要打开（或创建）一个文件，然后使用 mmap()将文件映射到内存中。与匿名共享内存不同，这里需要提供<strong>文件描述符</strong>而不是 MAP_ANONYMOUS 标志。</p><p><strong>示例代码片段如下：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> size = <span class="number">4096</span>; <span class="comment">// 共享内存区域大小</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;shared_file&quot;</span>, O_RDWR | O_CREAT, <span class="number">0666</span>);</span><br><span class="line">ftruncate(fd, size); <span class="comment">// 设置文件大小</span></span><br><span class="line"><span class="type">void</span>* shared_memory = mmap(<span class="literal">NULL</span>, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>在这里，shared_file 是被映射的文件名，size 是文件的预期大小。通过 ftruncate() 调整文件大小以匹配共享内存的需求。mmap()成功后返回指向共享内存区域的指针。</p><p><strong>使用场景：</strong></p><p><strong>大量数据交换</strong> ：基于文件的共享内存同样适用于多个进程需要进行大量数据交换的场景。与匿名共享内存不同的是，这些数据可以持久化存储到磁盘上。</p><p>在使用基于文件的共享内存时，同样需要解决多个进程共享数据的同步问题，以保证数据的一致性和完整性。</p><p><strong>解决方案</strong>：</p><ul><li><p><strong>信号量</strong>：<br>信号量可以理解是一个计数器，用来控制同时访问共享资源（如共享内存）的进程数量。如果信号量计数大于0，表示资源可用，进程可以访问资源并将计数减1；如果信号量计数为0，表示资源不可用，进程必须等待。当资源使用完毕后，进程会增加信号量计数，表示资源再次可用。</p></li><li><p><strong>文件锁</strong>：<br>文件锁允许进程对共享内存所基于的文件加锁，防止其他进程同时访问。如果一个进程要写入共享内存，它可以加一个排他锁，这时其他进程既不能读也不能写；如果只需要读取，进程可以加一个共享锁，这样其他进程也可以加共享锁来读取数据，但不能写入。在 Linux 中，文件锁的实现主要依赖于两个系统调用：fcntl 和 flock。而关于 fcntl 和 flock 的讲解，我在前文也有提到过。</p></li></ul><p><strong>简单来说</strong>：</p><ul><li>使用信号量是为了确保在同一时间只有限定数量的进程可以操作共享内存。</li><li>使用文件锁是为了防止在某个进程读写共享内存时，其他进程进行干扰。</li></ul><p>下面来看一个使用<strong>有名信号量解决基于文件的共享内存同步问题的示例</strong>，这个简单的示例演示了两个进程：一个进程向共享内存写入数据，另一个进程从共享内存读取数据。这两个进程使用同一个有名信号量来同步对共享内存区域的访问。</p><p><strong>示例代码：</strong></p><p>首先，确保你有一个名为 shared_file 的文件和一个名为 &#x2F;mysemaphore 的信号量。</p><p><strong>写入进程</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* filename = <span class="string">&quot;shared_file&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> size = <span class="number">4096</span>;</span><br><span class="line">    <span class="comment">// 打开文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(filename, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 错误处理并退出</span></span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 映射文件</span></span><br><span class="line">    <span class="type">void</span>* addr = mmap(<span class="literal">NULL</span>, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (addr == MAP_FAILED) &#123;</span><br><span class="line">        <span class="comment">// 错误处理并退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打开有名信号量</span></span><br><span class="line">    <span class="type">sem_t</span> *sem = sem_open(<span class="string">&quot;/mysemaphore&quot;</span>, O_CREAT, <span class="number">0666</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (sem == SEM_FAILED) &#123;</span><br><span class="line">        <span class="comment">// 错误处理并退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待信号量，开始写入数据</span></span><br><span class="line">    sem_wait(sem);</span><br><span class="line">    <span class="built_in">strcpy</span>((<span class="type">char</span>*)addr, <span class="string">&quot;Hello, Shared Memory!&quot;</span>);</span><br><span class="line">    sem_post(sem);</span><br><span class="line">    <span class="comment">// 清理</span></span><br><span class="line">    munmap(addr, size);</span><br><span class="line">    close(fd);</span><br><span class="line">    sem_close(sem);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>读取进程：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* filename = <span class="string">&quot;shared_file&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> size = <span class="number">4096</span>;</span><br><span class="line">    <span class="comment">// 打开文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(filename, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 错误处理并退出</span></span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 映射文件</span></span><br><span class="line">    <span class="type">void</span>* addr = mmap(<span class="literal">NULL</span>, size, PROT_READ, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (addr == MAP_FAILED) &#123;</span><br><span class="line">       <span class="comment">// 错误处理并退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打开有名信号量</span></span><br><span class="line">    <span class="type">sem_t</span> *sem = sem_open(<span class="string">&quot;/mysemaphore&quot;</span>, O_CREAT, <span class="number">0666</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (sem == SEM_FAILED) &#123;</span><br><span class="line">        <span class="comment">// 错误处理并退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待信号量，开始读取数据</span></span><br><span class="line">    sem_wait(sem);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Read from shared memory: %s\n&quot;</span>, (<span class="type">char</span>*)addr);</span><br><span class="line">    sem_post(sem);</span><br><span class="line">    <span class="comment">// 清理</span></span><br><span class="line">    munmap(addr, size);</span><br><span class="line">    close(fd);</span><br><span class="line">    sem_close(sem);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明</strong>：上面的信号量初始值为 1 ，实际上信号量在这里充当的就是互斥锁。</p><p><strong>Posix 共享内存</strong></p><p>POSIX 共享内存提供了一种高效的方式，允许多个进程通过共享内存区域进行通信。与基于文件的共享内存相比，POSIX 共享内存不需要直接映射磁盘上的文件，而是通过创建命名的共享内存对象来实现进程间的数据共享。这些对象虽然在逻辑上类似于文件（因为可以通过shm_open创建和打开），但实质上直接存在于内存中，提供了更快的数据访问速度。</p><p><strong>Posix 共享内存接口</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">shm_open()        <span class="comment">// 创建或打开一个共享内存对象</span></span><br><span class="line">shm_unlink()      <span class="comment">// 删除一个共享内存对象的名称</span></span><br><span class="line">ftruncate()       <span class="comment">// 调整共享内存对象的大小</span></span><br><span class="line">mmap()            <span class="comment">// 将共享内存对象映射到调用进程的地址空间</span></span><br><span class="line">munmap()          <span class="comment">// 解除共享内存对象的映射</span></span><br></pre></td></tr></table></figure><p><strong>示例演示</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SHM_NAME <span class="string">&quot;/example_shm&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHM_SIZE 4096</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> shm_fd;</span><br><span class="line">    <span class="type">void</span> *ptr;</span><br><span class="line">    <span class="comment">// 创建共享内存对象</span></span><br><span class="line">    shm_fd = shm_open(SHM_NAME, O_CREAT | O_RDWR, <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span> (shm_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 错误处理并退出</span></span><br><span class="line">        perror(<span class="string">&quot;shm_open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置共享内存大小</span></span><br><span class="line">    <span class="keyword">if</span> (ftruncate(shm_fd, SHM_SIZE) == <span class="number">-1</span>) &#123;</span><br><span class="line">       <span class="comment">// 错误处理并退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 映射共享内存</span></span><br><span class="line">    ptr = mmap(<span class="number">0</span>, SHM_SIZE, PROT_WRITE, MAP_SHARED, shm_fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ptr == MAP_FAILED) &#123;</span><br><span class="line">        <span class="comment">// 错误处理并退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 写入数据到共享内存</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *message = <span class="string">&quot;Hello, POSIX Shared Memory!&quot;</span>;</span><br><span class="line">    <span class="built_in">sprintf</span>(ptr, <span class="string">&quot;%s&quot;</span>, message);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Data written to shared memory: %s\n&quot;</span>, message);</span><br><span class="line">    <span class="comment">// 解除映射</span></span><br><span class="line">    munmap(ptr, SHM_SIZE);</span><br><span class="line">    <span class="comment">// 关闭共享内存对象</span></span><br><span class="line">    close(shm_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>System V共享内存</strong></p><p>System V共享内存是一种传统的进程间通信（IPC）机制，它允许多个进程通过共享内存区域进行通信。与POSIX共享内存不同，System V共享内存使用IPC键值key_t来标识和管理共享内存段，而不是通过命名的方式。这种机制提供了一套底层控制共享内存的API，允许进行更细粒度的操作，如权限控制、共享内存状态的查询和管理等。</p><p><strong>System V共享内存接口</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shmget()         <span class="comment">// 创建或获取共享内存段的标识符</span></span><br><span class="line">shmat()          <span class="comment">// 将共享内存段附加到进程的地址空间</span></span><br><span class="line">shmdt()          <span class="comment">// 分离共享内存段和进程的地址空间</span></span><br><span class="line">shmctl()         <span class="comment">// 对共享内存段执行控制操作</span></span><br></pre></td></tr></table></figure><p><strong>示例演示</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">key_t</span> key = ftok(<span class="string">&quot;somefile&quot;</span>, <span class="number">65</span>); <span class="comment">// 创建IPC键</span></span><br><span class="line">    <span class="type">int</span> shm_id;</span><br><span class="line">    <span class="type">void</span> *ptr;</span><br><span class="line">    <span class="comment">// 创建共享内存段</span></span><br><span class="line">    shm_id = shmget(key, <span class="number">1024</span>, <span class="number">0666</span>|IPC_CREAT);</span><br><span class="line">    <span class="keyword">if</span> (shm_id &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;shmget&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将共享内存段附加到进程的地址空间</span></span><br><span class="line">    ptr = shmat(shm_id, (<span class="type">void</span>*)<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ptr == (<span class="type">void</span>*) <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;shmat&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在共享内存上操作，例如写入数据</span></span><br><span class="line">    <span class="comment">// 示例：写入一个字符串</span></span><br><span class="line">    <span class="built_in">strcpy</span>(ptr, <span class="string">&quot;Hello, System V Shared Memory!&quot;</span>);</span><br><span class="line">    <span class="comment">// 分离共享内存段</span></span><br><span class="line">    <span class="keyword">if</span> (shmdt(ptr) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;shmdt&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除共享内存段</span></span><br><span class="line">    shmctl(shm_id, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>6.消息队列 (Message Queues)</strong></p><p><strong>概念</strong>：</p><p>消息队列是一种允许一个或多个进程向其写入消息，并由一个或多个进程读取消息的 IPC 机制。每条消息都由一个消息队列标识符（ID）识别， 且可以携带一个特定的类型。消息队列允许不同进程非阻塞地发送和接收记录或数据块，这些记录可以是不同类型和大小的。</p><p><strong>消息队列图解：</strong></p><p><img src="/images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/13.jpg"></p><p><strong>使用场景</strong>：</p><ul><li><p><strong>进程间通信：</strong><br>在涉及多个运行进程的应用中，消息队列提供了一种高效的方式来传递信息。它允许进程之间无需直接相互连接就能交换数据，从而简化了通信过程。</p></li><li><p><strong>异步数据处理：</strong><br>消息队列使进程能够异步处理信息。一个进程（即生产者）可以发送任务或数据至队列，并继续其他操作，而另一进程（即消费者）可以在准备就绪时从队列中取出并处理这些数据。这种模式有效地分离了数据的生成和消费过程，提高了应用的效率和响应速度。实际的应用比如：日志记录，某些系统可能有一个专门的进程负责记录日志，其他进程可以将日志消息发送到消息队列，由该专门进程异步地写入日志文件。</p></li></ul><p><strong>以下是使用 System V IPC 消息队列的一个简单示例:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">message</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;</span><br><span class="line">    <span class="type">char</span> mtext[<span class="number">100</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送消息至消息队列</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">key_t</span> key = ftok(<span class="string">&quot;queuefile&quot;</span>, <span class="number">65</span>);  <span class="comment">// 生成唯一键</span></span><br><span class="line">    <span class="type">int</span> msgid = msgget(key, <span class="number">0666</span> | IPC_CREAT); <span class="comment">// 创建消息队列</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">message</span> <span class="title">msg</span>;</span></span><br><span class="line">    msg.mtype = <span class="number">1</span>; <span class="comment">// 设置消息类型</span></span><br><span class="line">    <span class="built_in">sprintf</span>(msg.mtext, <span class="string">&quot;Hello World&quot;</span>); <span class="comment">// 消息内容</span></span><br><span class="line">    msgsnd(msgid, &amp;msg, <span class="keyword">sizeof</span>(msg.mtext), <span class="number">0</span>); <span class="comment">// 发送消息</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sent message: %s\n&quot;</span>, msg.mtext);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从消息队列中获取消息</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">key_t</span> key = ftok(<span class="string">&quot;queuefile&quot;</span>, <span class="number">65</span>);</span><br><span class="line">    <span class="type">int</span> msgid = msgget(key, <span class="number">0666</span> | IPC_CREAT);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">message</span> <span class="title">msg</span>;</span></span><br><span class="line">    msgrcv(msgid, &amp;msg, <span class="keyword">sizeof</span>(msg.mtext), <span class="number">1</span>, <span class="number">0</span>); <span class="comment">// 接收消息</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Received message: %s\n&quot;</span>, msg.mtext);</span><br><span class="line">    msgctl(msgid, IPC_RMID, <span class="literal">NULL</span>); <span class="comment">// 销毁消息队列</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>7.套接字 (Sockets)</strong></p><p><strong>概念</strong>：</p><p>套接字是一种在不同进程间进行数据交换的通信机制。在 Linux 中，套接字可以用于同一台机器上的进程间通信（IPC）或不同机器上的网络通信。套接字支持多种通信协议，最常见的是TCP（可靠的、连接导向的协议）和UDP（无连接的、不可靠的协议）。</p><p><strong>简单图解：</strong></p><p><img src="/images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/14.jpg"></p><p><strong>使用场景：</strong></p><p><strong>网络通信</strong>：<br>同一台主机或不同主机上的进程之间通过网络套接字进行数据交换。</p><p><strong>简单示例：</strong> - 使用 TCP 套接字进行通信</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务器端（监听和接收数据）:</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> server_fd, new_socket;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    <span class="type">int</span> addrlen = <span class="keyword">sizeof</span>(address);</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    server_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);  <span class="comment">// 创建套接字</span></span><br><span class="line">    <span class="comment">// 定义套接字地址</span></span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    address.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    address.sin_port = htons(<span class="number">8080</span>);</span><br><span class="line">    <span class="comment">// 绑定套接字</span></span><br><span class="line">    bind(server_fd, (<span class="keyword">struct</span> sockaddr *)&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    listen(server_fd, <span class="number">3</span>);    <span class="comment">// 监听套接字</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 接受连接</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Waiting for a connection...\n&quot;</span>);</span><br><span class="line">        new_socket = accept(server_fd, (<span class="keyword">struct</span> sockaddr *)&amp;address, (<span class="type">socklen_t</span>*)&amp;addrlen);</span><br><span class="line">        <span class="comment">// 读取数据</span></span><br><span class="line">        read(new_socket, buffer, <span class="number">1024</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Message: %s\n&quot;</span>, buffer);</span><br><span class="line">        <span class="comment">// 可以在这里处理收到的消息或执行其他任务</span></span><br><span class="line">        close(new_socket);  <span class="comment">// 关闭这次连接的套接字</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭监听的套接字</span></span><br><span class="line">    <span class="comment">// 注意：由于 while(1)，这行代码不会执行，除非在循环中加入退出条件</span></span><br><span class="line">    close(server_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端进程（发送数据）:</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> sock = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">    sock = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>); <span class="comment">// 创建套接字</span></span><br><span class="line">    serv_addr.sin_family = AF_INET; <span class="comment">// 定义套接字地址</span></span><br><span class="line">    serv_addr.sin_port = htons(<span class="number">8080</span>);</span><br><span class="line">    connect(sock, (<span class="keyword">struct</span> sockaddr *)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));    <span class="comment">// 连接到服务器</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 发送数据</span></span><br><span class="line">    <span class="type">char</span> *message = <span class="string">&quot;Hello from the client!&quot;</span>;</span><br><span class="line">    send(sock, message, <span class="built_in">strlen</span>(message), <span class="number">0</span>);</span><br><span class="line">    close(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>8.域套接字 (Unix Domain Sockets)</strong></p><p><strong>概念</strong>：</p><p>域套接字（Unix Domain Sockets）是一种在同一台机器上的进程间进行数据通信的机制。相对于网络套接字，它们提供了更高效的本地通信方式，<strong>因为数据不需要经过网络协议栈</strong>。域套接字支持流（类似TCP）和数据报（类似UDP）两种模式。</p><p><strong>特别说明</strong>：在域套接字通信中，<strong>“不经过网络协议栈”</strong> 指的是数据传输不需要IP层的路由、不需要TCP&#x2F;UDP等传输层协议的封包与解包处理，也不需要网络接口层的参与。这一点与网络套接字不同，后者用于跨网络的通信，需要经过完整的网络协议栈处理，包括数据的封装、传输、路由和解封装等。</p><p><strong>简单图解：</strong></p><p><img src="/images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/15.jpg"></p><p><strong>使用场景：</strong></p><ul><li><p><strong>本地进程间通信</strong>：</p><p>当需要在同一台机器上的不同进程间高效地交换数据时。</p></li><li><p><strong>替代管道和消息队列</strong>：</p><p>当需要比管道和消息队列更复杂的双向通信时。</p></li></ul><p><strong>简单示例：</strong> - 使用 Unix 域套接字进行通信</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务器端（监听和接收数据）:</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> server_fd, client_socket;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">address</span>;</span></span><br><span class="line">    server_fd = socket(AF_UNIX, SOCK_STREAM, <span class="number">0</span>);  <span class="comment">// 创建套接字</span></span><br><span class="line">    address.sun_family = AF_UNIX;     <span class="comment">// 设置套接字地址</span></span><br><span class="line">    <span class="built_in">strcpy</span>(address.sun_path, <span class="string">&quot;/tmp/unix_socket&quot;</span>);</span><br><span class="line">    <span class="comment">// 绑定和监听</span></span><br><span class="line">    bind(server_fd, (<span class="keyword">struct</span> sockaddr *)&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    listen(server_fd, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// 接受连接</span></span><br><span class="line">        client_socket = accept(server_fd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理数据</span></span><br><span class="line">        <span class="type">char</span> buffer[<span class="number">100</span>];</span><br><span class="line">        read(client_socket, buffer, <span class="number">100</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Received: %s\n&quot;</span>, buffer);</span><br><span class="line">        <span class="comment">// 进行其他的业务处理</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        </span><br><span class="line">        close(client_socket);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清理</span></span><br><span class="line">    close(server_fd);</span><br><span class="line">    unlink(<span class="string">&quot;/tmp/unix_socket&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端（发送数据）:</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> sock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">address</span>;</span></span><br><span class="line">    sock = socket(AF_UNIX, SOCK_STREAM, <span class="number">0</span>); <span class="comment">// 创建套接字</span></span><br><span class="line">    address.sun_family = AF_UNIX;           <span class="comment">// 设置套接字地址</span></span><br><span class="line">    <span class="built_in">strcpy</span>(address.sun_path, <span class="string">&quot;/tmp/unix_socket&quot;</span>);</span><br><span class="line">    <span class="comment">// 连接到服务器</span></span><br><span class="line">    connect(sock, (<span class="keyword">struct</span> sockaddr *)&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    <span class="comment">// 发送数据</span></span><br><span class="line">    <span class="type">char</span> *message = <span class="string">&quot;Hello from the client!&quot;</span>;</span><br><span class="line">    write(sock, message, <span class="built_in">strlen</span>(message));</span><br><span class="line">    <span class="comment">// 清理</span></span><br><span class="line">    close(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong>：</p><ul><li>Unix 域套接字的地址是文件系统中的路径，而不是IP地址和端口。</li><li>Unix 域套接字通常用于同一台机器上的进程间通信，而不适用于网络通信。</li><li>使用 Unix 域套接字时，需要确保套接字文件的路径是可访问的，并在通信完成后清理套接字文件。</li></ul><h3 id="Linux-线程"><a href="#Linux-线程" class="headerlink" title="Linux 线程"></a>Linux 线程</h3><p><img src="/images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/16.jpg"></p><h4 id="什么是线程？"><a href="#什么是线程？" class="headerlink" title="什么是线程？"></a>什么是线程？</h4><p>线程，有时被称为“轻量级进程”，是程序执行流的最小单位。它允许多任务在单个进程内部并发执行。</p><h4 id="线程与进程的区别："><a href="#线程与进程的区别：" class="headerlink" title="线程与进程的区别："></a>线程与进程的区别：</h4><ul><li><strong>进程</strong>: 拥有独立的地址空间和资源。</li><li><strong>线程</strong>: 共享其所在进程的资源，但有自己的堆栈空间。</li></ul><h4 id="创建你的第一个线程"><a href="#创建你的第一个线程" class="headerlink" title="创建你的第一个线程"></a>创建你的第一个线程</h4><p>在 Linux 下，我们使用 POSIX Threads （简称 Pthreads）库来操作线程。以下是一个简单的例子，创建并运行两个线程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Thread 1 function</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">func1</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello from thread 1!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thread 2 function</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">func2</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello from thread 2!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> thread1, thread2;</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;thread1, <span class="literal">NULL</span>, func1, <span class="literal">NULL</span>);    <span class="comment">// Create thread 1</span></span><br><span class="line">    pthread_create(&amp;thread2, <span class="literal">NULL</span>, func2, <span class="literal">NULL</span>);    <span class="comment">// Create thread 2</span></span><br><span class="line"></span><br><span class="line">    pthread_join(thread1, <span class="literal">NULL</span>); <span class="comment">// Wait for thread 1 to finish</span></span><br><span class="line">    pthread_join(thread2, <span class="literal">NULL</span>); <span class="comment">// Wait for thread 2 to finish</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="线程同步：何时使用？"><a href="#线程同步：何时使用？" class="headerlink" title="线程同步：何时使用？"></a>线程同步：何时使用？</h4><p>当两个或多个线程想要访问同一个资源时，问题就来了！如何确保资源的安全访问？有以下三种线程同步的方式。</p><ul><li><strong>互斥锁</strong>: 一个线程在使用资源时，锁住它，其他线程等待。一般用在临界区的保护。</li><li><strong>条件变量</strong>: 线程等待直到某个条件满足。一般和互斥锁搭配使用来实现线程同步 。</li><li><strong>信号量</strong>: 一种高级的同步方式，可以控制资源的访问数量。</li></ul><p> <strong>信号量更为通用</strong>，因为它不仅可以用作互斥锁，还可以用来同步线程，例如 ：确保线程按特定的顺序执行或控制对有限资源的访问。</p><p><strong>确保线程按特定的顺序执行</strong>：</p><p>在某些场景下，您可能希望线程以特定的顺序执行。例如，线程 A 必须在线程 B 之前执行。这可以通过使用信号量来实现。</p><p><strong>控制对有限资源的访问</strong>：</p><p>信号量也可用于控制对有限资源的访问。例如，数据库连接池，其中只有一定数量的连接可供线程使用，可以使用信号量来确保只有固定数量的线程可以同时访问这些资源。</p><p><strong>确保线程按特定的顺序执行的示例代码</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">sem_t</span> semA;</span><br><span class="line"><span class="comment">// 线程A</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">threadA</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread A is running\n&quot;</span>);</span><br><span class="line">    sem_post(&amp;semA); <span class="comment">// 释放信号量A</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程B</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">threadB</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    sem_wait(&amp;semA); <span class="comment">// 等待信号量A</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread B is running\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> tA, tB;</span><br><span class="line">    <span class="comment">// 初始化信号量</span></span><br><span class="line">    sem_init(&amp;semA, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">    pthread_create(&amp;tA, <span class="literal">NULL</span>, threadA, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tB, <span class="literal">NULL</span>, threadB, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 等待线程结束</span></span><br><span class="line">    pthread_join(tA, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tB, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 清理资源</span></span><br><span class="line">    sem_destroy(&amp;semA);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线程的优点与缺点"><a href="#线程的优点与缺点" class="headerlink" title="线程的优点与缺点:"></a>线程的优点与缺点:</h4><p><strong>优点</strong>:</p><ul><li>线程之间的切换成本比进程之间的切换成本低。</li><li>线程间的通信速度比进程间的通信速度快，因为线程共享同一地址空间。</li><li>利用多线程可以很容易地在单进程应用中实现并发。</li></ul><p><strong>缺点</strong>:</p><ul><li>因为线程共享同一地址空间，一个线程的错误可能会破坏其他线程的数据或状态。</li><li>需要复杂的同步操作来避免竞争条件。</li></ul><h4 id="常见问题与挑战"><a href="#常见问题与挑战" class="headerlink" title="常见问题与挑战"></a>常见问题与挑战</h4><p><strong>死锁</strong>:</p><p>死锁发生在两个或多个线程永久地等待对方释放锁的情况。它通常发生在多个线程需要多个锁时，如果不按相同的顺序获取锁，就可能陷入互相等待的状态。</p><p><strong>解决方案</strong>：</p><ul><li>确保所有线程以相同的顺序获取锁。</li><li>使用层次结构的锁定系统，其中线程必须按特定顺序获取锁。</li><li>设置超时，以便在等待锁的时间过长时，线程可以放弃等待，尝试其他操作。</li></ul><p><strong>线程安全</strong>：</p><p>线程安全是指确保代码可以在多线程环境中安全运行，不会因为多个线程同时访问共享资源而导致数据损坏或不一致。</p><p><strong>解决方案：</strong></p><ul><li><strong>使用同步机制</strong>，如互斥锁或信号量，来控制对共享资源的访问。</li><li><strong>编写无状态的代码，或者确保状态信息不在多个线程间共享。</strong> 无状态的代码指的是不保存任何与特定实例相关的数据（状态）的代码。在多线程环境中，这意味着代码不依赖于或不修改任何外部状态，如全局变量或类的成员变量。</li><li><strong>使用不可变对象</strong>，这些对象一旦创建就不会更改，因此可以安全地在多个线程间共享。不可变对象是指一旦被创建就不能被修改的对象(如字符串)，这些对象的状态在创建后是固定的，因此在多线程环境中安全。</li></ul><blockquote><p><strong>总结</strong>：编写无状态的代码和使用不可变对象都是避免多线程环境中的数据冲突和竞争条件的策略。无状态代码避免了共享数据，而不可变对象则确保了即使数据被共享，它们也不会被修改，从而保证线程安全。</p></blockquote><h4 id="进一步探索"><a href="#进一步探索" class="headerlink" title="进一步探索"></a>进一步探索</h4><p><strong>线程池</strong>: </p><p>线程池通过重用一组预先创建的线程来处理任务，减少了线程创建和销毁的开销。</p><p><strong>应用</strong>：线程池广泛用于网络服务器应用，特别是在需要处理大量短暂任务的场景中。</p><p><strong>高级同步原语</strong>: </p><p><strong>读写锁（Read-Write Locks）</strong></p><p>读写锁是一种特殊类型的锁，它允许多个线程同时读取共享资源，但写入操作需要独占访问。这意味着只要没有线程正在写入共享资源，多个线程可以同时读取资源而不会被阻塞。</p><p><strong>应用场景</strong>：适用于读操作远多于写操作的情况，比如缓存系统。</p><p><strong>优点</strong>：提高了在读多写少场景下的并发性能。</p><p><strong>实现</strong>：在 POSIX 线程库中，通过 pthread_rwlock_t 类型提供。</p><p><strong>简单示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_rwlock_t</span> rwlock = PTHREAD_RWLOCK_INITIALIZER;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">reader</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    pthread_rwlock_rdlock(&amp;rwlock);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Reader is reading...\n&quot;</span>);</span><br><span class="line">    sleep(<span class="number">1</span>); <span class="comment">// 模拟读取操作</span></span><br><span class="line">    pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">writer</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    pthread_rwlock_wrlock(&amp;rwlock);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Writer is writing...\n&quot;</span>);</span><br><span class="line">    sleep(<span class="number">1</span>); <span class="comment">// 模拟写入操作</span></span><br><span class="line">    pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> t1, t2;</span><br><span class="line">    pthread_rwlock_init(&amp;rwlock, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;t1, <span class="literal">NULL</span>, reader, <span class="literal">NULL</span>);</span><br><span class="line">    sleep(<span class="number">2</span>); <span class="comment">// 确保读者先运行</span></span><br><span class="line">    pthread_create(&amp;t2, <span class="literal">NULL</span>, writer, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(t1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(t2, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_rwlock_destroy(&amp;rwlock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>屏障（Barriers）</strong></p><p>屏障用于同步多个线程在程序中的特定点。当线程到达一个屏障时，它会等待，直到所有其他线程也都到达这个屏障。然后所有线程才能继续执行。</p><p><strong>应用场景</strong>：用于并行算法，确保所有线程完成某个阶段的工作后才开始下一个阶段。</p><p><strong>优点</strong>：确保所有线程同步进行，避免数据不一致。</p><p><strong>实现</strong>：在 POSIX 线程库中，通过 pthread_barrier_t 类型提供。</p><p><strong>简单示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NUM_THREADS 5</span></span><br><span class="line"><span class="type">pthread_barrier_t</span> barrier;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">task</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread %ld waiting at barrier\n&quot;</span>, (<span class="type">long</span>)arg);</span><br><span class="line">    pthread_barrier_wait(&amp;barrier);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread %ld passed barrier\n&quot;</span>, (<span class="type">long</span>)arg);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> threads[NUM_THREADS];</span><br><span class="line">    pthread_barrier_init(&amp;barrier, <span class="literal">NULL</span>, NUM_THREADS);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> i = <span class="number">0</span>; i &lt; NUM_THREADS; i++) &#123;</span><br><span class="line">        pthread_create(&amp;threads[i], <span class="literal">NULL</span>, task, (<span class="type">void</span>*)i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_THREADS; i++) &#123;</span><br><span class="line">        pthread_join(threads[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_barrier_destroy(&amp;barrier);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明</strong>：这个程序演示了如何使用屏障来同步多个线程，确保所有线程都到达一个执行点后才一起继续执行。在这个例子中，所有线程都会在打印“等待”信息后等待，直到它们全部到达 pthread_barrier_wait 调用处。只有当所有线程都到达这个点时，它们才会继续执行并打印“通过”信息。</p><p><strong>原子操作（Atomic Operations）</strong></p><p>原子操作是指在多线程环境中，一系列操作作为一个单独的不可中断的单位执行，确保在读取、修改和更新变量时的原子性。这些操作在执行的全过程中不会被线程调度机制中断。</p><p><strong>应用场景</strong>：</p><p>非常适合于计数器、标志位更新等简单状态的更新场景，其中对单一变量的读取、修改和更新必须作为一个整体来执行，以避免数据竞争和保证数据一致性。</p><p><strong>优点</strong>：</p><ul><li><strong>效率</strong>：相比锁机制，原子操作通常更高效，因为它们避免了锁的开销和潜在的上下文切换。</li><li><strong>简化编程模型</strong>：对于简单的同步需求，原子操作提供了一种简单直接的解决方案，避免了使用锁的复杂性。</li></ul><p><strong>实现</strong>：在 POSIX 线程库中，原子操作并非直接提供，但可以通过 GCC 提供的内建原子操作函数，如__sync_fetch_and_add、__sync_lock_test_and_set等。C++11及更高版本的标准也提供了原子操作的支持，如 std::atomic 类型。</p><p><strong>简单示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个全局计数器</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 线程函数，用于增加计数器</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">increment_counter</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i) &#123;</span><br><span class="line">        <span class="comment">// 使用GCC的内建原子操作函数进行原子增加</span></span><br><span class="line">        __sync_fetch_and_add(&amp;counter, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> t1, t2;</span><br><span class="line">    <span class="comment">// 创建两个线程，都执行increment_counter函数</span></span><br><span class="line">    pthread_create(&amp;t1, <span class="literal">NULL</span>, increment_counter, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;t2, <span class="literal">NULL</span>, increment_counter, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 等待线程完成</span></span><br><span class="line">    pthread_join(t1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(t2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 打印最终的计数器值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Final counter value: %d\n&quot;</span>, counter);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>自旋锁（Spinlocks）</strong></p><p>自旋锁是一种忙等待的锁，当一个线程尝试获取一个已经被其他线程持有的锁时，它会在一个循环中不断检查锁的状态。这意味着线程会一直占用 CPU，直到它能够获取到锁。</p><p><strong>应用场景</strong>：</p><p>特别适合锁持有时间非常短的场景，因为它避免了线程从运行态转为等待态的开销，这在多核处理器上尤其有用。</p><p><strong>实现</strong>：在 POSIX 线程库中，自旋锁通过 pthread_spinlock_t 类型提供，相关的操作包括 pthread_spin_lock、pthread_spin_unlock等。自旋锁的使用和管理相对简单，但需要谨慎使用以避免过度占用 CPU 资源。</p><p><strong>简单示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_spinlock_t</span> spinlock;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">task</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    pthread_spin_lock(&amp;spinlock);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread %ld got the lock\n&quot;</span>, (<span class="type">long</span>)arg);</span><br><span class="line">    sleep(<span class="number">1</span>); <span class="comment">// 模拟任务执行</span></span><br><span class="line">    pthread_spin_unlock(&amp;spinlock);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> t1, t2;</span><br><span class="line">    pthread_spin_init(&amp;spinlock, PTHREAD_PROCESS_PRIVATE);</span><br><span class="line">    pthread_create(&amp;t1, <span class="literal">NULL</span>, task, (<span class="type">void</span>*)<span class="number">1L</span>);</span><br><span class="line">    pthread_create(&amp;t2, <span class="literal">NULL</span>, task, (<span class="type">void</span>*)<span class="number">2L</span>);</span><br><span class="line">    pthread_join(t1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(t2, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_spin_destroy(&amp;spinlock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内存管理入门"><a href="#内存管理入门" class="headerlink" title="内存管理入门"></a>内存管理入门</h3><p>在前面的讲解中，我们已经学习了进程和线程的基本概念，了解了它们是操作系统进行资源分配和任务调度的基本单位。而无论是进程还是线程，它们的运行都离不开一个关键的系统资源——内存。这自然引出了一个重要的问题：操作系统是如何管理这些内存资源的？这正是我们接下来要讨论的主题— <strong>Linux内存管理</strong>。</p><h4 id="内存分配与释放"><a href="#内存分配与释放" class="headerlink" title="内存分配与释放"></a>内存分配与释放</h4><p>首先，我们先来看下内存的分配与释放，常见的内存分配方式包含以下两种：</p><p><strong>静态内存分配</strong> ： 是在编译时完成的，通常用于固定大小的数据结构，比如：普通数组。</p><p><strong>动态内存分配</strong> ： 则在运行时进行，允许程序根据需要分配任意大小的内存块，比如：动态数组。</p><p>我们一般使用 <strong>malloc和free</strong> 来进行动态内存分配与释放。</p><p>来看个动态内存分配的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int *array = malloc(10 * sizeof(int)); # 分配内存</span><br><span class="line">    if (array == NULL) &#123;</span><br><span class="line">        perror(&quot;malloc failed&quot;);</span><br><span class="line">        return EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">    #使用动态内存 array ...</span><br><span class="line"></span><br><span class="line">    free(array); # 释放内存</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h4><p>应用程序如果没有正确的管理内存的分配与回收，就有可能出现内存泄漏，严重点的有可能导致程序异常退出。</p><p><strong>那什么是内存泄露？</strong></p><p>内存泄露是指程序中动态分配的内存没有及时释放，导致这部分内存在程序执行过程中一直占用，无法被再次利用。在长时间运行的程序中，内存泄露可能会导致内存使用不断增加，最终耗尽所有可用内存，影响程序性能甚至引发程序崩溃。</p><p><strong>如何避免内存泄露？</strong></p><ul><li><p><strong>合理设计程序结构</strong>：确保每次 malloc 后都有对应的 free 操作。可以通过使用自动化工具，如 Valgrind 等，来检测程序运行中的内存泄露问题。</p></li><li><p><strong>使用智能指针</strong>：在支持 C++ 等高级语言中，使用智能指针（如 std::unique_ptr, std::shared_ptr 等）可以帮助管理动态内存的生命周期，智能指针会在适当的时候自动释放内存。</p></li><li><p><strong>及时释放内存</strong>：在不需要动态分配的内存后，应立即释放。尤其是在异常处理、错误处理的代码路径中，也不要忘记释放内存。</p></li><li><p><strong>规范化资源管理</strong>：使用 RAII（Resource Acquisition Is Initialization）原则管理资源，<strong>确保资源的获取即是初始化，随着对象的销毁资源被释放</strong>。</p></li></ul><h4 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a>虚拟内存管理</h4><p><strong>虚拟内存概念：</strong></p><p>虚拟内存是计算机系统内存管理的一种技术。它使得应用程序认为它拥有很大连续的、可用的内存空间，即使这些内存可能被分散存储在物理内存和磁盘上。</p><p><strong>虚拟内存的主要好处是</strong>：</p><ul><li>它提供了比实际物理内存更大的地址空间。</li><li>保证每个程序在内存中有一个连续的地址空间。</li><li>允许系统运行大于物理内存的程序。</li><li>通过内存隔离，提高了程序间的安全性。</li></ul><p>操作系统通过使用硬盘上的一块称为“交换空间”的区域来实现这一点，它作为物理内存的一个扩展。当系统的物理 RAM 不足时，它可以将当前不活跃的内存页面移动到磁盘上，从而为需要更多内存的进程腾出空间。</p><p><strong>分页机制</strong></p><p>分页是虚拟内存管理中最常用的技术之一。它将虚拟内存和物理内存分成大小相等的块，这些块在虚拟内存中被称为“页”(pages)，在物理内存中被称为“页框”(page frames)。每个程序都有一个页表，页表将程序的虚拟地址映射到物理内存的页框。</p><p><strong>分页机制如何工作：</strong></p><p>1.当程序试图访问虚拟内存中的地址时，它首先会检查页表。</p><p>2.如果找到了对应的物理地址，那么数据的存取操作就会继续。</p><p>3.如果没有找到，会触发一个缺页中断，由操作系统处理。</p><p><strong>缺页中断</strong></p><p>缺页中断（Page Fault）是分页系统中的一项关键机制，当一个进程访问的虚拟页不在物理内存中时触发。这时候，操作系统会分配一个物理页框，并将该虚拟页所对应的磁盘数据加载至页框中，并在页表中建立虚拟页和物理页的映射关系。这样，当下一次进程在访问相同虚拟页的时候，就可以直接访问内存中的数据了。</p><p>通过以上机制，虚拟内存管理提供了高效灵活的内存使用方式，允许操作系统优化内存分配，同时也给应用程序提供了简单的内存管理模型。</p><h3 id="文件系统：探索-Linux-中的数据管理"><a href="#文件系统：探索-Linux-中的数据管理" class="headerlink" title="文件系统：探索 Linux 中的数据管理"></a>文件系统：探索 Linux 中的数据管理</h3><p>前面我们探讨了 Linux 系统中的内存管理，包括内存分配与释放、内存泄漏和虚拟内存等概念，这些都是操作系统保证程序正常运行的基础。内存管理使得多个应用能够高效、安全地共享系统的物理内存资源，同时还提供了数据的临时存储能力。然而，内存只能提供临时存储，当系统断电或重启时，内存中的数据就会丢失。这就引出了我们下一个重要话题：<strong>文件系统</strong>。</p><p>在谈文件系统之前，我们先来了解下虚拟文件系统。</p><h4 id="虚拟文件系统（VFS）"><a href="#虚拟文件系统（VFS）" class="headerlink" title="虚拟文件系统（VFS）"></a>虚拟文件系统（VFS）</h4><p><strong>什么是VFS？</strong></p><p>Linux内核中的虚拟文件系统（VFS）是一个关键的抽象层，它为各种不同的文件系统提供了一个统一的操作接口。这意味着，不管数据实际上存储在哪个文件系统中（比如EXT4、XFS等），VFS都能提供一致的访问方式。</p><p><strong>VFS的作用</strong></p><p><strong>兼容性</strong>：使得不同的文件系统都能在 Linux 上工作。</p><p><strong>统一性</strong>：它为应用程序提供了一个标准的文件操作接口，简化了文件访问和管理。</p><p>接下来让我们来看下文件系统。</p><p><strong>Linux 的文件系统是什么？</strong></p><p>Linux 文件系统是 Linux 操作系统用于存储、管理和访问文件和目录的一套规则和结构。它提供了一个层次化的目录结构，让用户和程序能够以一致的方式组织和访问数据。Linux 文件系统支持多种类型，如 EXT4、XFS 和 Btrfs，每种都有其特定的优势和用途。文件系统管理文件的存储细节，包括文件的创建、读取、写入和删除操作，同时也处理文件的权限和安全性。通过虚拟文件系统（VFS）层，Linux 能够提供一个统一的接口来访问这些不同的文件系统，使得文件操作对用户和应用程序透明。</p><p><strong>文件系统核心组件:</strong></p><p><strong>超级块（Superblock）</strong></p><p>超级块是文件系统的元数据的一部分，它包含了关于整个文件系统的全局信息，如文件系统的类型、大小、状态、空闲和已用的块和Inode数量等。超级块的主要作用是提供文件系统的关键信息，以便操作系统能够正确地管理和访问文件系统。</p><p><strong>Inode</strong></p><p>Inode 是文件系统中的一个关键数据结构，每个文件和目录都有一个唯一的Inode。它包含了文件的元数据（如文件大小、所有者、权限、时间戳）和指向实际存储文件数据的数据块的指针。Inode 不存储文件名，文件名存储在目录文件中，这些目录文件将文件名映射到 Inode 号。<strong>inode</strong> 号是文件的唯一标识，而不是文件名。</p><p><strong>目录项（Dentry）</strong></p><p>目录项（或Dentry缓存）是内核用来维护文件名与其对应Inode之间映射的结构。目录项缓存是一个重要的性能优化机制，它减少了从文件名到文件内容的查找时间。</p><p><strong>文件数据块</strong></p><p>文件数据块是存储文件实际内容的磁盘空间。Linux文件系统将磁盘空间分割成一系列的块，这些块可以直接被Inode指向，或者通过间接块来存储较大文件的数据。</p><p><strong>文件和目录</strong></p><p>文件和目录是用户与文件系统交互的基本单元。在 Linux 中，一切皆文件：传统的数据文件、目录、设备（如字符设备和块设备）等都通过文件或文件系统的接口来访问。</p><p><strong>下面是文件、目录、inode 、以及数据块之间的映射关系图</strong>：</p><p><img src="/images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/17.jpg"></p><p>我以程序访问磁盘文件为例，来给大家说明下具体的访问过程，方便大家理解上述图示。</p><p><strong>操作系统会执行以下几个步骤</strong>：</p><ul><li><p><strong>解析文件路径</strong>：操作系统首先解析完整的文件路径，确定文件在文件系统中的位置。</p></li><li><p><strong>查找目录项</strong>：利用文件路径，操作系统在文件系统的目录结构中查找对应的目录项（Dentry）。目录项将文件名映射到一个唯一的Inode编号。</p></li><li><p><strong>访问Inode</strong>：每个文件都有一个Inode，其中包含该文件的元数据（如所有者、权限）和指向文件实际数据块的指针。操作系统使用目录项提供的 Inode 编号来访问 Inode Table，进而访问对应的 inode。</p></li><li><p><strong>读取数据块</strong>：通过 Inode 中的信息，操作系统找到存储文件数据的磁盘块位置，然后读取这些数据块以获取文件内容。</p></li></ul><p>除此之外，在 Linux 中，还存在两种特殊的引用文件的方式：<strong>硬链接和软链接</strong></p><h4 id="硬链接和软链接"><a href="#硬链接和软链接" class="headerlink" title="硬链接和软链接"></a>硬链接和软链接</h4><p><strong>什么是硬链接？</strong></p><p>硬链接实际上是目标文件的另一个名称。它与原文件共享相同的 <strong>inode</strong> 号，因此，无论通过哪个名称访问，内容都是一致的。</p><p><strong>图示</strong>：</p><p><img src="/images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/18.jpg"></p><p>这里，“file1”和“link1”都是硬链接，它们指向同一个inode。这意味着它们共享相同的数据块和文件属性。</p><p><strong>如何创建硬链接？</strong></p><p><strong>命令</strong>：<code> ln 源文件 目标文件</code></p><p>例如，创建一个名为 file1 的文件的硬链接 link1，你可以使用：ln file1 link1。</p><p><strong>特点</strong>：</p><ul><li>硬链接不能跨文件系统。</li><li>不能为目录创建硬链接。</li><li>删除原始文件或硬链接中的任何一个不会影响其他文件，因为它们共享相同的数据块。</li></ul><p><strong>什么是软链接？</strong></p><p>与硬链接不同，软链接是一个独立的文件，它并不包含实际的文件内容，而是指向另一个文件或目录的路径。</p><p><strong>图示</strong>：</p><p><img src="/images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/19.jpg"></p><p>在这里，“link1”是一个指向“file1”的软链接。与硬链接不同，软链接只是一个指向另一个文件或目录的路径。当我们访问软链接时，系统会自动重定向我们到它所指向的实际文件。</p><p><strong>如何创建软链接？</strong></p><p><strong>命令</strong>：<code> ln -s 源文件 目标文件</code></p><p>例如，为 file1 创建一个软链接 link1，你可以使用：ln -s file1 link1。</p><p><strong>特点</strong>：</p><ul><li>软链接可以跨文件系统。</li><li>可以为目录创建软链接。</li><li>如果删除了目标文件，软链接会变为死链接，无法再访问原始内容。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章主要是为想学习 Linux 系统编程的初学者提供一个学习指南，从基本概念到高级功能，我们不仅揭示了 Linux 系统的核心技术和架构，还探讨了用户空间与内核空间的关键区别，系统调用与库函数的基本理解，以及文件IO的多样化操作。我们学习了进程和线程的基础，理解了它们之间的差异，以及如何有效地使用线程同步技术来编写稳定的多线程程序。此外，我们还涵盖了内存管理的基础知识，从内存分配与释放到虚拟内存管理，最后学习了 Linux 文件系统的基本概念及其核心组件，以及硬链接和软链接的使用和区别。</p><p>无论你是刚开始接触 Linux 系统编程的新手，还是希望巩固现有知识的经验开发者，本文都提供了宝贵指南。</p><p>通过本文的学习，我希望读者能够：</p><ul><li>掌握 Linux 系统架构的关键组成部分，包括用户空间和内核空间的区别。</li><li>理解系统调用和库函数的作用，以及它们在系统编程中的重要性。</li><li>熟练进行文件IO操作，包括文件描述符的使用，文件位置的移动，以及高级文件I&#x2F;O技术的应用。</li><li>了解进程和线程的基本概念，包括它们的创建、终止和状态转换，以及进程间通信的方法。</li><li>掌握线程同步的技巧，了解线程的优缺点以及在实际编程中的应用。</li><li>建立内存管理的基本知识框架，包括内存分配释放、虚拟内存管理以及如何避免内存泄露。</li><li>探索 Linux 文件系统，理解虚拟文件系统（VFS）的概念，以及硬链接和软链接的使用和区别。</li></ul><h2 id="最后："><a href="#最后：" class="headerlink" title="最后："></a>最后：</h2><p>如果你对 Linux 系统编程以及计算机编程领域相关知识感兴趣，不妨关注我的公众号—<strong>「跟着小康学编程」</strong>。这里会定时更新相关的技术文章，文章通俗易懂，感兴趣的读者可以关注一下：</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>另外，小康最近新创建了一个技术交流群，大家如果在阅读的过程中有遇到问题或者有不理解的地方，欢迎大家加群询问或者评论区询问，我能解决的都尽可能给大家回复。</p><p>扫一扫小康的个人微信，备注「<strong>加群</strong>」即可。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> Linux系统编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux系统编程 </tag>
            
            <tag> Linux I/O </tag>
            
            <tag> Linux 进程和线程 </tag>
            
            <tag> Linux 内存管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何快速注册 OpenAI 账号</title>
      <link href="/register/"/>
      <url>/register/</url>
      
        <content type="html"><![CDATA[<h1 id="一分钟教你快速注册-OpenAI-账号"><a href="#一分钟教你快速注册-OpenAI-账号" class="headerlink" title="一分钟教你快速注册 OpenAI 账号"></a>一分钟教你快速注册 OpenAI 账号</h1><h4 id="首先，你必须得能科学上网（能够正常访问谷歌），即可注册。"><a href="#首先，你必须得能科学上网（能够正常访问谷歌），即可注册。" class="headerlink" title="首先，你必须得能科学上网（能够正常访问谷歌），即可注册。"></a>首先，你必须得能科学上网（能够正常访问谷歌），即可注册。</h4><p>（如果还不会科学上网，可以用这个： <a href="https://www.52xcjs.xyz/auth/register">科学稳定访问 openai</a>)</p><h2 id="快速注册步骤："><a href="#快速注册步骤：" class="headerlink" title="快速注册步骤："></a>快速注册步骤：</h2><p>国内的邮箱都不再允许注册 ChatGPT，建议申请一个免费的海外邮箱 Proton 来注册，其他海外邮箱，如 Gmail 也可以，但是注册难度高一些，步骤繁琐。</p><h3 id="第一步：注册-proton-邮箱"><a href="#第一步：注册-proton-邮箱" class="headerlink" title="第一步：注册 proton 邮箱"></a>第一步：注册 proton 邮箱</h3><h4 id="1-1-访问-proton"><a href="#1-1-访问-proton" class="headerlink" title="1.1 访问 proton"></a>1.1 访问 proton</h4><p><a href="https://proton.me/">https://proton.me/</a></p><p>选择右上角的 「Create a free account」</p><p><img src="/images/%E6%B3%A8%E5%86%8COpenAI%E8%B4%A6%E5%8F%B7/001.png"></p><h4 id="1-2-选择免费套餐"><a href="#1-2-选择免费套餐" class="headerlink" title="1.2 选择免费套餐"></a>1.2 选择免费套餐</h4><p><img src="/images/%E6%B3%A8%E5%86%8COpenAI%E8%B4%A6%E5%8F%B7/002.png"></p><h4 id="1-3-选择邮箱后缀，设置用户名和密码"><a href="#1-3-选择邮箱后缀，设置用户名和密码" class="headerlink" title="1.3 选择邮箱后缀，设置用户名和密码"></a>1.3 选择邮箱后缀，设置用户名和密码</h4><p>推荐选择 proton.me</p><p><img src="/images/%E6%B3%A8%E5%86%8COpenAI%E8%B4%A6%E5%8F%B7/003.png"></p><h4 id="1-4-通过真人验证"><a href="#1-4-通过真人验证" class="headerlink" title="1.4 通过真人验证"></a>1.4 通过真人验证</h4><p>依次拖动验证码，然后下一步即可</p><p><img src="/images/%E6%B3%A8%E5%86%8COpenAI%E8%B4%A6%E5%8F%B7/004.png"></p><p><img src="/images/%E6%B3%A8%E5%86%8COpenAI%E8%B4%A6%E5%8F%B7/005.png"></p><p><strong>注册完后，可以去登陆邮箱</strong>，方便接收验证码：</p><p><a href="https://proton.me/">https://proton.me/</a></p><h3 id="第二步：注册-OpenAI-账号"><a href="#第二步：注册-OpenAI-账号" class="headerlink" title="第二步：注册 OpenAI 账号"></a>第二步：注册 OpenAI 账号</h3><h4 id="2-1-首先打开-OpenAI-的账户注册页面，然后输入-proton-邮箱。"><a href="#2-1-首先打开-OpenAI-的账户注册页面，然后输入-proton-邮箱。" class="headerlink" title="2.1 首先打开 OpenAI 的账户注册页面，然后输入 proton 邮箱。"></a>2.1 首先打开 OpenAI 的账户注册页面，然后输入 proton 邮箱。</h4><p><a href="https://chat.openai.com/">https://chat.openai.com/</a></p><p><img src="/images/%E6%B3%A8%E5%86%8COpenAI%E8%B4%A6%E5%8F%B7/006.png"></p><p><img src="/images/%E6%B3%A8%E5%86%8COpenAI%E8%B4%A6%E5%8F%B7/007.png"></p><h4 id="2-2-接着设置-OpenAi-密码-如下就是你的-openai-账号和密码"><a href="#2-2-接着设置-OpenAi-密码-如下就是你的-openai-账号和密码" class="headerlink" title="2.2 接着设置 OpenAi 密码(如下就是你的 openai 账号和密码)"></a>2.2 接着设置 OpenAi 密码(如下就是你的 openai 账号和密码)</h4><p><img src="/images/%E6%B3%A8%E5%86%8COpenAI%E8%B4%A6%E5%8F%B7/008.png"></p><p>  <br><br><br>点击继续，接着点击 Resend email <br><br> </p><p><img src="/images/%E6%B3%A8%E5%86%8COpenAI%E8%B4%A6%E5%8F%B7/009.png"></p><p>  <br><br><br>接着验证邮箱，去 Proton.me 收件箱里点击「Verify email address」即可。<br><br> </p><p><img src="/images/%E6%B3%A8%E5%86%8COpenAI%E8%B4%A6%E5%8F%B7/010.png"><br><br><br><br>然后提供你的名和姓及生日，并点击 <strong>Agee</strong> 即可。</p>]]></content>
      
      
      <categories>
          
          <category> ChatGPT </category>
          
          <category> OpenAI 账号注册 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenAI 账号注册 </tag>
            
            <tag> ChatGPT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>欢迎关注我的微信公众号 — 跟着小康学编程</title>
      <link href="/xiaokangvx/"/>
      <url>/xiaokangvx/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康！</p><p>🌟 如果你对计算机编程感兴趣，想要从基础到进阶系统地学习编程语言和技术，那么你来对地方了！<strong>「跟着小康学编程」</strong>是你的最佳起点！</p><p>👨‍💻 这里是你的一站式编程学习平台，内容涵盖：</p><ul><li><strong>C&#x2F;C++、Java、Go 语言</strong>：无论你是初学者还是希望深化技能的开发者，这里都有适合你的资源。</li><li><strong>计算机基础</strong>：全面理解计算机基本原理，包括操作系统、算法、数据结构、网络和数据库。</li><li><strong>Linux系统和网络编程</strong>：掌握操作系统的核心技术和网络编程的高级技巧。</li><li><strong>MySQL数据库技术</strong>：学习如何利用MySQL进行高效的数据存储和复杂的数据管理。</li><li><strong>Redis高速缓存</strong>：掌握Redis在高速数据处理和缓存方面的应用，让你的应用运行得更快。</li><li><strong>RabbitMQ消息队列</strong>：了解RabbitMQ的高效消息传递机制，确保应用组件间的数据一致性和可靠性。</li><li><strong>微服务架构</strong>：探索将复杂应用分解为更小、更易管理的微服务的策略，使整个应用更容易管理和扩展。</li><li><strong>容器技术</strong>：深入Docker和Kubernetes，掌握现代容器化和自动化部署的关键技术</li><li><strong>未完待续</strong>。。。</li></ul><p>目前，公众号只提供了上述提到的部分技术文章。其他技术相关文章后续会依次补上。<strong>目标就是：为广大编程爱好者提供更加全面的编程指南。</strong></p><p>另外，后续也会增加计算机编程各个领域的面试题，包括：C&#x2F;C++、Java、Go、以及操作系统、计算机网络以及数据结构等面试题。为大家面试提供帮助。</p><p><strong>总之：本号的定位就是 C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习 + 计算机基础原理 + Linux编程 + 容器技术等。</strong> 文章尽可能的通俗易懂，而且文章都会有代码示例，方便初学者理解，有兴趣的朋友可以关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p><br><br> </p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/gzh.png"></p><p><br><br> </p><p><strong>注</strong>：上面提到的计算机学习资料包括<strong>C&#x2F;C++、Java、Go语言，计算机组成原理、操作系统、数据结构与算法、计算机网络以及 Linux 系统编程和网络编程、Linux 内核、数据库</strong>等书籍的电子档 pdf。</p><p><br><br> </p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p><br><br> </p><p>另外，小康最近创建了一个技术交流群，专门用来探讨技术相关或者解答读者的问题。大家在阅读技术文章的时候，如果觉得有问题的或者有不理解的知识点，欢迎大家加群询问。我能够解决的，尽量给大家回复。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 小康的联系方式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 我的公众号 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何快速升级到 GPT-4</title>
      <link href="/upgrade-gpt4/"/>
      <url>/upgrade-gpt4/</url>
      
        <content type="html"><![CDATA[<h1 id="【保姆级】如何升级-GPT-4？快速升级至ChatGPT-Plus指南-，ChatGPT4-0-注册及升级攻略指南"><a href="#【保姆级】如何升级-GPT-4？快速升级至ChatGPT-Plus指南-，ChatGPT4-0-注册及升级攻略指南" class="headerlink" title="【保姆级】如何升级 GPT-4？快速升级至ChatGPT Plus指南 ，ChatGPT4.0 注册及升级攻略指南"></a>【保姆级】如何升级 GPT-4？快速升级至ChatGPT Plus指南 ，ChatGPT4.0 注册及升级攻略指南</h1><p>首先，你必须得能科学上网（能够正常访问谷歌），如果你还不会，请了解这个：<a href="https://www.52xcjs.xyz/auth/register">科学稳定访问 openai</a></p><h2 id="升级-ChatGPT-Plus-的步骤："><a href="#升级-ChatGPT-Plus-的步骤：" class="headerlink" title="升级 ChatGPT Plus 的步骤："></a>升级 ChatGPT Plus 的步骤：</h2><p>（PS：如果不会操作，也可以提供代充、GPT 账号注册等服务，有需要加微信：<strong>jkfwdkf</strong>，备注：<strong>chatgpt</strong></p><h3 id="方法一：自己充值升级"><a href="#方法一：自己充值升级" class="headerlink" title="方法一：自己充值升级"></a>方法一：自己充值升级</h3><h4 id="步骤指南：轻松升级至-ChatGPT-Plus"><a href="#步骤指南：轻松升级至-ChatGPT-Plus" class="headerlink" title="步骤指南：轻松升级至 ChatGPT Plus"></a>步骤指南：轻松升级至 ChatGPT Plus</h4><p>之前了解到一种升级方式，非常方便和迅速，大概 2 分钟之内就可以搞定，它主要是通过虚拟信用卡 WildCard 来进行升级的！</p><p><strong>通过专属链接</strong> <a href="https://bewildcard.com/i/666GPT">WildCard | 一分钟开卡，轻松订阅海外软件服务 即可快速升级 ChatGPT Plus</a><br>（<strong>PS：大家可以使用我的邀请链接：<a href="https://bewildcard.com/i/666GPT">https://bewildcard.com/i/666GPT</a>  ， 邀请码：666GPT</strong>，开卡的时候需要填写邀请码）</p><p><strong>具体操作过程：</strong><br><strong>第一步：点击上述链接，先开卡</strong></p><p>1.立即注册</p><p><img src="/images/%E5%BF%AB%E9%80%9F%E5%8D%87%E7%BA%A7GPT4/001.png"><br><br><br> </p><p>2.填写手机号（你自己的手机号就行）</p><p><img src="/images/%E5%BF%AB%E9%80%9F%E5%8D%87%E7%BA%A7GPT4/002.png"><br><br><br> </p><p>3.下一步之后，填写你自己的个人身份信息【邮箱地址：你就填你容易记得的就行，比如：你叫张三，你就填zhangsan 即可】，然后点击下一步。</p><p><img src="/images/%E5%BF%AB%E9%80%9F%E5%8D%87%E7%BA%A7GPT4/003.png"></p><p>4.接着进行支付宝验证以及支付卡费即可。</p><p><strong>说明：</strong> 开卡的时候是需要支付卡费的，有 1 年和 2 年有效期的选择的。1年是 11.99 美元，2年是 13.99美元，折合人民币不到 100 左右，也没有其他的月租等费用。开1年和2年均可以。 </p><p><strong>第二步：注册 OpenAI 账户</strong>，得到 OpenAI 账号和密码。（这个需要1美元购买账号，比较方便）.</p><p><img src="/images/%E5%BF%AB%E9%80%9F%E5%8D%87%E7%BA%A7GPT4/004.png"><br><br><br> </p><p>然后购买一个账号（不到1美元），支持支付宝付款</p><p><img src="/images/%E5%BF%AB%E9%80%9F%E5%8D%87%E7%BA%A7GPT4/005.png"><br><br><br><br><strong>第三步：充值 GPT Plus 月费用 20 美元，大概 140 多人民币。</strong></p><p><strong>第四步：</strong> 最后点击 <strong>一键升级 GPT Plus</strong>，接着根据它的教程来完成最后一步升级操作。<br><br><br><br><img src="/images/%E5%BF%AB%E9%80%9F%E5%8D%87%E7%BA%A7GPT4/006.png"><br><br><br> </p><p><strong>第五步： 登录 ChatGPT 网站</strong>，<a href="https://chat.openai.com/">ChatGPT 网站链接</a>，登录的账号(电子邮件)和密码就是上面第二步注册的 OpenAI 账号和密码。</p><ul><li>登录成功之后，就直接点击下方红色箭头的 Upgrade Plan</li></ul><p><img src="/images/%E5%BF%AB%E9%80%9F%E5%8D%87%E7%BA%A7GPT4/007.png"><br><br><br>  </p><ul><li>接着点击 Upgrade to Plus</li></ul><p><img src="/images/%E5%BF%AB%E9%80%9F%E5%8D%87%E7%BA%A7GPT4/008.png"></p><p><br><br> </p><ul><li>然后全选复制下图的支付链接，粘贴至相应位置，点击确定支付并升级</li></ul><p><img src="/images/%E5%BF%AB%E9%80%9F%E5%8D%87%E7%BA%A7GPT4/009.png"></p><p><strong>完成上述步骤之后，你就可以愉快的体验 ChatGPT-PLUS 呢！</strong></p><p><strong>其他问题：</strong></p><p><strong>1.是否安全？</strong></p><p>这家国内的公司是<strong>专门解决支付问题</strong>的，会使用支付宝进行实名认证，大家不用担心安全问题。<br><strong>而且，它是支持随时提现的，大家不用担心充进去多余的钱取不出来，我亲自提现过，秒提支付宝！！。</strong></p><p><img src="/images/%E5%BF%AB%E9%80%9F%E5%8D%87%E7%BA%A7GPT4/010.png"></p><p><strong>关键是！！</strong>，该卡不仅可以用来订阅 ChatGPT，一些常见的国外付费订阅软件如 Midjourney，OnlyFans 都可以使用，强烈推荐开一个~</p><h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><p>如果你还嫌麻烦或者嫌贵，你可以直接找我代充，相比通过方法一自己充优惠些，你也不需要自己操作，省事。</p><p><strong>我的联系方式： 微信号：jkfwdkf 或者 扫码加微信</strong></p><p><img src="/images/%E5%BF%AB%E9%80%9F%E5%8D%87%E7%BA%A7GPT4/011.png"></p>]]></content>
      
      
      <categories>
          
          <category> ChatGPT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ChatGPT </tag>
            
            <tag> GPT-4 </tag>
            
            <tag> OpenAI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>侯捷 C++ 视频系列合集</title>
      <link href="/stl/"/>
      <url>/stl/</url>
      
        <content type="html"><![CDATA[<h2 id="侯捷-C-视频系列合集，包括：C-面向对象高级开发、STL源码剖析、STL标准库与泛型编程、C-11、C-14、C-内存管理"><a href="#侯捷-C-视频系列合集，包括：C-面向对象高级开发、STL源码剖析、STL标准库与泛型编程、C-11、C-14、C-内存管理" class="headerlink" title="侯捷 C++ 视频系列合集，包括：C++面向对象高级开发、STL源码剖析、STL标准库与泛型编程、C++11、C++14、C++内存管理"></a>侯捷 C++ 视频系列合集，包括：C++面向对象高级开发、STL源码剖析、STL标准库与泛型编程、C++11、C++14、C++内存管理</h2><p>想要搞定C++？看侯捷老师的视频就对了。侯捷不仅是C++界的大佬，还特别会把复杂的东西讲得简单明了。他的课从C++的ABC一直讲到那些让人头大的高级话题，比如怎么用STL，C++11和C++14有哪些酷炫的新特性，还有怎么管理内存不让程序崩溃等等。</p><p>这套视频适合所有人，不管你是C++新手，还是想要提升自己的老司机。侯捷老师用他那一套能让你边学边笑的方式，让你不仅学到东西，学习的过程也会变得超有趣。</p><p>总之，如果你想提升或者巩固你的C++技能，侯捷老师的视频绝对值得一看。跟着他学，C++不再难！</p><p>我之前在网上找过侯捷老师的 C++ 视频，发现不太全，于是我最近专门找了下，找到了相对比较全的视频，以供大家学习。</p><p><strong>包括</strong> :</p><ul><li>侯捷 C++面向对象高级开发</li><li>侯捷 C++ 标准 11 -14</li><li>侯捷 STL 和 泛型编程</li><li>侯捷 C++ 内存管理</li><li>侯捷 STL 与泛型编程</li></ul><p><img src="/images/STL/STL.png"></p><p><br><br> </p><blockquote><p>在这里分享给大家，我放在公众号后台了，大家可以扫下方二维码关注「<strong>跟着小康学编程</strong>」公众号，后台回复「<strong>STL</strong>」，即可获取。</p></blockquote><p><br><br> </p><p><img src="/images/STL/xkvxgzh.png"></p><p><br><br> </p><p><img src="/images/STL/gzh.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程视频合集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL 源码视频 </tag>
            
            <tag> 侯捷 C++ 视频合集 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
