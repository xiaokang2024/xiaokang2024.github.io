<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>如何快速掌握 C++：从新手到高手的学习指南</title>
      <link href="/how-to-learn-C++/"/>
      <url>/how-to-learn-C++/</url>
      
        <content type="html"><![CDATA[<p>大家好，我是小康，今天我们来聊下如何快速学习 C++ 语言。</p><p>本篇文章适合于有 C 语言编程基础的小伙伴们，如果还没有学习过 C，请看这篇文章先入个门：<a href="https://mp.weixin.qq.com/s?__biz=MzkyNjQyMTMyOA==&mid=2247487373&idx=1&sn=6304025e2c0a846e97999e765667d866&chksm=c236d7b2f5415ea4b12b87fddf981abcd325d7458885aeade0957db5344da97f1b82d7e65cce&token=733890015&lang=zh_CN#rd">C语言快速入门</a></p><h3 id="引言："><a href="#引言：" class="headerlink" title="引言："></a>引言：</h3><p>C++，作为一门集面向过程和面向对象编程于一体的强大语言，既保留了 C 语言的高效性，又引入了类、继承、多态、模板等现代编程概念，是学习计算机编程不可或缺的一环。本文旨在为初学者提供一个<strong>清晰的 C++ 学习路径</strong>，帮助你快速入门并掌握这门语言。</p><p>大家可以先浏览下本篇文章要讲解的 C++ 知识图谱：</p><p><img src="/images/C++%E8%AF%AD%E8%A8%80/1.png"></p><p>C++的基础语法我就不讲解了，包括<code>变量和常量的定义</code>、<code>标识符和关键字</code>、<code>语句</code>等，这些和 C 的一样，如果你还没有学习过 C 语言，可以看我之前的文章：「如何快速学习 C 语言 ？」</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>C++的基本数据类型包括  <code>字符型</code>、<code>整型</code>、<code>浮点型和布尔型</code>。</p><p><strong>字符型</strong> (char)：用于存储单个字符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> letter = <span class="string">&#x27;A&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>整型</strong> (int, short, long, long long)：用于存储整数, 以及它们的 unsigned 变体(unsigned int, unsigned short,unsigned long,unsigned long long)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> age = <span class="number">30</span>;</span><br><span class="line"><span class="type">long</span> var = <span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> bigInt = <span class="number">1000000</span>;</span><br></pre></td></tr></table></figure><p><strong>浮点型</strong> (float, double)：用于存储小数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> temperature = <span class="number">36.6</span>;</span><br><span class="line"><span class="type">double</span> distance = <span class="number">384400.0</span>; <span class="comment">// 从地球到月亮的距离，单位千米</span></span><br></pre></td></tr></table></figure><p><strong>布尔型</strong> (bool)：用于存储真（true）或假（false）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> isRainy = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><h3 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h3><p>枚举类型允许定义一个变量，它可以在几个预定义的值之间进行选择。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span> &#123;</span> RED, GREEN, BLUE &#125;;</span><br><span class="line">Color my_color = RED;</span><br></pre></td></tr></table></figure><h3 id="复合数据类型"><a href="#复合数据类型" class="headerlink" title="复合数据类型"></a>复合数据类型</h3><p>复合数据类型（也称为复杂数据类型）允许你将多个不同类型的数据项组合成一个单一的实体。这种类型的典型代表是<code>结构体</code>（struct）、<code>共用体</code>（union）和<code>类</code>（class）。</p><h4 id="结构体-struct"><a href="#结构体-struct" class="headerlink" title="结构体 (struct)"></a>结构体 (struct)</h4><p>结构体允许将多个不同类型的数据项组合成一个单一的复合类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义结构体类型</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义结构体类型变量并初始化</span></span><br><span class="line">Person person = &#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>&#125;;</span><br></pre></td></tr></table></figure><h4 id="联合体（union）"><a href="#联合体（union）" class="headerlink" title="联合体（union）"></a>联合体（union）</h4><p>联合体是一个用于优化内存使用的特殊数据类型，允许在同一内存位置存储不同的数据类型，但任一时刻只能使用其中一个成员。联合体变量使用关键字 <strong>union</strong> 来定义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Data</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">float</span> f;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Data</span> <span class="title">data</span>;</span></span><br></pre></td></tr></table></figure><h4 id="类-class"><a href="#类-class" class="headerlink" title="类 (class)"></a>类 (class)</h4><p>类是C++的核心，是支持面向对象编程的基础。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义 Book 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> title;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> author;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">read</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Reading &quot;</span> &lt;&lt; title &lt;&lt; <span class="string">&quot; by &quot;</span> &lt;&lt; author &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 定义 book 对象</span></span><br><span class="line">Book book = &#123;<span class="string">&quot;The C++ Programming Language&quot;</span>, <span class="string">&quot;Bjarne Stroustrup&quot;</span>&#125;;</span><br><span class="line"><span class="comment">// 调用 book 对象的 read 方法</span></span><br><span class="line">book.read();</span><br></pre></td></tr></table></figure><p>看不懂代码没关系，这里只需要了解 <code>类</code> 是 C++ 的一种特有数据类型。关于类的讲解下文会提及。</p><h3 id="派生数据类型"><a href="#派生数据类型" class="headerlink" title="派生数据类型"></a>派生数据类型</h3><p>派生数据类型是通过对已有的数据类型（基本类型、复合类型）进行某种形式的“扩展”或“派生”而得到的。典型的派生数据类型包括数组和指针。</p><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>数组用来存储固定大小的相同类型元素序列。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> numbers[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure><h4 id="指针："><a href="#指针：" class="headerlink" title="指针："></a>指针：</h4><p>指针用来存储变量的内存地址。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> var = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* ptr = &amp;var;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Value of var: &quot;</span> &lt;&lt; *ptr &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>这里我只简单提下。在上一篇文章<a href="https://mp.weixin.qq.com/s?__biz=MzkyNjQyMTMyOA==&mid=2247487373&idx=1&sn=6304025e2c0a846e97999e765667d866&chksm=c236d7b2f5415ea4b12b87fddf981abcd325d7458885aeade0957db5344da97f1b82d7e65cce&token=733890015&lang=zh_CN#rd">C语言快速入门</a><br>中关于数组和指针有过详细的讲解，不太了解的可以去看那片文章。C++ 的数组和指针和C的用法一样。只不过 C++ 多了一种比较特殊的类型-引用。</p><h4 id="引用："><a href="#引用：" class="headerlink" title="引用："></a>引用：</h4><p>C++中的引用是一种给已存在的变量起一个新名字（或别名）的机制。一旦一个引用被初始化为指向一个变量，它就一直指向那个变量：你对引用所做的任何操作都会影响到原始变量。</p><h5 id="引用的基本用法："><a href="#引用的基本用法：" class="headerlink" title="引用的基本用法："></a>引用的基本用法：</h5><p>引用在定义时必须被初始化，并且一旦被绑定到一个变量上，就不能再绑定到另一个变量上。引用的语法是在变量类型后面加上 <strong>&amp;</strong> 符号。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp; refA = a; <span class="comment">// refA是变量a的引用</span></span><br></pre></td></tr></table></figure><h5 id="引用的特性："><a href="#引用的特性：" class="headerlink" title="引用的特性："></a>引用的特性：</h5><ul><li>引用必须在定义时被初始化，并且一旦被初始化绑定到一个变量，就不能再指向其他变量。</li><li>引用不占用任何内存空间（引用只是变量的一个别名）。</li><li>不存在null引用。引用必须连接到一块合法的内存。</li></ul><h5 id="引用的用途："><a href="#引用的用途：" class="headerlink" title="引用的用途："></a>引用的用途：</h5><p>引用主要用于以下几个方面：</p><p><strong>1. 函数参数传递</strong>：通过传递引用给函数，可以让函数直接修改外部变量的值，而不是拷贝其值。这样做可以提高效率（尤其是对于大型对象）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过使用引用作为函数参数，可以使得函数能够修改调用者提供的参数。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">increment</span><span class="params">(<span class="type">int</span>&amp; value)</span> &#123;</span><br><span class="line">    value += <span class="number">1</span>; <span class="comment">// 直接修改传入的参数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line">    increment(x); <span class="comment">// x被修改为6</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;x after increment: &quot;</span> &lt;&lt; x &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 C++ 中，函数参数传递时，参数是类对象比较常见。</p><p><strong>2. 函数返回值</strong>：函数可以返回一个引用，从而允许对函数返回值直接赋值。这在操作重载运算符时尤其有用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="type">int</span> myNumber = <span class="number">10</span>; <span class="comment">// 全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回全局变量myNumber的引用</span></span><br><span class="line"><span class="type">int</span>&amp; <span class="title function_">getMyNumberRef</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> myNumber;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Original myNumber: &quot;</span> &lt;&lt; myNumber &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: 10</span></span><br><span class="line">    <span class="comment">// 通过函数返回的引用直接修改myNumber的值</span></span><br><span class="line">    getMyNumberRef() = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Modified myNumber: &quot;</span> &lt;&lt; myNumber &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: 20</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对于拷贝代价较大的对象（比如大型的类实例），通过引用传递或返回可以避免拷贝，提高程序效率。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>C++ 中的函数是一组一起执行一个任务的语句。函数允许你定义一次代码块并多次调用它，这有助于代码的重用和模块化。</p><h3 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h3><p>一个 C++ 函数定义包括以下几个主要部分：</p><ul><li><strong>返回类型</strong>：函数可以返回一个值。返回类型是函数返回值的数据类型。如果函数不返回值，则使用void类型。</li><li><strong>函数名称</strong>：标识函数的唯一名称。</li><li><strong>参数列表</strong>：括号内的参数，用于从函数调用者向函数传递信息。如果函数不接受任何参数，则括号为空。</li><li><strong>函数体</strong>：大括号内的一系列语句，定义了函数的执行任务。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数定义示例</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="函数声明（函数原型）"><a href="#函数声明（函数原型）" class="headerlink" title="函数声明（函数原型）"></a>函数声明（函数原型）</h3><p>为了在定义函数之前调用函数，你需要在调用点之前声明函数原型。函数声明（或称为函数原型）仅需要指定函数返回类型、函数名和参数类型，不需要函数体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>; <span class="comment">// 函数声明</span></span><br></pre></td></tr></table></figure><h3 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3><p>定义函数后，你可以通过提供函数名和所需的参数（如果有的话）来调用函数。</p><h4 id="函数调用方式"><a href="#函数调用方式" class="headerlink" title="函数调用方式"></a>函数调用方式</h4><p><strong>函数名(参数1，参数2，…)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> result = add(<span class="number">5</span>, <span class="number">3</span>); <span class="comment">// 函数调用</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出：Result: 8</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>C++支持几种参数传递方式：</p><ul><li><strong>按值传递</strong>：调用函数时，实参的值被拷贝给形参。在函数内对形参的修改不会影响实参。</li><li><strong>按引用传递</strong>：允许函数修改调用者的变量。这通过将形参定义为引用类型实现。</li><li><strong>按指针传递</strong>：意味着将变量地址作为参数传递给函数，函数通过这个指针直接访问和修改原始变量的值。</li></ul><h4 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// 按值传递</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">byValue</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">    value = <span class="number">10</span>; <span class="comment">// 只修改形参的值，对实参无影响</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 按引用传递</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">byReference</span><span class="params">(<span class="type">int</span>&amp; value)</span> &#123;</span><br><span class="line">    value = <span class="number">20</span>; <span class="comment">// 修改了实参的值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 按指针传递</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">byPointer</span><span class="params">(<span class="type">int</span>* value)</span> &#123;</span><br><span class="line">    *value = <span class="number">30</span>; <span class="comment">// 通过解引用修改了实参的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">1</span>, c = <span class="number">1</span>;</span><br><span class="line">    byValue(a);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After byValue: &quot;</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 1</span></span><br><span class="line">    byReference(b);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After byReference: &quot;</span> &lt;&lt; b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 20 </span></span><br><span class="line">    byPointer(&amp;c);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After byPointer: &quot;</span> &lt;&lt; c &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 30</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>C++中的函数重载（Function Overloading）是指允许在同一作用域内声明多个具有相同名称的函数，只要它们的参数列表（参数的类型、数量或顺序）不同即可。编译器根据函数调用时提供的参数类型和数量来决定具体调用哪个函数。</p><h4 id="代码示例：-1"><a href="#代码示例：-1" class="headerlink" title="代码示例："></a>代码示例：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下两个 print 函数构成重载</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Printing int: &quot;</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">double</span> f)</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Printing float: &quot;</span> &lt;&lt; f &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  print(<span class="number">10</span>);</span><br><span class="line">  print(<span class="number">10.5</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="特殊函数"><a href="#特殊函数" class="headerlink" title="特殊函数"></a>特殊函数</h3><h4 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h4><p>在 C++ 的类中定义的函数称为成员函数（Member Functions）。成员函数可以访问类的私有（private）、保护（protected）和公有（public）成员。</p><p>代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">myFunction</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 成员函数实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="常量成员函数"><a href="#常量成员函数" class="headerlink" title="常量成员函数"></a>常量成员函数</h4><p>常量成员函数是 C++ 中的一种特殊的成员函数，它保证在函数执行过程中<strong>不会修改对象的任何成员变量</strong>。这种函数通过在成员函数声明的末尾添加 <strong>const</strong> 关键字来定义。常量成员函数可以被任何类型的对象调用，包括常量对象。</p><p>在类的实现中，常量成员函数对类内部的状态（成员变量）只能进行只读操作，不能进行修改。这为类的使用提供了额外的安全保证，确保了不会意外改变对象状态的函数逻辑。</p><p>代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义 MyClass 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">private:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">public:</span><br><span class="line">    MyClass(<span class="type">int</span> v) : value(v) &#123;&#125; <span class="comment">// 构造函数，初始化value</span></span><br><span class="line">    <span class="comment">// 常量成员函数声明，使用const关键字</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span> <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value; <span class="comment">// 这里只是返回成员变量的值，不会修改它</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 尝试在常量成员函数中修改成员变量将导致编译错误</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">tryToModify</span><span class="params">()</span> <span class="type">const</span> &#123;</span><br><span class="line">        <span class="comment">// value = 100; // 错误：不能在常量成员函数中修改成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    MyClass <span class="title function_">obj</span><span class="params">(<span class="number">42</span>)</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The value is: &quot;</span> &lt;&lt; obj.getValue() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出：The value is: 42</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> MyClass <span class="title function_">constObj</span><span class="params">(<span class="number">55</span>)</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The value is: &quot;</span> &lt;&lt; constObj.getValue() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出：The value is: 55</span></span><br><span class="line">    <span class="comment">// constObj.tryToModify(); // 错误：不能在常量对象上调用非常量成员函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码看不懂不要紧，这里只要了解常量成员函数的基本概念，以及如何声明即可。看完下文类和对象的讲解，再回过头来看代码就可以理解。</p><h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><p>C++的面向对象编程（OOP）是一种编程范式，它使用“对象”来设计软件。对象可以包含数据（称为属性或成员变量）和代码（称为方法或成员函数）。C++的 OOP 建立在几个核心概念之上：类、封装、继承、多态。让我们一一详细讲解这些知识点。</p><h3 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h3><h4 id="类的定义："><a href="#类的定义：" class="headerlink" title="类的定义："></a>类的定义：</h4><p>类是创建对象的蓝图。它定义了对象的属性（成员变量）和行为（成员函数或方法），在C++中，使用关键字<code>class</code> 来定义类。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义 MyClass 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="成员的访问权限："><a href="#成员的访问权限：" class="headerlink" title="成员的访问权限："></a>成员的访问权限：</h4><p>在C++中，类的成员（包括变量和函数）可以具有三种不同的访问权限：<code>public</code>、<code>private</code>和<code>protected</code>。这些访问权限控制了类外部的代码对类成员的访问级别，从而实现了封装和数据隐藏。</p><ul><li><p><strong>public</strong>（公有成员）：可以被任何其他代码访问，无论是类的内部还是外部。如果类的成员声明为public，那么在类的实例化对象外部也可以直接访问这些成员。</p></li><li><p><strong>private</strong>（私有成员）：只能被该类的成员函数、友元函数和该类的其他实例访问。如果类的成员声明为private，那么这些成员只能在类的内部被访问。这是默认的访问级别，如果没有指定访问权限，则成员默认为private。</p></li><li><p><strong>protected</strong>（受保护成员）：可以被该类的成员函数、友元函数、该类的派生类中的成员访问。如果类的成员声明为protected，那么这些成员既可以在类的内部被访问，也可以在派生类中被访问，但不能直接通过类的实例在类的外部被访问。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> publicVar;  <span class="comment">// 公有成员变量，任何地方都可访问</span></span><br><span class="line">protected:</span><br><span class="line">    <span class="type">int</span> protectedVar;  <span class="comment">// 受保护成员变量，类内部和派生类可访问</span></span><br><span class="line">private:</span><br><span class="line">    <span class="type">int</span> privateVar;  <span class="comment">// 私有成员变量，仅类内部可访问</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">void</span> <span class="title function_">privateMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 私有成员函数，仅类内部可访问</span></span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">publicMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 公有成员函数，任何地方都可访问</span></span><br><span class="line">        privateVar = <span class="number">0</span>; <span class="comment">// 可以访问私有成员</span></span><br><span class="line">        privateMethod(); <span class="comment">// 可以调用私有成员函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="成员访问权限有什么用？"><a href="#成员访问权限有什么用？" class="headerlink" title="成员访问权限有什么用？"></a>成员访问权限有什么用？</h4><ul><li><strong>封装</strong>：通过将成员设为私有或受保护，类可以隐藏其实现细节，仅通过公有接口与外界交互。这样做可以在不影响外部代码的情况下自由修改类的内部实现。</li><li><strong>维护性</strong>：限制对成员的访问可以减少因错误使用类成员而产生的bug，使得代码更加可维护。</li><li><strong>扩展性</strong>：合理使用访问权限可以在不破坏原有类的基础上进行扩展，增加新的功能。</li></ul><h4 id="成员变量和成员函数"><a href="#成员变量和成员函数" class="headerlink" title="成员变量和成员函数"></a>成员变量和成员函数</h4><p>类中定义的变量称为成员变量，类中定义的函数称为成员函数。它们定义了类的属性和行为。</p><p>成员变量初始化有以下两种方式：</p><p><strong>1. 构造函数初始化列表</strong>：使用构造函数的初始化列表直接初始化成员变量，这是最常用且推荐的初始化成员变量的方式，特别是对于常量成员和引用成员。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> &#123;</span></span><br><span class="line">private:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">public:</span><br><span class="line">    Example(<span class="type">int</span> d) : data(d) &#123;&#125; <span class="comment">// 构造函数初始化列表</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>2. 在构造函数体内赋值</strong>：在函数体内对成员进行初始化。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> &#123;</span></span><br><span class="line">private:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">public:</span><br><span class="line">    Example(<span class="type">int</span> d) &#123;</span><br><span class="line">        data = d; <span class="comment">// 在构造函数体内赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h4><p><strong>构造函数</strong>：构造函数的名称与类名相同，可以有参数，也可以重载（即定义多个构造函数，每个构造函数有不同的参数列表）。如果你不提供任何构造函数，C++编译器会自动生成一个默认的无参构造函数。</p><p>构造函数在创建对象时自动调用，用于初始化对象。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    Car() &#123; <span class="comment">// 默认构造函数</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Car object created.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Car(<span class="built_in">string</span> brand) &#123; <span class="comment">// 带有参数的构造函数</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; brand &lt;&lt; <span class="string">&quot; car object created.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>析构函数</strong>：析构函数的名称是类名前加上波浪符号<code>~</code>，它不能带参数，因此一个类只能有一个析构函数。析构函数用于执行对象销毁前的清理工作，比如释放分配的资源等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    ~Car() &#123; <span class="comment">// 析构函数</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Car object destroyed.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过合理定义和使用构造函数和析构函数，我们可以确保对象在创建和销毁时维持合理的状态，以及有效地管理资源。</p><p>一个简单的 Car 类定义示例：</p><p>该 Car 类包含构造函数和析构函数，成员变量和成员函数等基本成员。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义 Car 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">string</span> brand;  <span class="comment">// 汽车的品牌</span></span><br><span class="line">    <span class="comment">// 构造函数，使用初始化列表来初始化成员变量。</span></span><br><span class="line">    Car(<span class="built_in">string</span> b) : brand(b) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; brand &lt;&lt; <span class="string">&quot; car is created.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~Car() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; brand &lt;&lt; <span class="string">&quot; car is destroyed.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 成员函数</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">drive</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Driving &quot;</span> &lt;&lt; brand &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Car <span class="title function_">myCar</span><span class="params">(<span class="string">&quot;Ford&quot;</span>)</span>;  <span class="comment">// 创建一个Car对象，品牌为&quot;Ford&quot;</span></span><br><span class="line">    myCar.drive();      <span class="comment">// 调用drive成员函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="对象的创建："><a href="#对象的创建：" class="headerlink" title="对象的创建："></a>对象的创建：</h4><p>对象是类的实例。通过类，我们可以创建对象，并使用其属性和方法。对象可以通过成员访问运算符<code>.</code>访问其成员变量和成员函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Car <span class="title function_">myCar</span><span class="params">(<span class="string">&quot;Ford&quot;</span>)</span>; <span class="comment">// 福特汽车</span></span><br><span class="line">myCar.drive();     <span class="comment">// 访问 myCar 对象的成员方法</span></span><br></pre></td></tr></table></figure><h4 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h4><p>在C++中，this指针是一个特殊的指针，它指向当前对象。每个非静态成员函数（包括构造函数、析构函数以及其他成员函数）都有一个this指针作为其隐式参数，这使得成员函数能够访问调用它的对象的成员。this指针在成员函数内部使用，特别是在需要引用调用函数的当前对象时。</p><p>当我们在类的成员函数中需要引用对象本身时，就会用到this指针。这在以下几种情况中尤其有用：</p><ul><li>当参数名称与成员变量名称相同时，用以区分成员变量和参数。</li><li>在实现链式调用时返回对象的引用。</li><li>当需要返回对象本身的指针时。</li></ul><p>示例代码：</p><p><strong>1. 区分成员变量和参数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> width;</span><br><span class="line">    Box(<span class="type">int</span> width) &#123;</span><br><span class="line">        <span class="comment">// 使用this指针区分成员变量和构造函数参数</span></span><br><span class="line">        this-&gt;width = width;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">displayWidth</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Width: &quot;</span> &lt;&lt; width &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 直接访问width，实际上是this-&gt;width</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个例子中，构造函数的参数width与类的成员变量width同名。通过使用this-&gt;width，我们明确指出了左边的width是对象的成员变量，而不是参数。</p><p><strong>2. 实现链式调用</strong></p><p>链式调用是一种编程风格，通过在成员函数末尾返回对象本身，可以连续调用多个成员函数。</p><p>示例代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span> &#123;</span></span><br><span class="line">private:</span><br><span class="line">    <span class="type">int</span> width;</span><br><span class="line">public:</span><br><span class="line">    Box&amp; <span class="title function_">setWidth</span><span class="params">(<span class="type">int</span> width)</span> &#123;</span><br><span class="line">        this-&gt;width = width;</span><br><span class="line">        <span class="keyword">return</span> *this;  <span class="comment">// 返回当前对象的引用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">displayWidth</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Width: &quot;</span> &lt;&lt; width &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Box box;</span><br><span class="line">    box.setWidth(<span class="number">10</span>).displayWidth();  <span class="comment">// 链式调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在setWidth函数中，返回*this允许链式调用，即连续调用对象的成员函数。</p><p><strong>3. 返回对象本身的指针</strong></p><p>有时候，我们可能需要在成员函数中返回指向当前对象的指针。</p><p>示例代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    Box* <span class="title function_">getPointer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> this;  <span class="comment">// 返回指向当前对象的指针</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在getPointer函数中，通过返回this，我们得到了一个指向当前对象的指针。</p><p>this指针是 C++ 中一个强大的工具，它提供了一个自引用的机制。通过 this 指针，类的成员函数可以访问调用它们的对象的其他成员。理解 this 指针对于深入学习C++面向对象编程非常重要。</p><p><strong>而理解 this 指针，关键是要了解它的底层原理</strong>：</p><p>在C++中，this指针的底层实现其实非常直观。当一个非静态成员函数被调用时，编译器隐式地将当前对象的地址作为一个参数传递给函数。这个隐式参数就是this指针。因此，每个非静态成员函数在内部都有一个名为this的额外参数，指向调用该函数的对象。</p><h5 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h5><ul><li><p>对于一个类<code>ClassType</code>中的非静态成员函数<code>memberFunction</code>，调用形式<code>object.memberFunction(args...)</code>,实际上在底层被编译器处理为<code>ClassType::memberFunction(&amp;object, args...)</code>，其中<code>&amp;object</code>就是<code>this指针</code>。</p></li><li><p>因此，即使你在成员函数定义中没有显式地看到<code>this</code>参数，编译器仍然按照每个非静态成员函数都有一个类型为<code>ClassType*</code>的<code>this指针</code>作为其第一个参数的方式来处理。</p></li></ul><p>考虑以下类定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">myFunction</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Value of a: &quot;</span> &lt;&lt; this-&gt;a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当你创建一个MyClass对象并调用其成员函数myFunction时：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyClass obj;</span><br><span class="line">obj.a = <span class="number">10</span>;</span><br><span class="line">obj.myFunction();</span><br></pre></td></tr></table></figure><p>在调用 obj.myFunction() 时，实际上编译器在底层将其转换为类似以下形式的调用（这是一种简化的表达，实际转换会依赖于具体的编译器）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyClass::myFunction(&amp;obj);</span><br></pre></td></tr></table></figure><p>这里，&amp;obj 是对象 obj 的地址，它被隐式地作为 this 指针传递给 myFunction。所以，在 myFunction 内部，当你访问 this-&gt;a 时，实际上就是通过 obj 的地址来访问它的成员变量 a。</p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>封装在 C++ 面向对象编程中是一种将数据（属性）和行为（方法）捆绑在一起的机制，同时对外隐藏内部实现的细节，仅通过定义好的接口与外界交互。</p><p><strong>简单来说</strong>:封装实质上是关于数据隐藏和接口暴露的。在定义一个类时，你会将某些数据成员标记为 private，这意味着它们只能被类的内部成员函数访问，对类的使用者来说，这些细节被隐藏了。然而，你也会提供public的成员函数作为操作这些数据的接口，这样类的使用者可以在不知道内部实现细节的情况下，通过这些接口来操作对象。</p><h4 id="封装的实现"><a href="#封装的实现" class="headerlink" title="封装的实现"></a>封装的实现</h4><p>在C++中，封装通过<strong>类</strong>实现，类中可以定义三种类型的成员：public（公有成员）、private（私有成员）和protected（受保护成员）。这些访问修饰符定义了成员的访问范围：</p><ul><li><strong>private</strong> 成员只能由同一类的成员函数访问。</li><li><strong>public</strong> 成员可以由任何可以访问类对象的代码访问。</li><li><strong>protected</strong> 成员可以被基类和派生类中的成员函数访问。</li></ul><p>通过精心设计公有接口，类的设计者可以控制外部代码对内部数据的访问方式，保护对象的状态不被非法操作破坏。</p><h4 id="封装的优势"><a href="#封装的优势" class="headerlink" title="封装的优势"></a>封装的优势</h4><ul><li><strong>数据安全</strong>：通过隐藏内部实现细节，减少了外部对内部数据的直接访问，降低了数据被误用或误修改的风险。</li><li><strong>接口清晰</strong>：用户只需关注类提供的公有接口，不必深究类的内部实现，使得类更加易于使用和理解。</li><li><strong>易于维护和扩展</strong>：类的内部实现可以自由修改，只要公有接口保持不变，就不会影响到使用该类的代码，提高了代码的可维护性和扩展性。</li></ul><p><strong>一个体现 C++ 封装的类的实现</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">private:</span><br><span class="line">    <span class="built_in">string</span> name;  <span class="comment">// 私有成员变量，存储人的姓名</span></span><br><span class="line">    <span class="type">int</span> age;      <span class="comment">// 私有成员变量，存储人的年龄</span></span><br><span class="line">public:</span><br><span class="line">    <span class="comment">// 构造函数，初始化姓名和年龄，使用初始化列表来初始化成员变量。</span></span><br><span class="line">    Person(<span class="built_in">string</span> n, <span class="type">int</span> a) : name(n), age(a) &#123;&#125;</span><br><span class="line">    <span class="comment">// 公有成员函数，设置姓名</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">setName</span><span class="params">(<span class="built_in">string</span> n)</span> &#123;</span><br><span class="line">        name = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 公有成员函数，获取姓名</span></span><br><span class="line">    <span class="built_in">string</span> <span class="title function_">getName</span><span class="params">()</span> <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 公有成员函数，设置年龄</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(a &gt;= <span class="number">0</span>) &#123; <span class="comment">// 确保年龄是非负数</span></span><br><span class="line">            age = a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 公有成员函数，获取年龄</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 成员函数，打印Person信息</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">printInfo</span><span class="params">()</span> <span class="type">const</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;, Age: &quot;</span> &lt;&lt; age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Person <span class="title function_">person</span><span class="params">(<span class="string">&quot;John Doe&quot;</span>, <span class="number">30</span>)</span>; <span class="comment">// 创建Person对象</span></span><br><span class="line">    person.printInfo(); <span class="comment">// 打印信息</span></span><br><span class="line">    <span class="comment">// 尝试修改Person的姓名和年龄</span></span><br><span class="line">    person.setName(<span class="string">&quot;Jane Doe&quot;</span>);</span><br><span class="line">    person.setAge(<span class="number">25</span>);</span><br><span class="line">    <span class="comment">// 再次打印修改后的信息</span></span><br><span class="line">    person.printInfo(); <span class="comment">// 打印信息</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h4 id="继承的定义"><a href="#继承的定义" class="headerlink" title="继承的定义"></a>继承的定义</h4><p>继承允许新的类（派生类）继承现有类（基类）的属性和方法。它支持代码重用，并建立了类之间的层次关系。</p><h4 id="继承的分类"><a href="#继承的分类" class="headerlink" title="继承的分类"></a>继承的分类</h4><h5 id="单一继承"><a href="#单一继承" class="headerlink" title="单一继承"></a>单一继承</h5><p>在单一继承中，一个派生类只继承自一个基类。这意味着派生类包含了基类的所有属性和方法，同时还可以添加自己的属性和方法，或者重写基类的方法。</p><p><strong>定义方式</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseClass</span> &#123;</span></span><br><span class="line">    <span class="comment">// 基类的成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedClass</span> :</span> public BaseClass &#123;</span><br><span class="line">    <span class="comment">// 派生类的成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里，DerivedClass 是通过单一继承从 BaseClass派生而来的。</p><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Eating.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span> public Animal &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">bark</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Barking.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Dog myDog;</span><br><span class="line">    myDog.eat(); <span class="comment">// 调用基类的方法</span></span><br><span class="line">    myDog.bark(); <span class="comment">// 调用派生类的方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h5><p>多重继承允许一个派生类同时从多个基类继承属性和方法。这种方式增加了灵活性，但也可能引入复杂性，例如需要处理潜在的命名冲突，以及著名的“菱形问题”。</p><p><strong>定义方式</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseClass1</span> &#123;</span></span><br><span class="line">    <span class="comment">// 基类1的成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseClass2</span> &#123;</span></span><br><span class="line">    <span class="comment">// 基类2的成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedClass</span> :</span> public BaseClass1, public BaseClass2 &#123;</span><br><span class="line">    <span class="comment">// 派生类的成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个例子中，DerivedClass 同时从 BaseClass1 和BaseClass2 继承，成为它们的派生类。</p><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Eating.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 第二个基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Flying.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类(麻雀)，继承自Animal和Bird</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sparrow</span> :</span> public Animal, public Bird &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="comment">//发出声音，模拟麻雀叫声</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">chirp</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Chirping.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Sparrow mySparrow;</span><br><span class="line">    mySparrow.eat(); <span class="comment">// 调用Animal基类的方法</span></span><br><span class="line">    mySparrow.fly(); <span class="comment">// 调用Bird基类的方法</span></span><br><span class="line">    mySparrow.chirp(); <span class="comment">// 调用派生类的方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多重继承允许一个派生类同时继承自多个基类。这是C++提供的一种强大功能，它可以让派生类继承并实现多个基类定义的接口和属性。然而，在使用多重继承时，我们可能会遇到一种特殊情况：菱形继承（也称为钻石继承）问题。</p><p><strong>菱形继承</strong></p><p>假设有这样一个场景：我们有一个基类A，然后有两个类B和C分别继承自A，最后有一个类D同时继承自B和C。这样构成的继承结构形状像一个菱形，因此称为菱形继承。如下图：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">     A</span><br><span class="line">    / \</span><br><span class="line">   B   C</span><br><span class="line">    \ /</span><br><span class="line">     D</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对应的代码示例：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> public A &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> public A &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> public B, public C &#123;</span><br><span class="line">    <span class="comment">// D通过B和C继承了A，可能会导致A的成员在D中存在多份拷贝</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>菱形继承引入的问题是D通过B和C继承了两份A的成员，这导致了数据冗余和不一致性的风险。特别是当试图访问从A继承来的成员时，编译器会因为不知道应该通过B还是C的路径去访问而产生歧义。</p><p><strong>解决菱形继承问题</strong></p><p>C++中通过引入虚继承来解决菱形继承问题。在菱形继承的结构中，将B和C对A的继承声明为虚继承（使用<code>virtual</code>关键字），可以确保D中只有一份A的成员副本。</p><p>这样，无论是通过B还是C，访问到的都是同一份来自A的成员，解决了成员访问歧义的问题，并且保证了数据的一致性。</p><p><strong>虚继承的声明方式</strong>：</p><p>通过在派生类中使用 <strong>virtual</strong> 关键字进行继承。</p><p>使用虚继承来解决菱形继承问题示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// B和C虚继承A</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> virtual public A &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> virtual public A &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// D继承自B和C</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> public B, public C &#123;&#125;;</span><br></pre></td></tr></table></figure><p>在这个例子中，通过将 B 和 C 对 A 的继承声明为虚继承，我们确保了在 D 中只有一份来自 A 的成员 value，无论是通过 B 还是 C 的路径访问 value，访问到的都是相同的成员。</p><h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><p>在C++中，友元（Friend）是一个允许某些外部函数或类访问另一个类的私有（private）和保护（protected）成员的特性。友元关系不受类之间的公有（public）、私有（private）和保护（protected）访问控制的约束，这使得某些特定的函数或类可以直接访问类的内部成员。</p><p>友元机制可以增强程序的灵活性，但同时也可能破坏对象的封装性。</p><p>友元可以是：</p><ul><li>友元函数</li><li>友元类</li><li>友元成员函数</li></ul><h4 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h4><p>友元函数在C++中是一种特殊的函数，它虽然不是类的成员函数，但能够访问类的私有（private）和保护（protected）成员。这允许全局函数访问类的私有成员。</p><p>友元函数的定义包含两个主要步骤：</p><ul><li><p><strong>在类内声明友元函数</strong>：你需要在类定义内部使用 <code>friend</code> 关键字声明该函数为友元，这告诉编译器这个特定的函数可以访问类的私有和保护成员。</p></li><li><p><strong>定义友元函数</strong>：友元函数的定义与普通函数相同，但需要注意的是，友元函数本身不是类的成员函数，因此它不能通过对象或指针来调用，而是像普通函数那样直接调用。</p></li></ul><p>代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">private:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">public:</span><br><span class="line">    MyClass(<span class="type">int</span> val) : value(val) &#123;&#125; <span class="comment">// 构造函数初始化value</span></span><br><span class="line">    <span class="comment">// 声明友元函数</span></span><br><span class="line">    friend <span class="type">void</span> <span class="title function_">friendFunction</span><span class="params">(MyClass&amp; obj)</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 定义友元函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">friendFunction</span><span class="params">(MyClass&amp; obj)</span> &#123;</span><br><span class="line">    <span class="comment">// 友元函数可以访问MyClass的私有成员value</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Accessing private member value: &quot;</span> &lt;&lt; obj.value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    MyClass <span class="title function_">myObj</span><span class="params">(<span class="number">100</span>)</span>;</span><br><span class="line">    <span class="comment">// 调用友元函数，并访问MyClass对象的私有数据</span></span><br><span class="line">    friendFunction(myObj); <span class="comment">// 输出: Accessing private member value: 100</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h4><p>当一个类被声明为另一个类的友元时，这个友元类的所有成员函数都可以访问另一个类的私有和保护成员。</p><p>示例代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span> &#123;</span></span><br><span class="line">    <span class="type">double</span> width;</span><br><span class="line">public:</span><br><span class="line">    Box(<span class="type">double</span> wid) : width(wid) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    friend <span class="class"><span class="keyword">class</span> <span class="title">Printer</span>;</span> <span class="comment">// 声明Printer为友元类</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Printer</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">printWidth</span><span class="params">(Box box)</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Width of box : &quot;</span> &lt;&lt; box.width &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Box <span class="title function_">box</span><span class="params">(<span class="number">10.0</span>)</span>;</span><br><span class="line">    Printer printer;</span><br><span class="line">    printer.printWidth(box);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子中，Printer 类是 Box 类的友元，因此 Printer 的成员函数 printWidth可以访问 Box 的私有成员 width。</p><h4 id="友元成员函数"><a href="#友元成员函数" class="headerlink" title="友元成员函数"></a>友元成员函数</h4><p>一个类的成员函数可以被声明为另一个类的友元。</p><p>示例代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span> &#123;</span></span><br><span class="line">    <span class="type">double</span> width;</span><br><span class="line">public:</span><br><span class="line">    Box(<span class="type">double</span> wid) : width(wid) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    friend <span class="type">void</span> <span class="title function_">Printer::printWidth</span><span class="params">(Box box)</span>; <span class="comment">// 前向声明</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Printer</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">printWidth</span><span class="params">(Box box)</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Width of box : &quot;</span> &lt;&lt; box.width &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Box <span class="title function_">box</span><span class="params">(<span class="number">10.0</span>)</span>;</span><br><span class="line">    Printer printer;</span><br><span class="line">    printer.printWidth(box); <span class="comment">// 使用Printer对象打印Box的宽度</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，Printer类的成员函数printWidth是Box类的友元，因此它可以访问Box的私有成员width。</p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>使用友元时应谨慎，因为它破坏了类的封装性。一个设计良好的类应该尽量隐藏其实现细节，只通过公共接口与外界交互。</li><li>友元关系不能被继承。</li><li>友元关系是单向的，即如果类A是类B的友元，类B不一定是类A的友元。</li></ul><h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><p>运算符重载是 C++ 中一个非常强大的特性，它允许开发者为自定义类型指定运算符操作的行为。这样，我们就可以对自定义类型使用标准的C++运算符，如+、-、&lt;&lt;等。这不仅可以提高代码的直观性，还可以使得自定义类型的操作更加自然。</p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>运算符重载允许开发者为自定义类型重新定义运算符的功能。它可以作为成员函数或非成员函数(友元函数)实现，但必须至少有一个操作数是用户定义的类型。</p><p><strong>使用运算符重载时，需要遵循一些规则</strong>：</p><ul><li>不能改变运算符的优先级。</li><li>不能创造新的运算符。</li><li>有些运算符不能被重载，如<code>.</code>、<code>::</code>、<code>?:</code>和<code>sizeof</code>。其他的内置运算符都是可以重载的，比如常见的算术运算符、比较运算符、逻辑运算符等。</li><li>大多数重载的运算符可以是成员函数，也可以是非成员函数，但有些必须是成员函数，如赋值运算符<code>=</code>。</li></ul><h4 id="运算符重载的分类"><a href="#运算符重载的分类" class="headerlink" title="运算符重载的分类"></a>运算符重载的分类</h4><p>根据运算符作用于的对象，运算符重载可以是成员函数或非成员函数。</p><h5 id="成员函数运算符重载"><a href="#成员函数运算符重载" class="headerlink" title="成员函数运算符重载"></a>成员函数运算符重载</h5><p>当运算符重载作为成员函数时，它的第一个操作数隐式地成为了调用它的对象，这意味着你不能改变操作数的顺序。这通常用于二元运算符，比如加法运算符+，或一元运算符，比如递增运算符++。</p><p>我们先来看个成员函数运算符重载的例子,以重载<code>+</code>运算符为例，定义一个 <code>Point</code> 类，并为它重载 <code>+</code> 运算符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    Point(<span class="type">int</span> x = <span class="number">0</span>, <span class="type">int</span> y = <span class="number">0</span>) : x(x), y(y) &#123;&#125;</span><br><span class="line">    <span class="comment">// 重载+运算符</span></span><br><span class="line">    Point operator+(<span class="type">const</span> Point&amp; rhs) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x + rhs.x, y + rhs.y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Point <span class="title function_">p1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span>, <span class="title function_">p2</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span>;</span><br><span class="line">    Point p3 = p1 + p2;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;p3 = (&quot;</span> &lt;&lt; p3.x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; p3.y &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们定义了 <code>Point</code> 类的对象可以通过<code>+</code>运算符相加，返回两点坐标的和。</p><h5 id="非成员函数运算符重载"><a href="#非成员函数运算符重载" class="headerlink" title="非成员函数运算符重载"></a>非成员函数运算符重载</h5><p>非成员函数运算符重载通常声明为类的友元，这样它们就可以访问类的私有成员。这种方式适用于操作符左侧的对象不是重载运算符所在类的实例的情况，比如<code>输出流运算符&lt;&lt;</code>。</p><p><strong>重载&lt;&lt;运算符</strong></p><p>接下来，我们看下非成员函数运算符重载的例子，重载<code>&lt;&lt;</code>运算符以便能够直接打印 <code>Point</code> 对象。</p><p>由于<code>&lt;&lt;</code>运算符需要操作<code>std::ostream</code>类型的左操作数（如<code>std::cout</code>），它不能作为成员函数重载，而应该是非成员函数(友元函数)。通常，我们会将这样的函数声明为友元，以便它可以访问类的私有成员。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    friend <span class="built_in">std</span>::ostream&amp; operator&lt;&lt;(<span class="built_in">std</span>::ostream&amp; os, <span class="type">const</span> Point&amp; p);</span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    Point(<span class="type">int</span> x = <span class="number">0</span>, <span class="type">int</span> y = <span class="number">0</span>) : x(x), y(y) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 重载&lt;&lt;运算符</span></span><br><span class="line"><span class="built_in">std</span>::ostream&amp; operator&lt;&lt;(<span class="built_in">std</span>::ostream&amp; os, <span class="type">const</span> Point&amp; p) &#123;</span><br><span class="line">    os &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; p.x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; p.y &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Point <span class="title function_">p1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; p1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 现在可以直接打印Point对象了</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这里留个问题</strong>：为什么<code>&lt;&lt;</code>运算符不能作为成员函数重载，而只能是非成员函数？</p><p>这个问题，在我开始学习运算符重载的时候就挺疑惑的，不过现在已经搞清楚了，接下来，我尽可能用易懂的文字及代码示例给大家讲解清楚：</p><p>在 C++ 中，当你使用如 <code>std::cout &lt;&lt; object</code>; 的形式进行输出时，期望的行为是把<code>object</code>的内容发送到输出流<code>std::cout</code>。为了实现这个行为，我们需要重载&lt;&lt;运算符。但这里的挑战在于，<code>std::cout</code>是一个<code>std::ostream</code>类型的对象，而<code>object</code>是另一个用户自定义类型的类对象。</p><p><strong>成员函数的限制</strong>：<br>如果<code>&lt;&lt;</code>运算符是作为用户自定义类型的一个成员函数来重载，它的使用方式将变为<code>object.operator&lt;&lt;(std::cout);</code>。这意味着，从语法上讲，你正在尝试向<code>object</code>发送<code>std::cout</code>，而不是反过来。这与我们通常使用输出流的直觉相违背，因为我们希望<code>std::cout</code>在左边，<code>object</code>在右边，即：<code>std::cout&lt;&lt;object</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    MyClass(<span class="type">int</span> v) : value(v) &#123;&#125;</span><br><span class="line">    <span class="comment">// 假设尝试将 &lt;&lt; 作为成员函数重载</span></span><br><span class="line">    <span class="type">void</span> operator&lt;&lt;(<span class="built_in">std</span>::ostream&amp; os) &#123;</span><br><span class="line">        os &lt;&lt; value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    MyClass <span class="title function_">obj</span><span class="params">(<span class="number">10</span>)</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; obj; <span class="comment">// 这是我们想要的使用方式</span></span><br><span class="line">    obj &lt;&lt; <span class="built_in">std</span>::<span class="built_in">cout</span>; <span class="comment">// 如果&lt;&lt;是成员函数，实际调用将会是这样，这显然不符合我们的预期</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>为什么用非成员函数?</strong></p><p>为了让<code>std::cout &lt;&lt; object;</code>按预期工作，我们需要把<code>&lt;&lt;</code>运算符重载为非成员函数，这样它就可以接受两个参数：左边的<code>std::ostream</code>对象和右边的用户自定义类型对象。这种方式符合我们直观的使用习惯。</p><p><strong>使用友元函数</strong></p><p>此外，由于重载的<code>&lt;&lt;</code>运算符通常需要访问用户自定义类型对象的内部数据（可能包括私有成员），我们一般会把这个重载函数声明为<strong>友元函数</strong>。这样，即使是非成员函数，它也能访问类的私有或受保护成员，从而可以输出对象的内部状态。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    MyClass(<span class="type">int</span> val) : value(val) &#123;&#125;</span><br><span class="line">    <span class="comment">// 注意，这里没有作为成员函数重载&lt;&lt;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载&lt;&lt;运算符作为全局函数，并声明为友元，以便可以访问MyClass的内部数据</span></span><br><span class="line"><span class="built_in">std</span>::ostream&amp; operator&lt;&lt;(<span class="built_in">std</span>::ostream&amp; os, <span class="type">const</span> MyClass&amp; obj) &#123;</span><br><span class="line">    os &lt;&lt; obj.value; <span class="comment">// 假设我们要输出MyClass对象的value成员</span></span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    MyClass <span class="title function_">myObject</span><span class="params">(<span class="number">10</span>)</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; myObject; <span class="comment">// 正确地把myObject的内容输出到std::cout</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>在讲解多态之前，我们先来回顾下继承，因为多态是建立在类的继承关系之上的。</p><p><strong>简单来说</strong>: 继承允许我们基于一个已有的类（称为基类）来创建新的类（称为派生类）。派生类继承了基类的属性和方法，并且可以添加自己的属性和方法，或者重写继承来的方法。这为代码复用提供了一个强大的机制。</p><p>多态，字面意思是“多种形态”。在C++中，它允许我们通过一个共同的接口来操作不同的数据类型。这听起来可能有点抽象，不过别担心，让我们通过一个例子来简化它。</p><p>想象一下，你在动物园里，看到了各种各样的动物。虽然每种动物都有自己独特的叫声，但是你可以通过一个统一的行为“发出声音”来描述它们的共性。在C++中，我们可以将这种“发出声音”的行为抽象成一个共同的接口，然后让每种动物类根据自己的特性来实现这个接口。</p><h4 id="多态的分类："><a href="#多态的分类：" class="headerlink" title="多态的分类："></a>多态的分类：</h4><p>在C++中，多态主要以两种形式出现：<strong>编译时多态和运行时多态。</strong></p><ul><li><p><strong>编译时多态</strong>，也称为静态多态，主要是通过函数重载和模板实现的。函数重载允许你在同一个作用域内创建多个同名函数，只要它们的参数列表不同即可。编译器根据调用函数时提供的参数类型和数量，来决定调用哪个函数。</p></li><li><p><strong>运行时多态</strong>，也称为动态多态，是通过虚函数和继承实现的。这允许你在基类中定义一个接口，并在派生类中以不同的方式实现该接口。运行时多态的关键在于，你在代码运行时才确定调用哪个函数。</p></li></ul><h4 id="运行时多态的实现："><a href="#运行时多态的实现：" class="headerlink" title="运行时多态的实现："></a>运行时多态的实现：</h4><p>要实现C++的运行时多态，你需要掌握两个核心概念：<strong>虚函数和指针或引用</strong>。</p><p><strong>虚函数</strong>：</p><p>虚函数是在基类中使用关键字 <code>virtual</code> 声明的函数，它可以在派生类中被重覆盖，覆盖指的是派生类被重写的函数和基类声明的虚函数具有相同的函数声明。这样当你通过基类的指针或引用调用虚函数时，C++会根据对象的实际类型来决定调用哪个版本的函数。</p><p><strong>简单示例</strong></p><p>让我们回到动物园的例子，如果“动物”是一个基类，“狗”和“猫”是派生类，那么即使我们有一个指向“动物”的指针，我们也可以用它来调用“狗”和“猫”特有的方法。</p><p>代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    virtual <span class="type">void</span> <span class="title function_">speak</span><span class="params">()</span> &#123; </span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Some sound&quot;</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span> public Animal &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">speak</span><span class="params">()</span>  &#123; </span><br><span class="line">          <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Woof&quot;</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span> public Animal &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">speak</span><span class="params">()</span>  &#123; </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Meow&quot;</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Animal* myAnimal = new Dog();</span><br><span class="line">    myAnimal-&gt;speak();  <span class="comment">// Outputs: Woof</span></span><br><span class="line"></span><br><span class="line">    myAnimal = new Cat();</span><br><span class="line">    myAnimal-&gt;speak();  <span class="comment">// Outputs: Meow</span></span><br><span class="line"></span><br><span class="line">    delete myAnimal; <span class="comment">// Assuming myAnimal now points to Cat, delete the Cat object</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们定义了一个基类 Animal 和两个派生类 Dog 和 Cat。每个类都有一个 speak 函数，但实现各不相同。通过基类指针调用 speak 时，C++运行时会根据对象的实际类型来决定调用 Dog 的 speak 还是 Cat 的 speak。</p><p><strong>这里问个问题</strong>：myAnimal是基类指针，为什么调用的是派生类(Cat类和Dog类)的方法？</p><p>其实就是通过多态和虚函数机制来实现的。简单来说：</p><ul><li><p><code>虚函数</code>：在基类中用virtual关键字声明的函数。派生类可以重写这些函数。</p></li><li><p><code>虚表指针</code>：每个包含虚函数的类对象都有一个指针（vptr），指向其类的虚表。</p></li><li><p><code>虚表</code>：每个包含虚函数的类都有一个虚函数表（简称vtable），里面存储了虚函数的地址。</p></li></ul><p><code>注意</code>：虚函数表（vtable）是在编译期间确定的，而虚表指针（vptr）是在每个对象被构造时创建并初始化的。(<strong>这个也是面试常考的点</strong>)</p><p>当通过基类指针调用虚函数时，程序会使用这个指针指向的对象的虚表来确定实际调用哪个函数(这个过程是在运行时做的)。这样，即便是通过基类指针，程序也能调用到派生类中重写的方法，实现了多态。 </p><p>在这个例子中，Animal 类中的 speak 函数被声明为 virtual，这使得 Dog 和 Cat类能够提供自己的speak函数实现。当通过类型为 Animal* 的指针 myAnimal 调用 speak 函数时，C++ 运行时会检查 myAnimal 实际指向的对象类型（Dog或Cat），并调用那个类型的 speak 函数。</p><h4 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h4><p>当我们希望定义一个通用接口，但又不想在基类中提供任何具体实现时，该怎么办。使用纯虚函数和抽象类即可实现。</p><h5 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h5><p>纯虚函数是一种特殊的虚函数，在基类中声明但不提供实现（不定义函数体），并且要求派生类必须提供具体的实现。这通过在函数声明的末尾加上<code>= 0</code>来实现。</p><p>纯虚函数的存在使得基类变成所谓的抽象类，这意味着它不能被直接实例化。这样，抽象类为派生类定义了一个或多个必须实现的接口，从而实现了一个完全抽象的概念层。</p><h5 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h5><p>抽象类是包含至少一个纯虚函数的类。它主要用作其他类的基类，定义了一组接口，派生类通过实现这些接口实现多态性。抽象类提供了一种强制派生类遵守特定设计契约的机制。</p><p>回到我们的动物园例子，假设我们想要强制每种动物都必须实现自己的“发出声音”的方法，但在“动物”这一概念层面，我们无法给出一个具体的实现。这就是纯虚函数和抽象类发挥作用的地方。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象基类Animal</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="comment">// 纯虚函数</span></span><br><span class="line">    virtual <span class="type">void</span> <span class="title function_">speak</span><span class="params">()</span> <span class="type">const</span> = <span class="number">0</span>;</span><br><span class="line">    virtual ~Animal() &#123;&#125; <span class="comment">// 虚析构函数，保证派生类的析构函数被调用</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dog类继承自Animal并实现speak方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span> public Animal &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">speak</span><span class="params">()</span> <span class="type">const</span>  &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Dog says: Woof!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Cat类继承自Animal并实现speak方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span> public Animal &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">speak</span><span class="params">()</span> <span class="type">const</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Cat says: Meow!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">letAnimalSpeak</span><span class="params">(<span class="type">const</span> Animal* animal)</span> &#123;</span><br><span class="line">    animal-&gt;speak(); <span class="comment">// 动态绑定speak方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Dog dog;</span><br><span class="line">    Cat cat;</span><br><span class="line">    letAnimalSpeak(&amp;dog);</span><br><span class="line">    letAnimalSpeak(&amp;cat);</span><br><span class="line">    <span class="comment">// Animal animal; // 错误：不能实例化抽象类</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这个示例中，Animal类成为了一个抽象基类，因为它包含了一个纯虚函数 speak。我们不能直接实例化 Animal 类，但我们可以通过它的派生类 Dog 和 Cat 来实例化对象，并且通过 Animal 类的引用或指针来调用它们各自的 speak 方法。</p><p>通过将 speak 方法定义为纯虚函数，我们确保了所有 Animal 的派生类都必须实现自己的 speak 方法，这样每种动物都有自己独特的发声方式。同时，这也展示了运行时多态的强大之处：即使是通过 Animal 类型的引用或指针，程序在运行时也能正确调用到派生类对象的 speak 方法。</p><p>引入纯虚函数和抽象类后，我们的代码设计变得更加清晰和严格。这种方式不仅强制派生类遵守一定的规则，也提供了一个明确的、可扩展的接口框架。</p><p><strong>使用多态的好处</strong>：<br>多态的使用提供了几个优点：</p><ul><li><strong>代码的可复用性</strong>：可以通过基类接口编写通用的代码，这些代码能够与任何派生类对象协同工作，从而减少代码重复。</li><li><strong>代码的可扩展性</strong>：新增派生类时，不需要修改现有的基类代码或其他派生类代码，只需覆盖基类的虚函数即可。</li><li><strong>接口的一致性</strong>：派生类可以有不同的实现，但是共享相同的基类接口，使得接口一致、清晰。</li></ul><p>在讲解虚函数的时候，我们提到了覆盖，然而在C++中也存在另外一个相似的概念叫隐藏，这两者也是比较容易混淆的，接下来我们来看下覆盖和隐藏是什么？以及它们之间的区别？</p><h3 id="覆盖和隐藏"><a href="#覆盖和隐藏" class="headerlink" title="覆盖和隐藏"></a>覆盖和隐藏</h3><p>在C++中，函数覆盖和函数隐藏是面向对象编程中的两个基本概念，它们都涉及到派生类（子类）与基类（父类）之间方法的关系。</p><h4 id="函数覆盖（Function-Overriding）"><a href="#函数覆盖（Function-Overriding）" class="headerlink" title="函数覆盖（Function Overriding）"></a>函数覆盖（Function Overriding）</h4><p>当派生类中的成员函数与基类中的一个虚函数具有相同的签名（即相同的函数名称、返回类型及参数列表）时，我们说派生类的函数覆盖了（overriding）基类的函数。函数覆盖是实现多态的关键机制之一。</p><ul><li>覆盖发生在派生类与基类之间的虚函数上。</li><li>覆盖的目的是在派生类中提供一个特定实现，替换掉基类中的默认实现。</li></ul><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    virtual <span class="type">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Display of Base&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> public Base &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">display</span><span class="params">()</span> override &#123; <span class="comment">// 覆盖基类的display函数</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Display of Derived&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Base* ptr = new Derived();</span><br><span class="line">    ptr-&gt;display(); <span class="comment">// 调用Derived类的display方法</span></span><br><span class="line">    delete ptr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，Derived 类的 display 函数覆盖了 Base 类的 display 函数。通过基类指针调用 display 时，实际上调用的是 Derived 类的实现。这其实就是所为的多态。</p><h4 id="函数隐藏（Function-Hiding）"><a href="#函数隐藏（Function-Hiding）" class="headerlink" title="函数隐藏（Function Hiding）"></a>函数隐藏（Function Hiding）</h4><p>当派生类中的函数与基类中的某个函数具有相同的名称，但是签名不同，则我们说派生类中的函数隐藏了（hiding）基类中的同名函数。</p><ul><li>隐藏与覆盖不同，它发生在所有同名函数上，无论它们是否为虚函数。</li><li>隐藏的发生仅仅因为函数的名称相同。</li></ul><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Display of Base&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> public Base &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">display</span><span class="params">(<span class="type">int</span>)</span> &#123; <span class="comment">// 隐藏了基类的display函数</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Display of Derived with parameter&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Derived obj;</span><br><span class="line">    obj.display(<span class="number">5</span>); <span class="comment">// 调用Derived类的display方法</span></span><br><span class="line">    <span class="comment">// obj.display(); // 错误：Base类的display方法被隐藏</span></span><br><span class="line">    obj.Base::display(); <span class="comment">// 明确调用Base类的display方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，Derived 类的 display 函数隐藏了 Base 类的 display 函数，因为它们的签名不同。尝试直接调用没有参数的 display() 会导致编译错误，除非我们明确指定要调用 Base 类的版本。</p><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>C++提供了四种类型转换运算符，用于在不同类型之间进行显式转换。这些转换方式比C语言中的传统转换提供了更好的类型安全性和可读性。</p><h4 id="1-静态类型转换（static-cast）"><a href="#1-静态类型转换（static-cast）" class="headerlink" title="1. 静态类型转换（static_cast）"></a>1. 静态类型转换（static_cast）</h4><p>static_cast是用于类型之间转换的最常见形式，它在编译时检查转换的合法性。如果转换不合法，编译时会报错。它主要用于以下场景：</p><ul><li><strong>基本数据类型的转换</strong>：如整型与浮点型之间的转换。</li><li><strong>类层次结构中的向上转换</strong>（从派生类到基类）：这是安全的。</li><li><strong>类层次结构中的向下转换</strong>（从基类到派生类）：可能不安全，因为基类指针可能并不真正指向一个派生类对象。</li><li><strong>void指针的转换</strong>：将void<em>转换为具体类型的指针，或将具体类型的指针转换为void</em>。</li></ul><p>基本数据类型的转换示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> d = <span class="number">10.5</span>;</span><br><span class="line"><span class="type">int</span> i = static_cast&lt;<span class="type">int</span>&gt;(d); <span class="comment">// double转int</span></span><br></pre></td></tr></table></figure><p>类层次结构中的向上转换、向下转换代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">baseMethod</span><span class="params">()</span> &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base method\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> public Base &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">derivedMethod</span><span class="params">()</span> &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Derived method\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向上转换</span></span><br><span class="line">Derived derivedObj;</span><br><span class="line">Base* basePtr = static_cast&lt;Base*&gt;(&amp;derivedObj); <span class="comment">// 安全的向上转换</span></span><br><span class="line">basePtr-&gt;baseMethod(); <span class="comment">// 正常：可以访问基类方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 向下转换</span></span><br><span class="line">Base baseObj;</span><br><span class="line">Derived* derivedPtr = static_cast&lt;Derived*&gt;(&amp;baseObj); <span class="comment">// 不安全的向下转换</span></span><br><span class="line"><span class="comment">// derivedPtr-&gt;derivedMethod(); // 不安全：baseObj不是Derived的实例</span></span><br></pre></td></tr></table></figure><h4 id="2-常量类型转换（const-cast）"><a href="#2-常量类型转换（const-cast）" class="headerlink" title="2. 常量类型转换（const_cast）"></a>2. 常量类型转换（const_cast）</h4><p><code>const_cast</code>主要用于修改类型的<code>const</code>属性，包括：去除<code>const</code>属性：允许修改原本被声明为<code>const</code>的变量。</p><p>代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp; b = const_cast&lt;<span class="type">int</span>&amp;&gt;(a); <span class="comment">// 去除const属性</span></span><br><span class="line">b = <span class="number">20</span>; <span class="comment">// 修改成功，但修改const变量是未定义行为</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; b&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">// 20</span></span><br></pre></td></tr></table></figure><h4 id="3-动态类型转换（dynamic-cast）"><a href="#3-动态类型转换（dynamic-cast）" class="headerlink" title="3. 动态类型转换（dynamic_cast）"></a>3. 动态类型转换（dynamic_cast）</h4><p><code>dynamic_cast</code>是C++中用于在类的继承体系内进行类型转换的操作符，特别适用于执行安全的向下转换。<strong>向下转换是指将基类的指针（或引用）转换为派生类的指针（或引用）</strong>。这种转换在运行时检查对象的实际类型，以确保转换的合法性和安全性.</p><p>dynamic_cast向下转换代码示例：</p><p>假设有一个基类 Base 和一个从 Base 派生的类 Derived：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    virtual <span class="type">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base class&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    virtual ~Base() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> public Base &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">print</span><span class="params">()</span> override &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Derived class&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">specificFunction</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Derived class specific function&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在，如果我们想安全地将基类 Base 的指针转换为派生类 Derived 的指针，并调用派生类的特定函数，我们可以使用dynamic_cast：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Base* basePtr = new Derived();</span><br><span class="line">    basePtr-&gt;print();  <span class="comment">// 输出: Derived class</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 安全的向下转换</span></span><br><span class="line">    Derived* derivedPtr = dynamic_cast&lt;Derived*&gt;(basePtr);</span><br><span class="line">    <span class="keyword">if</span> (derivedPtr != nullptr) &#123;</span><br><span class="line">        derivedPtr-&gt;specificFunction();  <span class="comment">// 输出: Derived class specific function</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Conversion failed.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    delete basePtr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，basePtr 实际上指向一个 Derived 类的对象，因此使用 dynamic_cast 将 basePtr 转换为 Derived* 类型是安全的，并且转换成功。这允许我们安全地调用 Derived 类的 specificFunction 方法。</p><p><code>dynamic_cast</code>类型转换如何使用讲完了，接下来我们来看下 dynamic_cast类型转换的具体过程是怎样的？</p><h5 id="dynamic-cast的工作原理"><a href="#dynamic-cast的工作原理" class="headerlink" title="dynamic_cast的工作原理"></a>dynamic_cast的工作原理</h5><p><code>dynamic_cast</code>利用 C++ 的<code>运行时类型信息（RTTI）</code>机制来检查转换的安全性。它在运行时检查对象的实际类型，以确保所执行的转换是合法的。这种检查使得dynamic_cast比其他类型转换操作符（如static_cast或reinterpret_cast）更安全，但也带来了一定的性能开销。</p><p><strong>RTTI 是什么？</strong></p><p>C++的RTTI（Runtime Type Information，运行时类型信息）是一种机制，它允许C++程序在运行时查询和操作对象的类型信息。这种能力使得dynamic_cast能够在执行类型转换前，检查转换是否安全，从而确保类型转换的正确性和安全性。</p><p>dynamic_cast类型转换的具体过程？</p><p><strong>1. 确定对象的实际类型</strong></p><p><strong>访问虚函数表（vtable）</strong>：在C++中，每个具有虚函数的类的对象都会有一个隐藏的指针（称为虚表指针vptr），指向一个静态的虚函数表（vtable）。vtable主要用于支持多态性，即在运行时决定调用哪个虚函数。</p><p><strong>类型信息（RTTI）在vtable中</strong>：除了虚函数的地址外，vtable还包含了指向特定的类型信息的指针，这里说的类型信息就是RTTI。RTTI的核心是type_info类的对象，它为每个类提供了唯一的类型标识。</p><p><strong>2. 利用RTTI确定实际类型</strong>：</p><ul><li>当使用dynamic_cast进行类型转换时，C++运行时会查找原对象的vtable，通过其中的RTTI信息（即指向type_info对象的指针）来获取对象的实际类型。</li><li>一旦获得了对象的实际类型信息，dynamic_cast接着检查这个类型与目标类型的关系。对于向下转换（基类指针转换为派生类指针），它验证目标派生类是否确实是源对象实际类型的派生类或相同类型。</li></ul><p>在多态的使用场景中，上面提到的原对象指的是一个指向基类的指针或引用指向的对象。<br>目标派生类指的是我们希望将原对象的基类指针或引用转换到的目标类。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Base* basePtr = new Derived();</span><br><span class="line">Derived* derivedPtr = dynamic_cast&lt;Derived*&gt;(basePtr);</span><br></pre></td></tr></table></figure><p>对于上面的代码示例：原对象指的就是 basePtr 基类指针指向的 Derived 对象。目标派生类指的是 Derived 类。</p><p><strong>3.验证转换的合法性并执行转换或失败处理</strong></p><ul><li>如果转换合法，dynamic_cast修改源指针或引用，使其指向正确的目标类型的对象。</li><li>如果转换不合法：对于指针类型，dynamic_cast返回nullptr，表示转换失败。<br>对于引用类型，dynamic_cast 抛出 std::bad_cast 异常，因为引用不能为 nullptr。</li></ul><h4 id="4-重新解释类型转换-reinterpret-cast"><a href="#4-重新解释类型转换-reinterpret-cast" class="headerlink" title="4.重新解释类型转换 reinterpret_cast"></a>4.重新解释类型转换 reinterpret_cast</h4><p>reinterpret_cast是C++中一种强大但需谨慎使用的类型转换操作符。它允许开发者在几乎任何指针类型之间进行转换，也支持指针与足够大的整数类型之间的转换。其基本作用是重新解释数据的位模式，但不改变数据本身。</p><p>由于 reinterpret_cast 不进行类型检查和转换安全性保证，使用时需要特别注意，以防止未定义行为的发生。</p><h5 id="指针类型转换"><a href="#指针类型转换" class="headerlink" title="指针类型转换"></a>指针类型转换</h5><p>reinterpret_cast 可以用来将一个指针类型转换为另一个指针类型，即便这两个类型之间并无直接的关联。这种转换基本上是在告诉编译器：<strong>将内存地址当作另一种类型来解释，但不改变位模式本身</strong>。这种转换不会进行任何类型安全检查，因此非常危险且易于产生错误。因此在解引用转换后的指针之前，你需要确保转换是有意义的。</p><p>指针类型转换示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">char</span>* cp = &amp;c;</span><br><span class="line"><span class="comment">// 将char*转换为int*，虽然不安全，但可以编译通过</span></span><br><span class="line"><span class="type">int</span>* ip = reinterpret_cast&lt;<span class="type">int</span>*&gt;(cp);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;*ip&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 输出随机值</span></span><br></pre></td></tr></table></figure><h5 id="指针与整数类型之间的转换"><a href="#指针与整数类型之间的转换" class="headerlink" title="指针与整数类型之间的转换"></a>指针与整数类型之间的转换</h5><p>reinterpret_cast也可以用于将指针转换为整数类型，或者相反。这在需要在整数和指针之间进行转换，例如，当与需要整数参数的底层系统调用交互时非常有用。为了安全地执行这种转换，整数类型必须足够大以存储指针值，通常使用 uintptr_t 或 intptr_t。</p><p>示例代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdint&gt;</span>  <span class="comment">// 包含uintptr_t定义</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">42</span>;</span><br><span class="line">    <span class="comment">// 将int指针转换为整数</span></span><br><span class="line">    <span class="type">uintptr_t</span> ptrAsInt = reinterpret_cast&lt;<span class="type">uintptr_t</span>&gt;(&amp;a);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The pointer as integer: &quot;</span> &lt;&lt; ptrAsInt &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将整数转换回int指针</span></span><br><span class="line">    <span class="type">int</span>* aPtrAgain = reinterpret_cast&lt;<span class="type">int</span>*&gt;(ptrAsInt);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The integer as pointer: &quot;</span> &lt;&lt; *aPtrAgain &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>指针与整数类型之间的转换的使用场景</strong>：</p><ul><li><p><strong>系统级调用或API</strong>:<br>一些底层的系统调用或API可能要求使用整数类型的“句柄”来代表资源或对象。在这些情况下，如果资源或对象由C++管理，并通过指针访问，我们可以临时将指针转换为整数类型的句柄，进行调用，然后再转换回指针进行操作。</p></li><li><p><strong>回调函数与用户数据</strong>:<br>在使用回调函数时，通常需要提供一个指向用户数据的指针。如果回调函数的接口仅允许传递整数类型的用户数据，我们可以将指针转换为整数进行传递，然后在回调函数中再转换回指针，以访问实际的用户数据。</p></li></ul><p>示例代码：使用回调函数</p><p>假设我们有一个C++库，该库提供了一个设置回调函数的API，但API要求回调函数的用户数据必须是uintptr_t类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdint&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyCallback</span><span class="params">(<span class="type">uintptr_t</span> userData)</span> &#123;</span><br><span class="line">    <span class="comment">// 在回调中将整数还原回指针</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span>* str = reinterpret_cast&lt;<span class="built_in">std</span>::<span class="built_in">string</span>*&gt;(userData);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *str &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">RegisterCallback</span><span class="params">(<span class="type">void</span>(*callback)(<span class="type">uintptr_t</span>), <span class="built_in">std</span>::<span class="built_in">string</span>* userData)</span> &#123;</span><br><span class="line">    <span class="comment">// 调用回调函数，将指针作为整数传递</span></span><br><span class="line">    callback(reinterpret_cast&lt;<span class="type">uintptr_t</span>&gt;(userData));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> myData = <span class="string">&quot;Hello, callback!&quot;</span>;</span><br><span class="line">    RegisterCallback(MyCallback, &amp;myData);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p>C++的模板是一种强大的编程特性，它允许程序员编写与类型无关的代码，也就是所谓的泛型编程。这使得我们可以编写一个通用的代码框架，它可以用于多种数据类型。使用模板可以大大提高代码的复用性和灵活性。</p><p>C++ 模板主要有两种形式：<strong>函数模板和类模板</strong></p><p>在讲解函数模板和类模板之前，我们先来了解下 <strong>模板参数</strong> ？</p><p>在 C++ 模板编程中，模板参数是定义模板时指定的一种占位符，它在模板实例化时被具体的类型或值所替代。模板参数使模板具有泛型，能够适应不同的数据类型或值。C++ 中的模板参数主要分为两类：<strong>类型参数和非类型参数</strong>。</p><h4 id="类型参数"><a href="#类型参数" class="headerlink" title="类型参数"></a>类型参数</h4><p>类型参数允许在模板定义时指定一些<strong>占位符</strong>类型，这些类型在模板实例化时被<strong>具体的类型</strong>所替代。这意味着你可以编写一个通用的模板，然后用不同的类型来实例化它，生成针对那些类型的特化版本。</p><p><strong>类型参数声明方式</strong>：使用关键字 typename 或 class 来声明。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">T <span class="title function_">max</span><span class="params">(T x, T y)</span> &#123;</span><br><span class="line">    <span class="comment">// 函数实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述示例中，<code>T</code>是一个类型参数，表示 max 函数的两个参数可以接受任何类型。</p><h4 id="非类型参数"><a href="#非类型参数" class="headerlink" title="非类型参数"></a>非类型参数</h4><p>非类型参数允许你将<strong>一个或多个常量值</strong>作为参数传递给模板。非类型参数必须是一个<strong>常量表达式</strong>，因为模板在编译时实例化。</p><p>下面来看类模板如何使用非类型参数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">template &lt;  T, <span class="type">size_t</span> N&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FixedArray</span> &#123;</span></span><br><span class="line">    T data[N]; <span class="comment">// N 是一个非类型参数</span></span><br><span class="line">public:</span><br><span class="line">    T&amp; operator[](<span class="type">size_t</span> index) &#123; <span class="keyword">return</span> data[index]; &#125;</span><br><span class="line">    <span class="type">const</span> T&amp; operator[](<span class="type">size_t</span> index) <span class="type">const</span> &#123; <span class="keyword">return</span> data[index]; &#125;</span><br><span class="line">    constexpr <span class="type">size_t</span> <span class="title function_">size</span><span class="params">()</span> <span class="type">const</span> &#123; <span class="keyword">return</span> N; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这个示例中，N是一个非类型参数，它指定了FixedArray的大小。</p><p>非类型参数大多数使用在类模板中，虽然非类型参数在函数模板中的使用不如在类模板中那么频繁，但在某些情况下，它们仍然非常有用，特别是当你需要根据编译时常量来调整函数行为时。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T, <span class="type">int</span> increment&gt;</span><br><span class="line">T <span class="title function_">addIncrement</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value + increment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>addIncrement</code> 函数模板通过非类型参数 <code>increment</code> 允许在编译时确定增加的量，这可以在不同的调用中提供不同的增量值。</p><h4 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h4><p>函数模板允许我们创建一个函数原型，它可以用不同的数据类型来实例化。这意味着我们可以用一个函数模板来创建一系列执行相似操作的函数，而无需为每种数据类型编写重复的代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">T <span class="title function_">max</span><span class="params">(T x, T y)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; y ? x : y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>调用函数模板</strong></p><p><strong>1. 自动类型推导:</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Max of &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; max(a, b) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line"></span><br><span class="line"><span class="type">double</span> c = <span class="number">3.5</span>, d = <span class="number">2.5</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Max of &quot;</span> &lt;&lt; c &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; d &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; max(c, d) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者这样调用：</span></span><br><span class="line">max(<span class="number">3</span>, <span class="number">5</span>)；</span><br></pre></td></tr></table></figure><p><strong>2. 显式指定模板参数类型</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Max of 2 and 3 is &quot;</span> &lt;&lt; max&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">3</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Max of 2.5 and 3.5 is &quot;</span> &lt;&lt; max&lt;<span class="type">double</span>&gt;(<span class="number">2.5</span>, <span class="number">3.5</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>上面整型的调用，函数模板实际上会被实例化为一个接受两个 int 类型参数的函数版本：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; y ? x : y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而对于double类型的调用，函数模板会被实例化为一个接受两个 double 类型参数的函数版本。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">max</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; y ? x : y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h4><p>类模板与函数模板类似，允许我们定义一个类蓝图，用于生成处理不同数据类型的类。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    Box(T value) : value(value) &#123;&#125;</span><br><span class="line">    T <span class="title function_">getValue</span><span class="params">()</span> <span class="type">const</span> &#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">private:</span><br><span class="line">    T value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建类模板实例</span></span><br><span class="line">Box&lt;<span class="type">int</span>&gt; <span class="title function_">intBox</span><span class="params">(<span class="number">123</span>)</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Value in intBox: &quot;</span> &lt;&lt; intBox.getValue() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">Box&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title function_">stringBox</span><span class="params">(<span class="string">&quot;Hello Templates&quot;</span>)</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Value in stringBox: &quot;</span> &lt;&lt; stringBox.getValue() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>通过以上例子，我们了解了模板的基本使用，以及它是如何提高代码的复用性的。</p><p>上面的<code>max</code>函数模板的通用性确保了它可以用于整数、浮点数，甚至是字符串等多种类型，展现了模板编程的灵活性。然而，这种通用性有时候也是一把双刃剑。以指针类型为例，如果我们使用上述<code>max</code>函数比较两个指针，它实际上会比较指针的地址，而不是指针所指向的值，这可能并不是我们期望的行为。</p><p>在这种情况下，C++提供了一种强大的机制来优化和定制模板行为——<strong>模板特化</strong>。模板特化允许我们为特定的类型或值集合提供专门的实现，以此来处理那些需要特殊考虑的特定情况。模板特化分为两大类：<strong>全特化（Explicit Specialization）和偏特化（Partial Specialization）</strong>。</p><h4 id="全特化"><a href="#全特化" class="headerlink" title="全特化"></a>全特化</h4><p>全特化（Explicit Specialization）是为一个已有的模板定义提供一个特定版本的过程，这个特定版本适用于特定的类型或值。全特化意味着为模板的所有参数指定具体的类型或值。全特化不再是模板，而是对模板的一个特定实例提供了一个完全定制的实现。</p><h5 id="类模板全特化："><a href="#类模板全特化：" class="headerlink" title="类模板全特化："></a>类模板全特化：</h5><p>当你想为一个特定类型提供一个完全不同的类模板实现时，可以使用全特化。</p><p><strong>语法</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt;&gt; <span class="comment">// 空尖括号代表全特化的声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span>&lt;</span>Type&gt; &#123;</span><br><span class="line">    <span class="comment">// 特化的实现</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span> <span class="comment">// 通用模板</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">function</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Generic MyClass\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>&lt;</span><span class="type">int</span>&gt; &#123; <span class="comment">// 全特化为int类型</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">function</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Specialized MyClass for int\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="函数模板全特化："><a href="#函数模板全特化：" class="headerlink" title="函数模板全特化："></a>函数模板全特化：</h5><p>与类模板相似，你也可以为特定类型提供特定的函数模板实现。</p><p><strong>语法</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt;&gt;</span><br><span class="line">ReturnType functionName&lt;SpecificType&gt;(parameters) &#123;</span><br><span class="line">    <span class="comment">// 特化的实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举一个函数模板全特化的例子，比如对于前面的<code>max</code>函数，我们想要对指针类型进行特化，使其比较指针所指向的值而不是指针地址：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">T <span class="title function_">max</span><span class="params">(T x, T y)</span> &#123; <span class="comment">// 通用模板</span></span><br><span class="line">    <span class="keyword">return</span> x &gt; y ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;&gt;   <span class="comment">//使用全特化</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* max&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(<span class="type">const</span> <span class="type">char</span>* a, <span class="type">const</span> <span class="type">char</span>* b) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(a, b) &gt; <span class="number">0</span> ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这个例子，展示如何为特定类型（在这里是const char*类型的字符串）提供特化实现。</p><h4 id="偏特化"><a href="#偏特化" class="headerlink" title="偏特化"></a>偏特化</h4><p>偏特化允许你为模板的<strong>一部分参数</strong>提供具体的类型或值，而其余参数仍然保持泛型。<strong>偏特化仅适用于类模板，不能用于函数模板</strong>。通过偏特化，你可以对模板的部分参数施加约束，从而为特定的类型组合提供特定的实现。</p><p><strong>语法示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T, typename U&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span>&#125;; <span class="comment">// 通用模板</span></span><br><span class="line"></span><br><span class="line">template &lt;typename U&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>&lt;</span><span class="type">int</span>, U&gt; &#123;&#125;; <span class="comment">// 对第一个参数为int的偏特化</span></span><br></pre></td></tr></table></figure><p>代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">template&lt;typename T, typename U&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span> <span class="comment">// 原始模板</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">function</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Generic MyClass&lt;T, U&gt;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename U&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>&lt;</span><span class="type">int</span>, U&gt; &#123; <span class="comment">// 偏特化其中一个参数为int</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">function</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Partially Specialized MyClass&lt;int, U&gt;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    MyClass&lt;<span class="type">double</span>, <span class="type">double</span>&gt; myClass1; <span class="comment">// 将使用原始模板</span></span><br><span class="line">    myClass1.function();</span><br><span class="line">    MyClass&lt;<span class="type">int</span>, <span class="type">double</span>&gt; myClass2; <span class="comment">// 将使用偏特化模板</span></span><br><span class="line">    myClass2.function();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p>在C++中，内存管理是一个非常重要的概念，它关系到程序的性能和稳定性。C++提供了多种内存管理方式，包括<strong>自动、静态、动态分配</strong>等。让我们一步一步来了解。</p><p>为了更好地理解这些内存管理方式及其应用场景，我们首先需要了解C&#x2F;C++程序在运行时的内存布局。这里我介绍 Linux C&#x2F;C++ 程序的内存布局，因为大多数 C&#x2F;C++ 程序都是运行在 Linux 操作系统上，因此有必要了解下。</p><h4 id="Linux-C-C-程序的内存布局图示"><a href="#Linux-C-C-程序的内存布局图示" class="headerlink" title="Linux C&#x2F;C++ 程序的内存布局图示"></a>Linux C&#x2F;C++ 程序的内存布局图示</h4><p><img src="https://files.mdnice.com/user/48364/48290d63-a0e4-4242-9393-edb280609e52.png"></p><p>上图中，从下往上，地址是增加的，<code>0-3G</code>属于用户空间，<code>3G-4G</code> 属于内核空间.</p><p>接下来，我们对上面图示的各个区（段）作个详细的说明： </p><h4 id="内核空间（Kernel-Space）"><a href="#内核空间（Kernel-Space）" class="headerlink" title="内核空间（Kernel Space）"></a>内核空间（Kernel Space）</h4><p>Kernel space（内核空间）指的是操作系统内核所占用的内存区域。这部分内存是保留给操作系统内核的，用于执行核心的系统任务和硬件操作。出于安全和稳定性的考虑，用户程序通常无法直接访问这部分内存。在多数操作系统中，内核空间位于内存地址的高区域。在32位Linux系统上，通常最高的1GB内存（如地址从0xC0000000到0xFFFFFFFF）被保留给内核空间，而剩下的下3GB内存用于用户空间。</p><h4 id="用户空间（User-Space）"><a href="#用户空间（User-Space）" class="headerlink" title="用户空间（User Space）"></a>用户空间（User Space）</h4><ul><li><p><strong>栈（Stack）</strong></p><p>栈用于存放函数的局部变量、函数参数和返回地址。栈有着LIFO（后进先出）的特性，每当进入一个新的函数调用时，就会在栈上为其分配空间，函数返回时则释放这些空间。栈的大小通常有限，并且由操作系统预先定义。</p></li><li><p><strong>内存映射段(Memory Mapping Segment)</strong></p><p>内存映射段是一块可以被用来映射文件内容到进程地址空间的内存区域。这不仅包括用于动态库（如libc.so等）的映射，还包括程序运行时可能使用的任何匿名映射或文件映射。</p></li><li><p><strong>堆（Heap）</strong></p><p>堆用于动态内存分配，由new和delete（或malloc和free）控制。不同于栈，堆上的内存分配和释放是不自动的，需要程序员手动管理。堆的大小相对更灵活，受限于系统的可用内存。</p></li><li><p><strong>BSS段（Block Started by Symbol）</strong></p><p>BSS段，全称为“Block Started by Symbol”，主要用于存储程序中未初始化的全局变量和静态变量。与数据段（存放已初始化的全局变量和静态变量）相对，BSS段的特点是在程序启动之前，操作系统会自动将其内容初始化为零。这意味着，如果你在程序中声明了一个未初始化的全局或静态变量，它会被放在BSS段。</p></li><li><p><strong>数据区</strong></p><p>这部分内存用于存放全局变量和静态变量。不同于栈和堆上的变量，全局&#x2F;静态变量的生命周期贯穿整个程序运行期间，从程序开始执行时分配，到程序结束时才被释放。</p></li><li><p><strong>代码区</strong></p><p>存放程序的二进制代码，即编译后的机器指令。这部分内存是只读的。</p></li></ul><p>接下来，我们详细来聊下C++的多种内存管理方式，包括<strong>自动、静态、动态分配</strong>。</p><h4 id="常见的内存管理方式"><a href="#常见的内存管理方式" class="headerlink" title="常见的内存管理方式"></a>常见的内存管理方式</h4><h5 id="自动存储（Stack-Allocation）"><a href="#自动存储（Stack-Allocation）" class="headerlink" title="自动存储（Stack Allocation）"></a>自动存储（Stack Allocation）</h5><p>最简单的内存管理方式是自动存储，也就是在函数内部声明的局部变量。这些变量在函数被调用时自动分配内存（在栈上分配），并在函数返回时自动释放。</p><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">function</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> localVar = <span class="number">5</span>; <span class="comment">// 自动存储，函数结束时自动销毁</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="静态存储（Static-Allocation）"><a href="#静态存储（Static-Allocation）" class="headerlink" title="静态存储（Static Allocation）"></a>静态存储（Static Allocation）</h5><p>静态存储用于全局变量和静态变量，其生命周期贯穿整个程序运行期间。静态变量只被初始化一次，在首次加载时分配内存。</p><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">function</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> staticVar = <span class="number">5</span>; <span class="comment">// 静态存储，整个程序运行期间持续存在</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="动态存储（Dynamic-Allocation）"><a href="#动态存储（Dynamic-Allocation）" class="headerlink" title="动态存储（Dynamic Allocation）"></a>动态存储（Dynamic Allocation）</h5><p>动态存储是C++内存管理的核心，允许在运行时分配任意大小的内存。它使用<code>new</code>和<code>delete</code>操作符来手动管理内存。</p><p><strong>使用new和delete</strong></p><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = new <span class="type">int</span>; <span class="comment">// 动态分配一个int</span></span><br><span class="line">*ptr = <span class="number">5</span>; <span class="comment">// 给分配的int赋值</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *ptr &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 使用分配的内存</span></span><br><span class="line">delete ptr; <span class="comment">// 释放内存</span></span><br></pre></td></tr></table></figure><p><strong>使用new[]和delete[]管理数组</strong></p><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="built_in">array</span> = new <span class="type">int</span>[<span class="number">5</span>]; <span class="comment">// 动态分配一个有5个整数的数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">    <span class="built_in">array</span>[i] = i * i;</span><br><span class="line">&#125;</span><br><span class="line">delete[] <span class="built_in">array</span>; <span class="comment">// 释放数组</span></span><br></pre></td></tr></table></figure><p>现在大家已经了解了C++中的内存管理基础，接下来，我们将探讨如何更安全、更有效地管理资源。C++提供了一个强大的编程范式，称为RAII（资源获取即初始化）。</p><h4 id="RAII"><a href="#RAII" class="headerlink" title="RAII"></a>RAII</h4><p>“Resource Acquisition Is Initialization” (RAII) 是一种在C++中管理资源（如内存、文件句柄等）的编程模式。在RAII模式下，<strong>资源的分配（获取）发生在构造函数中，资源的释放（归还）发生在析构函数中</strong>。这种方式利用了C++自动调用析构函数的特性，确保了资源总是被正确释放，即使在面对异常情况时也不例外。</p><h4 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h4><p>通过<code>RAII</code>的介绍，我们已经认识到构造函数和析构函数在资源管理中的重要性。然而，在现实的编程实践中，尤其是面对复杂的资源管理需求时，单靠构造函数和析构函数可能不足以保证资源的安全和高效管理。这时，智能指针的概念应运而生。</p><p><code>智能指针</code>，实质上是一种行为类似于指针的对象，但它们包裹了原始指针，自动管理指向的资源。智能指针的核心理念正是基于<code>RAII模式</code>——通过对象的生命周期来管理资源。当智能指针的实例被创建时，它获取一个资源（比如动态分配的内存）；当智能指针实例销毁时，它释放那个资源。</p><p>C++11 标准库中提供了几种智能指针，如std::unique_ptr、std::shared_ptr和std::weak_ptr，但是我这里不讲解C++11 标准库的智能指针，而是重点讲解<code>boost</code>库里的智能指针。这两者的实现原理类似。后续会出一篇专门讲解 <code>C++11</code>新特性的文章。</p><p>在C++11之前，C++社区已经有一套成熟的解决方案来处理资源管理问题，那就是boost库提供的智能指针。</p><p>boost库是C++标准的实验田，很多在boost中实现的功能后来都被纳入了C++标准库。例如，C++11标准中的智能指针（std::shared_ptr和std::unique_ptr）、基于范围的for循环、无序容器等，都是从Boost库中借鉴或直接采用的。因此，可以说Boost对C++标准的发展有着重要的贡献。</p><h5 id="boost库智能指针有哪些？"><a href="#boost库智能指针有哪些？" class="headerlink" title="boost库智能指针有哪些？"></a>boost库智能指针有哪些？</h5><p><strong>1. boost::scoped_ptr</strong></p><p><code>boost::scoped_ptr</code>是一种简单的智能指针，用于管理在作用域内分配的对象。它不能传递所有权，即不能从一个<code>scoped_ptr</code>拷贝或赋值给另一个<code>scoped_ptr</code>。当<code>scoped_ptr</code>离开作用域时，它所管理的对象会被自动销毁。</p><p>使用示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/scoped_ptr.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    MyClass() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;MyClass constructed\n&quot;</span>; &#125;</span><br><span class="line">    ~MyClass() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;MyClass destroyed\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    boost::scoped_ptr&lt;MyClass&gt; <span class="title function_">ptr</span><span class="params">(new MyClass)</span>;</span><br><span class="line">    <span class="comment">// ptr在这里可用</span></span><br><span class="line">&#125; <span class="comment">// ptr离开作用域，自动销毁MyClass实例</span></span><br></pre></td></tr></table></figure><p><strong>2. boost::shared_ptr</strong></p><p><code>boost::shared_ptr</code>是一种引用计数的智能指针，也称共享型智能指针，允许多个<code>shared_ptr</code>实例共享同一个对象的所有权。当最后一个引用（shared_ptr实例）被销毁或重新指向另一个对象时，所管理的对象会被自动释放。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/shared_ptr.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    MyClass() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;MyClass constructed\n&quot;</span>; &#125;</span><br><span class="line">    ~MyClass() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;MyClass destroyed\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    boost::<span class="built_in">shared_ptr</span>&lt;MyClass&gt; <span class="title function_">ptr1</span><span class="params">(new MyClass)</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        boost::<span class="built_in">shared_ptr</span>&lt;MyClass&gt; ptr2 = ptr1; <span class="comment">// ptr1和ptr2共享对象</span></span><br><span class="line">    &#125; <span class="comment">// ptr2离开作用域，对象不会被销毁，因为ptr1仍然存在，引用计数不为0</span></span><br><span class="line">&#125; <span class="comment">// ptr1离开作用域，对象被销毁（引用计数为0）</span></span><br></pre></td></tr></table></figure><p>对于上面提到的<code>引用计数</code>，大家可以简单理解为一个<code>非负整型数值</code>.</p><p><strong>3. boost::weak_ptr</strong></p><p><code>boost::weak_ptr</code>专门设计用于与<code>boost::shared_ptr</code>协同工作，解决潜在的循环引用问题。循环引用发生在两个或多个对象通过<code>shared_ptr</code>相互引用时，导致它们的引用计数永远不会归零，进而导致内存泄漏。<code>weak_ptr</code>提供了一种机制，允许对这些对象进行观察，而不增加引用计数。</p><p><strong>weak_ptr的几个特性</strong>：</p><ul><li><strong>观察者</strong>：boost::weak_ptr是对boost::shared_ptr所管理对象的非拥有性引用（观察者）。它允许你访问对象，但不会延长对象的生命周期。</li><li><strong>临时升级</strong>：虽然weak_ptr本身不能直接访问对象，但它可以被临时升级为一个shared_ptr（如果对象仍然存在），以安全地访问对象。</li><li><strong>解决循环引用</strong>：在使用shared_ptr管理相互引用的对象时，容易产生循环引用，导致对象无法被释放。weak_ptr不参与引用计数，因此可以打破这种循环，避免内存泄漏。</li></ul><p><strong>weak_ptr基本用法</strong>：</p><p><strong>1. 创建weak_ptr</strong></p><p>weak_ptr通常通过与一个shared_ptr关联来创建：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">boost::<span class="built_in">shared_ptr</span>&lt;<span class="type">int</span>&gt; <span class="title function_">sp</span><span class="params">(new <span class="type">int</span>(<span class="number">42</span>))</span>; <span class="comment">// 创建shared_ptr</span></span><br><span class="line">boost::weak_ptr&lt;<span class="type">int</span>&gt; <span class="title function_">wp</span><span class="params">(sp)</span>;            <span class="comment">// 通过shared_ptr创建weak_ptr</span></span><br></pre></td></tr></table></figure><p><strong>2. 使用weak_ptr</strong></p><p>要访问 weak_ptr 所观察的对象，需要将它临时升级为shared_ptr，这可以通过调用weak_ptr的lock方法实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">boost::<span class="built_in">shared_ptr</span>&lt;<span class="type">int</span>&gt; sp = wp.lock(); <span class="comment">// 尝试将weak_ptr升级为shared_ptr</span></span><br><span class="line"><span class="keyword">if</span> (sp) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *sp &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 安全使用</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;对象已被销毁&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 解决循环引用示例</strong></p><p>考虑两个类ClassA和ClassB，它们通过shared_ptr相互持有对方：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/shared_ptr.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassB</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassA</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    boost::<span class="built_in">shared_ptr</span>&lt;ClassB&gt; bPtr;</span><br><span class="line">    ~ClassA() &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ClassA destroyed\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassB</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    boost::<span class="built_in">shared_ptr</span>&lt;ClassA&gt; aPtr;</span><br><span class="line">    ~ClassB() &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ClassB destroyed\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    boost::<span class="built_in">shared_ptr</span>&lt;ClassA&gt; <span class="title function_">a</span><span class="params">(new ClassA())</span>;</span><br><span class="line">    boost::<span class="built_in">shared_ptr</span>&lt;ClassB&gt; <span class="title function_">b</span><span class="params">(new ClassB())</span>;</span><br><span class="line"></span><br><span class="line">    a-&gt;bPtr = b; <span class="comment">// a持有b的shared_ptr</span></span><br><span class="line">    b-&gt;aPtr = a; <span class="comment">// b持有a的shared_ptr，形成循环引用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，main 函数中创建了两个shared_ptr对象a和b，分别指向 ClassA 和ClassB 的新实例。然后，我们通过 a-&gt;bPtr &#x3D; b;和b-&gt;aPtr &#x3D; a;让这两个实例相互持有对方，从而创建了循环引用。</p><p>由于存在循环引用，当 main 函数执行完毕，尽管a和b的作用域结束，它们应该被销毁，但 ClassA 和 ClassB 的实例的引用计数并没有降到零（因为它们相互引用），导致析构函数没有被调用，从而引发内存泄漏。</p><p>如何解决？使用<code>weak_ptr</code>可以解决这个问题：</p><p>可以将其中一个类的shared_ptr成员改为weak_ptr。这样做可以打破循环引用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassB</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassA</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="comment">// 使用weak_ptr代替shared_ptr</span></span><br><span class="line">    boost::weak_ptr&lt;ClassB&gt; bPtr;</span><br><span class="line">    ~ClassA() &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ClassA destroyed\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassB</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    boost::<span class="built_in">shared_ptr</span>&lt;ClassA&gt; aPtr;</span><br><span class="line">    ~ClassB() &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ClassB destroyed\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    boost::<span class="built_in">shared_ptr</span>&lt;ClassA&gt; <span class="title function_">a</span><span class="params">(new ClassA())</span>;</span><br><span class="line">    boost::<span class="built_in">shared_ptr</span>&lt;ClassB&gt; <span class="title function_">b</span><span class="params">(new ClassB())</span>;</span><br><span class="line"></span><br><span class="line">    a-&gt;bPtr = b; <span class="comment">// ClassA中持有ClassB的弱引用</span></span><br><span class="line">    b-&gt;aPtr = a; <span class="comment">// ClassB中持有ClassA的强引用，形成非对称的引用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当main结束时，a和b的shared_ptr都会被销毁。</span></span><br><span class="line">    <span class="comment">// b的shared_ptr被销毁时，由于ClassA中持有的是ClassB的weak_ptr，不会阻止ClassB对象的销毁。</span></span><br><span class="line">    <span class="comment">// 因此，ClassB被销毁后，ClassA中的weak_ptr变为悬挂指针，但ClassA对象也会随之被安全销毁。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里大家只需要掌握这几种智能指针的简单使用即可，后面笔者有计划写一篇关于智能指针实现原理的文章，从源码实现的角度来讲解。帮助大家更好的理解智能指针。</p><h4 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h4><p>在C++中，内存泄漏是指程序分配的内存没有被正确释放，导致程序不再能够使用那部分内存。内存泄漏在长时间运行的程序中尤为危险，因为它们会逐渐消耗掉所有可用的内存资源，可能导致程序崩溃或系统变得缓慢。</p><h5 id="内存泄露的原因："><a href="#内存泄露的原因：" class="headerlink" title="内存泄露的原因："></a>内存泄露的原因：</h5><p>在C++中，内存泄露通常由以下几个原因引起：</p><ul><li><strong>动态分配内存未释放</strong>：使用new或malloc等分配内存后，未使用delete或free释放。</li><li><strong>资源未释放</strong>：除了内存外，文件句柄、数据库连接等资源未被关闭或释放也会造成资源泄露。</li><li><strong>循环引用</strong>：使用智能指针（如std::shared_ptr）时，不当的循环引用会导致对象无法被自动销毁。</li><li><strong>异常安全性问题</strong>：<br>当函数或方法在执行过程中抛出异常，而这个函数或方法之前进行了资源分配（如动态内存分配），如果没有正确地处理异常（例如通过异常安全的智能指针或try&#x2F;catch块来确保资源被释放），那么原本应该在函数结束时释放的资源可能会因为异常的抛出而遗漏。</li></ul><h5 id="内存泄露的检测："><a href="#内存泄露的检测：" class="headerlink" title="内存泄露的检测："></a>内存泄露的检测：</h5><p>检测内存泄露通常可以通过以下几种方式：</p><p><strong>1. 代码审查</strong>：通过审查代码逻辑，检查每次new的内存分配是否都有对应的delete释放。</p><p><strong>2. 运行时工具</strong>：</p><ul><li><p>Valgrind：Linux下一个强大的内存检测工具，能够检测出内存泄露、内存越界等问题。Valgrind的优点在于它不需要对程序进行重新编译，适用于几乎所有的二进制文件，但缺点是运行速度较慢，通常会让程序的执行速度降低10倍以上。</p></li><li><p>AddressSanitizer：一个快速的内存错误检测工具，能够检测出包括内存越界访问、使用后释放、堆栈缓冲区溢出等问题。与Valgrind相比，ASan的主要优点是执行速度快（一般只会让程序变慢2倍左右）和提供精确的错误信息，但它需要对程序进行重新编译并链接，并且增加了程序的内存需求。</p></li></ul><h5 id="如何避免内存泄漏？"><a href="#如何避免内存泄漏？" class="headerlink" title="如何避免内存泄漏？"></a>如何避免内存泄漏？</h5><p><strong>1. 限制动态内存的使用</strong></p><p>尽量减少动态内存分配的使用。许多情况下，可以通过使用栈分配的变量或标准容器来代替动态分配的内存。这不仅可以减少内存泄漏的风险，还可以提高程序的性能。</p><p><strong>2. 使用智能指针</strong>：尽量避免在代码中直接使用裸指针管理动态分配的内存。裸指针很容易导致内存泄漏，因为它们不会自动释放所指向的内存。如果确实需要使用指针，考虑使用<code>智能指针</code>来代替。</p><p><strong>3. 使用容器类</strong>：C++标准库提供了多种容器，如std::vector、std::list等，这些容器在内部管理内存，可以减少直接使用动态内存分配的需要。</p><p><strong>4. 使用对象池</strong>：<br>对于频繁创建和销毁的小对象，使用对象池可以是一个有效的解决方案。对象池预先分配一定数量的对象，并在需要时重用它们，从而避免了频繁的动态内存分配和释放。</p><p><strong>5. 定期检查和测试</strong>：使用内存检测工具定期检查程序，及早发现并修复内存泄漏问题。</p><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>C++中的异常处理是通过<code>try</code>、<code>catch</code>、<code>throw</code>关键字实现的，旨在处理程序运行时可能出现的错误和异常情况。使用异常处理可以使错误处理代码和正常业务逻辑分离，使程序结构更清晰，更易于维护。</p><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul><li><strong>throw</strong>：当检测到错误条件时，程序可以通过throw关键字抛出一个异常。抛出的异常可以是预定义的数据类型，也可以是自定义类型。</li><li><strong>try</strong>：try块包含可能抛出异常的代码。如果在try块中的代码抛出了异常，执行将跳转到相应的catch块。</li><li><strong>catch</strong>：catch块用于捕获和处理异常。可以定义多个catch块来捕获不同类型的异常。</li></ul><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><p>下面是一个简单的示例，演示了如何使用C++的异常处理机制：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">divide</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">        throw <span class="string">&quot;Division by zero error&quot;</span>; <span class="comment">// 抛出异常</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; divide(<span class="number">10</span>, <span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 正常情况</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; divide(<span class="number">10</span>, <span class="number">0</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 这里将抛出异常</span></span><br><span class="line">    &#125; catch (<span class="type">const</span> <span class="type">char</span>* msg) &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Error: &quot;</span> &lt;&lt; msg &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 捕获并处理异常</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中，divide函数在除数为零时抛出一个异常，main函数中的 try 块捕获并处理了这个异常。</p><h4 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h4><p>除了使用预定义类型作为异常外，C++还允许定义自定义异常类。通过继承标准的<code>exception</code>类来创建自定义异常更为方便：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义异常类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyException</span> :</span> public exception &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* <span class="title function_">what</span><span class="params">()</span> <span class="type">const</span> <span class="title function_">throw</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Custom error occurred&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        throw MyException();</span><br><span class="line">    &#125; catch (MyException&amp; e) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;MyException caught&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; e.what() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; catch (exception&amp; e) &#123;</span><br><span class="line">        <span class="comment">// 其他所有的异常</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，我们定义了一个名为MyException的自定义异常类，并在main函数中抛出和捕获了这个异常。自定义异常类通过覆写 what 方法提供了异常的描述信息。</p><p>通过合理使用C++的异常处理机制，可以有效地管理程序中的错误情况，提高程序的健壮性和可读性。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章旨在提供一个关于C++语言学习的指南，以帮助初学者系统地掌握C++编程的关键技能和概念。通过深入浅出的方式，我们逐步解析了C++开发的各个方面，从基础的数据类型、函数使用，到高级的面向对象编程技术，如类和对象的操作、封装、继承、以及多态等。</p><ul><li><p><strong>数据类型和函数</strong>：我们探讨了C++的基本数据类型、枚举、复合以及派生数据类型，这为理解C++提供了坚实的基础。同时，函数的定义、声明、调用以及参数传递等知识点，构建了函数编程的框架。</p></li><li><p><strong>面向对象编程</strong>：详细讨论了类和对象的定义、成员变量和函数、构造函数和析构函数等概念，强调了封装、继承和多态这三大面向对象编程的核心特性。特别地，通过this指针、友元、运算符重载的讲解，进一步拓展了面向对象的编程思维。</p></li><li><p><strong>高级特性</strong>：深入到模板编程，介绍了类型参数、非类型参数、函数模板、类模板以及模板的特化，这些内容展现了C++泛型编程的强大能力。同时，对C++中的内存管理、异常处理进行了探讨，了解了怎样编写高效且安全的C++代码。</p></li></ul><p>这篇文章主要是给大家提供一个如何快速学习 C++ 的指南，不知道怎样学习 C++ 的朋友可以 <strong>按照我列的知识点去看书，去实践，掌握 C++ 语言应该会很快的。记住：一定要多敲代码，多实践！！</strong></p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>如果单纯去学习C、C++语言是干不了任何事情的，作为与硬件和操作系统打交道的计算机底层语言，要想掌握 C和C++，你还得学习这几门课程：计算机组成原理、操作系统、数据结构。甚至还得了解汇编语言。除此之外，还需要学习 Linux 系统编程以及网络编程相关知识。</p><p>如果你想学习 Linux 编程，包括系统编程和网络编程相关的内容，可以关注我的公众号「跟着小康学编程」，这里会定时更新 计算机编程 相关的技术文章，感兴趣的读者可以关注一下。</p><p>另外：C&#x2F;C++、Java、Go语言，计算机组成原理、操作系统、数据结构与算法、计算机网络以及Linux 系统编程和网络编程、数据库等经典书籍的电子档 pdf 我已经为大家整理好了，想要获取的同学可以关注我的公众号「跟着小康学编程」，然后后台回复：pdf，即可获取。</p><p>另外，小康最近创建了一个技术交流群，专门用来探讨技术相关或者解答读者的问题。大家在阅读这篇文章的时候，如果觉得有问题的或者有不理解的知识点，欢迎大家加群或者评论区询问。我看到就会回复的。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言学习 </category>
          
          <category> C++ 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++入门 </tag>
            
            <tag> C++教程 </tag>
            
            <tag> C++快速学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入 C++11：从 auto 到 Lambda，解锁现代 C++ 的强大功能</title>
      <link href="/C++11/"/>
      <url>/C++11/</url>
      
        <content type="html"><![CDATA[<p>在介绍 C++11 之前，我们先回顾一下 C++98和C++03。C++98 作为 C++ 的第一个国际标准，奠定了这门语言的基础结构和核心特性，比如<strong>类、继承、模板、异常处理</strong>等。这些特性使得 C++ 成为一门强大的、面向对象的编程语言，广泛应用于系统&#x2F;应用软件、游戏开发、实时系统等领域。C++03 则是对 C++98 进行了修订，主要解决标准的疑义和错误，没有引入新特性。</p><p>然而，随着软件开发的不断进化，C++98和C++03 在表达能力、编程便利性和性能方面显示出了局限性。比如：<strong>对并发编程的支持不够强大，模板编程有时显得过于复杂，资源管理（尤其是内存管理）易于出错等</strong>。这些局限性促使了 C++11 标准的诞生，它被视为 C++ 的一次重大更新，于 2011 年正式发布。这次更新标志着 C++ 进入现代化的重要一步，引入了许多新特性和改进，旨在使 C++ 更易于使用，更灵活，同时提高了代码的安全性和性能。</p><p>另外，学习 C++11 新特性需要你有简单的 C、C++编程基础，还不了解的朋友可以看这两篇文章：<a href="https://mp.weixin.qq.com/s?__biz=MzkyNjQyMTMyOA==&mid=2247487373&idx=1&sn=6304025e2c0a846e97999e765667d866&chksm=c236d7b2f5415ea4b12b87fddf981abcd325d7458885aeade0957db5344da97f1b82d7e65cce&token=733890015&lang=zh_CN#rd">如何学习 C 语言</a>  和 <a href="https://mp.weixin.qq.com/s?__biz=MzkyNjQyMTMyOA==&mid=2247487758&idx=1&sn=1baa05f2c966eaa7623c8e48f152503d&chksm=c236c931f541402711b3130adeb3afc906af6ce954206cfe076e0c477e001d77fd041e802b3b&token=733890015&lang=zh_CN#rd">如何快速学习 C++</a>   ，文章通俗易懂而且有丰富的代码示例帮助理解。非常值得一看！！</p><p><strong>C++11 新增了很多新特性值得我们学习，包含如下</strong>：</p><p><img src="https://files.mdnice.com/user/48364/6fead36b-5fc0-4e44-b247-ee6ca9b8c83d.png"></p><h2 id="核心语言增强"><a href="#核心语言增强" class="headerlink" title="核心语言增强"></a>核心语言增强</h2><h3 id="自动类型推断-auto"><a href="#自动类型推断-auto" class="headerlink" title="自动类型推断 (auto)"></a>自动类型推断 (auto)</h3><p>auto 关键字让编译器能够自动推断变量的类型（通过变量初始化时的表达式来确定类型），简化了变量声明的语法。</p><h4 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> variable_name = expression;</span><br></pre></td></tr></table></figure><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = <span class="number">5</span>; <span class="comment">// x 是 int</span></span><br><span class="line"><span class="keyword">auto</span> y = <span class="number">3.14</span>; <span class="comment">// y 是 double</span></span><br></pre></td></tr></table></figure><h3 id="获取表达式的类型（decltype）"><a href="#获取表达式的类型（decltype）" class="headerlink" title="获取表达式的类型（decltype）"></a>获取表达式的类型（decltype）</h3><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">decltype(expression) variableName;</span><br></pre></td></tr></table></figure><p>这里，expression 是你要查询类型的表达式，而 variableName 是使用该表达式类型声明的变量名称。</p><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码:"></a>示例代码:</h4><p><strong>基础示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line">decltype(x) y = x; <span class="comment">// y 的类型是int</span></span><br></pre></td></tr></table></figure><p>在这个例子中，decltype(x)将y的类型推导为x的类型，即<code>int</code>。</p><p><strong>结合 auto 使用</strong>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto x = 1; // x 的类型是int</span><br><span class="line">decltype(x) y = x; // y 的类型也是int</span><br></pre></td></tr></table></figure><p><strong>用于复杂表达式</strong></p><p><code>decltype</code>  特别有用于表达式的类型不明显时：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">decltype(vec.begin()) it = vec.begin(); <span class="comment">// it 的类型是 std::vector&lt;int&gt;::iterator</span></span><br></pre></td></tr></table></figure><h3 id="基于范围的-for-循环"><a href="#基于范围的-for-循环" class="headerlink" title="基于范围的 for 循环"></a>基于范围的 for 循环</h3><p>C++11引入了基于范围的for循环（Range-based for loop），这是一个用于遍历序列（如数组、容器等）的语法糖。它简化了迭代序列中每个元素的代码书写方式，使代码更加简洁易读。</p><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法:"></a>基本语法:</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (declaration : range) &#123;</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>declaration</strong>：用于迭代序列中每个元素的变量声明。这个变量的类型可以是序列元素的类型，也可以是(auto)自动类型推导。</li><li><strong>range</strong>：要迭代的序列，可以是数组、容器（如std::vector、std::list等）或任何支持begin()和end()方法的对象。</li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h4><p><strong>遍历数组</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> element : <span class="built_in">array</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; element &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出: 1 2 3 4 5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>遍历容器（如std::vector）</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> element : vec) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; element &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出: 10 20 30 40 50</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用 auto 自动类型推导</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; words = &#123;<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span>, <span class="string">&quot;!&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> word : words) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; word &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出: Hello World !</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong>:</p><p>如果你需要在循环中修改序列中的元素，请使用引用<code>&amp;</code>来声明变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span>&amp; num : vec) &#123;</span><br><span class="line">    num *= <span class="number">2</span>; <span class="comment">// 修改元素值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不需要修改元素，并且元素类型较大时，考虑使用常量引用<code>const &amp;</code>来避免不必要的拷贝，提高效率。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; word : words) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; word &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>基于范围的for循环</strong>是 C++11 中引入的一项便利特性，通过简化集合的遍历操作，它让代码更加简洁，增强了代码的可读性和易用性。</p><h3 id="统一初始化"><a href="#统一初始化" class="headerlink" title="统一初始化"></a>统一初始化</h3><p>C++11 引入了统一初始化（Uniform Initialization），这是一种使用花括号 <code>&#123;&#125; </code>进行变量初始化的语法。它提供了一种一致的语法来初始化任何对象。</p><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法:"></a>语法:</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Type variable&#123;value1, value2, ...&#125;;</span><br></pre></td></tr></table></figure><p><strong>基本类型的初始化</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a&#123;<span class="number">10</span>&#125;;</span><br><span class="line"><span class="type">double</span> b&#123;<span class="number">3.14</span>&#125;;</span><br></pre></td></tr></table></figure><p><strong>聚合类型（如结构体和数组）的初始化</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line">Point p&#123;<span class="number">10</span>, <span class="number">20</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure><p><strong>容器的初始化</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure><p><strong>类对象的初始化</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    MyClass(<span class="type">int</span> x, <span class="type">double</span> y) : x_(x), y_(y) &#123;&#125;</span><br><span class="line">private:</span><br><span class="line">    <span class="type">int</span> x_;</span><br><span class="line">    <span class="type">double</span> y_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyClass obj&#123;<span class="number">5</span>, <span class="number">3.14</span>&#125;;</span><br></pre></td></tr></table></figure><h3 id="初始器列表（Initializer-Lists）"><a href="#初始器列表（Initializer-Lists）" class="headerlink" title="初始器列表（Initializer Lists）"></a>初始器列表（Initializer Lists）</h3><p>初始器列表是C++11引入的一项特性，它进一步扩展了统一初始化的能力，特别是对于容器和自定义类对象的初始化。它允许构造函数接收一个由花括号<code>&#123;&#125;</code>包围的元素列表，从而提供了一种简洁且强大的初始化方式。</p><h4 id="包含必要头文件"><a href="#包含必要头文件" class="headerlink" title="包含必要头文件"></a>包含必要头文件</h4><p>要使用初始器列表，你需要包含<code>&lt;initializer_list&gt;</code>头文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;initializer_list&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h4><p>初始器列表主要通过在类构造函数中使用<code>std::initializer_list&lt;T&gt;</code>类型的参数来实现，其中<code>T</code>是列表中元素的类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    ClassName(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;T&gt; <span class="built_in">list</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码:"></a>示例代码:</h4><p><strong>自定义类的初始器列表</strong></p><p>假设有一个代表简单整数集合的类，我们希望能够在创建对象时直接用一组整数来初始化这个集合：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntSet</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; elements;</span><br><span class="line">public:</span><br><span class="line">    IntSet(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="type">int</span>&gt; <span class="built_in">list</span>) : elements(<span class="built_in">list</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Initialized with elements: &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> elem : elements) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    IntSet mySet = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出: Initialized with elements: 1 2 3 4 5 </span></span><br></pre></td></tr></table></figure><p><strong>函数参数为初始器列表</strong>:</p><p>函数也可以接受<code>std::initializer_list&lt;T&gt;</code>类型的参数，这在需要传递一组值时非常有用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="type">int</span>&gt; vals)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> val : vals) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    print(&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出: 10 20 30 40 50 </span></span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><code>初始器列表（Initializer Lists）</code>为C++11提供了一种强大的初始化机制，特别是在初始化需要一组值的对象时。通过使用初始器列表，可以极大地简化代码，提高可读性和可维护性。这一特性在自定义类、函数参数传递时尤为有用。</p><h3 id="nullptr-关键字"><a href="#nullptr-关键字" class="headerlink" title="nullptr 关键字"></a>nullptr 关键字</h3><p>在 C++11 中，<code>nullptr</code> 是一个特殊的字面量，用于表示空指针。它是对之前 C++ 版本中使用整数 0 或宏 NULL 来表示空指针的改进。<code>nullptr</code> 的引入提供了一种类型安全的方式来表示没有指向任何对象的指针。</p><h4 id="定义及使用："><a href="#定义及使用：" class="headerlink" title="定义及使用："></a>定义及使用：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = nullptr;</span><br><span class="line"><span class="keyword">if</span> (ptr == nullptr) &#123;</span><br><span class="line">    <span class="comment">// 检查 ptr 是否为空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="为什么需要-nullptr？"><a href="#为什么需要-nullptr？" class="headerlink" title="为什么需要 nullptr？"></a>为什么需要 nullptr？</h4><ul><li><strong>类型安全</strong>：在 C++11 之前，NULL 通常被定义为 0，这意味着它实际上是一个整数。这可能导致类型混淆和错误，特别是在函数重载的情况下。<code>nullptr</code> 明确地表示一个空指针，不会与整数混淆。</li><li><strong>更好的语义</strong>：<code>nullptr</code> 直观地表示指针为空，改善了代码的可读性和意图表达。</li></ul><h4 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h4><p><strong>使用 nullptr 初始化指针</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = nullptr; <span class="comment">// ptr 是一个指向 int 的空指针</span></span><br></pre></td></tr></table></figure><p><strong>函数重载中 nullptr 的优势</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;func(int) called&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span>*)</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;func(int*) called&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    func(<span class="number">0</span>);        <span class="comment">// 调用 func(int)</span></span><br><span class="line">    func(nullptr);  <span class="comment">// 明确调用 func(int*)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，使用 <code>nullptr</code> 可以明确地调用接受指针参数的重载函数版本，避免了潜在的歧义。</p><p>通过引入<code>nullptr</code>，C++11 提高了代码的类型安全性和清晰度，明确区分了整数 0 和空指针的概念。</p><h3 id="长长整形（Long-Long-Int）"><a href="#长长整形（Long-Long-Int）" class="headerlink" title="长长整形（Long Long Int）"></a>长长整形（Long Long Int）</h3><p>在 C++11 之前，整型的最大大小受限于long int，其大小至少为32位。为了支持更大的整数，C++11引入了<code>long long int</code>和<code>unsigned long long int</code>类型，保证至少64位的大小。</p><h4 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="type">int</span> bigNumber = <span class="number">9223372036854775807LL</span>; <span class="comment">// LL 表示这是一个 long long 类型的字面量</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> bigUnsignedNumber = <span class="number">18446744073709551615ULL</span>; <span class="comment">// ULL 表示这是一个 unsigned long long 类型的字面量</span></span><br></pre></td></tr></table></figure><h3 id="无符号字面量"><a href="#无符号字面量" class="headerlink" title="无符号字面量"></a>无符号字面量</h3><p>无符号字面量就是用来表示无符号整数的字面量。在C++中，可以通过在整数后面添加<code>U</code>或<code>u</code>来创建无符号整型字面量。</p><p><strong>注意</strong>：字面量（Literal）是指在源代码中直接表示其值的固定值的表示法。字面量可以是数字、字符、字符串或其他固定值。</p><h4 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> x = <span class="number">123U</span>; <span class="comment">// U 表示无符号整数</span></span><br></pre></td></tr></table></figure><h3 id="用户自定义字面量"><a href="#用户自定义字面量" class="headerlink" title="用户自定义字面量"></a>用户自定义字面量</h3><p>C++11引入了用户自定义字面量（User-Defined Literals, UDL），允许开发者定义自己的字面量操作符，为字面量赋予新的含义。这通过定义一个以<code>_</code>开头的字面量操作符函数实现。</p><h4 id="语法：-1"><a href="#语法：-1" class="headerlink" title="语法："></a>语法：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return_type operator <span class="string">&quot;&quot;</span> _customSuffix(<span class="type">const</span> <span class="type">char</span>*);</span><br></pre></td></tr></table></figure><h4 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h4><p>定义一个将字符串转换为复数的自定义字面量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;complex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义自定义字面量 _i，用于创建复数</span></span><br><span class="line"><span class="built_in">std</span>::<span class="type">complex</span>&lt;<span class="type">double</span>&gt; operator<span class="string">&quot;&quot;</span> _i(<span class="type">long</span> <span class="type">double</span> d) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::<span class="type">complex</span>&lt;<span class="type">double</span>&gt;(<span class="number">0</span>, d); <span class="comment">// 第一个参数表示所构造复数的实部，第二个参数代表虚部。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">auto</span> c = <span class="number">3.14</span>_i; <span class="comment">// 使用自定义字面量创建一个复数，将会调用operator&quot;&quot; _i 函数</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Real part: &quot;</span> &lt;&lt; c.real() &lt;&lt; <span class="string">&quot;, Imaginary part: &quot;</span> &lt;&lt; c.imag() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>_i</code>是自定义的字面量操作符，它将跟随它的数字转换为一个复数。这使得代码更加直观和易于理解。</p><h3 id="强类型枚举-enum-class"><a href="#强类型枚举-enum-class" class="headerlink" title="强类型枚举 (enum class)"></a>强类型枚举 (enum class)</h3><p>C++11 引入了强类型枚举，也称为作用域枚举（scoped enums），使用 <code>enum class </code>关键字定义。与传统的枚举（unscoped enums）相比，强类型枚举具有更好的类型安全性，不会隐式地转换为整型，枚举值必须在作用域内访问，并且可以指定底层类型。</p><h4 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">EnumName</span> :</span> UnderlyingType &#123;</span><br><span class="line">    enumerator1,</span><br><span class="line">    enumerator2,</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>EnumName</strong> 是枚举类型的名称。</li><li><strong>UnderlyingType</strong> 是用来表示枚举值的底层类型，通常是某种整型（如int、unsigned int、short等）。如果没有该字段，则底层类型默认为 int</li></ul><h4 id="强类型枚举定义"><a href="#强类型枚举定义" class="headerlink" title="强类型枚举定义"></a>强类型枚举定义</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">Color</span> :</span> <span class="type">unsigned</span> <span class="type">int</span> &#123;</span><br><span class="line">    Red,</span><br><span class="line">    Green,</span><br><span class="line">    Blue</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">StatusCode</span> :</span> <span class="type">char</span> &#123;</span><br><span class="line">    Ok = <span class="string">&#x27;O&#x27;</span>,</span><br><span class="line">    Error = <span class="string">&#x27;E&#x27;</span>,</span><br><span class="line">    Unknown = <span class="string">&#x27;U&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="简单例子"><a href="#简单例子" class="headerlink" title="简单例子"></a>简单例子</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 传统枚举</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span> &#123;</span> Red, Green, Blue &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 强类型枚举  底层类型为 int</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">StrongColor</span> &#123;</span> Red, Green, Blue &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Color c = Red; <span class="comment">// 直接访问</span></span><br><span class="line">    <span class="comment">// StrongColor sc = Red; // 错误：Red 不在作用域内</span></span><br><span class="line">    StrongColor sc = StrongColor::Red; <span class="comment">// 正确：使用作用域访问</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// int colorInt = sc; // 错误：不能隐式转换为整型</span></span><br><span class="line">    <span class="type">int</span> colorInt = static_cast&lt;<span class="type">int</span>&gt;(sc); <span class="comment">// 正确：需要显式转换</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; colorInt &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出：0，假设 StrongColor::Red 底层对应的整数值为 0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，强类型枚举 StrongColor 的使用增加了类型安全性，避免了与整型之间的隐式转换，并且强制使用枚举类名作为作用域来访问枚举值。这些特性有助于避免命名冲突和提高代码清晰度。</p><h3 id="常量表达式-constexpr"><a href="#常量表达式-constexpr" class="headerlink" title="常量表达式 (constexpr)"></a>常量表达式 (constexpr)</h3><p>C++11 引入了 <code>constexpr</code> 关键字，用于定义常量表达式。这个关键字可以用于变量、函数和构造函数，允许在编译时进行计算，而不是运行时。这对于提高程序的性能非常有用，因为它允许在编译期间执行更多的计算，减少运行时的工作量。</p><h4 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h4><p><strong>定义常量表达式变量</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// type 变量类型</span></span><br><span class="line">constexpr type variable = value;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义常量</span></span><br><span class="line">constexpr <span class="type">int</span> max_size = <span class="number">100</span>; </span><br></pre></td></tr></table></figure><p><strong>定义常量表达式函数</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// type 函数的返回值类型</span></span><br><span class="line">constexpr type <span class="title function_">function_name</span><span class="params">(parameters)</span> &#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">定义常量表达式函数：</span><br><span class="line">constexpr <span class="type">int</span> <span class="title function_">square</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>常量表达式函数必须返回一个常量表达式，函数体中只能有一条返回语句，且不能包含任何形式的循环、分支（除了条件运算符）等。</p><p><strong>声明类构造函数</strong>：允许类类型在编译时被初始化。构造函数体必须为空，所有成员初始化都必须使用常量表达式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    constexpr <span class="title function_">Point</span><span class="params">(<span class="type">double</span> xVal = <span class="number">0</span>, <span class="type">double</span> yVal = <span class="number">0</span>)</span> : <span class="title function_">x</span><span class="params">(xVal)</span>, <span class="title function_">y</span><span class="params">(yVal)</span> &#123;&#125;</span><br><span class="line">    constexpr <span class="type">double</span> <span class="title function_">getX</span><span class="params">()</span> <span class="type">const</span> &#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">    constexpr <span class="type">double</span> <span class="title function_">getY</span><span class="params">()</span> <span class="type">const</span> &#123; <span class="keyword">return</span> y; &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    <span class="type">double</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  constexpr Point <span class="title function_">p</span><span class="params">(<span class="number">9.0</span>, <span class="number">27.0</span>)</span>;</span><br><span class="line">  constexpr <span class="type">double</span> x = p.getX(); <span class="comment">// 在编译时计算</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用-constexpr-的优点包括："><a href="#使用-constexpr-的优点包括：" class="headerlink" title="使用 constexpr 的优点包括："></a>使用 constexpr 的优点包括：</h4><ul><li><strong>性能提升</strong>：通过在编译时而不是运行时计算值，可以提高程序的运行效率。</li><li><strong>类型安全</strong>：与宏相比，<code>constexpr</code> 提供了更强的类型安全。</li><li><strong>更广泛的用途</strong>：<code>constexpr</code> 变量、函数和对象可以用在需要编译时常量的上下文中，如数组大小、模板参数等。</li></ul><h3 id="默认和删除函数"><a href="#默认和删除函数" class="headerlink" title="默认和删除函数"></a>默认和删除函数</h3><p>C++11引入了两个重要的特性：允许显式地声明默认构造函数和析构函数，以及允许删除函数。这些特性提供了对类行为更细致的控制，特别是在管理资源、实现单例模式或防止对象拷贝时非常有用。</p><h4 id="默认函数（-default）"><a href="#默认函数（-default）" class="headerlink" title="默认函数（&#x3D; default）"></a>默认函数（&#x3D; default）</h4><p>在C++11之前，如果你希望类有一个默认的构造函数、拷贝构造函数、拷贝赋值运算符或析构函数，你通常不需要做任何事情；编译器会为你自动生成这些。然而，一旦你定义了任何构造函数，编译器就不会自动生成默认构造函数了。C++11通过<code>= default</code>关键字允许你显式地要求编译器为你生成这些函数，即使你已经定义了其他构造函数。</p><p><strong>语法</strong>: </p><p><strong>使用关键字 <code>= default</code> 来声明</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    ClassName() = <span class="keyword">default</span>; <span class="comment">// 默认构造函数</span></span><br><span class="line">    ClassName(<span class="type">const</span> ClassName&amp;) = <span class="keyword">default</span>; <span class="comment">// 默认拷贝构造函数</span></span><br><span class="line">    ClassName&amp; operator=(<span class="type">const</span> ClassName&amp;) = <span class="keyword">default</span>; <span class="comment">// 默认拷贝赋值运算符</span></span><br><span class="line">    ~ClassName() = <span class="keyword">default</span>; <span class="comment">// 默认析构函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>代码示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    MyClass() = <span class="keyword">default</span>; <span class="comment">// 显式声明使用编译器生成的默认构造函数</span></span><br><span class="line">    MyClass(<span class="type">int</span> value) : data(value) &#123;&#125; <span class="comment">// 自定义构造函数</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">private:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="删除函数（-delete）"><a href="#删除函数（-delete）" class="headerlink" title="删除函数（&#x3D; delete）"></a>删除函数（&#x3D; delete）</h4><p>C++11允许你显式地禁用类的某些函数（比如拷贝构造函数或拷贝赋值运算符），只需将它们声明为<code>= delete</code>。这对于防止对象被无意拷贝或赋值非常有用，尤其在设计只能移动不能拷贝的资源管理类时。</p><p><strong>语法</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    ClassName(<span class="type">const</span> ClassName&amp;) = delete; <span class="comment">// 禁用拷贝构造函数</span></span><br><span class="line">    ClassName&amp; operator=(<span class="type">const</span> ClassName&amp;) = delete; <span class="comment">// 禁用拷贝赋值运算符</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>代码示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NonCopyable</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    NonCopyable() = <span class="keyword">default</span>;</span><br><span class="line">    NonCopyable(<span class="type">const</span> NonCopyable&amp;) = delete; <span class="comment">// 禁止拷贝</span></span><br><span class="line">    NonCopyable&amp; operator=(<span class="type">const</span> NonCopyable&amp;) = delete; <span class="comment">// 禁止赋值</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结:"></a>总结:</h4><p><code>= default</code>和<code>= delete</code>是C++11中引入的两个关键特性，它们提供了对类默认行为的显式控制。通过<code>= default</code>，你可以明确地告诉编译器为类生成默认的构造函数、析构函数或拷贝&#x2F;赋值运算符，即使定义了其他构造函数。通过<code>= delete</code>，你可以防止类的拷贝或赋值，这在设计不可拷贝的资源管理类或单例类时特别有用。这两个特性让类的设计意图更加清晰，同时也有助于避免潜在的错误。</p><h3 id="委托构造函数"><a href="#委托构造函数" class="headerlink" title="委托构造函数"></a>委托构造函数</h3><p>在 C++11 中，委托构造函数（Delegating Constructors）是一种允许一个构造函数在同一个类中调用另一个构造函数的功能，目的是为了减少代码重复，提高代码复用性。这允许构造函数之间的代码共享，从而避免在每个构造函数中重复相同的初始化代码。</p><h4 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h4><p>委托构造函数的语法相当直接，就是在构造函数的初始化列表中调用同一个类的另一个构造函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    ClassName(参数列表) : ClassName(其他参数列表) &#123;</span><br><span class="line">        <span class="comment">// 构造函数体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里，构造函数通过在其初始化列表中调用另一个构造函数（即委托给另一个构造函数），实现对对象的初始化。</p><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><p>考虑一个简单的 Rectangle 类，它有两个成员变量：长度和宽度。我们可以使用委托构造函数来确保所有的构造逻辑都通过一个主要的构造函数来执行，避免代码的重复。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="comment">// 主构造函数</span></span><br><span class="line">    Rectangle(<span class="type">double</span> width, <span class="type">double</span> height) : width(width), height(height) &#123;</span><br><span class="line">        <span class="comment">// 这里可以包含一些特定的初始化逻辑</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Rectangle(double, double)&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 委托构造函数，委托给主构造函数</span></span><br><span class="line">    Rectangle(<span class="type">double</span> side) : Rectangle(side, side) &#123;</span><br><span class="line">        <span class="comment">// 注意：这里的初始化逻辑会在主构造函数之后执行</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Rectangle(double)&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">area</span><span class="params">()</span> <span class="type">const</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Area: &quot;</span> &lt;&lt; width * height &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    <span class="type">double</span> width, height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Rectangle <span class="title function_">square</span><span class="params">(<span class="number">5</span>)</span>; <span class="comment">// 使用委托构造函数</span></span><br><span class="line">    square.area(); <span class="comment">// 输出: Area: 25</span></span><br><span class="line">    </span><br><span class="line">    Rectangle <span class="title function_">rectangle</span><span class="params">(<span class="number">4</span>, <span class="number">5</span>)</span>; <span class="comment">// 使用主构造函数</span></span><br><span class="line">    rectangle.area(); <span class="comment">// 输出: Area: 20</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，Rectangle类有三个构造函数：</p><ul><li>一个是接受两个参数（宽度和高度）的主构造函数。</li><li>另外两个是委托构造函数，一个不带参数，默认构造一个宽度和高度都为0的矩形；另一个只带一个参数，构造一个正方形。</li></ul><p>这样的设计让构造函数的初始化逻辑更加集中，如果需要修改初始化逻辑，只需要修改主构造函数即可，提高了代码的可维护性。</p><h3 id="继承构造函数"><a href="#继承构造函数" class="headerlink" title="继承构造函数"></a>继承构造函数</h3><p>在C++11中，引入了<strong>继承构造函数</strong>的概念，这允许派生类继承并直接使用基类的构造函数，而不需要在派生类中重新定义相同的构造函数。这个特性通过简化代码，避免不必要的重复，提高了代码的可维护性。</p><h4 id="语法-6"><a href="#语法-6" class="headerlink" title="语法"></a>语法</h4><p>要在派生类中继承基类的构造函数，你可以使用<code>using</code> 声明。基本语法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> public Base &#123;</span><br><span class="line">public:</span><br><span class="line">    using Base::Base;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里，Derived 类通过 <code>using Base::Base;</code>声明，继承了 Base 类所有的构造函数。</p><h4 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h4><p>考虑以下基类Person，它有一个构造函数，接受一个表示人名的字符串参数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    Person(<span class="built_in">std</span>::<span class="built_in">string</span> n) : name(n) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Person(&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在，我们定义一个 Employee 类，它是 Person 的派生类，并且我们想让 Employee 类能够直接使用 Person 类的构造函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> :</span> public Person &#123;</span><br><span class="line">public:</span><br><span class="line">    using Person::Person; <span class="comment">// 继承构造函数</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">printName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Employee Name: &quot;</span> &lt;&lt; name &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接着，我们可以这样使用 Employee 类：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Employee <span class="title function_">emp</span><span class="params">(<span class="string">&quot;John Doe&quot;</span>)</span>;</span><br><span class="line">    emp.printName(); <span class="comment">// 输出：Employee Name: John Doe</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，Employee 类继承了 Person 类的构造函数，所以我们可以直接使用一个字符串参数来构造 Employee 对象。这就避免了在 Employee 类中重新定义一个接受相同参数的构造函数。</p><h3 id="显式虚函数重载-override"><a href="#显式虚函数重载-override" class="headerlink" title="显式虚函数重载(override)"></a>显式虚函数重载(override)</h3><p>C++11引入了一种新的方式来控制虚函数的重载，称为“显式虚函数重载”(Explicit Virtual Function Override)。这通过在派生类中的成员函数声明时使用<code>override</code>关键字实现。这个关键字明确指出一个成员函数意图重写一个基类的虚函数。使用<code>override</code>可以提高代码的可读性，并且帮助编译器检查派生类是否真正重载了基类中的虚函数，避免因拼写错误或函数签名不匹配而导致的问题。</p><h4 id="语法：-2"><a href="#语法：-2" class="headerlink" title="语法："></a>语法：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    virtual <span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> public Base &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">func</span><span class="params">()</span> override; <span class="comment">// 明确指明重载基类的虚函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    virtual <span class="type">void</span> <span class="title function_">sayHello</span><span class="params">()</span>  &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hello from Base&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> public Base &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">sayHello</span><span class="params">()</span>  override &#123; <span class="comment">// 正确重载 Base 的 sayHello</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hello from Derived&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Base* base = new Derived();</span><br><span class="line">    base-&gt;sayHello(); <span class="comment">// 输出: Hello from Derived</span></span><br><span class="line">    delete base;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，Derived 类通过 <code>override</code> 关键字明确表示 sayHello 函数重写了 Base 类中的虚函数。如果签名不匹配，编译器将报错。</p><h3 id="final-关键字"><a href="#final-关键字" class="headerlink" title="final 关键字"></a>final 关键字</h3><p>在C++11中，<code>final</code>关键字被引入作为类和虚函数的新修饰符。当<code>final</code>用于类时，它阻止该类被继承。当用于虚函数时，它阻止该函数在派生类中被进一步重写。这提供了一种明确表达设计意图的方式，并能够避免不必要的运行时错误。</p><h4 id="用于类"><a href="#用于类" class="headerlink" title="用于类"></a>用于类</h4><p>当 <code>final</code> 用于一个类时，任何尝试继承该类的行为都将导致编译错误。</p><p><strong>语法</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> <span class="keyword">final</span> &#123;</span> </span><br><span class="line">  <span class="comment">/* 类定义实现 */</span>  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>代码示例</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> <span class="keyword">final</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> public Base &#123; <span class="comment">// 这将导致编译错误</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个示例中，尝试从 Base 类派生 Derived 类会导致编译错误，因为 Base 类被标记为 final。</p><h4 id="用于虚函数"><a href="#用于虚函数" class="headerlink" title="用于虚函数"></a>用于虚函数</h4><p>当 <code>final</code> 用于虚函数时，它表示该函数不能在任何派生类中被重写。</p><p><strong>语法</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virtual <span class="type">void</span> <span class="title function_">function</span><span class="params">()</span> final;</span><br></pre></td></tr></table></figure><p><strong>示例</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    virtual <span class="type">void</span> <span class="title function_">show</span><span class="params">()</span> final &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base show&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> public Base &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">show</span><span class="params">()</span> override &#123; <span class="comment">// 这将导致编译错误</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Derived show&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个示例中，Derived 类尝试重写 Base 类中的 show 函数会导致编译错误，因为 show 函数在 Base 类中被标记为 final。</p><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景:"></a>使用场景:</h4><p>final关键字的使用场景主要包括：</p><ul><li><strong>性能优化</strong>：防止类的继承或虚函数的重写可以让编译器进行更多的优化，因为编译器知道没有更多的派生类或重写的函数需要考虑。</li><li><strong>设计安全</strong>：当你的设计不希望或不需要继承或重写时，使用final可以防止其他开发者不小心破坏你的设计意图。</li></ul><p>final关键字的引入增强了C++的类型安全性和性能优化能力，同时也提供了更明确的类设计意图表达方式。</p><h3 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h3><p>C++11 引入了 Lambda 表达式，为 C++ 程序员提供了一种方便的匿名函数对象创建方式。Lambda 表达式广泛用于简化代码，尤其是在需要小段函数逻辑作为参数传递给算法或线程时。</p><h4 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h4><p><strong>Lambda 表达式的基本语法如下</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[ capture ] ( parameters ) -&gt; return_type &#123;</span><br><span class="line">    <span class="comment">// Function body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>capture</strong>：捕获列表，定义了 Lambda 函数体外部变量的访问方式。可以是值捕获、引用捕获或隐式捕获等。</li><li><strong>parameters</strong>：参数列表，与普通函数的参数列表相同。可以为空。</li><li><strong>return_type</strong>：返回类型，可以省略，编译器会自动推导返回类型。</li><li><strong>Function body</strong>：函数体，包含了 Lambda 表达式的逻辑。</li></ul><p><strong>示例</strong>:</p><p><strong>1. 基本Lambda表达式</strong></p><p>不带参数，自动推导返回类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> greet = []() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hello, World!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;;</span><br><span class="line">greet();  <span class="comment">// 调用Lambda表达式</span></span><br></pre></td></tr></table></figure><p><strong>2. 带参数的Lambda表达式</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> add = [](<span class="type">int</span> x, <span class="type">int</span> y) &#123; <span class="keyword">return</span> x + y; &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;3 + 4 = &quot;</span> &lt;&lt; add(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p><strong>3. 指定返回类型的Lambda表达式</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> divide = [](<span class="type">double</span> x, <span class="type">double</span> y) -&gt; <span class="type">double</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (y == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 防止除以0</span></span><br><span class="line">    <span class="keyword">return</span> x / y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;5.0 / 2.0 = &quot;</span> &lt;&lt; divide(<span class="number">5.0</span>, <span class="number">2.0</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p><strong>4. 捕获外部变量</strong></p><p>值捕获：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">4</span>;</span><br><span class="line"><span class="comment">// [x] 以值的方式捕获变量x</span></span><br><span class="line"><span class="keyword">auto</span> square = [x]() &#123; <span class="keyword">return</span> x * x; &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Square of 4 is &quot;</span> &lt;&lt; square() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>引用捕获：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::for_each(numbers.begin(), numbers.end(), [&amp;total](<span class="type">int</span> x) &#123;</span><br><span class="line">    total += x;  <span class="comment">// &#x27;total&#x27;通过引用捕获，可以修改其值</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Total: &quot;</span> &lt;&lt; total &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p><strong>5. 捕获所有外部变量</strong></p><p>使用<code>[=]</code>捕获所有外部变量（通过值），使用<code>[&amp;]</code>捕获所有外部变量（通过引用）。</p><p><strong>总结</strong>:</p><p>Lambda表达式是C++11中引入的强大特性，它提供了一种便捷的方式来定义和使用匿名函数。通过捕获列表，Lambda表达式可以捕获并使用定义它们的作用域中的变量。Lambda表达式广泛应用于标准库算法、异步编程和事件处理等场景。</p><h3 id="尾返回类型"><a href="#尾返回类型" class="headerlink" title="尾返回类型"></a>尾返回类型</h3><p>C++11引入了尾返回类型（Trailing Return Type）的概念，允许开发者将函数的返回类型声明在函数参数列表之后。这在某些情况下，尤其是当返回类型依赖于函数参数类型的时候，变得非常有用。使用尾返回类型，你可以利用<code>auto</code>关键字和<code>-&gt;</code>运算符来指定返回类型。</p><h4 id="尾返回类型的基本语法"><a href="#尾返回类型的基本语法" class="headerlink" title="尾返回类型的基本语法"></a>尾返回类型的基本语法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> <span class="title function_">functionName</span><span class="params">(parameters)</span> -&gt; returnType;</span><br></pre></td></tr></table></figure><p>这里，<code>returnType</code>是一个类型表达式，它描述了函数的返回类型，并且它可以使用函数参数。</p><h4 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码:"></a>示例代码:</h4><p><strong>简单示例</strong>:</p><p>在最简单的形式中，尾返回类型让函数的声明更清晰：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> -&gt; <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管在这个简单例子中使用尾返回类型可能看起来没有必要，它展示了基本的语法结构。</p><p><strong>依赖于模板参数的返回类型</strong>:</p><p>尾返回类型特别有用于模板编程中，当函数的返回类型依赖于其模板参数时：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T, typename U&gt;</span><br><span class="line"><span class="keyword">auto</span> <span class="title function_">add</span><span class="params">(T x, U y)</span> -&gt; <span class="title function_">decltype</span><span class="params">(x + y)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，add 函数的返回类型是 T 和 U 类型相加的结果类型。使用 decltype 关键字和尾返回类型，我们可以精确地指定这个返回类型。</p><p><strong>使用于lambda表达式</strong>:</p><p>尾返回类型同样适用于C++11中的 lambda 表达式，允许在更复杂的场景下指定返回类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> getLambda = []() -&gt; <span class="built_in">std</span>::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> [](<span class="type">int</span> x, <span class="type">int</span> y) -&gt; <span class="type">int</span> &#123; <span class="keyword">return</span> x + y; &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个例子中，getLambda是一个返回类型为std::function&lt;int(int, int)&gt;的 lambda 表达式，它本身返回另一个计算两个整数和的 lambda 表达式。</p><p><strong>为什么需要尾返回类型</strong>?</p><p>在C++11之前，函数的返回类型必须在函数名之前声明，这在大多数情况下工作得很好。然而，对于返回类型依赖于函数参数的情况（特别是模板编程中），这种方法就显得力不从心了。尾返回类型提供了一种灵活的方式来声明这些依赖于参数的返回类型，使得函数签名更加清晰和灵活。</p><p>尾返回类型是现代C++（C++11及以后版本）中推荐的一种高级特性，它在编写泛型代码和lambda表达式时特别有用。通过这种方式，C++程序员可以编写出更清晰、更灵活、更安全的代码。</p><h3 id="内联命名空间（Inline-Namespaces）"><a href="#内联命名空间（Inline-Namespaces）" class="headerlink" title="内联命名空间（Inline Namespaces）"></a>内联命名空间（Inline Namespaces）</h3><p>C++11引入了内联命名空间（Inline Namespaces）的概念，这是一种特殊的命名空间，其成员在外层命名空间中也可以直接访问，无需通过内联命名空间的名称。这个特性主要用于版本控制和兼容性，允许库开发者在不破坏现有代码基础上引入新版本的API。</p><h4 id="语法-7"><a href="#语法-7" class="headerlink" title="语法"></a>语法</h4><p>使用<code>inline</code>关键字来定义内联命名空间：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">namespace outer &#123;</span><br><span class="line">    <span class="keyword">inline</span> namespace inner &#123;</span><br><span class="line">        <span class="comment">// void func() &#123;&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，inner是一个内联命名空间，outer是它的外层命名空间。由于inner被声明为内联的，所以outer命名空间中的代码可以直接访问 inner 中的成员，无需显式地通过 inner 命名空间的名称。</p><h4 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a>代码示例</h4><p>假设我们有一个库，该库提供了一个函数 foo。随着时间的推移，库的版本更新，我们添加了一个新的实现，但我们想保持对旧版本的兼容。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">namespace Library &#123;</span><br><span class="line">    <span class="comment">// 旧版本</span></span><br><span class="line">    namespace Version1 &#123;</span><br><span class="line">        <span class="type">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Version 1 of foo\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新版本</span></span><br><span class="line">    <span class="keyword">inline</span> namespace Version2 &#123;</span><br><span class="line">        <span class="type">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Version 2 of foo\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Library::foo(); <span class="comment">// 直接访问最新版本</span></span><br><span class="line">    Library::Version1::foo(); <span class="comment">// 显式访问旧版本</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，Version2 是一个内联命名空间。当我们调用 Library::foo() 时，由于 Version2 是内联的，编译器会直接在 Library 的内联命名空间中查找 foo 函数，因此调用的是 Version2 中的 foo。如果需要显式调用旧版本的 foo 函数，可以通过完整的命名空间路径 Library::Version1::foo() 来实现。</p><h4 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h4><p>内联命名空间的一个典型应用场景是库版本管理。通过将最新版本的定义放在内联命名空间中，库的用户可以不做任何修改地自动使用最新版本的功能。同时，如果需要引用特定版本的定义，也可以通过指定命名空间的名称来实现。</p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项:"></a>注意事项:</h4><ul><li>一个命名空间内只能有一个内联命名空间是活跃的，也就是说，如果有多个内联命名空间，只有最后一个声明为内联的命名空间才会被视为活跃的。</li><li>内联命名空间主要用于版本控制和向后兼容性，不推荐在日常编程中过度使用。</li></ul><p>内联命名空间提供了一种优雅的方式来处理库和应用程序在不同版本间的平滑过渡和兼容性问题，是 C++11 中对库设计者非常有用的一个特性。</p><h3 id="静态断言（static-assert）"><a href="#静态断言（static-assert）" class="headerlink" title="静态断言（static_assert）"></a>静态断言（static_assert）</h3><p>C++11 引入了<strong>静态断言（static_assert）</strong>，这是一种在编译时进行断言检查的机制。静态断言让开发者能够在编译期间检查表达式是否为真，如果表达式结果为假，则编译器会产生一个编译错误并显示开发者提供的消息。这个特性特别适合用于检查模板参数、常量表达式、等编译时信息，以确保代码的正确性和类型安全。</p><h4 id="语法-8"><a href="#语法-8" class="headerlink" title="语法"></a>语法</h4><p>static_assert 的基本语法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static_assert</span>(常量表达式, 错误消息);</span><br></pre></td></tr></table></figure><ul><li><strong>常量表达式</strong>：需要在编译时求值的表达式，结果为布尔值。如果表达式的结果为 false，则编译器会产生一个错误。</li><li><strong>错误消息</strong>：这是一个字符串字面量，用于在常量表达式的求值结果为 false 时提供错误信息。</li></ul><h4 id="示例代码-3"><a href="#示例代码-3" class="headerlink" title="示例代码:"></a>示例代码:</h4><p><strong>检查类型大小</strong> : 使用 <code>static_assert</code> 来确保特定类型的大小符合预期：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static_assert</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) == <span class="number">4</span>, <span class="string">&quot;int类型必须是4字节大小&quot;</span>);</span><br></pre></td></tr></table></figure><p>这个static_assert会检查 int 类型是否是4字节（32位）大小。如果在某些平台上 int 不是4字节大小，编译器将会报错。</p><p><strong>模板参数约束</strong>:<br>在模板编程中，static_assert 可以用来约束模板参数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> &#123;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    std::is_arithmetic&lt;T&gt;::value 用于在编译时检查一个类型是否为算术类型（即整数类型和浮点类型）。</span></span><br><span class="line"><span class="comment">    如果类型是算术类型，std::is_arithmetic&lt;T&gt;::value会是true，否则是false。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">static_assert</span>(<span class="built_in">std</span>::is_arithmetic&lt;T&gt;::value, <span class="string">&quot;MyArray只能用于算术类型&quot;</span>);</span><br><span class="line">    <span class="comment">// 类实现...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个例子中，static_assert用来确保MyArray模板只能用于算术类型（如int、float等）。如果尝试用非算术类型实例化MyArray，编译器将报错。</p><p><strong>验证编译时条件</strong>:<br>static_assert 也可以用于验证其他编译时能够确定的条件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">constexpr <span class="type">int</span> <span class="title function_">getNumber</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="number">5</span>; &#125;</span><br><span class="line"><span class="keyword">static_assert</span>(getNumber() == <span class="number">5</span>, <span class="string">&quot;函数getNumber必须返回5&quot;</span>);</span><br></pre></td></tr></table></figure><p>这里，static_assert验证getNumber函数是否总是返回5。由于getNumber被声明为constexpr，它的返回值可以在编译时确定，因此适合用于static_assert。</p><h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><p>C++11引入了<code>右值引用</code>，这是一个指向临时对象（即右值）的引用，允许开发者安全地从临时对象中移动数据，而不仅仅是复制。这个特性是实现<code>移动语义</code>（Move Semantics）和<code>完美转发</code>（Perfect Forwarding）的基础，对于提高程序性能尤其在涉及大量数据操作时非常关键。</p><h4 id="语法-9"><a href="#语法-9" class="headerlink" title="语法:"></a>语法:</h4><p>右值引用使用<code>&amp;&amp;</code>符号来声明。与左值引用（使用<code>&amp;</code>）不同，右值引用绑定到临时对象上。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Type&amp;&amp; name = expression;</span><br></pre></td></tr></table></figure><ul><li><strong>Type</strong>：变量的类型。</li><li><strong>name</strong>：变量的名称。</li><li><strong>expression</strong>：必须是一个右值表达式，通常是一个临时对象或者是通过<code>std::move</code>转换的。</li></ul><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><p><strong>简单的右值引用示例</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp;&amp; rref = <span class="number">5</span>; <span class="comment">// 5 是一个整数字面量，是右值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 std::move 转换左值为右值引用</span></span><br><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp;&amp; moved_x = <span class="built_in">std</span>::move(x);</span><br></pre></td></tr></table></figure><p>右值引用主要用于实现<code>移动语义和完美转发</code>。</p><h3 id="移动语义（Move-Semantics）"><a href="#移动语义（Move-Semantics）" class="headerlink" title="移动语义（Move Semantics）"></a>移动语义（Move Semantics）</h3><p>移动语义是 C++11 引入的一项重要特性，它允许资源（如动态分配的内存）在对象之间转移，而不是复制。这一特性显著提高了性能，尤其是在处理大型数据对象时，因为它避免了不必要的复制操作。移动语义主要通过两个新的构造函数实现：<strong>移动构造函数和移动赋值操作符</strong>，它们都使用了右值引用这一特性。</p><h4 id="移动构造函数"><a href="#移动构造函数" class="headerlink" title="移动构造函数"></a>移动构造函数</h4><p>移动构造函数允许从一个即将被销毁的对象中“窃取”资源。它的参数是该对象类型的右值引用。</p><p><strong>语法</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ClassName 表示类名</span></span><br><span class="line">ClassName(ClassName&amp;&amp; other) ;</span><br></pre></td></tr></table></figure><h4 id="移动赋值操作符"><a href="#移动赋值操作符" class="headerlink" title="移动赋值操作符"></a>移动赋值操作符</h4><p>移动赋值操作符允许将一个即将被销毁的对象的资源赋值给另一个对象。它的参数也是该对象类型的右值引用。</p><p><strong>语法</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassName&amp; operator=(ClassName&amp;&amp; other) ;</span><br></pre></td></tr></table></figure><h4 id="示例代码-4"><a href="#示例代码-4" class="headerlink" title="示例代码"></a>示例代码</h4><p>假设有一个简单的 Buffer 类，它管理一块动态分配的内存：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Buffer</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    Buffer(<span class="type">size_t</span> size) : size(size), data(new <span class="type">int</span>[size]) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 移动构造函数</span></span><br><span class="line">    Buffer(Buffer&amp;&amp; other) noexcept : size(other.size), data(other.data) &#123;</span><br><span class="line">        other.data = nullptr; <span class="comment">// 防止析构时释放内存</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 移动赋值操作符</span></span><br><span class="line">    Buffer&amp; operator=(Buffer&amp;&amp; other) noexcept &#123;</span><br><span class="line">        <span class="keyword">if</span> (this != &amp;other) &#123;</span><br><span class="line">            delete[] data; <span class="comment">// 释放原来的资源</span></span><br><span class="line">            data = other.data; <span class="comment">// 窃取资源</span></span><br><span class="line">            size = other.size;</span><br><span class="line">            other.data = nullptr; <span class="comment">// 防止析构时释放内存</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *this;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~Buffer() &#123; delete[] data; &#125;</span><br><span class="line">    </span><br><span class="line">private:</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">    <span class="type">int</span>* data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个例子中，Buffer 类定义了一个移动构造函数和一个移动赋值操作符。当一个 Buffer 对象通过移动构造函数或移动赋值操作符与另一个 Buffer 对象交互时，它实际上是从源对象窃取了资源（这里是指针 data），而不是复制资源。这样可以避免不必要的复制开销，并提高性能。</p><h4 id="使用-std-move-触发移动语义"><a href="#使用-std-move-触发移动语义" class="headerlink" title="使用 std::move 触发移动语义:"></a>使用 std::move 触发移动语义:</h4><p>要触发移动操作，通常需要使用 <code>std::move</code> 函数将对象显式转换为<code>右值引用</code>，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Buffer <span class="title function_">buffer1</span><span class="params">(<span class="number">1024</span>)</span>; <span class="comment">// 创建一个Buffer对象</span></span><br><span class="line">Buffer <span class="title function_">buffer2</span><span class="params">(<span class="built_in">std</span>::move(buffer1))</span>; <span class="comment">// 使用移动构造函数</span></span><br></pre></td></tr></table></figure><p>在这个示例中，std::move(buffer1) 将 buffer1 转换为右值引用，从而允许使用移动构造函数来初始化 buffer2。这意味着 buffer1 的资源被转移到了 buffer2，并且 buffer1 不再拥有这些资源。</p><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p>移动语义通过引入移动构造函数和移动赋值操作符，以及配合右值引用，为 C++ 提供了一种高效的资源管理方式。这改善了 C++ 程序的性能，特别是在涉及到大量数据处理的场景中。通过减少不必要的数据复制，移动语义使得资源的转移变得更加高效和直接。</p><h3 id="完美转发（Perfect-Forwarding）"><a href="#完美转发（Perfect-Forwarding）" class="headerlink" title="完美转发（Perfect Forwarding）"></a>完美转发（Perfect Forwarding）</h3><p>C++11 引入的完美转发是一种技术，允许函数将其接收到的参数以完全不变的形式转发给另一个函数。这意味着参数的左值、右值特性和类型都被保持不变。完美转发非常有用，尤其是在<strong>模板编程和泛型编程</strong>中，它可以帮助我们编写能够接受任意参数并将其正确转发的代码。</p><h4 id="使用-std-forward"><a href="#使用-std-forward" class="headerlink" title="使用 std::forward"></a>使用 std::forward</h4><p>完美转发通常通过 <code>std::forward</code> 实现，它允许你根据模板参数的类型来保持参数的左值或右值特性。</p><p><strong>语法</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line"><span class="type">void</span> <span class="title function_">wrapper</span><span class="params">(T&amp;&amp; arg)</span> &#123;</span><br><span class="line">    <span class="comment">// 使用 std::forward&lt;T&gt; 来完美转发 arg</span></span><br><span class="line">    callee(<span class="built_in">std</span>::forward&lt;T&gt;(arg));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>T&amp;&amp;</code> 表示一个通用引用（universal reference），它可以绑定到左值或右值。</li><li><code>std::forward&lt;T&gt;(arg)</code> 负责保持 arg 的原始类型，确保参数 arg 的值类别（左值或右值）被保持不变地转发。</li></ul><p><strong>示例代码</strong>:</p><p>假设我们有以下 callee 函数，它有两个重载，分别处理左值和右值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">callee</span><span class="params">(<span class="type">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; arg)</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;callee called with a left value: &quot;</span> &lt;&lt; arg &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">callee</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>&amp;&amp; arg)</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;callee called with a right value: &quot;</span> &lt;&lt; arg &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们使用完美转发来实现 wrapper 函数，它可以将其接收到的参数以原样转发给 callee：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line"><span class="type">void</span> <span class="title function_">wrapper</span><span class="params">(T&amp;&amp; arg)</span> &#123;</span><br><span class="line">    callee(<span class="built_in">std</span>::forward&lt;T&gt;(arg));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> lv = <span class="string">&quot;left value&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    wrapper(lv);  <span class="comment">// 调用 callee(const std::string&amp;)</span></span><br><span class="line">    waapper(<span class="built_in">std</span>::move(lv)); <span class="comment">// 调用 callee(std::string&amp;&amp;)</span></span><br><span class="line">    wrapper(<span class="string">&quot;right value&quot;</span>);  <span class="comment">// 调用 callee(std::string&amp;&amp;)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 main 函数中，wrapper 首先以一个左值字符串调用，接着使用std::move(lv)调用，然后以一个右值字符串字面量调用。由于使用了 std::forward，wrapper 能够保持参数的原始值类别（左值或右值），因此能够触发 callee 的正确重载。</p><h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结:"></a>总结:</h4><p>完美转发是一个非常有用的技术，它使得模板函数能够接受任意类型的参数，并将这些参数以其原始的左值或右值状态传递给其他函数。这在编写泛型代码或模板库时尤其重要，因为它允许代码以一种类型安全且效率高的方式处理各种调用场景。通过结合使用<code>通用引用（T&amp;&amp;）</code>和 <code>std::forward</code>，开发者可以编写出既灵活又高效的模板函数。</p><h2 id="标准库增强"><a href="#标准库增强" class="headerlink" title="标准库增强"></a>标准库增强</h2><h3 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h3><h4 id="线程（std-thread）"><a href="#线程（std-thread）" class="headerlink" title="线程（std::thread）"></a>线程（std::thread）</h4><p>C++11 引入了原生线程支持，通过 <code>&lt;thread&gt;</code> 头文件提供了 std::thread 类，使得创建和管理线程变得直接且易于使用。这是对 C++ 标准库的重要扩展，允许直接在 C++ 代码中实现多线程编程，而不再依赖于操作系统特定的线程库。</p><p><strong>基本使用</strong>:</p><p>要使用 <code>std::thread</code>，你需要创建一个 <code>std::thread</code> 对象并向其传递一个函数，这个函数将在新线程中执行。</p><p><strong>示例代码</strong>：创建并启动一个线程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程执行的函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">threadTask</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hello, Thread!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建并启动新线程</span></span><br><span class="line">    <span class="built_in">std</span>::thread <span class="title function_">t</span><span class="params">(threadTask)</span>;</span><br><span class="line">    <span class="comment">// 等待线程完成任务</span></span><br><span class="line">    t.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>传递参数</strong>:</p><p>如果你需要向线程函数传递参数，可以直接将它们作为 std::thread 构造函数的参数传递。</p><p><strong>示例代码</strong>：向线程函数传递参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printMessage</span><span class="params">(<span class="type">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; message)</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; message &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> message = <span class="string">&quot;Hello from the thread with arguments!&quot;</span>;</span><br><span class="line">    <span class="comment">// message作为参数传递给线程函数</span></span><br><span class="line">    <span class="built_in">std</span>::thread <span class="title function_">t</span><span class="params">(printMessage, message)</span>;</span><br><span class="line">    t.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>线程管理</strong>:</p><p><strong>加入线程</strong> : 当你创建一个线程时，你需要决定程序何时等待这个线程完成其工作。调用 <code>std::thread</code> 对象的 <code>join()</code> 方法，会使当前线程（通常是主线程或创建该子线程的线程）暂停执行，直到被 <code>join()</code> 的那个线程完成执行。<strong>这保证了两个重要的事项</strong>：</p><ul><li><strong>线程同步</strong>：确保所有必要的线程操作在程序继续之前完成。</li><li><strong>资源回收</strong>：一旦子线程完成执行，系统会回收它使用的所有资源。</li></ul><p><strong>使用方法</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t.join();</span><br></pre></td></tr></table></figure><p><strong>分离线程</strong> : 有时，你可能希望线程“独立”执行，而不是等待它结束。通过调用线程对象的 <code>detach()</code> 方法，你可以实现这一点。分离线程意味着：</p><ul><li><strong>线程的自主性</strong>：分离的线程会在自己的执行流中独立运行，主线程（或任何其他线程）不会等待它结束。</li><li><strong>资源管理</strong>：一旦分离的线程完成其任务，它占用的资源将由操作系统自动回收。你不需要（也不能）对其调用 join()。</li></ul><p><strong>使用方法</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t.detach();</span><br></pre></td></tr></table></figure><p><strong>获取线程ID</strong>:<br>每个线程都有一个唯一的 <code>ID</code>，可以通过 <code>get_id()</code> 方法获取。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Thread ID: &quot;</span> &lt;&lt; t.get_id() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p><strong>当前线程的 ID</strong></p><p>可以使用 <code>std::this_thread::get_id()</code> 获取当前线程的 ID。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Current thread ID: &quot;</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p><strong>线程休眠</strong>:</p><p><code>std::this_thread::sleep_for()</code> 函数可以使当前线程暂停执行指定的时间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="comment">// 使当前线程休眠 1 秒</span></span><br><span class="line"><span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>));</span><br></pre></td></tr></table></figure><h4 id="多线程同步"><a href="#多线程同步" class="headerlink" title="多线程同步"></a>多线程同步</h4><p>C++11 引入了多线程同步的机制，来帮助程序员控制并发执行的线程之间的执行顺序，确保数据的一致性和防止竞态条件。这包括了<code>互斥锁（mutexes）</code>、<code>条件变量（condition variables）</code>、以及<code>原子操作（atomic operations）</code>等。下面是这些同步机制的基本介绍和示例。</p><p><strong>1. 互斥锁（Mutex）</strong></p><p>互斥锁（mutex）是用于管理对共享资源的访问的同步原语。当多个线程尝试同时访问同一个资源时，互斥锁确保每次只有一个线程能够访问该资源，从而防止数据竞争和保证数据的一致性。</p><p>C++11 在 <code>&lt;mutex&gt;</code> 头文件中提供了几种类型的互斥锁：</p><p><strong>std::mutex</strong></p><p><code>std::mutex</code> 提供了基本的互斥锁功能。</p><p><strong>基本语法</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::mutex mtx;</span><br><span class="line">mtx.lock();   <span class="comment">// 加锁</span></span><br><span class="line"><span class="comment">// 临界区代码</span></span><br><span class="line">mtx.unlock(); <span class="comment">// 解锁</span></span><br></pre></td></tr></table></figure><p><strong>主要成员函数</strong>:</p><ul><li><strong>lock()</strong>    : 锁定互斥锁。如果互斥锁已被其他线程锁定，则调用线程将阻塞，直到互斥锁变为可用。</li><li><strong>unlock()</strong>  : 解锁互斥锁，使其变为可用状态。</li><li><strong>try_lock()</strong>: 尝试锁定互斥锁而不阻塞。如果互斥锁已经被其他线程锁定，则立即返回 false；如果成功锁定，则返回 true。</li></ul><p><strong>示例代码</strong>：使用 <code>std::mutex</code> 保护共享数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::mutex mtx; <span class="comment">// 创建互斥锁</span></span><br><span class="line"><span class="type">int</span> shared_data = <span class="number">0</span>; <span class="comment">// 共享数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">incrementSharedData</span><span class="params">()</span> &#123;</span><br><span class="line">    mtx.lock(); <span class="comment">// 加锁</span></span><br><span class="line">    ++shared_data;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">&quot; incremented shared_data to &quot;</span> &lt;&lt; shared_data &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    mtx.unlock(); <span class="comment">// 解锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::thread <span class="title function_">t1</span><span class="params">(incrementSharedData)</span>;</span><br><span class="line">    <span class="built_in">std</span>::thread <span class="title function_">t2</span><span class="params">(incrementSharedData)</span>;</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>std::recursive_mutex</strong></p><p><code>std::recursive_mutex</code>是可递归的互斥锁，允许同一个线程多次对同一个互斥锁对象加锁。它维护了一个锁计数和拥有线程的标识，当计数降到 0 时锁被释放。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::recursive_mutex rec_mtx;</span><br><span class="line">rec_mtx.lock();   <span class="comment">// 第一次加锁</span></span><br><span class="line">rec_mtx.lock();   <span class="comment">// 第二次加锁，合法</span></span><br><span class="line"><span class="comment">// 临界区代码</span></span><br><span class="line">rec_mtx.unlock(); <span class="comment">// 第一次解锁</span></span><br><span class="line">rec_mtx.unlock(); <span class="comment">// 第二次解锁，锁被完全释放</span></span><br></pre></td></tr></table></figure><p><strong>std::timed_mutex</strong></p><p><code>std::timed_mutex</code>提供了基本的互斥锁功能，并支持尝试加锁一段时间。如果在指定时间内没有获取到锁，操作会失败并返回。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::timed_mutex tm_mtx;</span><br><span class="line"><span class="keyword">if</span> (tm_mtx.try_lock_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>))) &#123;</span><br><span class="line">    <span class="comment">// 临界区代码</span></span><br><span class="line">    tm_mtx.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>std::recursive_timed_mutex</strong></p><p><code>std::recursive_timed_mutex</code>结合了<code>std::recursive_mutex</code>的可递归特性和<code>std::timed_mutex</code>的定时尝试加锁功能。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::recursive_timed_mutex rt_mtx;</span><br><span class="line"><span class="keyword">if</span> (rt_mtx.try_lock_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>))) &#123;</span><br><span class="line">    <span class="comment">// 临界区代码，可以多次加锁</span></span><br><span class="line">    rt_mtx.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用注意</strong>:</p><ul><li><p>在使用互斥锁时，推荐使用<code>std::lock_guard</code>或<code>std::unique_lock</code>等 RAII（Resource Acquisition Is Initialization）封装，以自动管理锁的加锁和解锁过程，避免因异常而导致的死锁问题。</p></li><li><p>根据具体需求选择合适的互斥锁类型。比如，如果不需要递归加锁或定时尝试加锁的功能，使用最简单的std::mutex即可。</p></li></ul><p>C++11的互斥锁类型提供了灵活的同步机制，帮助开发者在多线程程序中安全地管理对共享数据的访问。</p><p><strong>2. 条件变量（Condition Variable）</strong></p><p>C++11中的条件变量也是线程同步的一种机制，用于在某些条件发生变化时通知一个或多个正在等待的线程。条件变量通常与互斥量（mutex）一起使用，以确保线程安全地访问共享数据。条件变量主要通过<code>std::condition_variable</code>类提供。</p><p><strong>条件变量常见接口</strong>：</p><p><strong>1. wait</strong></p><p>该函数用于等待一个条件成立。它会原子地释放锁并使当前线程挂起，直到被其他线程通过 notify_one 或 notify_all 唤醒。一旦当前线程被唤醒，wait 会再次获取锁。</p><p><strong>语法</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv.wait(unique_lock&lt;<span class="built_in">std</span>::mutex&gt;&amp; lock);</span><br></pre></td></tr></table></figure><p><strong>2. wait_for</strong></p><p>等待条件变量被通知一段时间。如果在指定的时间内条件变量没有被通知，则超时并返回。</p><p><strong>语法</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv.wait_for(unique_lock&lt;<span class="built_in">std</span>::mutex&gt;&amp; lock, duration);</span><br></pre></td></tr></table></figure><p><strong>3. wait_until</strong><br>等待直到某个时间点，如果条件变量在这个时间点之前没有被通知，则超时并返回。</p><p><strong>语法</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv.wait_until(unique_lock&lt;<span class="built_in">std</span>::mutex&gt;&amp; lock, time_point);</span><br></pre></td></tr></table></figure><p><strong>4. notify_one</strong><br>用于唤醒一个等待（挂起）在条件变量上的线程。如果有多个线程在等待，只有一个会被随机唤醒。</p><p><strong>语法</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv.notify_one();</span><br></pre></td></tr></table></figure><p><strong>5. notify_all</strong></p><p>该函数用于唤醒所有等待（挂起）在条件变量上的线程。</p><p><strong>语法</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv.notify_all();</span><br></pre></td></tr></table></figure><p><strong>示例代码</strong>：使用 <code>std::condition_variable</code> 实现线程同步</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::mutex mtx;</span><br><span class="line"><span class="built_in">std</span>::condition_variable cv;</span><br><span class="line"><span class="type">bool</span> ready = <span class="literal">false</span>; <span class="comment">// 条件变量关联的条件</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">doPrint</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// std::unique_lock :锁管理工具，自动管理互斥锁的锁定与解锁。</span></span><br><span class="line">    <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title function_">lck</span><span class="params">(mtx)</span>;</span><br><span class="line">    <span class="keyword">while</span> (!ready) </span><br><span class="line">        cv.wait(lck); <span class="comment">// 等待条件成立，即：ready 变为true</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">&quot; is running\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">go</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title function_">lck</span><span class="params">(mtx)</span>;</span><br><span class="line">    ready = <span class="literal">true</span>;</span><br><span class="line">    cv.notify_all(); <span class="comment">// 通知所有等待的线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::thread threads[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">        threads[i] = <span class="built_in">std</span>::thread(doPrint);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;10 threads ready to race...\n&quot;</span>;</span><br><span class="line">    go(); <span class="comment">// 让所有线程开始执行</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; th : threads) th.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 原子操作（Atomic）</strong></p><p>原子操作是指不可分割的操作，这些操作要么完全执行，要么完全不执行，不会出现部分执行的情况。这对于多线程编程至关重要，因为它们可以用来保护在多线程环境中共享的数据，而无需使用互斥锁。C++11 通过 <code>&lt;atomic&gt;</code> 头文件引入了原子类型和操作。</p><p><strong>原子类型</strong>:</p><p>C++11 提供了一系列原子类型，如 <code>std::atomic_int</code>, <code>std::atomic_long</code>, <code>std::atomic_bool</code> 等，以及一个模板类 <code>std::atomic&lt;T&gt;</code>，允许创建任意类型 <code>T</code> 的原子对象。</p><p><strong>基本用法</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="type">int</span>&gt; <span class="title function_">count</span><span class="params">(<span class="number">0</span>)</span>;  <span class="comment">// 原子整型变量</span></span><br></pre></td></tr></table></figure><p><strong>主要成员函数</strong>:</p><ul><li><strong>store()</strong>: 存储（赋值）一个值到原子对象。</li><li><strong>load()</strong>: 从原子对象加载（获取）一个值。</li><li><strong>exchange()</strong>: 原子地替换原子对象的值。</li><li><strong>compare_exchange_weak() 和 compare_exchange_strong()</strong>: 比较原子对象的值，如果与期望值相同，则替换为新值。</li><li><strong>fetch_add(), fetch_sub(), fetch_or(), fetch_and(), fetch_xor()</strong>: 原子地执行加、减、或、与、异或操作。</li></ul><p><strong>示例代码</strong>:</p><p><strong>简单原子操作</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="type">int</span>&gt; <span class="title function_">count</span><span class="params">(<span class="number">0</span>)</span>;  <span class="comment">// 原子计数器</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i) &#123;</span><br><span class="line">        count.fetch_add(<span class="number">1</span>);  <span class="comment">// 原子地增加计数器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt; threads;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        threads.push_back(<span class="built_in">std</span>::thread(increment));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; th : threads) &#123;</span><br><span class="line">        th.join();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Final count: &quot;</span> &lt;&lt; count.load() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子创建了 10 个线程，每个线程都对一个原子计数器执行 10000 次增加操作。因为 count 是原子类型，所以即使多个线程同时修改它，最终的结果也是准确的，不会发生数据竞争。</p><p><strong>比较并交换</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="type">int</span>&gt; <span class="title function_">value</span><span class="params">(<span class="number">10</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">check_and_increase</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> oldValue = value.load();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!value.compare_exchange_weak(oldValue, oldValue + <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="comment">// 循环直到成功更新</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    check_and_increase();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子展示了如何使用 <code>compare_exchange_weak</code> 来原子地更新一个值，只有当当前值等于期望的旧值时，才将其更新为新值，否则重试操作。</p><p><code>value.compare_exchange_weak(oldValue, oldValue + 1)</code><br>这是一个原子的比较并交换操作，它尝试将 value 的当前值与 oldValue 比较：</p><ul><li><p><strong>如果相等</strong>（说明期间 value 的值未被其他线程改变），则将 value 更新为 oldValue + 1。</p></li><li><p><strong>如果不相等</strong>（说明期间 value 的值被其他线程改变了），操作失败，oldValue 被更新为 value 的新值，然后循环再尝试。</p><p><code>compare_exchange_weak</code>方法返回 true 表示成功更新，false 表示更新失败。</p></li></ul><p>通过使用原子操作，可以在多线程环境中安全地操作共享数据，而无需引入可能导致性能下降的互斥锁。</p><h4 id="std-once-flag-和-std-call-once"><a href="#std-once-flag-和-std-call-once" class="headerlink" title="std::once_flag 和 std::call_once"></a>std::once_flag 和 std::call_once</h4><p>在C++11中，<code>std::once_flag</code>和<code>std::call_once</code>共同提供了一种线程安全的方式来执行一次性初始化。这种机制尤其用于延迟初始化和单例模式中，确保某个函数或某段初始化代码在多线程环境下仅被执行一次，无论有多少线程尝试。</p><p><strong>std::once_flag</strong>:</p><p><code>std::once_flag</code>是一个不能被复制的类型，用来与 std::call_once 一起标记某个函数或初始化代码是否已经被执行。每个<code>std::once_flag</code>对象通常与一次性初始化任务相关联。</p><p><strong>std::call_once</strong>:</p><p><code>std::call_once</code>函数接受一个 std::once_flag 对象和一个要执行的函数，保证无论有多少线程尝试调用<code>std::call_once</code>，该函数仅被执行一次。</p><p><strong>语法</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">call_once</span><span class="params">(<span class="built_in">std</span>::once_flag&amp; flag, Callable&amp;&amp; func, Args&amp;&amp;... args)</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>flag</strong>：一个std::once_flag对象，标记func是否被执行过。</li><li><strong>func</strong>：要执行的函数或可调用对象。</li><li><strong>args</strong>：传递给func的参数列表。</li></ul><p><strong>示例代码</strong>:</p><p>下面是一个使用<code>std::once_flag</code>和<code>std::call_once</code>实现的线程安全的延迟初始化示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::once_flag flag; <span class="comment">// 用于标记延迟初始化是否执行</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_once</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Called once&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_work</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 尝试执行do_once，由于使用了std::once_flag，</span></span><br><span class="line">    <span class="comment">// 即使有多个线程调用do_work，do_once也只会执行一次</span></span><br><span class="line">    <span class="built_in">std</span>::call_once(flag, do_once);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::thread <span class="title function_">t1</span><span class="params">(do_work)</span>;</span><br><span class="line">    <span class="built_in">std</span>::thread <span class="title function_">t2</span><span class="params">(do_work)</span>;</span><br><span class="line">    <span class="built_in">std</span>::thread <span class="title function_">t3</span><span class="params">(do_work)</span>;</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">    t3.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，do_work 函数尝试执行 do_once 函数，但由于 do_once 与一个 std::once_flag 对象 flag 相关联，并通过 std::call_once 来调用，因此无论有多少线程调用 do_work，do_once 只会被执行一次。这种模式对于资源的延迟初始化非常有用，尤其是在资源初始化开销较大或只有在真正需要时才应被初始化的情况下。</p><h4 id="std-future和std-promise"><a href="#std-future和std-promise" class="headerlink" title="std::future和std::promise"></a>std::future和std::promise</h4><p>在C++11中，<code>std::future</code>和<code>std::promise</code>是处理异步操作的两个重要类。它们协同工作，提供了一种从异步操作中获取结果的机制。</p><p><strong>std::promise</strong>:</p><p><code>std::promise</code>对象可以存储某一类型的值，该值可以在将来某个时刻被获取。通过 std::promise，你可以在一个线程中设置一个值，然后在另一个线程中通过与之关联的 std::future 对象来获取这个值。</p><p><strong>语法</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  T：存储的值的类型。</span></span><br><span class="line"><span class="built_in">std</span>::promise&lt;T&gt; promise;</span><br></pre></td></tr></table></figure><p><strong>主要接口</strong>:</p><ul><li>set_value(const T&amp;)：设置一个值，该值可以通过关联的 std::future 对象来获取。</li><li>get_future()：返回一个<code>std::future&lt;T&gt;</code>对象，用于获取通过 set_value 设置的值。</li></ul><p><strong>std::future</strong>:</p><p><code>std::future</code> 对象持有一个异步操作的结果。它从关联的 std::promise 对象获取值或异常。</p><p><strong>语法</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  T：存储的值的类型。</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">future</span>&lt;T&gt; <span class="built_in">future</span> = promise.get_future();</span><br><span class="line"></span><br><span class="line">value = <span class="built_in">future</span>.get();</span><br></pre></td></tr></table></figure><p><strong>主要接口</strong>:</p><ul><li>get()：获取由 std::promise 设置的值。调用get()会阻塞，直到值被设置。</li><li>wait()：等待异步操作完成，但不获取结果。</li></ul><p><strong>示例代码</strong>:</p><p>下面是一个使用<code>std::promise</code>和<code>std::future</code>来传递异步操作结果的简单示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步任务：计算一个数的平方</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">compute</span><span class="params">(<span class="built_in">std</span>::promise&lt;<span class="type">int</span>&gt;&amp;&amp; prom, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="type">int</span> result = x * x;</span><br><span class="line">    prom.set_value(result);  <span class="comment">// 在子线程中设置结果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::promise&lt;<span class="type">int</span>&gt; prom;  <span class="comment">// 创建一个std::promise&lt;int&gt;对象</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="type">int</span>&gt; fut = prom.get_future();  <span class="comment">// 获取与promise关联的future</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::thread <span class="title function_">th</span><span class="params">(compute, <span class="built_in">std</span>::move(prom), <span class="number">10</span>)</span>;  <span class="comment">// 创建一个线程执行异步任务</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取异步操作的结果</span></span><br><span class="line">    <span class="type">int</span> value = fut.get();  <span class="comment">// 阻塞，直到异步操作完成并设置了结果</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The square of 10 is &quot;</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    th.join();  <span class="comment">// 等待子线程完成</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，compute 函数在一个新线程中执行，并计算一个数的平方，然后通过传入的 std::promise 对象设置结果。主线程通过与 promise 对象关联的 future 对象等待并获取这个结果。</p><p><strong>总结</strong>:</p><p><code>std::promise</code>和<code>std::future</code>为 C++11 引入的异步编程提供了强大的支持，允许在不同线程之间传递数据和状态信息。它们使得编写并发程序变得更加简洁和安全，尤其是在需要从异步操作中获取结果时。</p><h4 id="打包任务（packaged-task）"><a href="#打包任务（packaged-task）" class="headerlink" title="打包任务（packaged_task）"></a>打包任务（packaged_task）</h4><p>C++11引入了<code>std::packaged_task</code>，它是一个模板类，用于封装任何可以调用的目标（比如函数、lambda表达式、绑定表达式或其他函数对象），以便异步调用。<code>std::packaged_task</code>将调用的结果存储为一个<code>std::future</code>对象，这样就可以在未来某个时刻获取该结果。这使得<code>std::packaged_task</code>成为实现任务异步执行并获取其结果的强大工具。</p><p><strong>语法</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::packaged_task&lt;ReturnType(ArgsTypes...)&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>ReturnType</strong>：调用的返回类型。</li><li><strong>ArgsTypes</strong>：调用的参数类型列表。</li></ul><p><strong>主要接口</strong>:</p><ul><li>operator()(Args…)：执行封装的任务。</li><li>get_future()：返回一个<code>std::future&lt;ReturnType&gt;</code>对象，用于获取任务的结果。</li></ul><p><strong>示例代码</strong>:</p><p>假设我们有一个函数，计算两个整数的和，并希望异步执行这个函数并获取结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个简单的函数，计算两个整数的和</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 封装sum函数到packaged_task中</span></span><br><span class="line">    <span class="built_in">std</span>::packaged_task&lt;<span class="title function_">int</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>&gt; <span class="title function_">task</span><span class="params">(sum)</span>;</span><br><span class="line">    <span class="comment">// 获取与packaged_task关联的future对象，以便之后获取结果</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="type">int</span>&gt; result = task.get_future();</span><br><span class="line">    <span class="comment">// 在一个新线程中执行任务</span></span><br><span class="line">    <span class="built_in">std</span>::thread <span class="title function_">th</span><span class="params">(<span class="built_in">std</span>::move(task), <span class="number">2</span>, <span class="number">3</span>)</span>; <span class="comment">// 传递参数2和3给sum函数</span></span><br><span class="line">    <span class="comment">// 等待任务完成并获取结果</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The sum is: &quot;</span> &lt;&lt; result.get() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出：The sum is: 5 </span></span><br><span class="line">    <span class="comment">// 等待线程完成</span></span><br><span class="line">    th.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们创建了一个 std::packaged_task 对象 task，它封装了 sum 函数。通过调用 task.get_future()，我们获得了一个std::future对象，它将在task执行完成后包含 sum 函数的返回值。然后，我们创建了一个线程th，并将task（通过std::move移动）和sum函数需要的参数传递给这个线程，以异步执行task。通过result.get()，我们阻塞等待任务完成，并获取sum函数的结果。</p><p><strong>总结</strong>:</p><p><code>std::packaged_task</code> 是C++11中处理异步任务的强大工具。它允许程序员封装任何可调用的目标，以便异步执行，同时通过<code>std::future</code>提供了一种机制来获取异步操作的结果。这种模式非常适用于需要将计算密集型任务移出主线程以避免阻塞主执行流的场景。</p><h4 id="异步（Async）"><a href="#异步（Async）" class="headerlink" title="异步（Async）"></a>异步（Async）</h4><p>C++11 通过引入 <code>std::async</code> 函数提供了一种更简洁、更高层的方式来创建异步任务。<code>std::async</code> 会启动一个异步任务，该任务可以在新线程中执行或延迟执行，具体取决于给定的策略参数，并返回一个 <code>std::future</code> 对象，用于访问异步操作的结果。</p><p><strong>函数声明</strong>:</p><p><strong>普通版本的函数声明</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template &lt;<span class="class"><span class="keyword">class</span> <span class="title">F</span>, <span class="title">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">future</span>&lt;typename <span class="built_in">std</span>::result_of&lt;F(Args...)&gt;::type&gt; async(F&amp;&amp; f, Args&amp;&amp;... args);</span><br></pre></td></tr></table></figure><p><strong>指定启动策略的重载版本的函数声明</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template &lt;<span class="class"><span class="keyword">class</span> <span class="title">F</span>, <span class="title">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">future</span>&lt;typename <span class="built_in">std</span>::result_of&lt;F(Args...)&gt;::type&gt; async(<span class="built_in">std</span>::launch policy, F&amp;&amp; f, Args&amp;&amp;... args);</span><br></pre></td></tr></table></figure><ul><li><strong>policy</strong>：指定执行策略，可以是 std::launch::async（强制在新线程中执行任务）、std::launch::deferred（延迟执行任务，直到调用 std::future::get 或 std::future::wait）、或者这两者的位或组合。</li><li><strong>f</strong>：要异步执行的函数或可调用对象。</li><li><strong>args</strong>：传递给 f 的参数。</li></ul><p><strong>返回值是</strong>： <code>std::future</code> 类型的对象，它持有异步任务的结果。</p><p><strong>示例代码</strong>:</p><p><strong>异步执行任务</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">compute</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 启动异步任务，自动选择执行策略</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="type">int</span>&gt; result = <span class="built_in">std</span>::async(compute, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 做一些其他的事情...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取异步任务的结果，如果任务尚未完成，则这里会阻塞等待</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The result is: &quot;</span> &lt;&lt; result.get() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用执行策略</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Task runs in a thread.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 强制在新线程中启动异步任务</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="type">void</span>&gt; f1 = <span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::async, task);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 延迟执行任务，直到调用 get() 或 wait()</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="type">void</span>&gt; f2 = <span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::deferred, task);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此时，第一个任务已经在新线程中执行</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第二个任务将在调用 get() 或 wait() 时在当前线程(主线程)中执行</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 等待第一个任务完成</span></span><br><span class="line">    f1.get();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 启动第二个任务，并等待它完成</span></span><br><span class="line">    f2.get();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结</strong>:</p><p><code>std::async</code> 提供了一种便捷的方式来执行异步任务，无需直接处理线程的创建和管理。通过返回一个 <code>std::future</code> 对象，它允许以线程安全的方式访问异步任务的结果。使用 <code>std::async</code> 可以使并发编程变得更简单、更直观。</p><h4 id="线程局部存储（Thread-Local-Storage，TLS）"><a href="#线程局部存储（Thread-Local-Storage，TLS）" class="headerlink" title="线程局部存储（Thread Local Storage，TLS）"></a>线程局部存储（Thread Local Storage，TLS）</h4><p>C++11 引入了线程局部存储（Thread Local Storage，TLS），允许数据在每个线程中都有自己的独立实例。这意味着每个线程都有自己的数据副本，修改一个线程中的数据不会影响到其他线程中的相同数据。这是通过<code>thread_local</code>关键字来实现的，它指定了变量的存储期为线程的生命周期。</p><p><strong>语法</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">thread_local</span> Type variableName = initialValue;</span><br></pre></td></tr></table></figure><ul><li><strong>thread_local</strong>：关键字，用于声明线程局部存储变量。</li><li><strong>Type</strong>：变量的类型。</li><li><strong>variableName</strong>：变量的名称。</li><li><strong>initialValue</strong>（可选）：变量的初始值。</li></ul><p><strong>示例代码</strong>：</p><p>以下是一个展示如何使用<code>thread_local</code>关键字的简单示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个线程局部变量</span></span><br><span class="line"><span class="keyword">thread_local</span> <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">incrementCounter</span><span class="params">(<span class="type">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; threadName)</span> &#123;</span><br><span class="line">    ++counter; <span class="comment">// 访问和修改线程局部变量</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Counter in &quot;</span> &lt;&lt; threadName &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; counter &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::thread <span class="title function_">t1</span><span class="params">([&amp;]() &#123;</span></span><br><span class="line"><span class="params">        incrementCounter(<span class="string">&quot;t1&quot;</span>);</span></span><br><span class="line"><span class="params">        incrementCounter(<span class="string">&quot;t1&quot;</span>);</span></span><br><span class="line"><span class="params">    &#125;)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::thread <span class="title function_">t2</span><span class="params">([&amp;]() &#123;</span></span><br><span class="line"><span class="params">        incrementCounter(<span class="string">&quot;t2&quot;</span>);</span></span><br><span class="line"><span class="params">        incrementCounter(<span class="string">&quot;t2&quot;</span>);</span></span><br><span class="line"><span class="params">    &#125;)</span>;</span><br><span class="line"></span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，counter是一个线程局部存储变量，因为它前面有<code>thread_local</code>关键字。这意味着每个线程调用 incrementCounter 函数时，都会修改它自己的 counter 副本，而不是共享一个全局 counter。因此，尽管 incrementCounter 函数在两个不同的线程中都被调用了两次，每个线程的输出将独立地显示 counter 从1递增到2，证明每个线程都有自己的 counter 副本。</p><p><strong>总结</strong>:</p><p>使用 <code>thread_local</code> 声明的变量为每个线程提供了一个独立的变量副本，这有助于减少对全局状态的依赖，从而使代码在并发环境中更安全、更容易理解。线程局部存储特别适用于保持线程的状态或避免不必要的锁争用，提高程序的效率和性能。</p><h3 id="函数包装器（function-wrapper）"><a href="#函数包装器（function-wrapper）" class="headerlink" title="函数包装器（function wrapper）"></a>函数包装器（function wrapper）</h3><p>在C++11中，<code>std::function</code>是一个函数包装器（function wrapper），它提供了一种通用、类型安全的方式来存储和调用任何可调用对象，包括普通函数、Lambda 表达式、函数指针、以及具有 operator() 成员函数的对象（如函数对象或类实例）。</p><h4 id="语法-10"><a href="#语法-10" class="headerlink" title="语法"></a>语法</h4><p><code>std::function</code> 的语法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::function&lt;ReturnType(ArgumentTypes...)&gt;</span><br></pre></td></tr></table></figure><p>其中 <code>ReturnType</code> 是可调用对象返回的类型，<code>ArgumentTypes...</code> 是可调用对象接受的参数类型列表。</p><p><strong>示例代码</strong>:</p><p><strong>1. 存储和调用普通函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; func = print;</span><br><span class="line">    func(<span class="number">10</span>);  <span class="comment">// 输出：10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 存储和调用Lambda表达式</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; add = [](<span class="type">int</span> a, <span class="type">int</span> b) &#123; <span class="keyword">return</span> a + b; &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;3 + 4 = &quot;</span> &lt;&lt; add(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出：3 + 4 = 7</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 存储和调用成员函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">triple</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span> * x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    MyClass obj;</span><br><span class="line">    <span class="built_in">std</span>::function&lt;<span class="type">int</span>(MyClass&amp;, <span class="type">int</span>)&gt; func = &amp;MyClass::triple;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;3 tripled is &quot;</span> &lt;&lt; func(obj, <span class="number">3</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出：3 tripled is 9</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4. 存储和调用函数对象</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Adder</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; func = Adder();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;1 + 2 = &quot;</span> &lt;&lt; func(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出：1 + 2 = 3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h4><p><code>std::function</code> 是 C++11 提供的一个非常灵活的机制，它使得函数的存储、传递和调用变得非常简单和统一。无论是普通函数、成员函数、Lambda 表达式还是函数对象，都可以用 <code>std::function</code> 来处理。这种统一的接口使得编写接受函数作为参数的泛型代码变得更加容易和直观。</p><h3 id="绑定器（std-bind）"><a href="#绑定器（std-bind）" class="headerlink" title="绑定器（std::bind）"></a>绑定器（std::bind）</h3><p>C++11标准引入了<code>std::bind</code>，这是一个非常有用的函数适配器，它位于<code>&lt;functional&gt;</code>头文件中。<code>std::bind</code>可以被用来将一个函数或可调用对象（如函数指针、成员函数指针、Lambda表达式、函数对象等）与其参数绑定，生成一个新的可调用对象。这意味着你可以预设某些参数的值，创建一个新的函数版本，这个新版本只需要剩余的参数即可被调用。</p><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> newCallable = <span class="built_in">std</span>::bind(callable, arg1, arg2, ..., argN);</span><br></pre></td></tr></table></figure><ul><li>callable：原始的可调用对象，可以是函数指针、成员函数指针、Lambda 表达式或其他函数对象。</li><li>arg1, arg2, …, argN：要绑定的参数列表，可以是具体的值或引用，也可以是 <code>std::placeholders::_1</code>, <code>std::placeholders::_2</code>, … 来占位，这表示该位置的参数将在新生成的可调用对象被调用时指定。</li></ul><p><strong>示例</strong>:</p><p><strong>1. 绑定普通函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> n1, <span class="type">int</span> n2, <span class="type">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; str)</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n1 &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; n2 &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; str &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">auto</span> f = <span class="built_in">std</span>::bind(print, <span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    f(); <span class="comment">// 输出：1, 2, Hello</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 使用占位符</strong></p><p>使用 <code>std::placeholders</code> 中的占位符，可以在绑定时留下未指定的参数，这些参数需要在新可调用对象被调用时提供：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> n1, <span class="type">int</span> n2, <span class="type">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; str)</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n1 &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; n2 &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; str &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    using namespace <span class="built_in">std</span>::placeholders; <span class="comment">// 对于 _1, _2, _3...</span></span><br><span class="line">    <span class="keyword">auto</span> f = <span class="built_in">std</span>::bind(print, _2, _1, <span class="string">&quot;Bound&quot;</span>);</span><br><span class="line">    f(<span class="number">3</span>, <span class="number">5</span>); <span class="comment">// 输出：5, 3, Bound</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 绑定类的成员函数</strong></p><p>对于类的成员函数，<code>std::bind</code> 也能够被用来绑定，但需要提供<strong>成员函数的地址</strong>作为第一个参数，而第二个参数是<strong>要绑定的对象的指针或引用</strong>，之后的参数则是成员函数的参数，这些参数可以是具体的值，也可以是占位符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">memberFunc</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Member function called with &quot;</span> &lt;&lt; x &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    MyClass obj;</span><br><span class="line">    <span class="keyword">auto</span> f = <span class="built_in">std</span>::bind(&amp;MyClass::memberFunc, &amp;obj, <span class="number">100</span>);</span><br><span class="line">    f(); <span class="comment">// 输出：Member function called with 100</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结-5"><a href="#总结-5" class="headerlink" title="总结:"></a>总结:</h4><p><code>std::bind</code> 是 C++11 引入的一个功能强大的工具，它使得函数调用更加灵活，允许预先绑定参数，创建新的可调用对象。但在 C++11 以后，<code>Lambda 表达式</code>因其更简洁的语法和更好的性能，通常被推荐为更好的替代方案。</p><h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><p>C++11 引入了几种智能指针类型，这些智能指针主要存在于 <code>&lt;memory&gt;</code> 头文件中，它们自动管理内存，帮助避免内存泄露，使得资源管理更加安全和容易。智能指针的类型包括 <code>std::unique_ptr</code>、<code>std::shared_ptr</code> 和 <code>std::weak_ptr</code>。</p><h4 id="std-unique-ptr"><a href="#std-unique-ptr" class="headerlink" title="std::unique_ptr"></a>std::unique_ptr</h4><p><code>std::unique_ptr</code>是一种独占所有权的智能指针，确保同一时刻只有一个智能指针实例可以指向一个给定的对象。当<code>std::unique_ptr</code>被销毁时，它所指向的对象也会被销毁。</p><p><strong>语法</strong>：</p><p>创建 <code>std::unique_ptr</code> 的基本语法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Type&gt; <span class="title function_">ptr</span><span class="params">(new Type(arguments))</span>;</span><br></pre></td></tr></table></figure><p><strong>主要特性</strong>:</p><ul><li><strong>独占所有权</strong>：一个 std::unique_ptr 同时只能拥有一个对象的所有权。</li><li><strong>自动资源管理</strong>：std::unique_ptr 负责自动释放其所拥有的对象。</li><li><strong>不可复制</strong>：为保证资源独占性，std::unique_ptr 不能被复制，但可以被移动，从而转移资源所有权。</li></ul><p><strong>示例代码</strong>:</p><p>创建和使用 <code>std::unique_ptr</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    MyClass() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;MyClass created\n&quot;</span>; &#125;</span><br><span class="line">    ~MyClass() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;MyClass destroyed\n&quot;</span>; &#125;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Doing something\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;MyClass&gt; <span class="title function_">myPtr</span><span class="params">(new MyClass())</span>;</span><br><span class="line">    myPtr-&gt;doSomething();</span><br><span class="line">    <span class="comment">// 当 myPtr 离开作用域时，MyClass 的实例会自动被销毁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这个例子中，我们通过 new MyClass() 显式地创建了一个 MyClass 的实例，并将其传递给 <code>std::unique_ptr&lt;MyClass&gt;</code> 的构造函数来初始化 myPtr。</p><p>转移 <code>std::unique_ptr</code> 的所有权:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;MyClass&gt; <span class="title function_">ptr1</span><span class="params">(new MyClass())</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;MyClass&gt; ptr2 = <span class="built_in">std</span>::move(ptr1);</span><br><span class="line"><span class="comment">// 现在 ptr2 拥有 MyClass 实例的所有权，而 ptr1 为空（nullptr）</span></span><br></pre></td></tr></table></figure><p>在这个例子中，使用 std::move 将 ptr1 的所有权转移给 ptr2。之后，ptr1 变为 nullptr。</p><p>从 <code>C++14</code> 开始，推荐使用 <code>std::make_unique</code> 函数来创建 <code>std::unique_ptr</code>，因为这种方式更安全，可以防止潜在的内存泄漏：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> ptr = <span class="built_in">std</span>::make_unique&lt;Type&gt;(arguments);</span><br></pre></td></tr></table></figure><h4 id="std-shared-ptr"><a href="#std-shared-ptr" class="headerlink" title="std::shared_ptr"></a>std::shared_ptr</h4><p><code>std::shared_ptr</code> 是一种引用计数的智能指针，也称共享型智能指针，它允许多个 std::shared_ptr 实例共享同一个对象的所有权。当最后一个拥有对象的 std::shared_ptr 被销毁或重置时，对象会被自动删除。</p><p><strong>语法</strong>：</p><p>使用构造函数创建 <code>std::shared_ptr</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Type&gt; <span class="title function_">ptr</span><span class="params">(new Type(args...))</span>;</span><br></pre></td></tr></table></figure><p>也可以使用 <code>std::make_shared</code> 模板函数来创建<code>std::shared_ptr</code>， <code>std::make_shared</code>函数在C++11 引入的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> ptr = <span class="built_in">std</span>::make_shared&lt;Type&gt;(args...);</span><br></pre></td></tr></table></figure><ul><li><strong>Type</strong>：要创建的对象的类型。</li><li><strong>args</strong>：传递给对象构造函数的参数列表。</li></ul><p><strong>代码示例</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    MyClass() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;MyClass created\n&quot;</span>; &#125;</span><br><span class="line">    ~MyClass() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;MyClass destroyed\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// std::shared_ptr&lt;MyClass&gt; sharedPtr1(new MyClass());</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;MyClass&gt; sharedPtr1 = <span class="built_in">std</span>::make_shared&lt;MyClass&gt;();</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;MyClass&gt; sharedPtr2 = sharedPtr1; <span class="comment">// 共享所有权</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Inside block\n&quot;</span>;</span><br><span class="line">    &#125; <span class="comment">// sharedPtr2 被销毁，对象不会被删除，因为 sharedPtr1 仍然存在</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Outside block\n&quot;</span>;</span><br><span class="line">&#125; <span class="comment">// sharedPtr1 被销毁，对象现在被删除</span></span><br></pre></td></tr></table></figure><h4 id="std-weak-ptr"><a href="#std-weak-ptr" class="headerlink" title="std::weak_ptr"></a>std::weak_ptr</h4><p><code>std::weak_ptr</code>是一种非拥有（弱）引用计数的智能指针，它指向由某个 <code>std::shared_ptr</code> 所管理的对象。它不会增加对象的引用计数，这样就避免了潜在的循环引用问题。</p><p><strong>语法</strong>：</p><p>你可以通过从一个 std::shared_ptr 或另一个 std::weak_ptr 创建一个 std::weak_ptr：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::weak_ptr&lt;Type&gt; <span class="title function_">weakPtr</span><span class="params">(sharedPtr)</span>;</span><br></pre></td></tr></table></figure><p><strong>示例代码</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span> <span class="comment">// 前向声明</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;B&gt; bPtr;</span><br><span class="line">    ~A() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;A destroyed\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">std</span>::weak_ptr&lt;A&gt; aPtr; <span class="comment">// 使用 weak_ptr 解决循环引用</span></span><br><span class="line">    ~B() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;B destroyed\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;A&gt; <span class="title function_">a</span><span class="params">(new A())</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;B&gt; <span class="title function_">b</span><span class="params">(new B())</span>;</span><br><span class="line">    a-&gt;bPtr = b;</span><br><span class="line">    b-&gt;aPtr = a; <span class="comment">// B 持有 A 的弱引用，不增加引用计数</span></span><br><span class="line">&#125; <span class="comment">// a 和 b 能够正确被销毁，避免了循环引用导致的内存泄露</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这个示例中，A 和 B 相互引用。如果它们都使用 std::shared_ptr 进行引用，则会创建循环引用，导致对象无法被正确销毁。通过让 B 中的 A 引用成为 std::weak_ptr，我们打破了循环引用，使对象能够在不再被需要时正确地被销毁。</p><h4 id="总结-6"><a href="#总结-6" class="headerlink" title="总结:"></a>总结:</h4><p><code>std::shared_ptr 和 std::weak_ptr</code> 提供了强大的内存管理功能，帮助避免了内存泄露和循环引用问题。std::shared_ptr 通过引用计数机制管理对象生命周期，而 std::weak_ptr 允许对这些对象进行弱引用，这对于实现如缓存、观察者模式等功能非常有用。</p><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><h4 id="noexcept-关键字"><a href="#noexcept-关键字" class="headerlink" title="noexcept 关键字"></a>noexcept 关键字</h4><p><code>noexcept</code> 是 C++11 引入的一个关键字，用于指定函数不会抛出异常。它有两种主要用法：<strong>一种是作为异常规范</strong>，用来标明函数不会抛出任何异常；<strong>另一种是作为运算符</strong>，用来检查表达式是否可能抛出异常。</p><p><strong>作为异常规范</strong></p><p>当 <code>noexcept</code> 用作异常规范时，它直接跟在函数声明的参数列表之后。这表明函数保证不抛出任何异常。如果函数违反了这一保证，即它抛出了异常，程序将调用 <code>std::terminate</code>，通常会导致程序终止。</p><p><strong>语法</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">function</span><span class="params">()</span> noexcept;</span><br></pre></td></tr></table></figure><p><strong>示例</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">noThrow</span><span class="params">()</span> noexcept &#123;</span><br><span class="line">    <span class="comment">// 这个函数保证不会抛出异常</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        noThrow(); <span class="comment">// 安全调用，不会抛出异常</span></span><br><span class="line">    &#125; catch (...) &#123;</span><br><span class="line">        <span class="comment">// 这里不会被执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>作为运算符</strong></p><p><code>noexcept</code> 运算符用来检查一个表达式是否保证不抛出异常。它的结果是一个编译时的布尔值，如果表达式保证不抛出异常，结果为 <code>true</code>，否则为 <code>false</code>。</p><p><strong>语法</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">noexcept(expression)</span><br></pre></td></tr></table></figure><p><strong>示例</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mayThrow</span><span class="params">()</span> &#123;</span><br><span class="line">    throw <span class="built_in">std</span>::runtime_error(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">noThrow</span><span class="params">()</span> noexcept &#123;</span><br><span class="line">    <span class="comment">// 不会抛出异常</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::boolalpha;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;mayThrow() noexcept? &quot;</span> &lt;&lt; noexcept(mayThrow()) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: false</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;noThrow() noexcept? &quot;</span> &lt;&lt; noexcept(noThrow()) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  <span class="comment">// 输出: true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>noexcept 规范和 noexcept 运算符的区别</strong>:</p><ul><li><strong>noexcept 规范</strong>：用来标明一个函数不会抛出任何异常。如果函数声明为 noexcept 但抛出了异常，程序将调用 std::terminate。</li><li><strong>noexcept 运算符</strong>：用来检查一个表达式是否保证不抛出异常。这对于模板编程和泛型编程中根据是否可能抛出异常来进行不同的代码路径优化特别有用。</li></ul><p>使用 noexcept 的优势:</p><ul><li><strong>性能优化</strong>：编译器可以对标记为 noexcept 的函数进行更多优化，因为它知道这些函数不会抛出异常。</li><li><strong>异常安全保证</strong>：通过明确指出哪些函数是不会抛出异常的，可以帮助编写更清晰、更健壮的代码。</li></ul><p>总之，<code>noexcept</code>是 C++11 引入的一个重要特性，它提高了异常安全性，并且在编写需要异常保证的函数时提供了更多的灵活性。</p><h4 id="异常传递工具"><a href="#异常传递工具" class="headerlink" title="异常传递工具"></a>异常传递工具</h4><p>在 C++11 中，引入了一组异常传递工具，允许在程序的不同部分之间传递异常信息。这些工具主要包括 <code>std::exception_ptr</code>、<code>std::current_exception</code> 和 <code>std::rethrow_exception</code>，它们定义在 <code>&lt;exception&gt; </code>头文件中。这些机制特别适用于多线程编程，其中异常可能在一个线程中抛出并需要在另一个线程中被捕获和处理。</p><p><strong>std::exception_ptr</strong></p><p><code>std::exception_ptr</code> 是一个智能指针，用于存储和传递异常对象的信息。它可以捕获任何抛出的异常，并允许在稍后的时间点重新抛出该异常，无论异常的类型如何。</p><p><strong>std::current_exception</strong></p><p><code>std::current_exception</code> 用于捕获当前抛出的异常，并返回一个 std::exception_ptr，指向该异常对象的拷贝。如果当前没有异常被抛出，它返回一个空的 std::exception_ptr。</p><p><strong>std::rethrow_exception</strong></p><p><code>std::rethrow_exception</code> 接受一个 std::exception_ptr 作为参数，并重新抛出由该指针所指向的异常。这允许在异常被捕获后的任何时间点重新抛出相同的异常。</p><p><strong>示例代码</strong>：</p><p>下面的代码演示了如何使用这些异常传递工具来捕获、存储、传递和重新抛出异常：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">processException</span><span class="params">(<span class="built_in">std</span>::exception_ptr eptr)</span> &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        <span class="keyword">if</span> (eptr) &#123;</span><br><span class="line">            <span class="built_in">std</span>::rethrow_exception(eptr); <span class="comment">// 重新抛出异常</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (<span class="type">const</span> <span class="built_in">std</span>::exception&amp; e) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Handled exception: &quot;</span> &lt;&lt; e.what() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::exception_ptr eptr;</span><br><span class="line">    </span><br><span class="line">    try &#123;</span><br><span class="line">        throw <span class="built_in">std</span>::runtime_error(<span class="string">&quot;A runtime error occurred&quot;</span>);</span><br><span class="line">    &#125; catch (...) &#123;</span><br><span class="line">        eptr = <span class="built_in">std</span>::current_exception(); <span class="comment">// 捕获并存储当前异常</span></span><br><span class="line">    &#125;</span><br><span class="line">    processException(eptr); <span class="comment">// 处理存储的异常</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在这个示例中</strong>：</p><ul><li>首先，在 main 函数中，一个 std::runtime_error 异常被抛出。</li><li>接着使用 catch (…) 捕获这个异常，并通过调用 std::current_exception 将其存储在 std::exception_ptr 中。</li><li>然后，将这个 std::exception_ptr 传递给 processException 函数。</li><li>在 processException 函数中，使用 std::rethrow_exception 重新抛出异常，然后在另一个 catch 块中捕获并处理它。</li></ul><p>重新抛出异常而不是直接处理，主要是为了：</p><ul><li><strong>保持灵活性</strong>：可以在更合适的地方或时间处理异常。</li><li><strong>保存信息</strong>：保留完整的异常信息，便于后续调试和诊断。</li><li><strong>统一处理</strong>：方便在程序的一个集中地点处理所有异常。</li></ul><p>这套异常传递工具为异常的传递和处理提供了极大的灵活性，尤其是在复杂的程序结构或多线程环境中。</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>本篇文章旨在为热衷于掌握 C++11 新特性的朋友们提供一份实用的学习指南。通过介绍各项新特性并辅以实际代码示例，希望初学者能够不仅理解这些特性背后的概念，还能<strong>学会如何在实际项目中应用它们</strong>。</p><p>C++11 的新特性覆盖了<strong>语言核心和标准库</strong>的方方面面，从简化代码书写、提高性能，到增强代码的安全性和可读性，接下来我们简单来回顾下上面所讲的。</p><ul><li>自动类型推断 (auto 和 decltype) 使得变量声明更加简洁，让编译器为我们做更多的工作。</li><li>基于范围的 for 循环 让遍历容器和序列变得更加直观。</li><li>统一的初始化方式 和 初始器列表 为各种对象和容器的初始化提供了一致的语法。</li><li>智能指针（如 std::unique_ptr, std::shared_ptr 和 std::weak_ptr）管理动态分配的内存，使得资源管理更加安全和方便。</li><li>并发编程 特性（包括 std::thread, std::async 等）允许我们更好地利用现代多核处理器的计算能力。</li><li>异常处理 得到增强，noexcept 关键字和新的异常传递工具让异常的处理和传递更加灵活和安全。</li><li>Lambda 表达式 和 函数对象 让编写匿名函数变得简单，为 STL 算法等的使用提供了巨大的便利。</li></ul><h3 id="最后："><a href="#最后：" class="headerlink" title="最后："></a>最后：</h3><p>如果你对 C&#x2F;C++&#x2F;Go 语言学习 + 计算机基础 + Linux编程 + 容器技术等内容感兴趣，不妨关注我的公众号—「跟着小康学编程」。这里会定时更新相关的技术文章，感兴趣的读者可以关注一下：</p><p>另外，小康最近新创建了一个技术交流群，大家如果在阅读的过程中有遇到问题或者有不理解的地方，欢迎大家加群询问或者评论区询问，我能解决的都尽可能给大家回复。</p><p>扫一扫小康的个人微信，备注「加群」即可。</p>]]></content>
      
      
      <categories>
          
          <category> C++ 编程教程 </category>
          
          <category> 编程语言学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11 新特性 </tag>
            
            <tag> Modern C++ </tag>
            
            <tag> auto 关键字 </tag>
            
            <tag> Lambda 表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何快速学习 C 语言？</title>
      <link href="/how-to-learn-C/"/>
      <url>/how-to-learn-C/</url>
      
        <content type="html"><![CDATA[<p>大家好，我是小康，今天我们来聊下如何学习 C 语言。</p><p>C 语言，强大而灵活，是许多现代编程语言的基石。本文将带你快速了解 C语言 的基础知识，无论你是编程新手还是希望回顾基础，这里都有你需要的。</p><p>初学者在开始学习 C 语言的时候，往往不知道怎样高效的学习这门课，网上很多人都会推荐去看各种 C 语言书籍，我觉得没必要去看那么多，贪多嚼不烂！为了让更多初学的朋友快速入门 C 语言，我这里将 C 的各个知识点进行了汇总，并附有代码示例，以便大家理解，掌握这些就可以啦。如果你时间比较充足，可以看<strong>丹尼斯·里奇的《C程序设计语言》</strong> 这本书，再搭配浙大<strong>翁恺</strong>的 C 语言课程：<a href="https://www.bilibili.com/video/BV1Ls411w7rx/?spm_id_from=333.337.search-card.all.click&vd_source=404f52a7ebbf2477ea859f9609a15c65">C语言程序设计 浙江大学：翁恺_哔哩哔哩_bilibili</a></p><p><strong>最佳的学习方法就是</strong>：根据<strong>我的知识点</strong>来看丹尼斯·里奇的《C程序设计语言》，再加上翁恺的 C 语言课程，搭配学习，效果最好。如果你认为自己自学能力很好或者时间有限，那么完全不需要看视频，本篇文章已经囊括了全部的知识点。</p><p>废话不多说了，直接带你快速入门 C 语言编程。</p><p><img src="/images/C%E8%AF%AD%E8%A8%80/1.png"></p><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h3 id="1-标识符和关键字"><a href="#1-标识符和关键字" class="headerlink" title="1.标识符和关键字"></a>1.标识符和关键字</h3><p>标识符用于<strong>变量、函数</strong>的名称。规则：由字母、数字、下划线组成，但不以数字开头。</p><p>关键字是 C 语言中已定义的特殊单词，如 <strong>int、return</strong> 等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line"><span class="type">int</span> variable; <span class="comment">// &#x27;int&#x27; 是关键字, &#x27;variable&#x27; 是标识符</span></span><br></pre></td></tr></table></figure><h3 id="2-变量和常量"><a href="#2-变量和常量" class="headerlink" title="2.变量和常量"></a>2.变量和常量</h3><p>变量是可以改变值的标识符。</p><p>常量是一旦定义，其值不可改变的标识符。常量使用 <code>const</code>来定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line"><span class="type">int</span> age = <span class="number">25</span>;       <span class="comment">// 定义变量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_AGE = <span class="number">99</span>; <span class="comment">// 定义常量</span></span><br></pre></td></tr></table></figure><h3 id="3-运算符和表达式"><a href="#3-运算符和表达式" class="headerlink" title="3.运算符和表达式"></a>3.运算符和表达式</h3><p>在 C 语言中，运算符是用于执行特定数学和逻辑计算的符号。运算符可以根据它们的功能和操作数的数量被分为几个不同的类别。</p><h4 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h4><p>这些运算符用于执行基本的数学计算。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ 加法</span><br><span class="line">- 减法</span><br><span class="line">* 乘法</span><br><span class="line">/ 除法</span><br><span class="line">% 取余（模运算，只适用于整数）</span><br></pre></td></tr></table></figure><h4 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h4><p>关系运算符用于比较两个值之间的大小关系。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">== 等于</span><br><span class="line">!= 不等于</span><br><span class="line">&gt; 大于</span><br><span class="line">&lt; 小于</span><br><span class="line">&gt;= 大于等于</span><br><span class="line">&lt;= 小于等于</span><br></pre></td></tr></table></figure><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><p>逻辑运算符用于连接多个条件（布尔值）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;&amp; 逻辑与</span><br><span class="line">|| 逻辑或</span><br><span class="line">! 逻辑非</span><br></pre></td></tr></table></figure><h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h4><p>赋值运算符用于将值分配给变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">= 简单赋值</span><br><span class="line">+= 加后赋值</span><br><span class="line">-= 减后赋值</span><br><span class="line">*= 乘后赋值</span><br><span class="line">/= 除后赋值</span><br><span class="line">%= 取余后赋值</span><br></pre></td></tr></table></figure><h4 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h4><p>位运算符对整数的二进制表示进行操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&amp; 位与</span><br><span class="line">| 位或</span><br><span class="line">^ 位异或</span><br><span class="line">~ 位非</span><br><span class="line">&lt;&lt; 左移</span><br><span class="line">&gt;&gt; 右移</span><br></pre></td></tr></table></figure><h4 id="递增和递减运算符"><a href="#递增和递减运算符" class="headerlink" title="递增和递减运算符"></a>递增和递减运算符</h4><p>这些运算符用于增加或减少变量的值。此类运算符都只作用于一个操作数，因此也被称之为一元运算符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">++ 递增运算符</span><br><span class="line">-- 递减运算符</span><br></pre></td></tr></table></figure><h4 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h4><p>C 语言提供了一个三元运算符用于基于条件选择两个值之一。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">? : 条件运算符</span><br></pre></td></tr></table></figure><p>下面是一些使用这些运算符的简单示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> result;</span><br><span class="line"></span><br><span class="line">result = a + b; <span class="comment">// 加法</span></span><br><span class="line">result = a &gt; b ? a : b; <span class="comment">// 条件运算符，选择a和b之间的较大者</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line">flag = !flag; <span class="comment">// 逻辑非，flag的值变为0</span></span><br><span class="line"></span><br><span class="line">result = a &amp; b; <span class="comment">// 位与运算</span></span><br><span class="line"></span><br><span class="line">a++; <span class="comment">// 递增a的值</span></span><br></pre></td></tr></table></figure><p>表达式是<strong>运算符和操作数</strong>组合成的序列。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line"><span class="type">int</span> sum = <span class="number">10</span> + <span class="number">5</span>; <span class="comment">// &#x27;+&#x27; 是运算符, &#x27;10 + 5&#x27; 是表达式,10，5 是操作数</span></span><br></pre></td></tr></table></figure><h3 id="4-语句"><a href="#4-语句" class="headerlink" title="4.语句"></a>4.语句</h3><p>C语言中的<strong>语句</strong>是构成程序的<strong>基本单位</strong>，用于表达特定的操作或逻辑。它们可以控制程序的流程、执行计算、调用函数等。语句以分号（;）结束，形成了程序的执行步骤。</p><p> C 语言的语句可以分为以下几类：</p><h4 id="表达式语句："><a href="#表达式语句：" class="headerlink" title="表达式语句："></a>表达式语句：</h4><p>最常见的语句，执行一个操作，如赋值、函数调用等，并以分号结束。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = b + c;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello, World!\n&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="复合语句（块）"><a href="#复合语句（块）" class="headerlink" title="复合语句（块）"></a>复合语句（块）</h4><p>由花括号{}包围的一系列语句和声明，允许将多个语句视为单个语句序列。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h4><p>根据表达式的真假来执行不同的代码块。</p><ul><li><p>if语句：是最基本的条件语句，根据条件的真假来执行相应的代码块。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    <span class="comment">// 条件为真时执行</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 条件为假时执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>switch语句</strong>：根据表达式的值选择多个代码块之一执行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(expression) &#123;</span><br><span class="line">    <span class="keyword">case</span> constant1:</span><br><span class="line">        <span class="comment">// 表达式等于 constant1 时执行</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> constant2:</span><br><span class="line">        <span class="comment">// 表达式等于 constant2 时执行</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// 无匹配时执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h4><p>重复执行一段代码直到给定的条件不满足。</p><ul><li><p><strong>while循环</strong>：先判断条件，条件满足则执行循环体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (condition) &#123;</span><br><span class="line">    <span class="comment">// 条件为真时执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>do-while循环</strong>：先执行一次循环体，然后判断条件。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// 至少执行一次</span></span><br><span class="line">&#125; <span class="keyword">while</span> (condition);</span><br></pre></td></tr></table></figure><ul><li><strong>for循环</strong>：在循环开始时初始化变量，然后判断条件，最后在每次循环结束时执行更新表达式。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (initialization; condition; increment) &#123;</span><br><span class="line">         <span class="comment">// 条件为真时执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 示例：</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="跳转语句"><a href="#跳转语句" class="headerlink" title="跳转语句"></a>跳转语句</h4><p>提供了改变代码执行顺序的能力。</p><ul><li><strong>break语句</strong>：用于立即退出最近的<code>switch</code>或循环（<code>while</code>、<code>do-while</code>、<code>for</code>）语句。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">5</span>) </span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// 当 i 等于5时退出循环 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>continue语句</strong>：跳过当前循环的剩余部分，并继续下一次循环的执行（仅适用于<code>while</code>、<code>do-while</code>、<code>for</code>循环）。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">5</span>) <span class="keyword">continue</span>; <span class="comment">// 当i等于5时，跳过当前循环的剩余部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong><code>goto</code>语句</strong>：将控制转移到程序中标记的位置。尽管存在，但建议避免使用<code>goto</code>，因为它使得程序的流程变得难以追踪和理解。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">label:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This is a label.&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">goto</span> label;     </span><br></pre></td></tr></table></figure></li></ul><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>数据类型的一个常见用途就是：<strong>定义变量</strong>。常见的数据类型可以大致分为以下几个类别：</p><h4 id="1-基本类型"><a href="#1-基本类型" class="headerlink" title="1.基本类型"></a>1.基本类型</h4><p><strong>整型</strong>：</p><p>整数类型用于存储整数值，可以是有符号的（可以表示负数）或无符号的（仅表示非负数）。其中 int 是最常用的整数类型。为了适应不同的精度需求和内存大小限制，C语言提供了几种不同大小的整数类型。</p><p><strong>有符号整型</strong>：</p><ul><li>short int 或简写为short，用于存储较小范围的整数。它至少占用16位（2个字节）的存储空间。</li><li>int 是最基本的整数类型，用于存储标准整数。在大多数现代编译器和平台上，它占用32位（4个字节）。</li><li>long int 或简写为 long，用于存储比int更大范围的整数。它至少占用32位，但在一些平台上可能会占用64位（8个字节）。</li><li>long long int 或简写为 long long，是C99标准引入的，用于提供更大范围的整数存储。它保证至少占用64位（8个字节）。</li></ul><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>;         <span class="comment">// 定义一个整形变量，初始值为5</span></span><br><span class="line"><span class="type">long</span> b = <span class="number">100000L</span>;  <span class="comment">// 定义一个长整形变量，初始值为100000</span></span><br></pre></td></tr></table></figure><p><strong>无符号整型</strong>：</p><ul><li><p>unsigned short int 或简写为 unsigned short，专门用于存储较小范围的正整数或零。这种类型至少占用16位（2个字节）的存储空间。</p></li><li><p>unsigned int 是用于存储标准大小的非负整数的基本类型。在大多数现代编译器和平台上，它占用32位（4个字节）。</p></li><li><p>unsigned long int 或简写为 unsigned long，用于存储大范围的非负整数。这种类型至少占用32位，在其他平台上可能占用64位（8个字节）</p></li><li><p>unsigned long long int 或简写为 unsigned long long，是为了在需要非常大范围的正整数时使用的。按照C99标准规定，它至少占用64位（8个字节）。</p></li></ul><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> x = <span class="number">150</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> y = <span class="number">100000UL</span>;</span><br></pre></td></tr></table></figure><p><strong>浮点型:</strong></p><p>浮点类型用于存储实数（小数点数字），包括 float 和 double。</p><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> f = <span class="number">5.25f</span>;</span><br><span class="line"><span class="type">double</span> d = <span class="number">10.75</span>;</span><br></pre></td></tr></table></figure><p><strong>浮点型使用场景</strong>：float 和 double：用于需要表示小数的场景，如科学计算、金融计算等。float 提供了足够的精度，适合大多数应用，而 double 提供了更高的精度，适用于需要非常精确的计算结果的场景。</p><p><strong>布尔类型:</strong><br>布尔类型 bool 用于表示真（true）或假（false）。</p><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> flag = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p><strong>布尔类型使用场景</strong>：bool 类型一般用于逻辑判断，表示条件是否满足。常用于控制语句（如if、while）的条件表达式，或表示函数返回的成功、失败状态。</p><p><strong>枚举类型:</strong><br>枚举（enum）允许定义一组命名的整数常量。使用关键字<code>enum</code>定义枚举类型变量。</p><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">day</span> &#123;</span>sun, mon, tue, wed, thu, fri, sat&#125;;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">day</span> <span class="title">today</span> =</span> mon;</span><br></pre></td></tr></table></figure><p><strong>枚举类型使用场景</strong>：<br>枚举类型 enum 用于定义一组命名的整数常量，使程序更易于阅读和维护。常用于表示状态、选项、配置等固定的集合。</p><h4 id="2-复合类型"><a href="#2-复合类型" class="headerlink" title="2.复合类型:"></a>2.复合类型:</h4><p><strong>结构体</strong></p><p>结构体（struct）允许将多个不同类型的数据项组合成一个类型。使用关键字<code>struct</code>定义结构体。</p><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义 Person 结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义结构体变量 person1</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">person1</span>;</span></span><br></pre></td></tr></table></figure><p><strong>结构体类型使用场景</strong>：用于组合不同类型的数据项，表示具有结构的数据。</p><ul><li><p><strong>表示实体或对象</strong>：用于封装和表示具有多个属性的复杂实体，如人、书籍、产品等。</p></li><li><p><strong>数据记录</strong>：组织和管理具有多个相关字段的数据记录，适用于数据库记录、日志条目等。</p></li><li><p><strong>网络编程</strong>：构造和解析网络协议的数据包，适用于客户端和服务器之间的通信。</p></li><li><p><strong>创建复杂的数据结构</strong>：作为链表、树、图等复杂数据结构的基本构建块，通过指针连接结构体实现。</p></li></ul><p><strong>联合体</strong></p><p>联合体（union）在 C 语言中是一个用于优化内存使用的特殊数据类型，允许在同一内存位置存储不同的数据类型，但任一时刻只能使用其中一个成员。联合体变量使用关键字<code>union</code> 来定义。</p><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Data</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">float</span> f;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Data</span> <span class="title">data</span>;</span></span><br></pre></td></tr></table></figure><p><strong>联合体类型使用场景</strong>：</p><ul><li><p><strong>节省内存</strong>：当程序中的变量可能代表不同类型的数据，但不会同时使用时，联合体能有效减少内存占用。</p></li><li><p><strong>底层编程</strong>：在需要直接与硬件交互，或需要精确控制数据如何存储和解读时，联合体提供了直接访问内存表示的能力。</p></li><li><p><strong>网络通信</strong>：用于根据不同的协议或消息类型解析同一段网络数据。</p></li><li><p><strong>类型转换</strong>：允许以一种数据类型写入联合体，然后以另一种类型读取，实现不同类型之间的快速转换。</p></li></ul><h4 id="3-派生类型："><a href="#3-派生类型：" class="headerlink" title="3.派生类型："></a>3.派生类型：</h4><p><strong>数组</strong></p><p>数组是一种派生类型，它允许存储固定数量的同类型元素。当然，类型可以是多种，整形，浮点型，结构体等类型。在内存中，数组的元素按顺序紧密排列。数组的使用使得数据管理更加方便，尤其是当你需要处理大量<strong>同质数据</strong>时。</p><blockquote><p><strong>同质数据</strong>:具有相同数据类型的元素或值</p></blockquote><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, numbers[<span class="number">0</span>]); <span class="comment">// 输出数组的第一个元素</span></span><br></pre></td></tr></table></figure><p>数组的索引从<code>0</code>开始，<code>numbers[0]</code>表示数组中的第一个元素。</p><p><strong>指针</strong></p><p>指针是存储另一个变量地址的变量。指针在C语言中非常重要，它提供了直接访问内存的能力，使得程序可以通过地址来操作变量。</p><p><strong>声明和使用指针</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> var = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *ptr = &amp;var; <span class="comment">// 声明一个指针 ptr，并将其初始化为 var 的地址</span></span><br></pre></td></tr></table></figure><p>通过指针访问值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;Value of var: %d\n&quot;, *ptr); // 使用解引用操作符*来访问指针指向的值</span><br></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>上面有提到过数组的概念，接下来让我们来详细讲解下数组：</p><p>数组是一种存储固定数量同类型元素的线性集合。在C语言中，这意味着如果你<strong>有一组相同类型的数据</strong>要存储，比如一周内每天的温度，那数组就是你的首选。</p><h3 id="声明与初始化"><a href="#声明与初始化" class="headerlink" title="声明与初始化"></a>声明与初始化</h3><p>声明数组的语法相当直观。比如，你想存储5个整数，可以这样声明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> days[len];</span><br></pre></td></tr></table></figure><p>这里，int表明了数组中元素的类型，days是数组的名称，而[len]则指定了数组可以存储元素的个数，len 必须是数值常量。</p><p>初始化数组可以在声明的同时进行，确保数组中的每个元素都有一个明确的起始值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> days[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure><p>如果数组的大小在初始化时已知，你甚至可以省略大小声明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> days[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure><h3 id="访问与遍历"><a href="#访问与遍历" class="headerlink" title="访问与遍历"></a>访问与遍历</h3><p>数组的元素可以通过索引（或下标）进行访问，索引从<code>0</code>开始，这意味着在上面的 days 数组中，第一个元素是<code>days[0]</code>，最后一个元素是<code>days[4]</code>。</p><p>遍历数组，即访问数组中的每个元素，通常使用循环结构，如for循环：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, days[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><p>多维数组是一种直接在类型声明时定义多个维度的数组。它们通常用于存储具有多个维度的数据，如矩阵或数据表。</p><h4 id="定义和初始化"><a href="#定义和初始化" class="headerlink" title="定义和初始化"></a>定义和初始化</h4><p>多维数组的定义遵循这样的格式：类型 名称[维度1大小][维度2大小]…[维度N大小];</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> matrix[<span class="number">2</span>][<span class="number">3</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这定义了一个2x3的整型矩阵，并进行了初始化。</p><h4 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h4><p>访问多维数组的元素需要提供每一个维度的索引：数组名[索引1][索引2]…[索引N];</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> value = matrix[<span class="number">1</span>][<span class="number">2</span>]; <span class="comment">// 访问第二行第三列的元素</span></span><br></pre></td></tr></table></figure><h3 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h3><p>动态数组提供了一种在运行时确定数组大小的能力，通过动态内存分配函数来实现。</p><h4 id="动态一维数组"><a href="#动态一维数组" class="headerlink" title="动态一维数组:"></a>动态一维数组:</h4><p>动态一维数组通常通过指针和 malloc 或 calloc 函数创建：</p><p>malloc 分配的内存是未初始化的，而 calloc 会将内存初始化为零。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *arr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">10</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 分配10个整数的空间</span></span><br></pre></td></tr></table></figure><h4 id="动态多维数组"><a href="#动态多维数组" class="headerlink" title="动态多维数组:"></a>动态多维数组:</h4><p>动态多维数组的创建稍微复杂，因为需要为每个维度分别进行内存分配：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> **matrix = (<span class="type">int</span>**)<span class="built_in">malloc</span>(<span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>*)); <span class="comment">// 创建2个指针的数组，对应2行</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">    matrix[i] = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 为每行分配3个整数的空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用完动态数组后，必须<strong>手动释放其内存以避免内存泄漏</strong>：</p><h4 id="动态一维数组内存的释放："><a href="#动态一维数组内存的释放：" class="headerlink" title="动态一维数组内存的释放："></a>动态一维数组内存的释放：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">free</span>(arr)</span><br></pre></td></tr></table></figure><h4 id="动态多维数组内存的释放："><a href="#动态多维数组内存的释放：" class="headerlink" title="动态多维数组内存的释放："></a>动态多维数组内存的释放：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">free</span>(matrix[i]); <span class="comment">// 释放每一行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(matrix); <span class="comment">// 最后释放指针数组</span></span><br></pre></td></tr></table></figure><h3 id="数组与函数"><a href="#数组与函数" class="headerlink" title="数组与函数"></a>数组与函数</h3><p>在 C 语言中，数组可以作为参数传递给函数。不过，由于数组在传递时会退化为指向其首元素的指针，我们需要另外传递数组的大小：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="built_in">array</span>[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line"><span class="type">int</span> len = <span class="keyword">sizeof</span>(<span class="built_in">array</span>)/<span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>]); <span class="comment">//计算数组的长度</span></span><br><span class="line">printArray(<span class="built_in">array</span>,len);</span><br><span class="line"><span class="comment">//printArray(array,len) 被调用时，printArray函数形参arr会退化成 int*</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printArray</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组使用场景："><a href="#数组使用场景：" class="headerlink" title="数组使用场景："></a>数组使用场景：</h3><ul><li><strong>固定大小集合</strong>：适用于存储已知数量的数据元素。</li><li><strong>顺序访问和高效索引</strong>：数组元素存储在连续的内存地址中，可以通过索引快速访问。</li><li><strong>多维数据表示</strong>：可以方便地表示多维数据结构，如二维数组表示矩阵。</li></ul><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>在 C 语言中，指针是一种特殊的变量类型，它的值是内存中另一个变量的地址。指针提供了一种方式来间接访问和操作内存中的数据。</p><p>可以把指针想象成一个指向内存中某个位置的箭头。每个变量都占用内存中的一定空间，指针的作用就是记录那个空间的起始地址。</p><h3 id="定义指针"><a href="#定义指针" class="headerlink" title="定义指针"></a>定义指针</h3><p>指针的定义需要指定指针类型，它表明了指针所指向的数据的类型。定义指针的一般形式是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type* pointerName;</span><br></pre></td></tr></table></figure><p>其中 type 是指针所指向的数据的类型，*表示这是一个指针变量，pointerName 是指针变量的名称。</p><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* ptr; <span class="comment">// 定义一个指向int类型数据的指针</span></span><br></pre></td></tr></table></figure><p>这个声明创建了一个名为ptr的指针，它可以指向int类型的数据。开始时，ptr未被初始化，它可能包含任意值（即任意地址）。在使用指针之前，通常会将其初始化为某个变量的地址，或者通过动态内存分配函数分配的内存块的地址。</p><h3 id="指针的初始化"><a href="#指针的初始化" class="headerlink" title="指针的初始化"></a>指针的初始化</h3><p>指针可以通过使用地址运算符 &amp; 来获取变量的地址进行初始化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> var = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* ptr = &amp;var; <span class="comment">// ptr现在指向var</span></span><br></pre></td></tr></table></figure><p>或者，指针也可以被初始化为动态分配的内存地址：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// ptr指向一块新分配的int大小的内存</span></span><br></pre></td></tr></table></figure><h3 id="使用指针"><a href="#使用指针" class="headerlink" title="使用指针"></a>使用指针</h3><h4 id="解引用（Dereferencing）"><a href="#解引用（Dereferencing）" class="headerlink" title="解引用（Dereferencing）"></a>解引用（Dereferencing）</h4><p>通过解引用操作*，可以访问或修改指针所指向的内存位置中存储的数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*ptr = <span class="number">20</span>; <span class="comment">// 修改ptr所指向的内存中的值为20</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,*ptr); <span class="comment">// 输出指针指向的数据</span></span><br></pre></td></tr></table></figure><h4 id="指针运算"><a href="#指针运算" class="headerlink" title="指针运算"></a>指针运算</h4><p>指针的真正强大之处在于它能进行算术运算，这使得通过指针遍历数组和访问数据变得非常高效。</p><ul><li><strong>递增（++）</strong>：指针递增，其值增加了指向类型的大小（如int是4字节）。</li><li><strong>递减（–）</strong>：与递增相反，指针递减会减去指向类型的大小。</li><li><strong>指针的加减</strong>：可以将指针与整数相加或相减，改变其指向。</li></ul><p>指针递增（++）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">10</span>, <span class="number">20</span>&#125;;</span><br><span class="line"><span class="type">int</span> *ptr = arr;</span><br><span class="line">ptr++; <span class="comment">// 现在指向arr[1]</span></span><br></pre></td></tr></table></figure><p>指针递减（–）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptr--; <span class="comment">// 回到arr[0]</span></span><br></pre></td></tr></table></figure><p>指针的加减</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ptr += <span class="number">1</span>; <span class="comment">// 移动到arr[1]</span></span><br><span class="line">ptr -= <span class="number">1</span>; <span class="comment">// 回到arr[0]</span></span><br></pre></td></tr></table></figure><h3 id="指针与数组"><a href="#指针与数组" class="headerlink" title="指针与数组"></a>指针与数组</h3><p>数组名在表达式中会被当作指向其首元素的指针。这意味着数组和指针在很多情况下可以互换使用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> *p = arr; <span class="comment">// 指向数组首元素的指针</span></span><br></pre></td></tr></table></figure><h3 id="指针与函数"><a href="#指针与函数" class="headerlink" title="指针与函数"></a>指针与函数</h3><p>函数参数为指针，通过传递指针给函数，可以让函数直接修改变量的值，而不是在副本上操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">addTen</span><span class="params">(<span class="type">int</span> *p)</span> &#123;</span><br><span class="line">    *p += <span class="number">10</span>; <span class="comment">// 直接修改原始值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="返回指针的函数"><a href="#返回指针的函数" class="headerlink" title="返回指针的函数"></a>返回指针的函数</h3><p>函数也可以返回指针，但要确保指针指向的是静态内存或者是动态分配的内存，避免悬挂指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回静态内存地址</span></span><br><span class="line"><span class="type">int</span>* <span class="title function_">getStaticValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> value = <span class="number">10</span>; <span class="comment">// 静态局部变量</span></span><br><span class="line">    <span class="keyword">return</span> &amp;value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回动态分配内存地址</span></span><br><span class="line"><span class="type">int</span>* <span class="title function_">getDynamicArray</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>*)<span class="built_in">malloc</span>(size * <span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 动态分配内存</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>避免悬挂指针</strong>：</p><p>悬挂指针是指向已经释放或无效内存的指针。如果函数返回了指向局部非静态变量的指针，就会导致悬挂指针的问题，因为局部变量的内存在函数返回后不再有效。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="title function_">getLocalValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">10</span>; <span class="comment">// 局部变量</span></span><br><span class="line">    <span class="keyword">return</span> &amp;value; <span class="comment">// 错误：返回指向局部变量的指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是错误的做法，因为 value 是局部变量，在函数结束时被销毁，返回的指针指向一个已经不存在的内存位置。</p><h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><p>函数指针存储了函数的地址，可以用来动态调用函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数原型</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">greet</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, World!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数指针声明</span></span><br><span class="line"><span class="type">void</span> (*funcPtr)(<span class="type">void</span>) = &amp;greet;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过函数指针调用函数</span></span><br><span class="line">funcPtr();</span><br></pre></td></tr></table></figure><h3 id="指针数组与函数"><a href="#指针数组与函数" class="headerlink" title="指针数组与函数"></a>指针数组与函数</h3><p>指针数组可以用来存储函数指针，实现函数的动态调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义两个简单的函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">world</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;World\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个函数指针数组并初始化</span></span><br><span class="line">    <span class="type">void</span> (*funcPtrs[<span class="number">2</span>])() = &#123;hello, world&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 动态调用函数</span></span><br><span class="line">    funcPtrs[<span class="number">0</span>](); <span class="comment">// 调用hello函数</span></span><br><span class="line">    funcPtrs[<span class="number">1</span>](); <span class="comment">// 调用world函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个示例中，funcPtrs是一个存储函数指针的数组。通过指定索引，我们可以动态地调用hello或world函数。</p><h3 id="多级指针"><a href="#多级指针" class="headerlink" title="多级指针"></a>多级指针</h3><p>多级指针，例如二级指针，是指针的指针。它们在处理多维数组、动态分配的多维数据结构等场景中非常有用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> var = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> *ptr = &amp;var;</span><br><span class="line"><span class="type">int</span> **pptr = &amp;ptr; <span class="comment">// 二级指针</span></span><br></pre></td></tr></table></figure><h3 id="指针使用场景："><a href="#指针使用场景：" class="headerlink" title="指针使用场景："></a>指针使用场景：</h3><ul><li><strong>动态内存管理</strong>：配合malloc、realloc、calloc等函数，实现运行时的内存分配和释放。</li><li><strong>函数参数传递</strong>：允许函数通过指针参数修改调用者中的变量值。</li><li><strong>数组和字符串操作</strong>：通过指针算术运算灵活地遍历和操作数组和字符串。</li><li><strong>构建数据结构</strong>：是实现链表、树、图等复杂数据结构的基础。</li></ul><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>在 C 语言中，字符串是以字符数组的形式存在的，以空字符 <code>\0</code>（ASCII码为<code>0</code>的字符）结尾。这意味着，当 C 语言处理字符串时，它会一直处理直到遇到这个空字符。理解这一点对于正确操作 C 语言中的字符串至关重要。</p><h3 id="声明和初始化字符串"><a href="#声明和初始化字符串" class="headerlink" title="声明和初始化字符串"></a>声明和初始化字符串</h3><p>在 C 语言中，可以使用字符数组来声明和初始化字符串：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> greeting[<span class="number">6</span>] = &#123;<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure><p>更简单的方式是使用<strong>字符串字面量</strong>，编译器会自动在字符串末尾加上\0：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> greeting[] = <span class="string">&quot;Hello&quot;</span>;</span><br></pre></td></tr></table></figure><p>字符串除了使用字符数组来表示还可以用字符指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *greeting = <span class="string">&quot;Hello&quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="字符串的输入和输出"><a href="#字符串的输入和输出" class="headerlink" title="字符串的输入和输出"></a>字符串的输入和输出</h3><p>使用 <code>printf</code> 函数输出字符串，使用%s格式指定符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, greeting);</span><br></pre></td></tr></table></figure><p>使用 <code>scanf</code> 函数读取字符串（注意，scanf在读取字符串时会因空格、制表符或换行符而停止读取）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> var;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;var); <span class="comment">// 输入整型值</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, name); <span class="comment">// 输入字符串</span></span><br><span class="line"><span class="comment">// 不需要&amp;符号，因为数组名本身就是地址</span></span><br></pre></td></tr></table></figure><h3 id="字符串操作函数"><a href="#字符串操作函数" class="headerlink" title="字符串操作函数"></a>字符串操作函数</h3><p>C 标准库（string.h）提供了一系列操作字符串的函数，包括字符串连接、复制、长度计算等。</p><h4 id="字符串复制"><a href="#字符串复制" class="headerlink" title="字符串复制"></a>字符串复制</h4><ul><li>strcpy(destination, source)：复制source字符串到destination。</li><li>strncpy(destination, source, n)：复制最多n个字符从source到destination。</li></ul><h4 id="字符串连接"><a href="#字符串连接" class="headerlink" title="字符串连接"></a>字符串连接</h4><ul><li>strcat(destination, source)：将source字符串追加到destination字符串的末尾。</li><li>strncat(destination, source, n)：将最多n个字符从source字符串追加到destination字符串的末尾。</li></ul><h4 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h4><ul><li>strcmp(str1, str2)：比较两个字符串。如果str1与str2相同，返回<code>0</code>。</li><li>strncmp(str1, str2, n)：比较两个字符串的前n个字符。</li></ul><h4 id="字符串长度"><a href="#字符串长度" class="headerlink" title="字符串长度"></a>字符串长度</h4><ul><li>strlen(str)：返回str的长度，不包括结尾的<code>\0</code>。</li></ul><h4 id="字符串查找"><a href="#字符串查找" class="headerlink" title="字符串查找"></a>字符串查找</h4><ul><li>strchr(str, c)：查找字符c在str中首次出现的位置。</li><li>strrchr(str, c)：查找字符c在str中最后一次出现的位置。</li><li>strstr(haystack, needle)：查找字符串needle在haystack中首次出现的位置。</li><li>strspn(str1, str2)：返回str1中包含的仅由str2中字符组成的最长子串的长度。</li><li>strcspn(str1, str2)：返回str1中不含有str2中任何字符的最长子串的长度。</li><li>strpbrk(str1, str2)：搜索str1中的任何字符是否在str2中出现，返回第一个匹配字符的位置。</li></ul><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li>strdup(str)：复制str字符串，使用malloc动态分配内存（非标准函数，但常见）。</li><li>memset(ptr, value, num)：将ptr开始的前num个字节都用value填充。</li><li>memcpy(destination, source, num)：从source复制num个字节到destination。</li><li>memmove(destination, source, num)：与memcpy相似，但正确处理重叠的内存区域。</li></ul><p>下面是一个简单的示例，展示如何使用部分字符串函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> str1[<span class="number">20</span>] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="type">char</span> str2[<span class="number">20</span>] = <span class="string">&quot;World&quot;</span>;</span><br><span class="line">    <span class="type">char</span> str3[<span class="number">40</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 字符串连接</span></span><br><span class="line">    <span class="built_in">strcpy</span>(str3, str1);</span><br><span class="line">    <span class="built_in">strcat</span>(str3, <span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="built_in">strcat</span>(str3, str2);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str3); <span class="comment">// 输出 &quot;Hello World&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字符串比较</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(str1, str2) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\&quot;%s\&quot; is less than \&quot;%s\&quot;\n&quot;</span>, str1, str2);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 字符串查找</span></span><br><span class="line">    <span class="type">char</span> *p = <span class="built_in">strstr</span>(str3, <span class="string">&quot;World&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (p) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Found \&quot;World\&quot; in \&quot;%s\&quot;\n&quot;</span>, str3);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数是一种让程序结构化的重要方式，允许代码的重用、模块化设计和简化复杂问题。<br>C 语言支持自定义函数和标准库函数。</p><h3 id="函数定义与声明"><a href="#函数定义与声明" class="headerlink" title="函数定义与声明:"></a>函数定义与声明:</h3><p>定义指明了函数的实际代码体（即函数做什么和如何做）。</p><p>声明告诉编译器函数的名称、返回类型和参数（类型和数量），但不定义具体的操作。</p><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">函数声明</span></span><br><span class="line"><span class="comment">int ：函数返回类型， add ： 函数名</span></span><br><span class="line"><span class="comment">int x, int y ：参数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数参数传递"><a href="#函数参数传递" class="headerlink" title="函数参数传递"></a>函数参数传递</h3><ul><li><strong>按值传递</strong>：函数收到参数值的副本。在函数内部对参数的修改不会影响原始数据。</li><li><strong>按指针（地址）传递</strong>：通过传递参数的地址（使用指针），函数内的变化可以影响原始数据。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按值传递</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">changeValue</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    num = <span class="number">100</span>; <span class="comment">// 尝试修改，实际不会影响原始值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">// x的副本被传递</span></span><br><span class="line">    changeValue(x);  <span class="comment">// 函数调用：执行函数</span></span><br><span class="line">    <span class="comment">// x的值不变，仍然是5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按指针（地址）传递</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">changeReference</span><span class="params">(<span class="type">int</span> *num)</span> &#123;</span><br><span class="line">    *num = <span class="number">100</span>; <span class="comment">// 通过指针修改原始值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line">    change(x); <span class="comment">// 传递x的地址</span></span><br><span class="line">    <span class="comment">// x的值现在变成了100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数调用："><a href="#函数调用：" class="headerlink" title="函数调用："></a>函数调用：</h3><p>函数调用是 C 语言中一个核心概念，它允许在程序的任何地方执行一个函数。函数调用的基本过程包括将控制权从调用函数（caller）转移到被调用函数（callee），执行被调用函数的代码体，然后返回控制权给调用函数。</p><h4 id="函数调用过程："><a href="#函数调用过程：" class="headerlink" title="函数调用过程："></a>函数调用过程：</h4><p><strong>1. 参数传递</strong>：当调用函数时，会按照函数定义的参数列表，将实际参数的值（按值传递）或地址（按指针传递）传递给函数。</p><p><strong>2. 执行函数体</strong>：一旦参数被传递，控制权转移到被调用函数，开始执行函数体内的代码。</p><p><strong>3. 返回值</strong>：函数完成其任务后，可以通过 return 语句返回一个值给调用者。如果函数类型为 void，则不返回任何值。</p><p><strong>4. 控制权返回</strong>：函数执行完毕后，控制权返回到调用函数的位置，程序继续执行下一条语句。</p><h3 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h3><p>递归函数是一种直接或间接调用自身的函数。它通常用于解决可以分解为相似子问题的问题。</p><p><strong>示例</strong>：计算阶乘：n！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">factorial</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用场景</strong>：递归在算法领域非常有用，尤其适合处理分治法、快速排序、二叉树遍历等问题。</p><h3 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h3><p>使用 inline 关键字声明的函数，在编译时会将函数体的代码直接插入每个调用点，而不是进行常规的函数调用。这可以减少函数调用的开销，但增加了编译后的代码大小。</p><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; y ? x : y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用场景</strong>：对于那些体积小、调用频繁的函数，使用inline可以减少函数调用的开销，如简单的数学运算和逻辑判断函数。</p><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>函数指针使得 C 语言支持回调函数，即将函数作为参数传递给另一个函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">greet</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, World!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">repeat</span><span class="params">(<span class="type">void</span> (*callbackFunc)(), <span class="type">int</span> times)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; times; i++) &#123;</span><br><span class="line">        callbackFunc(); <span class="comment">// 调用回调函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    repeat(greet, <span class="number">3</span>); <span class="comment">// 将greet函数作为参数传递给repeat函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用场景</strong>：<br>允许库或框架的用户提供自定义代码片段，根据需要在框架内部调用，以实现特定功能。例如，自定义排序函数中的比较操作。</p><h3 id="函数的分类"><a href="#函数的分类" class="headerlink" title="函数的分类:"></a>函数的分类:</h3><ul><li><p><strong>用户定义函数</strong>：由程序员定义的函数，用于执行特定任务。</p></li><li><p><strong>标准库函数</strong>：C 语言标准库提供的函数，常见的标准库函数包括以下几类：</p><p><strong>1. 输入和输出</strong>（stdio.h）：用于格式化输入和输出，如printf和scanf，以及文件操作的fgets和fputs。</p><p><strong>2. 字符串处理</strong>（string.h）：提供字符串操作的基本函数，包括复制(strcpy)、连接(strcat)、长度计算(strlen)和比较(strcmp)。</p><p><strong>3. 数学计算</strong>（math.h）：包括幂函数(pow)、平方根(sqrt)和三角函数(sin, cos, tan)等数学运算。</p><p><strong>4. 内存管理</strong>（stdlib.h）：用于动态内存分配和释放，包括malloc、free和realloc等函数。</p></li></ul><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>在 C 语言中，内存管理是一个核心概念，涉及到动态内存分配、使用和释放。理解如何在C语言中管理内存对于编写高效、可靠的程序至关重要。</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>C语言中的内存大致可以分为两大部分：<strong>静态&#x2F;自动内存分配和动态内存分配</strong>。</p><h4 id="静态内存分配："><a href="#静态内存分配：" class="headerlink" title="静态内存分配："></a>静态内存分配：</h4><p>静态内存分配发生在程序编译时，它为全局变量和静态变量分配固定大小的内存。这些变量在程序启动时被创建，在程序结束时才被销毁。例如，全局变量、static 静态变量都属于这一类。它的生命周期贯穿整个程序执行过程。</p><h4 id="自动内存分配："><a href="#自动内存分配：" class="headerlink" title="自动内存分配："></a>自动内存分配：</h4><p>自动内存分配是指在函数调用时为其局部变量分配栈上的内存。这些局部变量只在函数执行期间存在，函数返回时它们的内存自动被释放。自动内存分配的变量的生命周期仅限于它们所在的函数调用栈帧内。</p><p>简而言之，静态内存分配涉及到整个程序运行期间都存在的变量，而自动内存分配涉及到只在特定函数调用期间存在的局部变量。</p><h4 id="动态内存分配："><a href="#动态内存分配：" class="headerlink" title="动态内存分配："></a>动态内存分配：</h4><p>C语言中的动态内存分配是一种在程序运行时（而不是在编译时）分配和释放内存的机制。这允许程序根据需要分配任意大小的内存块，使得内存使用更加灵活。C 提供了几个标准库函数来管理动态内存，主要包括malloc、calloc、realloc和free。</p><p>下面让我们来看下这几个内存分配函数如何使用？</p><p><code>malloc :</code><br>malloc函数用来分配一块指定大小的内存区域。分配的内存未初始化，可能包含任意数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：size 是要分配的字节大小。</span></span><br><span class="line"><span class="comment">返回值：成功时返回指向分配的内存的指针；如果分配失败，则返回NULL。</span></span><br><span class="line"><span class="comment">注意：malloc 分配的内存内容是未初始化的，数据可能是未知的。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> size)</span>; <span class="comment">// 函数原型</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> *ptr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">5</span>); <span class="comment">// 分配一个5个整数大小的内存块</span></span><br><span class="line"><span class="keyword">if</span> (ptr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">// 使用ptr</span></span><br><span class="line">    <span class="built_in">free</span>(ptr); <span class="comment">// 释放内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>释放内存</strong></p><p>使用 free 函数来释放之前通过malloc、calloc或realloc分配的内存。释放后的内存不能再被访问，否则会导致未定义行为（如程序崩溃）。</p><p>释放内存后，已释放内存的指针称为<strong>悬挂指针</strong>。尝试访问已释放的内存将导致未定义行为。为了避免这种情况，释放内存后应将指针设置为 NULL。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">free</span>(ptr);</span><br><span class="line">ptr = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><p>如果忘记释放已分配的动态内存，这部分内存将无法被再次利用，导致内存泄漏。长时间运行的程序如果频繁泄漏内存，可能会耗尽系统资源。 </p><h4 id="检测和避免"><a href="#检测和避免" class="headerlink" title="检测和避免"></a>检测和避免</h4><p><strong>检测工具</strong>：</p><ul><li><strong>Valgrind</strong>：Linux下一个广泛使用的内存调试工具，可以帮助开发者发现内存泄漏、使用未初始化的内存、访问已释放的内存等问题。</li><li><strong>Visual Leak Detector</strong> (VLD)：专为 Windows 平台开发的内存泄露检测工具，集成于Visual Studio，用于检测基于C&#x2F;C++的应用程序。</li></ul><p><strong>避免策略</strong>：<br>及时释放内存：确保每次malloc或calloc后，相应的内存不再需要时使用 free 释放。</p><h2 id="预处理指令"><a href="#预处理指令" class="headerlink" title="预处理指令"></a>预处理指令</h2><p>C 语言中的预处理指令是在编译之前由预处理器执行的指令。它们不是 C 语言的一部分，而是在编译过程中的一个步骤，用于文本替换、条件编译等。预处理指令以井号（#）开头。</p><p>下面是一些常见的预处理指令及其使用示例：</p><h3 id="include-指令"><a href="#include-指令" class="headerlink" title="#include 指令"></a>#include 指令</h3><p>#include指令用于包含一个源代码文件或标准库头文件。它告诉预处理器在实际编译之前，将指定的文件内容插入当前位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> <span class="comment">// 包含标准输入输出头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myheader.h&quot;</span> <span class="comment">// 包含用户定义的头文件</span></span></span><br></pre></td></tr></table></figure><h3 id="define-指令"><a href="#define-指令" class="headerlink" title="#define 指令"></a>#define 指令</h3><p>#define用于定义宏。它告诉预处理器，将后续代码中所有的宏名称替换为定义的内容。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQUARE(x) ((x) * (x))</span></span><br></pre></td></tr></table></figure><h3 id="undef-指令"><a href="#undef-指令" class="headerlink" title="#undef 指令"></a>#undef 指令</h3><p>#undef 用于取消宏的定义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TABLE_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> TABLE_SIZE <span class="comment">// 取消 TABLE_SIZE 的定义</span></span></span><br></pre></td></tr></table></figure><h3 id="if-else-elif-endif-指令"><a href="#if-else-elif-endif-指令" class="headerlink" title="#if, #else, #elif, #endif 指令"></a>#if, #else, #elif, #endif 指令</h3><p>这些指令用于条件编译。只有当给定的条件为真时，编译器才会编译这部分代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DEBUG</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Debug information\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>#ifdef 和 #ifndef 指令</p><p>#ifdef检查一个宏是否被定义，#ifndef检查一个宏是否未被定义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义宏 DEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Debug mode is on.\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DEBUG</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Debug mode is off.\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="error-和-pragma-指令"><a href="#error-和-pragma-指令" class="headerlink" title="#error 和 #pragma 指令"></a>#error 和 #pragma 指令</h3><p>#error 指令允许程序员在代码中插入一个编译时错误。当预处理器遇到#error指令时，它会停止编译过程，并显示紧跟在#error后面的文本消息。这对于指出代码中的问题、配置错误或不支持的编译环境非常有用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined(_WIN64) || defined(__x86_64__)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> SUPPORTED_PLATFORM</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SUPPORTED_PLATFORM</span></span><br><span class="line">    <span class="meta">#<span class="keyword">error</span> <span class="string">&quot;This code must be compiled on a supported platform.&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>_WIN64和__x86_64__是预定义的宏，它们通常在编译器层面被定义，用于指示特定的平台或架构。<br>这些宏不是在用户的源代码中定义的，而是由编译器根据目标编译平台自动定义。</p><p>#pragma 指令用于提供编译器特定的指令，其行为依赖于使用的编译器。它通常用于控制编译器的特定行为，如禁用警告、优化设置或其他编译器特定的特性。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once  <span class="comment">// 防止头文件内容被多次包含</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize (<span class="string">&quot;O3&quot;</span>) <span class="comment">// 指示GCC编译器使用O3级别的优化</span></span></span><br></pre></td></tr></table></figure><p>下面是一个简单的示例，展示了如何使用预处理指令来控制代码的编译。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG 1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Debugging is enabled.\n&quot;</span>);</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Program is running.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，如果DEBUG被定义，则程序会打印调试信息。这是通过条件编译指令#ifdef实现的。</p><p>C 语言的预处理指令是编写灵活和高效代码的强大工具。通过合理使用预处理指令，可以实现<strong>条件编译、调试开关</strong>等功能，从而提升代码的可维护性和性能。</p><h2 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h2><p>在C语言中，输入和输出（I&#x2F;O）是基于数据流的概念。数据流可以是输入流或输出流，用于从源（如键盘、文件）读取数据或向目标（如屏幕、文件）写入数据。C标准库stdio.h提供了丰富的I&#x2F;O处理函数。</p><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><h4 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h4><p><strong>1. 输入流</strong>：数据从输入源（如键盘、文件）流向程序。</p><p><strong>2. 输出流</strong>：数据从程序流向输出目标（如显示器、文件）。</p><p><strong>3. 标准流</strong></p><ul><li><strong>stdin</strong>：标准输入流，通常对应于键盘输入。</li><li><strong>stdout</strong>：标准输出流，通常对应于屏幕输出。</li><li><strong>stderr</strong>：标准错误流，用于输出错误消息，即使在标准输出被重定向的情况下，错误信息通常也会显示在屏幕上。</li></ul><p><strong>4. 文件流</strong></p><p>  除了标准的输入和输出流，C语言允许操作文件流，即直接从文件读取数据或向文件写入数据。</p><h4 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h4><p>缓冲区是临时存储数据的内存区域，在数据在源和目标之间传输时使用。</p><p><strong>分类</strong>：</p><ul><li><strong>全缓冲</strong>：当缓冲区满时，数据才会被实际地写入目的地。例如，向文件写入数据通常是全缓冲的。</li><li><strong>行缓冲</strong>：当遇到换行符时，数据才会被实际地写入目的地。例如，标准输出stdout（通常是终端或屏幕）就是行缓冲的。</li><li><strong>无缓冲</strong>：数据立即被写入目的地，不经过缓冲区。例如，标准错误 stderr 通常是无缓冲的</li></ul><h3 id="格式化输入、输出函数"><a href="#格式化输入、输出函数" class="headerlink" title="格式化输入、输出函数"></a>格式化输入、输出函数</h3><h4 id="scanf和printf"><a href="#scanf和printf" class="headerlink" title="scanf和printf:"></a>scanf和printf:</h4><p>printf 函数用于向标准输出（通常是屏幕）打印格式化的字符串。</p><p>scanf 函数用于从标准输入（通常是键盘）读取格式化的输入。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Enter your age: &quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;age);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;You are %d years old.\n&quot;</span>, age);</span><br></pre></td></tr></table></figure><h4 id="getchar和putchar-字符输入、输出"><a href="#getchar和putchar-字符输入、输出" class="headerlink" title="getchar和putchar: 字符输入、输出"></a>getchar和putchar: 字符输入、输出</h4><p>getchar 函数用于读取下一个可用的字符从标准输入，并返回它。</p><p>putchar 函数用于写一个字符到标准输出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> ch;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Enter a character: &quot;</span>);</span><br><span class="line">ch = getchar();</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">&#x27;You entered: &#x27;</span>);</span><br><span class="line"><span class="built_in">putchar</span>(ch);</span><br></pre></td></tr></table></figure><h4 id="gets和puts-字符串输入、输出"><a href="#gets和puts-字符串输入、输出" class="headerlink" title="gets和puts : 字符串输入、输出"></a>gets和puts : 字符串输入、输出</h4><p>gets 函数用于从标准输入读取一行字符串直到遇到换行符。gets函数已经被废弃，因为它存在缓冲区溢出的风险，推荐使用fgets。</p><p>puts 函数用于输出一个字符串到标准输出，并在末尾自动添加换行符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Enter a string: &quot;</span>);</span><br><span class="line">fgets(str, <span class="number">100</span>, <span class="built_in">stdin</span>); <span class="comment">// 使用fgets代替gets</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;You entered: &quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(str);</span><br></pre></td></tr></table></figure><h4 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h4><p><strong>fopen、fclose、fgetc、fputc、fscanf、fprintf、feof、fseek、ftell、rewind</strong></p><p>fopen 和 fclose 函数用于打开和关闭文件。</p><p>fgetc 和 fputc 用于读写单个字符到文件。</p><p>fscanf 和 fprintf 用于读写格式化的数据到文件。</p><p>feof 用于检测文件结束。</p><p>fseek 设置文件位置指针到指定位置。</p><p>ftell 返回当前文件位置。</p><p>rewind 重置文件位置指针到文件开始。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FILE *file = fopen(<span class="string">&quot;example.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;Error opening file&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">fprintf</span>(file, <span class="string">&quot;Hello, file!\n&quot;</span>);</span><br><span class="line">fclose(file);</span><br></pre></td></tr></table></figure><h4 id="错误处理-perror"><a href="#错误处理-perror" class="headerlink" title="错误处理: perror"></a>错误处理: perror</h4><p>perror 函数用于打印一个错误消息到标准错误。它将根据全局变量 errno 的值输出一个描述当前错误的字符串。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FILE *file = fopen(<span class="string">&quot;nonexistent.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">fclose(file);</span><br></pre></td></tr></table></figure><h2 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h2><p>C语言的标准库提供了一系列广泛使用的函数，使得处理输入输出、字符串操作、内存管理、数学计算和时间操作等任务变得简单。下面是一些基本的标准库及其常用函数的简单介绍：</p><h3 id="stdio-h"><a href="#stdio-h" class="headerlink" title="stdio.h"></a>stdio.h</h3><p><strong>用途</strong>：输入和输出</p><p><strong>常用函数</strong>：printf()（输出格式化文本），scanf()（输入格式化文本）</p><h3 id="stdlib-h"><a href="#stdlib-h" class="headerlink" title="stdlib.h"></a>stdlib.h</h3><p><strong>用途</strong>：通用工具，如内存管理、程序控制</p><p><strong>常用函数</strong>：malloc()（分配内存），free()（释放内存），atoi()（字符串转整数）</p><h3 id="string-h"><a href="#string-h" class="headerlink" title="string.h"></a>string.h</h3><p><strong>用途</strong>：字符串处理</p><p><strong>常用函数</strong>：strcpy()（复制字符串），strlen()（计算字符串长度）</p><h3 id="math-h"><a href="#math-h" class="headerlink" title="math.h"></a>math.h</h3><p><strong>用途</strong>：数学计算</p><p><strong>常用函数</strong>：pow()（幂运算），sqrt()（平方根）</p><h3 id="time-h"><a href="#time-h" class="headerlink" title="time.h"></a>time.h</h3><p><strong>用途</strong>：时间和日期处理</p><p><strong>常用函数</strong>：time()（获取当前时间），localtime()（转换为本地时间）</p><h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h2><h3 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h3><p>typedef 是一种关键字，用于为现有的数据类型创建一个新的名称（别名）。这在提高代码的可读性和简化复杂类型定义方面非常有用。</p><h4 id="用途"><a href="#用途" class="headerlink" title="用途:"></a>用途:</h4><ul><li><strong>定义复杂的数据结构</strong>：当你有一个复杂的结构体或联合体时，可以使用 typedef 给它一个更简单的名字。</li><li><strong>提高代码的可移植性</strong>：通过 typedef 定义平台相关的类型，使得代码更容易在不同平台间移植。</li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> ulong;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125; Point;</span><br></pre></td></tr></table></figure><p>在这个例子中，ulong   现在可以用作 unsigned long 类型的别名，而 Point 可以用作上述结构体的类型名称。</p><h3 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h3><p>命令行参数允许用户在程序启动时向程序传递信息。C 程序的 main 函数可以接受命令行参数，这是通过 main 函数的参数实现的：<code>int argc, char *argv[]</code>。</p><h4 id="用途-1"><a href="#用途-1" class="headerlink" title="用途"></a>用途</h4><ul><li>参数个数（argc）：表示传递给程序的命令行参数的数量。</li><li>参数值（argv）：是一个指针数组，每个元素指向一个参数的字符串表示。</li></ul><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Program name: %s\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Arguments: \n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; argc; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, argv[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No additional arguments were passed.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，程序首先打印出程序自己的名字（<code>argv[0]</code>），然后检查是否有其他命令行参数传递给程序，并打印它们。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章主要是提供一个 C 语言入门的学习指南，帮助初学者快速入门 C 语言。</p><p>下面，让我们简短回顾下上文提到的知识点：</p><ul><li><strong>基础语法</strong>：我们介绍了 C 语言的基本构建块，包括变量声明、数据类型和控制流结构，这是编写任何 C 程序的基础。</li><li><strong>数组和指针</strong>：这两个概念是 C 语言中管理数据集的核心工具。我们学习了如何通过它们高效地访问和操作数据。</li><li><strong>字符串处理</strong>：学习了 C 语言中字符串的操作和处理方法，包括字符串的基本操作如连接、比较和搜索。</li><li><strong>函数</strong>：介绍了函数的定义和使用，强调了封装和模块化代码的重要性，以提高程序的可读性和可维护性。</li><li><strong>内存管理</strong>：了解了C语言如何与计算机内存直接交互，包括动态分配、使用和释放内存的方法。</li><li><strong>预处理指令</strong>：讨论了预处理器如何在编译之前处理源代码，以及如何使用预处理指令来增强程序的可配置性和灵活性。</li><li><strong>输入和输出</strong>：我们学习了标准输入输出库的基本使用，理解了如何实现程序与用户之间的交互。</li><li><strong>标准库</strong>：介绍了C语言提供的强大标准库，它包括了一系列实用的函数和工具，用于处理字符串、数学计算、时间日期等。</li></ul><h3 id="最后："><a href="#最后：" class="headerlink" title="最后："></a>最后：</h3><p>当然，学习 C 语言只是学习编程的第一步，作为一门直接与硬件和操作系统打交道的计算机底层语言，要想掌握 C，你还得学习这两门课程：计算机组成原理、操作系统。甚至，你还得学习汇编语言。除此之外，学会在 Linux 环境下进行 C 编程也是必须要掌握的。 如果你想学习 Linux 编程，包括系统编程和网络编程相关的内容，可以关注我的公众号「跟着小康学编程」，这里会定时更新计算机编程相关的技术文章，感兴趣的读者可以关注一下：</p><p>另外，我最近新创建了一个技术交流群，大家如果在阅读的过程中有遇到问题或者有不理解的地方，欢迎大家加群询问或者评论区询问，我能解决的都尽可能给大家回复。</p><p>扫一扫小康的个人微信，备注「<strong>加群</strong>」即可。 </p>]]></content>
      
      
      <categories>
          
          <category> 编程语言学习 </category>
          
          <category> C 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言入门 </tag>
            
            <tag> C语言基础 </tag>
            
            <tag> C快速学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 网络编程从入门到进阶 学习指南</title>
      <link href="/netprog/"/>
      <url>/netprog/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>大家好，我是小康。在上一篇文章中，我们探讨了 Linux 系统编程的诸多基础构件，包括文件操作、进程管理和线程同步等，接下来，我们将视野扩展到网络世界。在这个新篇章里，我们要让应用跳出单机限制，学会在网络上跨机器交流信息。</p><p>接下来，我们要深入套接字（sockets）和 TCP&#x2F;IP 协议，揭示如何在 Linux 下构建通信和网络服务。我们会从基础说起，逐步深入。目标是为初学者提供一个 <strong>Linux 网络编程从入门到进阶</strong>的学习指南！</p><h1 id="网络通信基础"><a href="#网络通信基础" class="headerlink" title="网络通信基础"></a>网络通信基础</h1><p>思考一下，如果计算机想要“交朋友”，它们需要怎样互相沟通？正如人们交流需要使用语言一样，计算机通信也必须遵守一套规则 — 这就是<strong>网络协议</strong>。</p><p>协议确保信息可以在不同的设备和平台之间清晰、准确地传递。要深入理解协议，我们首先要熟悉两个基础的通信模型：OSI 和 TCP&#x2F;IP 模型。</p><h2 id="OSI-模型和-TCP-IP-模型"><a href="#OSI-模型和-TCP-IP-模型" class="headerlink" title="OSI 模型和 TCP&#x2F;IP 模型"></a>OSI 模型和 TCP&#x2F;IP 模型</h2><p>在网络通信的世界里，OSI（开放式系统互联通信参考模型）和 TCP&#x2F;IP（传输控制协议&#x2F;网际协议）模型扮演着基础框架的角色。它们各自描述了网络通信的多个层次和阶段，但以不同的方式来分类和处理数据传输的细节。</p><ul><li><p><strong>OSI模型</strong> </p><p>OSI（Open Systems Interconnection）模型是一个概念性框架，用于描述网络中不同操作层次的功能。由七层组成，从物理硬件的电气信号（物理层），到应用层（如网页浏览器），每一层都有其独特的功能和协议。</p></li><li><p><strong>TCP&#x2F;IP模型</strong></p><p>TCP&#x2F;IP 模型，则更加贴近实际网络中的运作。Linux 的网络协议栈就是基于该模型实现的。它是基于四层架构，将网络通信过程简化并集中在协议族上，如传输控制协议（TCP）和互联网协议（IP），这两种协议是现代网络通信中最为核心的部分。</p></li></ul><h3 id="简单图示："><a href="#简单图示：" class="headerlink" title="简单图示："></a>简单图示：</h3><p><img src="/images/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/1.png"></p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="地址簿：IP地址和MAC地址"><a href="#地址簿：IP地址和MAC地址" class="headerlink" title="地址簿：IP地址和MAC地址"></a>地址簿：IP地址和MAC地址</h3><p>想象一下，互联网是一个巨大的数字城市，而每台计算机或网络设备就像是住在这个城市里的居民。</p><p><strong>IP地址：数字世界的“家庭住址”</strong></p><p>每台设备的 IP 地址就像是它在这个数字城市里的家庭住址。当计算机需要发送信息或访问网络资源时，它会使用目的地设备的 IP 地址来确保信息正确地送达。这个地址有点像是我们现实世界中的邮寄地址，可以根据网络环境的变化而变化（例如，当设备从家庭网络移动到办公室网络时）。</p><p><strong>MAC地址：网络中的“身份证”</strong></p><p>然后，我们有 MAC 地址，这是网络设备的另一个关键标识。每台设备的 MAC 地址都是独一无二的，类似于每个人的身份证号码。它是在设备制造时就被分配的，并且在大多数情况下，这个地址是固定不变的。MAC 地址在本地网络（如家庭或办公室网络）内起着重要作用，它帮助确保信息被准确地送达到特定设备，就像邮递员需要知道收件人的详细身份信息才能将包裹准确递交。</p><p><strong>总结一下</strong>：ip 地址可以让数据包找到目的主机所在的网络，而 MAC 地址确保数据包能准确送到目的主机上。</p><h4 id="导航路线：子网掩码和网关"><a href="#导航路线：子网掩码和网关" class="headerlink" title="导航路线：子网掩码和网关"></a>导航路线：子网掩码和网关</h4><p><strong>子网掩码：定位网络的“区域地图”</strong></p><p>子网掩码可以被视为定位网络内部和外部地址的“区域地图”。就像在一个大城市中，你需要知道哪些街道属于你的社区，哪些通往城市的其他部分。子网掩码帮助计算机确定一个 IP 地址是属于本地网络（即同一个子网）还是位于外部网络。</p><ul><li><strong>内部导航</strong>：如果目的地IP地址与计算机所在的子网相匹配（根据子网掩码判断），则数据包在本地网络内传送。</li><li><strong>外部导航</strong>：如果目的地不在本地子网内，计算机知道它需要将数据发送到更远的目的地。</li></ul><p><strong>网关：网络间的“中转站”</strong></p><p>网关在网络通信中扮演中转站的角色。当你的数据包需要从一个网络（比如你的家庭网络）发送到另一个网络（比如你的工作地点的网络）时，网关是这个旅程的第一站。</p><ul><li><strong>路由决策</strong>：网关检查数据包的目的 IP 地址，然后使用它的路由表来决定最佳的路径将数据包发送到目标网络。</li></ul><p><strong>总结：</strong> 子网掩码和网关共同协作，帮助数据包在复杂的网络结构中找到最有效的路径。子网掩码确定数据包是否在本地网络内，而网关指导跨网络的数据传输。</p><h4 id="端口-：确保数据到达正确的“应用程序门牌号”"><a href="#端口-：确保数据到达正确的“应用程序门牌号”" class="headerlink" title="端口 ：确保数据到达正确的“应用程序门牌号”"></a>端口 ：确保数据到达正确的“应用程序门牌号”</h4><p>好了，现在我们的数据包已经知道了去哪里，但它如何确保被正确的程序接收呢？这就是端口登场的时候了。端口号就像是收件人的门牌号，确保数据不只是送到了正确的地址，而且被正确的应用程序接收。</p><h2 id="Linux-套接字编程"><a href="#Linux-套接字编程" class="headerlink" title="Linux 套接字编程"></a>Linux 套接字编程</h2><p><img src="/images/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/2.png"></p><h3 id="套接字是什么"><a href="#套接字是什么" class="headerlink" title="套接字是什么"></a>套接字是什么</h3><p>在网络编程中，<strong>套接字</strong>就像是网络世界的<strong>通信端口</strong>。每一个联网的应用程序，为了能够互发消息，都会使用到这样一个端口。这个端口允许数据从一个程序流向另一个程序。简而言之，套接字是应用程序用来在网络上交流的桥梁。</p><p>想象一下，你要用手机给朋友发一条信息。你只需要知道他们的手机号码，这样信息就可以直接发送到他们的手机上。在网络编程中，套接字的作用类似。它使用IP地址 （类似于手机号码） 来确定数据发送的目标位置，而端口号则像是确定信息应该送达到对方手机中的哪个应用程序。这样，套接字（使用 ip 地址和端口）确保了数据能够准确地发送给正在监听那个特定端口的程序。</p><p><strong>套接字的工作原理</strong>：</p><p>套接字的工作原理就像是电话通话的过程。首先，你需要拨打一个号码（即IP地址+端口号）来建立连接。一旦连接建立，电话线（网络连接）就激活了，你的声音（数据）就可以通过它传送。</p><p>在这个过程中：</p><p><strong>拨号</strong>对应于网络编程中的<strong>连接建立</strong>，这是通过调用套接字API来完成的，比如 connect( )函数。</p><p><strong>通话</strong>对应于<strong>数据传输</strong>，你可以通过套接字发送 send( ) 和接收 recv( )数据。</p><p><strong>挂断</strong>对应于<strong>结束连接</strong>，完成通信后，你需要关闭套接字 close( )函数，以结束会话并清理资源。</p><p>在整个通信过程中，套接字保证了数据从一个程序准确地传送到另一个程序，无论这两个程序是在同一台计算机上还是跨越了广阔的互联网。</p><p>在 Linux 中，套接字其实就是一系列的编程接口，Linux 提供了很多特定的 API 来创建和使用套接字，接下来，让我们学习如何使用 Linux 套接字 api 来编写各种网络服务程序。</p><h3 id="套接字类型"><a href="#套接字类型" class="headerlink" title="套接字类型"></a>套接字类型</h3><p>在 Linux 中，有三种套接字类型，<strong>前两种是重点掌握的</strong>，第三种了解即可。</p><p><strong>TCP套接字 (SOCK_STREAM):</strong> </p><ul><li>这是一种可靠的套接字连接，保证数据传输的完整性和顺序。</li><li>必须先建立连接，才能传输数据。</li><li>常用于需要准确数据传输的应用，如网页浏览和文件传输。</li></ul><p><strong>UDP套接字 (SOCK_DGRAM):</strong></p><ul><li>不需要建立连接，但是数据传输可能会丢失，没有先后顺序。</li><li>适用于视频流和在线游戏，这些应用可以容忍一定的数据丢失。</li></ul><p><strong>原始套接字 (SOCK_RAW):</strong></p><ul><li>允许直接对较低层次的协议如 IP 或 ICMP 进行访问和操作，它绕过了 TCP 和 UDP 的处理。</li><li>开发者可以使用原始套接字来构建自定义的协议或直接处理来自网络的数据包。</li><li>通常用于需要进行网络诊断或网络安全应用，如自定义的ping实现，或者网络嗅探器。</li></ul><p>选择哪种类型取决于你的应用需求—是否需要可靠传输（TCP），还是速度更快但可能丢失数据也没关系（UDP）。</p><p>选择使用原始套接字通常意味着你需要对网络协议有深入的理解，因为你将直接与网络层面的数据交互。这比处理 TCP 和 UDP 套接字更复杂，通常只在特殊情况下使用，例如网络工具的开发或定制协议的实现。</p><h3 id="套接字常用-API"><a href="#套接字常用-API" class="headerlink" title="套接字常用 API"></a>套接字常用 API</h3><p>接下来，看下常用的套接字 API：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">socket()                    : 创建套接字</span><br><span class="line">bind()                      : 绑定套接字到本地地址</span><br><span class="line">listen()                    : 监听网络连接</span><br><span class="line">accept()                    : 接受网络连接</span><br><span class="line">connect()                   : 连接到远程主机</span><br><span class="line">send(), recv()              : 发送和接收数据（面向连接的套接字）</span><br><span class="line">sendto(), recvfrom()        : 发送和接收数据（无连接的套接字）</span><br><span class="line">close() ,shutdown()         : 关闭套接字</span><br><span class="line">getsockopt(), setsockopt()  : 获取和设置套接字选项</span><br></pre></td></tr></table></figure><h3 id="套接字地址结构以及地址转换-API"><a href="#套接字地址结构以及地址转换-API" class="headerlink" title="套接字地址结构以及地址转换 API"></a>套接字地址结构以及地址转换 API</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sockaddr 是一个通用的套接字地址结构，它通常与特定的地址族结构（如 sockaddr_in ）一起使用。</span></span><br><span class="line"><span class="comment"> 这是因为多数套接字函数，如 bind(), connect(), 和 accept()，需要使用指向 sockaddr 结构的指针的参数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">   <span class="type">sa_family_t</span>     sa_family;      <span class="comment">/* Address family */</span></span><br><span class="line">   <span class="type">char</span>            sa_data[];      <span class="comment">/* Socket address */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 套接字地址结构（适用于IPv4网络通信的地址结构）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">sa_family_t</span>    sin_family; <span class="meta"># address family: AF_INET </span></span><br><span class="line">    <span class="type">in_port_t</span>      sin_port;   <span class="meta"># port in network byte order </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>   <span class="meta"># ip address </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     <span class="type">uint32_t</span>       s_addr;    <span class="meta"># address in network byte order </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">网络地址转换函数 (用于将IP地址在可打印的格式和二进制结构之间转换)</span></span><br><span class="line"><span class="comment">将点分十进制的IP地址（如&quot;192.168.1.1&quot;）转换成网络字节顺序的二进制形式</span></span><br><span class="line"><span class="comment">inet_pton()   </span></span><br><span class="line"><span class="comment">将网络字节顺序的二进制IP地址转换为点分十进制字符串格式</span></span><br><span class="line"><span class="comment">inet_ntop()   </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># demo 示例:</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INET_ADDRSTRLEN 16；</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str[INET_ADDRSTRLEN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">ipv4addr</span>;</span></span><br><span class="line">inet_pton(AF_INET, <span class="string">&quot;192.168.1.1&quot;</span>, &amp;ipv4addr);</span><br><span class="line">inet_ntop(AF_INET, &amp;ipv4addr, str, INET_ADDRSTRLEN);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The IPv4 address is: %s\n&quot;</span>, str);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="字节序转换-API"><a href="#字节序转换-API" class="headerlink" title="字节序转换 API"></a>字节序转换 API</h3><p>在网络编程中，字节序（也称为端序）指的是数值在内存中保存的顺序。不同的计算机体系结构可能会采用不同的字节序来表示数据。最常见的两种字节序是<strong>大端字节序</strong>（Big-Endian）和<strong>小端字节序</strong>（Little-Endian）。在网络通信中，为了确保数据在不同的系统间正确传输和解释，定义了一个统一的字节序，即：<strong>网络字节序</strong>，它采用<strong>大端字节序</strong>。</p><p>由于主机字节序与网络字节序可能不同，因此在发送数据前，发送方需要将其主机字节序的数值转换为网络字节序；接收方收到数据后，需要将网络字节序的数值转换回主机字节序。</p><p>Linux 提供了一组 API 来处理字节序的转换：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将无符号长整型数/无符号短整型数从主机字节顺序转换为网络字节顺序。</span></span><br><span class="line">htonl() 和 htons()  </span><br><span class="line"><span class="comment">// 将一个无符号长整型数/无符号短整型数从网络字节顺序转换为主机字节顺序。</span></span><br><span class="line">ntohl() 和 ntohs()  </span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">为了方便记忆，大家可以这样理解：h 代表 host(主机)，n 代表 network(网络)，</span></span><br><span class="line"><span class="comment">l 代表 long(四字节：代表ip)，s 代表 short（两字节：代表端口） 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">以 htons() 举例，host to network short 即：将端口从主机字节序转成网络字节序。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>注意：htonl 和 ntohl 一般处理的是 IP 地址，而 htons 和 ntohs 一般处理的是端口。</strong></p><h3 id="Linux-常见的-IO-模型"><a href="#Linux-常见的-IO-模型" class="headerlink" title="Linux 常见的 IO 模型"></a>Linux 常见的 IO 模型</h3><p>前面我们已经学习了 Linux 基础的 socket API，这样我们便可以编写简单的网络服务程序。但现在，我们面临一个新挑战：如何利用有限的服务器资源，来同时高效处理大量的并发请求呢？</p><p>传统的单线程处理方式在现代网络服务中已不合时宜，因为它无法同时处理多个请求，导致效率低下。为了突破这一限制，我们需探究 Linux 提供的各种 I&#x2F;O 模型。这些模型提供了从阻塞到非阻塞，从多路复用到完全异步的不同解决方案，以适应各种网络应用场景，确保服务器在面对大量请求时也能保持高效运行。</p><p><strong>在讨论这些 IO 模型之前，我们先简单回顾一下 I&#x2F;O 是什么</strong>：</p><p>在计算机中，“I&#x2F;O”就是输入和输出的简称，它描述了数据在计算机系统和外部世界之间的流动。具体来说：</p><ul><li><p><strong>输入</strong>：数据进入计算机，比如你在键盘上敲击字母时，字母被读入计算机。</p></li><li><p><strong>输出</strong>：数据离开计算机，例如屏幕上显示信息。</p></li></ul><p>当提到网络时，“I&#x2F;O”扩展了含义：</p><ul><li><p><strong>网络输入</strong>：从外部网络接收数据到你的本地计算机，如通过网络下载文件到你的计算机。</p></li><li><p><strong>网络输出</strong>：这是指将数据从你的本地计算机发送到外部网络，比如通过计算机发送文件给你的好友。</p></li></ul><p>简而言之，I&#x2F;O 是数据在计算机和其他设备或网络之间传递的方式。</p><p><strong>用户进程如何进行 IO 操作？</strong></p><p>让我们通过一个示意图来直观展示用户进程如何从网络获取数据并将其存储到磁盘的整个过程：</p><p><img src="/images/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/3.png"></p><p>从上图我们也能够清楚的看到，进程进行一次 I&#x2F;O 操作需要经过两个步骤:</p><p>以 read 读操作为例：</p><p><strong>第一步：等待网络数据的到来</strong></p><p>当网络数据到达时，网络接口卡（NIC）首先通过直接内存访问（DMA）将数据传输到内核空间分配的 socket 接收缓冲区中，无需 CPU 参与。</p><p><strong>第二步：CPU 复制数据至用户空间</strong></p><p>一旦数据通过 DMA 传输到内核的 socket 接收缓冲区，用户进程的 read 系统调用会被唤醒（如果它在等待数据的话）。接下来，CPU 会介入，将数据从内核缓冲区复制到用户空间提供的缓冲区中。</p><p>也就是说，在 I&#x2F;O 操作的过程中，<strong>存在两个潜在的等待时间点 ：一个是等待网络数据到达 socket 接收缓冲区，另一个是等待 CPU 复制数据至用户空间。</strong></p><p>为了减少这些等待时间对应用程序性能的影响，Linux 提供了五种 I&#x2F;O 模型，它们分别针对这两个步骤的效率问题提供不同的解决方案。</p><p><strong>接下来，我们将深入了解 Linux 支持的五种 I&#x2F;O 模型:</strong></p><h4 id="阻塞IO（Blocking-I-O）"><a href="#阻塞IO（Blocking-I-O）" class="headerlink" title="阻塞IO（Blocking I&#x2F;O）"></a>阻塞IO（Blocking I&#x2F;O）</h4><p><strong>简单图示</strong>：</p><p><img src="/images/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/4.png"></p><p>在阻塞 I&#x2F;O 中，<strong>进程在等待网络数据到达和内核复制数据到用户空间这两个步骤中都需要等待</strong>。当一个进程发起 I&#x2F;O 请求时，它会一直等待直到数据被复制到它的应用层缓冲区中，然后才继续执行。</p><h4 id="非阻塞I-O（Non-blocking-I-O）"><a href="#非阻塞I-O（Non-blocking-I-O）" class="headerlink" title="非阻塞I&#x2F;O（Non-blocking I&#x2F;O）"></a>非阻塞I&#x2F;O（Non-blocking I&#x2F;O）</h4><p><strong>简单图示</strong>：</p><p><img src="/images/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/5.png"></p><p>在非阻塞 I&#x2F;O 模型中，当进程尝试从 socket 读取数据时，如果数据尚未到达，read调用不会阻塞进程。相反，它会立即返回一个 EWOULDBLOCK 或 EAGAIN 错误。也就是说，进程不需要等待网络数据到达 socket 接收缓冲区就可以返回继续执行其他任务。</p><p>一旦数据到达并存储在内核缓冲区中，而当进程尝试再次读取，这次 read 操作将成功，并将数据从内核空间复制到用户空间，但这里的数据复制过程是需要等待的。</p><p><strong>总结一下</strong>：<strong>在非阻塞 I&#x2F;O 模型中，进程需要等待 socket 数据从内核空间复制到用户空间。</strong> 而在等待网络数据到达 socket 接收缓冲区这个时间点是不需要等待的。但是进程需要不断地“轮询”文件描述符，检查 socket 接收缓冲区是否有数据，频繁的轮询可能会导致 CPU 资源的浪费。</p><h4 id="I-O多路复用（I-O-Multiplexing）"><a href="#I-O多路复用（I-O-Multiplexing）" class="headerlink" title="I&#x2F;O多路复用（I&#x2F;O Multiplexing）"></a>I&#x2F;O多路复用（I&#x2F;O Multiplexing）</h4><p><strong>简单图示</strong>：</p><p><img src="/images/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/6.png"></p><p><strong>工作原理：</strong></p><p>I&#x2F;O 多路复用允许一个进程或线程同时监控多个网络 sockets 的状态。它通过单个系统调用（select）来检查多个 sockets 是否有数据可读、可写或是否有异常。Linux 提供了多种 I&#x2F;O 复用技术，包括上面提到的 select、以及 poll、epoll。</p><p><strong>那 I&#x2F;O 多路复用是如何减少上述提到的两个潜在的等待时间的？</strong></p><p><strong>等待网络数据到达</strong></p><ul><li><p>在 I&#x2F;O 多路复用模式下，进程不会在单个 socket 上阻塞等待数据到达。相反，当任何一个被监控的 socket 接收到数据，系统调用（如select）会返回。当 select 返回时，它指示一个或多个 sockets 已接收到数据。这意味着数据已经被网络接口卡（NIC）通过 DMA 操作传输到相应的 socket 接收缓冲区中。</p></li><li><p>这样，进程不必在每个 socket 上分别等待，而是在多个sockets上集中等待，提高了效率。</p></li></ul><p><strong>但是，在 I&#x2F;O 多路复用中， select、poll 或 epoll 系统调用依然会阻塞等待网络数据的到达</strong></p><p><strong>等待CPU复制数据至用户空间</strong></p><p>进程随后可以立即对准备就绪的 socket fd 进行 read 操作。因为数据已经在内核的缓冲区中，CPU 只需要将数据从内核空间复制到用户空间。但这个拷贝数据的完成</p><p>也就是说在 I&#x2F;O 多路复用中，<strong>select、poll 或 epoll 系统调用依然会阻塞等待网络数据的到达</strong>，但是他的<strong>优势在于可以监控多个 sockets 的接收缓冲区是否有数据到来</strong>。当多个 sockets 的接收缓冲区有数据到来，<strong>进程会一直等待 CPU 复制数据至用户空间才能干其他任务</strong>。</p><h4 id="信号驱动I-O（Signal-driven-I-O）"><a href="#信号驱动I-O（Signal-driven-I-O）" class="headerlink" title="信号驱动I&#x2F;O（Signal-driven I&#x2F;O）"></a>信号驱动I&#x2F;O（Signal-driven I&#x2F;O）</h4><p><strong>简单图示</strong>：</p><p><img src="/images/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/7.png"></p><p>信号驱动 I&#x2F;O 也是属于Linux 中的一种 IO 模型，它允许应用程序在不阻塞等待 I&#x2F;O 操作完成的情况下继续执行其他任务。当 I&#x2F;O 操作（如数据的读取或写入）准备就绪时，操作系统会向应用程序发送一个信号，通知它可以开始执行 I&#x2F;O 操作了。这种模式主要通过使用信号（如 SIGIO）来实现。</p><p><strong>两个等待时间点对信号驱动 I&#x2F;O 的影响</strong> :</p><p><strong>等待网络数据到达</strong>：在信号驱动 I&#x2F;O 模型中，应用程序在等待数据到达时<strong>不需要阻塞等待</strong>。它可以继续执行其他任务或处于休眠状态，直到操作系统发出数据已准备就绪的信号（如 SIGIO）。</p><p><strong>等待内核复制数据到用户空间</strong>：当应用程序收到信号并开始实际的 I&#x2F;O 操作（如 read）时，<strong>它仍然需要等待操作系统将数据从内核空间复制到用户空间</strong>。</p><p>尽管信号驱动 I&#x2F;O 提供了一种异步通知机制，使得应用程序能够在I&#x2F;O事件准备好时接收通知，但它在实践中不如其他模型（如IO复用）那么广泛使用，原因包括：</p><ul><li><p><strong>编程复杂性</strong>：使用信号驱动I&#x2F;O要求程序员熟悉信号处理和非阻塞I&#x2F;O操作，这增加了编程的复杂性。</p></li><li><p><strong>信号合并和丢失</strong><br>Linux 信号处理机制通常不会为同一类型的信号排队。这意味着如果在处理一个信号时另一个相同类型的信号发生，后者可能不会触发额外的信号处理调用，导致应用程序可能错过一些I&#x2F;O事件的通知。这种信号的合并行为限制了信号驱动I&#x2F;O模型在高并发场景下准确响应每个I&#x2F;O事件的能力。</p></li><li><p><strong>更好的替代方案</strong>：对于需要处理多个并发I&#x2F;O操作的应用程序，I&#x2F;O复用（特别是epoll）提供了更高的效率和更好的控制。epoll特别适用于高并发场景，并且相对于信号驱动I&#x2F;O更易于管理和使用。</p></li></ul><h4 id="异步I-O（Asynchronous-I-O）"><a href="#异步I-O（Asynchronous-I-O）" class="headerlink" title="异步I&#x2F;O（Asynchronous I&#x2F;O）"></a>异步I&#x2F;O（Asynchronous I&#x2F;O）</h4><p><strong>简单图示</strong>：</p><p><img src="/images/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/8.png"></p><p>aio_read 是 POSIX 异步 I&#x2F;O 接口的一部分，它专门用于执行异步文件读取操作。不太适用于网络 I&#x2F;O 。因此上面的图示是基于文件读取对异步 IO 的工作过程进行说明的。</p><p><strong>工作原理：</strong></p><p>在异步 I&#x2F;O 模型中，当应用程序发起一个I&#x2F;O操作（例如 aio_read 读取）时，它不需要等待操作完成就可以继续执行其他任务。应用程序仅仅是向操作系统发出 I&#x2F;O 请求，并且当 I&#x2F;O 操作真正完成时，操作系统会通知应用程序。这种方式允许应用程序更有效地利用 CPU 时间，因为它不需要在 I&#x2F;O 操作完成前空闲等待。</p><p>那前面提到的两个潜在等待时间对异步 IO 是否会有影响呢？</p><p><strong>等待内核 PageCache 数据准备好：</strong></p><p>在异步 I&#x2F;O 中，应用程序在发出读写请求后立即返回，不需要等待数据在内核中准备好。这意味着应用程序可以继续执行其他任务，而内核会异步的从磁盘读取数据至内核缓存 PageCache 中。</p><p><strong>注意：</strong> 上面我是通过 aio_read 系统调用来说明异步 I&#x2F;O 的工作原理的，aio_read 是 Linux 的 POSIX 异步 I&#x2F;O (AIO) 库提供的接口，主要设计用于文件和块设备的异步读写操作，而不支持网络 I&#x2F;O。因此这里是等待内核的 PageCache 数据准备好而不是等待网络数据准备好，但都可以归纳为等待数据准备好。</p><p><strong>等待CPU复制数据至用户空间</strong>：</p><p> 一旦数据在 pagecache 中准备好，操作系统负责将这些数据从内核空间复制到用户空间指定的缓冲区。<strong>这个复制过程是由内核自动执行的，而不是由用户进程主动复制的。</strong> 用户程序不需要等待这一过程的完成，可以继续进行其他工作。只有在数据完全复制到用户空间后，应用程序才会收到一个完成的信号或通知。进而处理拷贝至用户空间的数据。</p><p><strong>也就是说：在异步 IO 中，不管是等待数据准备好还是等待 CPU 复制数据至用户空间，用户进程都不需要等待。</strong></p><h4 id="Linux-网络-I-O-性能优化"><a href="#Linux-网络-I-O-性能优化" class="headerlink" title="Linux 网络 I&#x2F;O 性能优化"></a>Linux 网络 I&#x2F;O 性能优化</h4><p>在前面的部分，我们探讨了 Linux的 各种I&#x2F;O模型。每种模型都有其独特的使用场景和性能特点。特别是在网络编程中，选择合适的I&#x2F;O模型对于提高服务器的处理能力至关重要。但是，仅仅选择合适的I&#x2F;O模型并不足以确保最佳性能。实际上，网络I&#x2F;O性能还受到许多其他因素的影响，比如<strong>网卡配置、带宽、服务器的并发处理能力</strong>等。因此，我们需要进一步优化 Linux 网络 I&#x2F;O 性能，以确保我们的应用可以充分利用服务器资源，提供更快、更可靠的服务。</p><p><strong>那么，如何优化 Linux 网络 I&#x2F;O 性能呢？</strong></p><p>网络 I&#x2F;O 性能优化主要就是从硬件和软件两个方面来进行：</p><p><strong>首先来看下硬件优化：</strong><br>硬件优化无非就是提升服务器硬件性能，包括 CPU、网卡配置升级、内存配置升级等。</p><ul><li><strong>使用多核 CPU</strong> ：确保服务器有足够的CPU核心来处理高网络负载。</li><li><strong>内存升级</strong>：增加足够的内存以支持高速网络操作，特别是对于需要大量内存缓存的应用。</li><li><strong>网络接口卡</strong>：升级NIC：使用更高速率的NIC，例如从1Gbps升级到10Gbps或更高。<br>或者使用 NIC 多队列（Multi-queue）：使用支持多队列的NIC，以便分散处理负载到多个CPU核心。</li></ul><p><strong>接下来来看下软件优化：</strong></p><p> <strong>1.首先来看下应用程序设计，应用程序本身的设计对网络 I&#x2F;O 性能有着重大影响：</strong></p><ul><li><p><strong>选择合适的 I&#x2F;O 模型</strong>：<br>选择合适的 I&#x2F;O 模型，根据应用的特点和需求选择合适的 I&#x2F;O 模型。对于高并发的网络服务，I&#x2F;O 多路复用（如 epoll、kqueue）通常是最佳选择。它们允许单个线程高效地监控和处理多个网络连接，减少了线程切换的开销。而对于 I&#x2F;O 密集型的应用，异步 I&#x2F;O模型可能会更高效，异步 I&#x2F;O （如 io_uring、libaio）提供了一种不阻塞应用程序主逻辑的方式来处理 I&#x2F;O 请求。这种模型允许应用程序在 I&#x2F;O 请求正在处理时继续执行其他任务。</p></li><li><p><strong>使用零拷贝技术</strong>：<br>传统的数据传输过程涉及多次数据拷贝，包括从内核缓冲区到用户缓冲区。零拷贝技术（如 sendfile）可以减少这些拷贝操作，直接在内核中处理数据，从而减少 CPU 使用和提高效率。</p></li><li><p><strong>批量处理和缓冲</strong> : 聚集数据，以减少网络交互和磁盘操作的次数。</p><p> <strong>a:聚集数据</strong>：通过累积数据到达一定量后再进行处理，而不是每次接收到数据就立即处理。以读取网络数据下载至本地磁盘为例：可以等待数据积累到一定量的时候在写入磁盘，这样可以减少磁盘 I&#x2F;O 次数。</p><p><strong>b.缓冲区管理</strong>：需要合理管理缓冲区，以避免溢出，并在适当的时候重置或清空缓冲区。</p><p><strong>c.适用场景</strong>：这种模式适合于数据量大、数据频繁到达的场景，如日志收集、批量数据处理等。</p></li><li><p><strong>并发和并行处理</strong>：利用多核处理器的优势，通过多线程或多进程来提高并发处理能力。</p></li></ul><p> <strong>2. 接下来看下关于操作系统方面的调整，操作系统级别的调整对于优化网络 I&#x2F;O 也是至关重要的</strong></p><ul><li><p><strong>增加文件描述符限制</strong>：对于高并发的网络服务器，提高文件描述符的限制是必要的，以避免因达到文件描述符上限而无法接受新连接。你可以通过 ulimit -n 命令或修改 &#x2F;etc&#x2F;security&#x2F;limits.conf 文件来增加这个限制。</p></li><li><p><strong>调整 TCP 协议栈参数</strong>：常见的 TCP协议栈参数有如下的几类：</p><p><strong>a：缓冲区大小和资源管理</strong>：<br>这些参数控制 TCP 缓冲区的大小和整体 TCP 缓冲区的资源管理，以优化数据传输性能和内存使用。</p><p><strong>tcp_rmem 和 tcp_wmem</strong> ：分别控制 TCP 接收和发送缓冲区的大小。</p><p><strong>tcp_mem</strong> ：控制整体 TCP 缓冲区在系统范围内的使用情况。</p><p><strong>b: 连接建立和终止：</strong><br>这类参数涉及 TCP 连接的建立过程和连接终止时的行为。</p><p><strong>tcp_syn_retries 和 tcp_synack_retries</strong> : 分别控制 TCP SYN 连接请求和 SYN-ACK 包的重试次数。</p><p> <strong>tcp_fin_timeout</strong> ： tcp_fin_timeout 参数设置了 TCP 连接在 FIN-WAIT-2 状态下的超时时间。这个参数定义了在一个 TCP 连接被本地端关闭后，系统等待对方发送 FIN 包以完成连接终止过程的最长时间。如果在这个超时时间内没有收到对方的 FIN 包，连接将被强制关闭。</p><p><strong>c :连接保活和状态管理：</strong><br>这些参数用于检测和维持空闲连接，以及管理连接状态。</p><p><strong>tcp_keepalive_time</strong> ：设置在开始发送 keepalive 探测之前，一个 TCP 连接必须处于空闲状态的时间。</p><p><strong>tcp_keepalive_probes</strong> ：设置在断开连接之前，最多发送多少个 keepalive 探测包。</p><p><strong>tcp_keepalive_intvl</strong> ： 设置两个连续 keepalive 探测包之间的时间间隔。</p><p><strong>tcp_tw_reuse</strong> :  设置允许在 TIME_WAIT 状态的套接字上的端口被重新用于新的连接。</p><p><strong>d:性能优化 :</strong> 这些参数用于提升网络性能，减少延迟。</p><p><strong>tcp_nodelay</strong> : 禁用 Nagle 算法，减少发送小块数据的延迟。（Nagle 算法是一种为了减少网络上小数据包数量而设计的 TCP 特性。它通过累积较小的数据包并将它们组合成更大的数据块来发送，从而减少了网络上的总数据包数量）。</p><p><strong>tcp_max_syn_backlog</strong> : 设置 SYN 接收队列的最大长度，优化高并发连接的接收。</p><p>除了 SYN 接收队列，TCP 连接还涉及到一个“已连接队列”（也称为 accept 队列），该队列用于存储已经完成三次握手、等待应用程序 accept 的连接。</p><p><strong>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;somaxconn</strong>： 该参数控制着已连接队列的最大长度。 </p><p><strong>调整方法:</strong><br>这些参数通常通过修改 &#x2F;etc&#x2F;sysctl.conf 文件或使用 sysctl 命令进行调整。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sysctl -w net.ipv4.tcp_rmem=&#x27;4096 87380 6291456&#x27;</span><br><span class="line">sysctl -w net.ipv4.tcp_wmem=&#x27;4096 16384 4194304&#x27;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 调整这些参数时，应谨慎考虑系统的整体资源和应用的具体需求。不恰当的设置可能导致性能下降或系统资源耗尽。在生产环境中应用更改前，最好在测试环境中进行充分的测试。</p></li></ul><h3 id="Linux-常见的服务器模型"><a href="#Linux-常见的服务器模型" class="headerlink" title="Linux 常见的服务器模型"></a>Linux 常见的服务器模型</h3><p>服务器模型是网络服务器程序设计的基石，它决定了服务器如何管理多个客户端的连接和请求。接下来，让我们来看看 <strong>Linux</strong> 下的几种常见的服务器模型是怎样工作的？</p><h4 id="单进程服务器：一对一服务"><a href="#单进程服务器：一对一服务" class="headerlink" title="单进程服务器：一对一服务"></a>单进程服务器：一对一服务</h4><p>在单进程服务器模型中。服务器使用一个主进程来逐个处理客户端的连接请求。这意味着，当服务器正在服务一个客户端时，其他客户端必须等待直到当前客户端服务结束。</p><p><strong>图示</strong>：</p><p><img src="/images/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/9.png"></p><p><strong>单进程回射服务器示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">server_fd = socket();</span><br><span class="line">bind();</span><br><span class="line">listen();</span><br><span class="line"><span class="comment">// The main server loop</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    newsockfd = accept(server_fd，...);</span><br><span class="line">    <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="number">256</span>);</span><br><span class="line">    <span class="comment">// Read and write to the connection in a loop</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        n = read(newsockfd, buffer, <span class="number">255</span>);</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">// If read returns 0, the client has closed the connection</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// printf(&quot;Client: %s\n&quot;, buffer);</span></span><br><span class="line">        write(newsockfd, buffer, <span class="built_in">strlen</span>(buffer));</span><br><span class="line">    &#125;</span><br><span class="line">    close(newsockfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>缺点</strong>：</p><ul><li><p><strong>无法实现并发</strong>： 单进程服务器在任何时刻只能处理一个客户端的请求。这意味着如果有多个客户端同时请求服务，除了第一个之外的所有请求都必须等待，这限制了服务器的并发处理能力。</p></li><li><p><strong>性能瓶颈</strong>： 由于服务器在处理当前请求时无法接受新的连接，这会导致服务器对其他客户端的响应时间延长，特别是在高流量的情况下，效率低下。</p></li><li><p><strong>资源利用不充分</strong>： 在多核心处理器上，单进程模型无法充分利用多核的优势，因为它只在一个核心上运行，没有并行处理能力。</p></li></ul><h4 id="多进程服务器"><a href="#多进程服务器" class="headerlink" title="多进程服务器"></a>多进程服务器</h4><p>了解了单进程服务器模型的缺点后，我们自然会寻求更高效的方案来处理多客户端并发的情况。这就引出了多进程服务器模型，它是解决单进程模型限制的常见方案。</p><p>在多进程模型中，服务器为每个新的客户端连接创建一个独立的进程。这允许服务器同时处理多个客户端请求，极大地提高了并发处理能力和资源利用率。</p><p><strong>图示</strong>：</p><p><img src="/images/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/10.png"></p><p><strong>多进程回射服务器示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">server_fd = socket();</span><br><span class="line">bind();</span><br><span class="line">listen();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="type">int</span> new_socket =accept(server_fd, ...);    </span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        close(new_socket);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">      close(server_fd); <span class="comment">// Child does not need the listener</span></span><br><span class="line">      handle_client(new_socket);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        close(new_socket); <span class="comment">// Parent does not need this socket</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">handle_client</span><span class="params">(<span class="type">int</span> new_socket)</span> &#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> bytes_read;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        bytes_read = read(new_socket, buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">        <span class="keyword">if</span> (bytes_read &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// Break the loop if read error or end of file</span></span><br><span class="line">        &#125;</span><br><span class="line">        write(new_socket, buffer, bytes_read);</span><br><span class="line">    &#125;</span><br><span class="line">    close(new_socket);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>多进程服务器优点</strong>：</p><ul><li><p><strong>稳定性</strong>: 多进程服务器中，每个进程是独立的。如果一个进程崩溃，通常不会影响到其他进程，从而提高了服务器的整体稳定性。</p></li><li><p><strong>隔离性</strong>: 每个进程有自己的地址空间，这意味着进程之间的内存是隔离的。这样可以防止某个进程的错误操作影响到其他进程。</p></li><li><p><strong>利用多核优势</strong>: 多进程模型能够在多核处理器上运行，每个进程可以被操作系统调度到不同的CPU核心上，充分利用硬件资源。</p></li></ul><p><strong>缺点</strong>：</p><ul><li><p><strong>资源消耗</strong>: 每个进程都需要一定量的内存和系统资源，如果进程数过多，会占用大量的系统资源，这可能导致服务器的性能下降。</p></li><li><p><strong>上下文切换开销</strong>: 多进程意味着操作系统需要频繁地在进程之间进行上下文切换，这个过程涉及到保存和加载寄存器、更新各种表等操作，会消耗一定的CPU时间。</p></li></ul><h4 id="多线程服务器"><a href="#多线程服务器" class="headerlink" title="多线程服务器"></a>多线程服务器</h4><p>虽然多进程模型提高了服务器的稳定性和隔离性，但它也带来了<strong>资源消耗、上下文切换开销</strong>等限制。针对多进程模型的这些限制，多线程服务器模型提供了一个更为高效的解决方案。</p><p>多线程服务器模型在同一个进程内创建多个线程来处理客户端请求，每个线程能够独立执行，<strong>它们共享进程的资源，如内存空间等资源。而且上下文切换也更快。</strong></p><p><strong>图示</strong>：<br><img src="/images/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/11.png"></p><p><strong>多线程回射服务器的示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">server_fd = socket();</span><br><span class="line">bind(server_fd, ...);</span><br><span class="line">listen(server_fd, ...);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="type">int</span> new_socket = accept(server_fd, ...);</span><br><span class="line">    <span class="type">pthread_t</span> thread_id;</span><br><span class="line">    <span class="keyword">if</span> (pthread_create(&amp;thread_id, <span class="literal">NULL</span>, handle_client, (<span class="type">void</span>*)&amp;new_socket) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Handle error</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">handle_client</span><span class="params">(<span class="type">void</span>* socket)</span> &#123;</span><br><span class="line">    <span class="type">int</span> new_socket = *(<span class="type">int</span>*)socket;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> bytes_read;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        bytes_read = read(new_socket, buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">        <span class="keyword">if</span> (bytes_read &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// Break the loop if read error or end of file</span></span><br><span class="line">        &#125;</span><br><span class="line">        write(new_socket, buffer, bytes_read);</span><br><span class="line">    &#125;</span><br><span class="line">    close(new_socket);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>多线程服务器优缺点</strong>：</p><ul><li><strong>资源效率</strong>: 线程共享进程的内存空间，相较于多进程模型，多线程服务器在内存和资源上的开销更小。</li><li><strong>上下文切换效率</strong>: 线程间的上下文切换比进程间的切换要快，因为线程共享许多资源，切换时所需的资源较少（<strong>线程切换一般只需要切换各自寄存器和栈上的数据</strong>）。</li><li><strong>利用多核优势</strong>: 线程可以分布在多个 CPU 核心上运行，这使得多线程服务器能够充分利用多核 CPU 的计算能力。</li></ul><p><strong>缺点</strong>：</p><ul><li><strong>同步复杂性</strong>: 因为线程共享内存和资源，所以必须仔细设计同步机制来避免竞态条件和其他并发问题。</li><li><strong>稳定性风险</strong>: 一个线程的错误可能影响整个进程，因为它们共享同一内存空间。这可能导致整个服务器程序崩溃。</li><li><strong>资源限制</strong>: 虽然线程比进程轻量，但大量线程仍然会消耗大量系统资源，尤其是在高并发情况下。</li><li><strong>调试困难</strong>: 多线程程序的调试较为复杂，尤其是当出现了线程安全问题时，这些问题可能难以重现和定位。</li></ul><h4 id="线程池模型"><a href="#线程池模型" class="headerlink" title="线程池模型"></a>线程池模型</h4><p>在多线程服务器模型中，每个客户端请求都由一个新的线程来处理。这种方法虽然有效，<strong>但在面对大量并发请求时，频繁地创建和销毁线程会导致服务器的性能下降。</strong> 特别是在请求数量剧增的情况下，线程创建和销毁的开销会变得显著，同时过多的活跃线程也会竞争有限的CPU和内存资源，进一步影响服务的响应时间和吞吐量。</p><p>而在线程池模型中，服务器启动时会预先创建一定数量的线程，这些线程存放在池中，并不立即执行任务。当客户端请求到达时，请求会被分配给线程池中的一个空闲线程，该线程负责处理整个请求过程。处理完毕后，线程并不销毁，而是返回到池中等待处理下一个请求。</p><p><strong>图示</strong>：</p><p><img src="/images/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/12.png"></p><p><strong>说明</strong>：</p><p><strong>服务器（Server）</strong>：这是整个流程开始的地方。服务器初始化一个线程池，并不断监听客户端的连接请求。当一个客户端连接请求到来时，服务器接受这个连接（accept()），然后把相应的任务（job：一般是读写客户端数据的逻辑）添加到线程池的任务队列中去。最终，当服务器不再需要线程池时，会销毁它。</p><p><strong>线程池（ThreadPool</strong>）：线程池是预先创建的线程集合，用于执行多个任务。它分为两个主要部分：</p><ul><li><strong>任务队列（Job Queue）</strong>：这里存放所有待处理的任务（jobs）。当服务器接受一个客户端的连接，它会创建一个任务，并将其添加到这个队列中。</li><li><strong>线程队列（Thread Queue）</strong>：这里存放的是线程池中所有可用的线程。当任务队列中有任务时，线程池会分配一个线程去执行这个任务。</li></ul><p><strong>客户端（Clients）</strong>：客户端通过网络连接与服务器进行通信。</p><h4 id="I-O多路复用服务器"><a href="#I-O多路复用服务器" class="headerlink" title="I&#x2F;O多路复用服务器"></a>I&#x2F;O多路复用服务器</h4><p><strong>什么是 I&#x2F;O 多路复用？</strong></p><p>在 Linux 中，I&#x2F;O 多路复用是一种允许<strong>单个进程或线程同时监控多个文件描述符</strong>（通常是网络套接字）上的读写就绪状态的技术。这使得程序能够在一个或多个文件描述符上发生 I&#x2F;O 事件时被通知，从而对这些事件作出响应（比如进行读写操作）。这种机制极大地提高了处理多个并发网络连接的效率，因为它允许使用较少的系统资源（如进程和线程）来管理大量的连接。</p><p>上面我们在讲解 I&#x2F;O 模型的时候，提到了 IO 多路复用，而在讲解服务器模型我们又再次提到了IO 多路复用。<strong>可能大家会有疑问：IO 多路复用到底属于 I&#x2F;O 模型还是服务器模型？</strong></p><p>其实 I&#x2F;O 多路复用技术是两者之间的桥梁：它是一种有效的 I&#x2F;O 处理方式，同时也是构建服务器模型的基础。</p><ul><li>I&#x2F;O 多路复用作为 I&#x2F;O 模型，关注的是如何有效地管理和执行 I&#x2F;O 操作，特别是在涉及多个 I&#x2F;O 源（如网络套接字）时。</li><li>I&#x2F;O 多路复用作为服务器模型，则是在这种 I&#x2F;O 操作的管理方式基础上构建整个服务器的架构，决定如何接收和处理多个客户端请求，如何分配处理程序来响应这些请求，以及如何利用系统资源。</li></ul><p><strong>简单来说，I&#x2F;O 模型是关于”如何执行 I&#x2F;O”的，而服务器模型是基于某种 I&#x2F;O 模型来构建服务的，以及如何组织服务器程序以响应客户端请求。</strong></p><p><strong>常见的 I&#x2F;O 多路复用技术</strong>：</p><p>Linux 提供了多种 I&#x2F;O 多路复用的机制，如 select, poll, 和 epoll。这些技术的主要区别在于它们处理大量文件描述符的方式和效率。</p><p><strong>IO 复用之 Select</strong>：</p><p><strong>基本概念</strong>：<br>Linux 中的 select 函数是一种常用的 I&#x2F;O 复用技术。它允许程序监视多个文件描述符（FDs），以检测是否有任何一个或多个 FD 准备好进行读取、写入或是否有异常发生。这种技术特别适用于同时处理多个网络连接或其他类型的 I&#x2F;O 操作（如：文件I&#x2F;O）。</p><p><strong>函数声明</strong></p><p>select 函数的基本声明如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, <span class="keyword">struct</span> timeval *timeout)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数结构</span></span><br><span class="line"><span class="comment">nfds：监视的文件描述符集合中最大的文件描述符加一。</span></span><br><span class="line"><span class="comment">readfds：一个指向 fd_set 结构的指针，用于监视哪些 FD 准备好进行读操作。</span></span><br><span class="line"><span class="comment">writefds：一个指向 fd_set 结构的指针，用于监视哪些 FD 准备好进行写操作。</span></span><br><span class="line"><span class="comment">exceptfds：一个指向 fd_set 结构的指针，用于监视哪些 FD 有异常发生。</span></span><br><span class="line"><span class="comment">timeout：指定 select 等待准备就绪的 FD 的最长时间。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>fd_set 结构图解展示</strong>：</p><p>fd_set 是一个文件描述符数组，用于指示 select 函数应该监视的 FDs。</p><p><strong>fd_set 结构图解展示</strong>：</p><p><img src="/images/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/13.jpg"></p><p><strong>说明</strong>：</p><p>参数 readfds、writefds、exceptfds 从用户空间传入内核空间和从内核空间返回用户空间，文件描述符数组中的值代表的含义不同：</p><p><strong>以可读事件 readfds 为例</strong>：</p><p><strong>从用户空间传入内核空间</strong>：数组值为 0 代表不监控该文件描述符（fd），数组值为 1 代表要监控该文件描述符（fd）。</p><p><strong>从内核空间返回用户空间</strong>：数组值为 0 代表该文件描述符数据未准备就绪，数组值为 1 代表该文件描述符数据准备就绪。用户进程可以进行读操作了。</p><p><strong>select 并发回射服务器程序示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 8080</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_CLIENTS 30</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> server_fd, new_socket, client_socket[MAX_CLIENTS];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    <span class="type">int</span> addrlen = <span class="keyword">sizeof</span>(address);</span><br><span class="line">    fd_set readfds;</span><br><span class="line">    <span class="type">int</span> max_sd, sd, activity, i, valread;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">1025</span>];  <span class="comment">// 数据缓冲区</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化所有客户端套接字</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_CLIENTS; i++) &#123;</span><br><span class="line">        client_socket[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建套接字</span></span><br><span class="line">    server_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 绑定套接字</span></span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    address.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    address.sin_port = htons(PORT);</span><br><span class="line">    bind(server_fd, (<span class="keyword">struct</span> sockaddr *)&amp;address, <span class="keyword">sizeof</span>(address))&lt;<span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听套接字</span></span><br><span class="line">    listen(server_fd, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        FD_ZERO(&amp;readfds);<span class="comment">// 清空 fd_set</span></span><br><span class="line">        FD_SET(server_fd, &amp;readfds); <span class="comment">// 添加 server_fd 到 fd_set</span></span><br><span class="line">        max_sd = server_fd;</span><br><span class="line">        <span class="comment">// 添加客户端套接字到 fd_set</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_CLIENTS; i++) &#123;</span><br><span class="line">            sd = client_socket[i];</span><br><span class="line">            <span class="keyword">if</span> (sd &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                FD_SET(sd, &amp;readfds);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sd &gt; max_sd) &#123;</span><br><span class="line">                max_sd = sd;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 select 监听套接字</span></span><br><span class="line">        activity = select(max_sd + <span class="number">1</span>, &amp;readfds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接受新连接</span></span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(server_fd, &amp;readfds)) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((new_socket = accept(server_fd, (<span class="keyword">struct</span> sockaddr *)&amp;address, (<span class="type">socklen_t</span>*)&amp;addrlen))&lt;<span class="number">0</span>) &#123;</span><br><span class="line">              <span class="comment">// 错误处理并退出</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将新套接字添加到数组</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_CLIENTS; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (client_socket[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                    client_socket[i] = new_socket;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     <span class="comment">// 其他套接字的数据处理</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_CLIENTS; i++) &#123;</span><br><span class="line">        sd = client_socket[i];</span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(sd, &amp;readfds)) &#123;</span><br><span class="line">            <span class="comment">// 检查是否是断开连接，否则接收数据</span></span><br><span class="line">            <span class="keyword">if</span> ((valread = read(sd, buffer, <span class="number">1024</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">                close(sd);</span><br><span class="line">                client_socket[i] = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                buffer[valread] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                <span class="comment">// 将接收到的数据发送回客户端</span></span><br><span class="line">                send(sd, buffer, <span class="built_in">strlen</span>(buffer), <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>select优缺点</strong>：</p><p><strong>优点</strong>:</p><ul><li><p><strong>能够同时监视多个套接字</strong>:  select 允许服务器以单线程的方式监视多个套接字，来检测它们是否有可读、可写或异常条件发生。</p></li><li><p><strong>无需多线程或多进程</strong>：select 采用单线程的处理方式，使用 select 可以避免复杂的多线程或多进程管理，减少了上下文切换的开销，简化了并发处理。</p></li><li><p><strong>适用于小到中等规模的负载</strong>：对于不是很高的并发连接数（几百的连接数），select 通常可以满足需求，且效率不错。</p></li></ul><p><strong>缺点</strong>:</p><ul><li><p><strong>文件描述符限制</strong>：select 可以监视的文件描述符数量是有限的，通常由 <strong>FD_SETSIZE</strong> 常量决定，这在很多系统上默认是1024。这限制了服务器可以处理的最大并发连接数。当然 select 也会受限于系统级别的文件描述符数量限制。</p></li><li><p><strong>效率问题</strong>：随着文件描述符数量的增加，select 的性能会线性下降。每次调用select时，都需要重新传入整个文件描述符集合，内核需要遍历这个集合来更新状态，这在文件描述符很多时会成为瓶颈。</p></li><li><p><strong>响应时间变长</strong>：在 select 返回的文件描述符列表集合中，如果有多个文件描述符同时变为活跃状态，服务器通常会按顺序处理它们。这可能导致对列表前面的连接有偏见，使得后面的连接等待时间较长。</p></li></ul><p><strong>IO 复用之 Poll</strong>：</p><p><strong>基本概念</strong>：<br>poll 也是一种 IO 复用技术，用于监视多个文件描述符（通常是网络套接字）的可读性、可写性和异常状态。与 select 类似，poll 允许您的程序监视多个文件描述符，直到一个或多个文件描述符准备好进行 IO 操作。这使得您可以同时管理多个网络连接，而不是逐个阻塞地处理它们。</p><p><strong>函数声明</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span>;</span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">fds：指向一个 pollfd 结构数组的指针，该数组包含要监视的文件描述符及其请求的事件（如 POLLIN 表示可读，POLLOUT 表示可写）。</span></span><br><span class="line"><span class="comment">nfds：指定数组 fds 中的元素数量。</span></span><br><span class="line"><span class="comment">timeout：指定等待时间（毫秒）。特殊值有：0 立即返回（非阻塞），-1 无限等待直到某个事件发生。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>pollfd 结构</strong></p><p>poll 函数使用 pollfd 结构来指定要监视的文件描述符和事件类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> fd;         <span class="comment">// 文件描述符</span></span><br><span class="line">    <span class="type">short</span> events;   <span class="comment">// 请求的事件</span></span><br><span class="line">    <span class="type">short</span> revents;  <span class="comment">// 实际发生的事件</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">fd：文件描述符</span><br><span class="line">events：要监视的事件，如 POLLIN、POLLOUT</span><br><span class="line">revents：由 poll 函数设置，表明哪些事件实际发生了</span><br></pre></td></tr></table></figure><p><strong>Poll 底层采用的数据结构图解</strong></p><p><img src="/images/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/14.jpg"></p><p><strong>底层数据结构：</strong></p><p><strong>用户空间数组</strong>：用户空间程序使用数组（类型为 struct pollfd）来提供要监视的文件描述符及其感兴趣的事件</p><p>但在内核中，为了有效地处理这些文件描述符，poll 的实现转而使用链表。</p><p><strong>内核空间链表</strong>：</p><ul><li>当 poll 系统调用被执行时，内核首先将这个数组中的数据复制到内核空间。</li><li>在内核中，为了更灵活地处理可能的大量文件描述符，这些 pollfd 结构被组织成链表形式。</li><li>链表的每个节点可能包含一个或多个 pollfd 结构，具体取决于可用的内存和文件描述符的数量。</li></ul><p><strong>poll 优缺点</strong>：</p><p><strong>优点</strong>：</p><p><strong>无内置文件描述符限制</strong>：与 select 不同，poll 不受文件描述符数量的限制。select 通常受限于 FD_SETSIZE，这在处理大量并发连接时可能成为瓶颈。<strong>但它仍然受限于系统级别的文件描述符限制。</strong></p><p><strong>简化的接口</strong>：poll 使用单个结构体数组来表示所有监视的文件描述符和相关事件，相比 select 需要使用三个文件描述符集（读、写、异常），接口更为简洁。</p><p><strong>更直观的事件模型</strong>：poll 使用位字段来表示不同的事件类型，这使得事件模型比 select 的方式更直观和易于理解。</p><p><strong>缺点</strong>：</p><p><strong>线性扫描开销</strong>：poll 在处理文件描述符时，需要对整个数组进行线性扫描。当监视的文件描述符数量非常大时，这可能导致性能下降。</p><p>总的来说，poll 是 select 的一种改进，特别是在可处理的文件描述符数量上没有限制，但在高性能和大规模并发处理方面，epoll 在现代 Linux 系统上通常是更佳的选择。</p><p><strong>poll 并发回射服务器程序示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 8080</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_CLIENTS 30</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> listen_fd, new_socket, valread;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    <span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> addrlen = <span class="keyword">sizeof</span>(address);</span><br><span class="line">    <span class="type">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">client_fds</span>[<span class="title">MAX_CLIENTS</span>];</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建监听套接字</span></span><br><span class="line">   listen_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)；</span><br><span class="line">    <span class="comment">// 绑定套接字</span></span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    address.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    address.sin_port = htons(PORT);</span><br><span class="line"></span><br><span class="line">    bind(listen_fd, (<span class="keyword">struct</span> sockaddr *)&amp;address, <span class="keyword">sizeof</span>(address)</span><br><span class="line">    listen(listen_fd, <span class="number">3</span>); <span class="comment">// 开始监听</span></span><br><span class="line">    <span class="comment">// 初始化 pollfd 结构</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_CLIENTS; i++) &#123;</span><br><span class="line">        client_fds[i].fd = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    client_fds[<span class="number">0</span>].fd = listen_fd;</span><br><span class="line">    client_fds[<span class="number">0</span>].events = POLLIN;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主循环</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> activity = poll(client_fds, MAX_CLIENTS, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (activity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">//出错处理并退出</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查是否有新的连接</span></span><br><span class="line">        <span class="keyword">if</span> (client_fds[<span class="number">0</span>].revents &amp; POLLIN) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((new_socket = accept(listen_fd, (<span class="keyword">struct</span> sockaddr *)&amp;address, (<span class="type">socklen_t</span>*)&amp;addrlen)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="comment">//出错处理并退出</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加新的套接字到数组</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; MAX_CLIENTS; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (client_fds[i].fd == <span class="number">-1</span>) &#123;</span><br><span class="line">                    client_fds[i].fd = new_socket;</span><br><span class="line">                    client_fds[i].events = POLLIN;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查客户端活动</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; MAX_CLIENTS; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (client_fds[i].fd &gt; <span class="number">0</span> &amp;&amp; (client_fds[i].revents &amp; POLLIN)) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((valread = read(client_fds[i].fd, buffer, BUFFER_SIZE)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    buffer[valread] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                    send(client_fds[i].fd, buffer, valread, <span class="number">0</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    close(client_fds[i].fd);</span><br><span class="line">                    client_fds[i].fd = <span class="number">-1</span>; <span class="comment">// 标记为可用</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>IO 复用之 Epoll</strong></p><p><strong>基本概念</strong>：<br>epoll 是 Linux 系统中一种高效的 I&#x2F;O 事件通知机制，特别适用于处理大量并发网络连接。与传统的 select 或 poll 方法相比，epoll 的独特之处在于其对活跃连接的高效处理能力。它通过维护一个活跃事件集合，避免了对所有文件描述符的遍历，显著提升了性能。这使得 epoll 成为构建高性能网络应用程序的理想选择。</p><p><strong>函数声明</strong></p><p>epoll 主要涉及三个系统调用：epoll_create、epoll_ctl 和 epoll_wait。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// epoll_create：创建一个 epoll 实例。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>;</span><br><span class="line"><span class="comment">// poll_ctl：管理（添加、修改或删除）监视的文件描述符。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">epfd：由 epoll_create 返回的 epoll 实例文件描述符。</span></span><br><span class="line"><span class="comment">op：要执行的操作，如 EPOLL_CTL_ADD（添加）、EPOLL_CTL_MOD（修改）、EPOLL_CTL_DEL（删除）。</span></span><br><span class="line"><span class="comment">fd：关联的文件描述符。</span></span><br><span class="line"><span class="comment">event：指向 epoll_event 结构的指针，指定感兴趣的事件和任何关联的用户数据。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 待在 epoll 文件描述符上注册的事件发生</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event *events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">epfd：epoll 实例的文件描述符。</span></span><br><span class="line"><span class="comment">events：用于从内核获取事件的 epoll_event 结构数组。</span></span><br><span class="line"><span class="comment">maxevents：指示数组中可以返回的最大事件数。</span></span><br><span class="line"><span class="comment">timeout：等待事件的最大时间（毫秒），-1 表示无限等待。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>epoll_event 结构</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span>     events;    <span class="comment">/* Epoll events */</span></span><br><span class="line">    <span class="type">epoll_data_t</span> data;      <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">events 字段用于指定感兴趣的事件类型，例如 EPOLLIN（可读）、EPOLLOUT（可写）等。</span></span><br><span class="line"><span class="comment">data 字段通常用于存储用户定义的数据，如文件描述符、指向对象的指针等。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//epoll_data_t 是一个联合（union），它用于存储用户定义的数据，可以是文件描述符、指针或任何其他用户需要的数据类型。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *ptr;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">uint32_t</span> u32;</span><br><span class="line">    <span class="type">uint64_t</span> u64;</span><br><span class="line">&#125; <span class="type">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">例如，您可以在 epoll_ctl 调用时，使用 epoll_data_t 的 fd 字段来存储正在监视的文件描述符，</span></span><br><span class="line"><span class="comment">或者使用 ptr 字段来存储指向某个对象或结构的指针。这样，在事件发生时，您可以快速访问与该事件相关联的数据。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>Epoll 的两种触发模式</strong>：</p><p>在 Linux 中，epoll 提供了两种触发模式：<strong>水平触发（Level-Triggered, LT）和边缘触发（Edge-Triggered, ET）</strong>。理解这两种模式对于使用 epoll 来说非常关键，因为它们决定了在文件描述符（FD）上发生事件时，epoll 如何通知应用程序。</p><p><strong>水平触发（Level-Triggered, LT）</strong></p><p><strong>触发条件</strong>：只要文件描述符关联的 socket 缓冲区上有数据可读或有空间可写，epoll_wait 就会返回该文件描述符。这意味着，只要有未处理的数据（如缓冲区中还有数据未读），epoll_wait 会不断地通知应用程序去读数据至用户空间缓存，从而进行处理。</p><p><strong>处理方式</strong>：这种模式更加容易处理，因为即使应用程序没有一次性处理所有的可用数据，epoll_wait 会再次通知你该文件描述符上仍有待处理的数据。</p><p><strong>水平触发的优点</strong>：</p><ul><li><p><strong>简单易懂</strong>：水平触发的行为更直观，容易理解和实现，尤其是对于那些不太熟悉非阻塞 I&#x2F;O 编程的开发者。</p></li><li><p><strong>容错性高</strong>：在水平触发模式下，只要文件描述符的状态仍满足条件（如有数据可读），epoll_wait 会持续通知应用程序，减少了因遗漏事件处理导致的错误。</p></li></ul><p><strong>水平触发的缺点</strong>：</p><ul><li><p><strong>可能的性能开销</strong>：在高负载或大量并发连接的情况下，水平触发可能导致频繁的 epoll_wait 响应。因为只要文件描述符仍然处于活跃状态（例如，仍有数据可读），它就会不断地触发事件。</p></li><li><p><strong>资源使用效率</strong>：由于频繁的事件触发，水平触发模式可能导致更高的CPU使用率，尤其是当有大量活跃的文件描述符时。</p></li></ul><p><strong>水平触发示例代码：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line"><span class="type">int</span> epoll_fd, fd;</span><br><span class="line"></span><br><span class="line">event.events = EPOLLIN; <span class="comment">// LT 是默认模式</span></span><br><span class="line">event.data.fd = fd;</span><br><span class="line">epoll_ctl(epoll_fd, EPOLL_CTL_ADD, fd, &amp;event);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件循环</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[<span class="title">MAX_EVENTS</span>];</span></span><br><span class="line">    <span class="type">int</span> n = epoll_wait(epoll_fd, events, MAX_EVENTS, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (events[i].data.fd == fd) &#123;</span><br><span class="line">            <span class="comment">// 可以读取部分数据，即使不全部读取完，该 FD 仍然会再次报告</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>边缘触发（Edge-Triggered, ET）</strong></p><p><strong>触发条件</strong>：只有文件描述符的状态发生改变时，epoll_wait 才会通知应用进程来读写数据（只通知一次），直到文件描述符的状态再次发生变化。</p><p><strong>那什么才是文件描述符的状态发生改变呢？</strong></p><p>文件描述符的状态发生改变指的是 <strong>fd 从不可读的状态改变成可读的状态或者fd 从不可写的状态改变成可写的状态。</strong></p><p><strong>对于 socket 可读事件来说</strong>：</p><p>fd 从不可读的状态改变成可读的状态，简单理解就是：<strong>fd 对应的 socket 接收缓冲区从无数据到有数据。</strong> </p><p><strong>具体点</strong>：就是当数据首次到达一个空的 socket 接收缓冲区时，epoll_wait 会通知应用程序一次。此时，缓冲区状态从“无数据可读”变为“有数据可读”。又或者应用程序开始读取数据，并将缓冲区中的数据读完（读操作返回 EAGAIN），然后又有新数据到达。这两种情况都是属于 socket 接收缓冲区从无数据到有数据的例子。</p><p><strong>再来看个特殊情况：</strong></p><p>在 ET 模式下，一旦应用程序开始读取数据，如果没有一次性将缓冲区中的所有数据都读取完（即仍有未读取的数据留在缓冲区中），此时不会触发新的 epoll_wait 通知。但是如果此时接收缓冲区又来了新数据，即使文件描述符的状态并没有发生改变，但也会触发新的 epoll_wait 通知的。</p><p><strong>对于 socket 可写事件来说</strong>：</p><p>文件描述符的状态发生改变指的是：fd 从不可写的状态改变成可写的状态。简单理解就是：<strong>fd 对应的 socket 发送缓冲区从满到不满。</strong> 对于可写事件，存在以下两个场景：</p><h4 id="场景一：持续有空间"><a href="#场景一：持续有空间" class="headerlink" title="场景一：持续有空间"></a>场景一：持续有空间</h4><p>假设你有一个socket连接，你正在向它发送数据。在边缘触发（ET）模式下：</p><ul><li><strong>初始状态</strong>：连接建立后，发送缓冲区为空，所以你可以开始发送数据。</li><li><strong>持续发送</strong>：只要发送缓冲区有空间，你可以继续发送数据。在这个过程中，如果缓冲区从未真正变满过（即，你的发送速度不超过网络层处理和发送数据的速度），epoll_wait不会因为缓冲区有空间而特别通知你，因为从epoll的角度看，这不是一个“状态变化”。</li></ul><h4 id="场景二：缓冲区满后又有空间"><a href="#场景二：缓冲区满后又有空间" class="headerlink" title="场景二：缓冲区满后又有空间"></a>场景二：缓冲区满后又有空间</h4><p>现在，让我们看一个缓冲区实际变满的情况：</p><p><strong>1.发送直至满</strong>：你继续发送数据，直到达到一个点，发送缓冲区满了，这时，尝试再发送数据会失败（通常返回EAGAIN或EWOULDBLOCK）。</p><p><strong>2.等待可写</strong>：这时，你应该停止发送数据，等待 epoll_wait 通知你 socket 再次可写。</p><p><strong>3.缓冲区部分清空</strong>：随着时间的推移，网络层将缓冲区中的数据发送出去，缓冲区从“满”变为“有空间”（即，部分数据被发送出去，为新数据腾出了空间）。</p><p><strong>4.收到通知</strong>：因为缓冲区的状态从“满”变为“有空间”，这是一个状态变化，epoll_wait 会通知你 socket 现在可写。</p><p><strong>处理方式</strong>：ET 模式要求你必须一次性处理所有可用的数据。如果处理不完全，epoll_wait 不会再次通知你该文件描述符上的事件，除非新的数据到达或再次变为可写。</p><p><strong>边缘触发示例代码：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line"><span class="type">int</span> epoll_fd, fd;</span><br><span class="line"></span><br><span class="line">event.events = EPOLLIN | EPOLLET; <span class="comment">// 启用 ET 模式</span></span><br><span class="line">event.data.fd = fd;</span><br><span class="line">epoll_ctl(epoll_fd, EPOLL_CTL_ADD, fd, &amp;event);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件循环</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[<span class="title">MAX_EVENTS</span>];</span></span><br><span class="line">    <span class="type">int</span> n = epoll_wait(epoll_fd, events, MAX_EVENTS, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (events[i].data.fd == fd) &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">ssize_t</span> count = read(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                <span class="keyword">if</span> (count == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (errno != EAGAIN) &#123;</span><br><span class="line">                        <span class="comment">// 处理非 EAGAIN 错误</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>; <span class="comment">// 没有更多数据可读</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 处理读取的数据</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>边缘触发的优缺点：</strong></p><p><strong>优点：</strong></p><p><strong>减少通知频率：</strong></p><p>在 ET 模式中，epoll_wait 只在文件描述符（如套接字）的状态发生变化时通知一次（例如，从不可读变为可读）。这减少了系统不断检查状态的需要，尤其在管理大量连接时非常有效。</p><p><strong>提高事件处理效率：</strong></p><p>由于减少了频繁的事件通知，应用程序可以更集中地处理每次通知的事件。这在同时处理许多连接时提升了效率。每次事件都得到了充分的处理，而不是浪费资源在重复或不必要的检查上，从而整体提高了处理大量并发连接的效率。</p><p><strong>降低资源占用：</strong></p><p>ET 模式通过减少频繁的事件检查和处理，有助于减少 CPU 和内存的使用，尤其在高负载下。</p><p><strong>更好的扩展性：</strong></p><p>对于需要处理大量并发连接的高性能服务器，ET 模式能够更高效地利用资源，使服务器能够承载更多的连接，从而提升整体的扩展能力。</p><p><strong>缺点：</strong></p><p><strong>处理逻辑更加复杂：</strong></p><p>在 ET 模式下，必须在每次通知时尽可能完整地处理 I&#x2F;O 事件（读取或写入所有数据），因为相同条件下不会再次收到通知。这要求程序能够有效地一次性处理大量数据。</p><p><strong>可能会错过一些数据：</strong></p><p>如果在处理通知时没有完全读取或写入所有数据，剩余的数据可能不会触发新的通知，导致程序错过一些重要数据。</p><p><strong>依赖于非阻塞 I&#x2F;O：</strong></p><p>ET 模式通常和非阻塞 I&#x2F;O 结合使用。在这种模式下，编程变得更复杂，因为需要处理非阻塞调用可能遇到的特殊情况，如 EAGAIN 或 EWOULDBLOCK。</p><p><strong>总结：</strong></p><p><strong>水平触发</strong>：更易于使用和理解，但可能会导致更多的 epoll_wait 调用，尤其是在高负载下。</p><p><strong>边缘触发</strong>：更高的性能潜力，减少了 epoll_wait 调用的次数，但需要更谨慎的缓冲区管理和错误处理。</p><p><strong>Epoll 优缺点</strong></p><p><strong>优点：</strong></p><p><strong>1.高效的文件描述符管理</strong></p><p>在 epoll 中，高效的文件描述符管理首先依赖于高效的数据结构（红黑树和链表）以及回调函数。epoll 使用红黑树来组织所有监控的文件描述符，提供快速的查找、插入和删除操作。链表则用于存储准备就绪的事件，使得 epoll_wait 能迅速返回这些事件。每当监控的文件描述符发生状态变化（例如，socket 上有数据到来）时，与之关联的回调函数被内核自动触发。这些回调函数直接将就绪的文件描述符事件添加到 epoll 的就绪链表中。使得 epoll_wait 快速返回，这种集成了回调机制和高效数据结构的方法，使 epoll 在处理大量并发连接时比传统的 select 和 poll 方法更高效。</p><p>  相比之下，select 和 poll 每次调用时都需要遍历整个文件描述符集合，以检查每个描述符的状态。当文件描述符数量很大时，这种方法的效率显著降低。</p><p><strong>2.更好的可扩展性</strong></p><p>epoll 能够处理的文件描述符数量远超过 select 的 FD_SETSIZE 限制（通常为1024），使其能够更有效地处理成千上万的并发连接。这使 epoll 成为高并发网络应用的理想选择，例如大型网站的服务器。</p><p><strong>3.减少复制操作</strong></p><p>在传统的 select 和 poll 方法中，应用程序需要在每次调用时将整个文件描述符集合从用户空间复制到内核空间，内核处理完后再将结果复制回用户空间。这种来回复制操作效率比较低。</p><p>而在 epoll 中，只需要将就绪事件从内核空间的就绪链表复制到用户空间，而非整个被监控的文件描述符集合。这种机制大大减少了数据在用户空间和内核空间之间频繁来回复制的需求，特别是在只有少数文件描述符就绪的大规模并发连接场景中，显著降低了上下文切换和数据复制的开销，从而提高了整体的效率和性能。</p><p><strong>4.支持边缘触发（ET）和水平触发（LT）</strong></p><ul><li><strong>两种触发模式</strong>：epoll 提供了边缘触发（ET）和水平触发（LT）两种模式。边缘触发仅在文件描述符状态发生变化时通知一次，而水平触发则在描述符保持某状态时持续通知。</li><li><strong>适应不同的使用场景</strong>：<br>这种灵活性使得开发者可以根据具体的应用需求和行为特点选择最合适的模式，以优化性能。</li></ul><p><strong>缺点：</strong></p><p><strong>平台依赖性：</strong> epoll 是 Linux 特有的，不具备 select 和 poll 那样的跨平台特性。这意味着基于 epoll 的应用程序不能在非 Linux 系统上直接运行，限制了其可移植性。</p><p><strong>边缘触发模式的挑战</strong></p><p>在边缘触发（ET）模式下，epoll 只在状态变化时通知一次。这意味着应用程序必须正确处理所有的数据，否则可能会丢失未处理的事件。 </p><p><strong>Epoll 并发回射服务器程序示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_EVENTS 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> READ_BUF_SIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 8080</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> listen_fd, conn_fd, epoll_fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>, <span class="title">events</span>[<span class="title">MAX_EVENTS</span>];</span></span><br><span class="line">    <span class="type">int</span> event_count, i;</span><br><span class="line">    <span class="type">char</span> read_buf[READ_BUF_SIZE];</span><br><span class="line"></span><br><span class="line">    socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    server_addr.sin_port = htons(PORT);</span><br><span class="line">    bind(listen_fd, (<span class="keyword">struct</span> sockaddr *)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr))</span><br><span class="line">    listen(listen_fd, SOMAXCONN)</span><br><span class="line"></span><br><span class="line">    epoll_fd = epoll_create1(<span class="number">0</span>);</span><br><span class="line">    event.events = EPOLLIN;</span><br><span class="line">    event.data.fd = listen_fd;</span><br><span class="line"></span><br><span class="line">    epoll_ctl(epoll_fd, EPOLL_CTL_ADD, listen_fd, &amp;event)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        event_count = epoll_wait(epoll_fd, events, MAX_EVENTS, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; event_count; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (events[i].data.fd == listen_fd) &#123;</span><br><span class="line">                conn_fd = accept(listen_fd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">                <span class="keyword">if</span> (conn_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">                    perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                event.events = EPOLLIN | EPOLLET;</span><br><span class="line">                event.data.fd = conn_fd;</span><br><span class="line">                <span class="keyword">if</span> (epoll_ctl(epoll_fd, EPOLL_CTL_ADD, conn_fd, &amp;event) == <span class="number">-1</span>) &#123;</span><br><span class="line">                    perror(<span class="string">&quot;epoll_ctl&quot;</span>);</span><br><span class="line">                    close(conn_fd);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> nbytes = read(events[i].data.fd, read_buf, READ_BUF_SIZE);</span><br><span class="line">                <span class="keyword">if</span> (nbytes &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    close(events[i].data.fd);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    write(events[i].data.fd, read_buf, nbytes);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(listen_fd);</span><br><span class="line">    close(epoll_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="异步I-O服务器模型"><a href="#异步I-O服务器模型" class="headerlink" title="异步I&#x2F;O服务器模型"></a>异步I&#x2F;O服务器模型</h4><p>在讲述了 I&#x2F;O 多路复用服务器模型后，我们看到它如何使单个进程能够有效地管理多个网络连接。通过 select、poll 或 epoll，进程可以在多个连接上同时等待数据，而无需为每个连接阻塞等待。这种方法提升了并发处理的效率，<strong>但它有一个局限性：一旦某个连接的 I&#x2F;O 操作开始，该进程必须等待该操作完成才能继续处理下一个连接。</strong> 简单理解就是：处理各个连接的 IO 读写是同步的，是串行的。</p><p>为了解决这一问题，引入了异步I&#x2F;O服务器模型。这种模型极大提升了服务器的任务处理能力，它允许进程在发起I&#x2F;O操作后立即转而执行其他工作，而无需等待I&#x2F;O操作的完成。这一过程由操作系统在后台管理，一旦I&#x2F;O操作完成，进程便会收到通知。进程只需要去处理已被拷贝至应用层缓冲区的数据。</p><p><strong>Linux中的异步I&#x2F;O实现</strong>：</p><p>在Linux中，异步 IO 模型主要由 <strong>Linux aio</strong>（通过libaio库）和 <strong>io_uring</strong> 两种技术来实现。</p><p><strong>Linux aio(libaio)</strong></p><p>Linux aio 是 Linux 系统中较早支持的异步I&#x2F;O机制。它通过 libaio 库提供了一系列的API，允许应用程序非阻塞地启动和管理I&#x2F;O操作。当一个I&#x2F;O请求被提交后，libaio负责将其发送到操作系统，应用程序可以继续执行而无需等待。一旦I&#x2F;O操作完成，应用程序将通过回调函数或其他机制得到通知。</p><p><strong>libaio提供的 API</strong> :</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">io_setup       ：创建一个异步I/O上下文。</span><br><span class="line">io_submit      ：向异步I/O上下文提交一个或多个I/O请求。</span><br><span class="line">io_getevents   ：从异步I/O上下文中获取已完成的事件。</span><br><span class="line">io_destroy     ：销毁一个异步I/O上下文。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>尽管 libaio 为异步 I&#x2F;O 提供了基础支持，但它有一定的局限性，<strong>比如：它只适用于文件 I&#x2F;O，并不适合用于网络 I&#x2F;O。</strong></p><p>以下是一个简洁的 libaio 使用示例，演示了如何在 Linux 系统中以异步方式进行文件读取。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libaio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/eventfd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FILE_PATH <span class="string">&quot;example_file.txt&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">io_context_t</span> ctx;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iocb</span> <span class="title">cb</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iocb</span> *<span class="title">cbs</span>[1];</span></span><br><span class="line">    <span class="type">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">    <span class="type">int</span> file_fd, efd, ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_event</span> <span class="title">events</span>[1];</span></span><br><span class="line">    <span class="type">uint64_t</span> u;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;ctx, <span class="number">0</span>, <span class="keyword">sizeof</span>(ctx));</span><br><span class="line">    io_setup(<span class="number">10</span>, &amp;ctx);</span><br><span class="line">    file_fd = open(FILE_PATH, O_RDWR | O_CREAT, <span class="number">0644</span>);</span><br><span class="line">    <span class="comment">// 创建eventfd用于通知</span></span><br><span class="line">    efd = eventfd(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 准备异步读请求</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;cb, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> iocb));</span><br><span class="line">    io_prep_pread(&amp;cb, file_fd, buffer, BUFFER_SIZE, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 设置eventfd作为完成事件的通知</span></span><br><span class="line">    cb.data = (<span class="type">void</span> *)(<span class="type">uintptr_t</span>)efd;</span><br><span class="line">    cbs[<span class="number">0</span>] = &amp;cb;</span><br><span class="line">    <span class="comment">// 提交异步I/O请求</span></span><br><span class="line">    io_submit(ctx, <span class="number">1</span>, cbs)</span><br><span class="line">    <span class="comment">// 在这里，主线程可以执行其他业务逻辑</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    read(efd, &amp;u, <span class="keyword">sizeof</span>(<span class="type">uint64_t</span>));  <span class="comment">// 在主线程中等待通知</span></span><br><span class="line">    io_getevents(ctx, <span class="number">1</span>, <span class="number">1</span>, events, <span class="literal">NULL</span>);  <span class="comment">// 读取异步I/O事件</span></span><br><span class="line">    <span class="comment">// 处理完成的I/O事件</span></span><br><span class="line">    <span class="keyword">if</span>(events[<span class="number">0</span>].data == (<span class="type">void</span> *)(<span class="type">uintptr_t</span>)efd) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Read %zd bytes: %.*s\n&quot;</span>, events[<span class="number">0</span>].res, (<span class="type">int</span>)events[<span class="number">0</span>].res, buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    close(file_fd);</span><br><span class="line">    io_destroy(ctx);</span><br><span class="line">    close(efd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>io_uring</strong>：</p><p>io_uring 是 Linux 内核 5.1 版本引入的全新异步 I&#x2F;O 框架，io_uring 旨在提供一种高效、灵活且功能丰富的方式来执行异步 I&#x2F;O 操作。与 libaio 相比，io_uring 提供了更低的系统调用开销，更简单的接口，以及更好的性能。</p><p><strong>如何工作</strong>：</p><p>io_uring 的核心思想是通过两个队列来管理异步 I&#x2F;O 请求。一个叫做提交队列（SQ），另一个叫完成队列（CQ）。</p><p>1.<strong>提交请求</strong>：当你的程序想要执行一个 I&#x2F;O 操作，比如读取网络数据，它会创建一个请求并把它放到提交队列（SQ）中。</p><p>2.<strong>内核处理</strong>：Linux 内核会查看提交队列，取出请求并处理它们。你的程序不需要等待内核完成这个操作，它可以继续做其他事情。</p><p>3.<strong>完成通知</strong>：一旦内核完成了一个请求，它会把结果放入完成队列（CQ）中。这样程序就知道该操作已经完成，可以继续处理结果了。</p><p><strong>io_uring 的优势：</strong></p><ul><li><strong>性能</strong>：它允许应用程序一次性地批量提交多个 I&#x2F;O 请求，减少了系统调用的数量，所以 io_uring 能够提供比传统的异步 I&#x2F;O 更好的性能。</li><li><strong>减少等待</strong>：应用程序不需要每次提交一个请求就等待结果，它可以继续执行其他任务，同时内核在背后处理这些 I&#x2F;O 请求。</li><li><strong>功能丰富</strong>：io_uring 支持各种类型的 I&#x2F;O 操作，包括但不限于文件读写、网络操作等。</li><li><strong>易用性</strong>：io_uring 提供了一个更为简洁和一致的接口，相比于旧的异步 I&#x2F;O 接口，它更易于使用和理解。</li></ul><p>关于异步 IO 服务器模型的学习，大家只需要理解异步IO的工作方式，以及了解在 Linux 中可以通过 libaio 和 io_uring 技术可以构建异步 IO 服务器模型。如果想深入学习 io_uring 的底层原理，则可以去官网或者谷歌搜索相关资料去深入学习。</p><p><strong>这篇文章，大家可以去了解：</strong><br><a href="https://cloud.tencent.com/developer/article/2187655">https://cloud.tencent.com/developer/article/2187655</a> </p><p><strong>关于具体的代码示例，则可以去了解 liburing 这个库的 example 代码示例</strong>：<a href="https://github.com/axboe/liburing">https://github.com/axboe/liburing</a></p><h3 id="服务器架构模式"><a href="#服务器架构模式" class="headerlink" title="服务器架构模式"></a>服务器架构模式</h3><p>在前面的介绍中，我们了解了常见的服务器模型，但是这些模型在应对高并发场景都会遇到一些挑战，特别是在处理大量并发连接和高效率 I&#x2F;O 操作方面。尽管模型如多线程、线程池和 I&#x2F;O 多路复用提供了并发处理的基础架构，但它们各自都有局限性，特别是在高并发和低延迟要求的场景中。</p><p>这些挑战促使了对一种更高效、更可扩展的并发处理模式的需求— 这就是 Reactor 模式。Reactor 模式采用事件驱动的方法，结合同步 I&#x2F;O 多路复用技术，如 select、poll 或 epoll，提供了一种不同于传统线程模型的并发处理机制。</p><p><strong>为什么需要 Reactor 模式？</strong></p><p><strong>并发和 I&#x2F;O 效率</strong>：传统的多线程和多进程模型在处理成千上万的并发连接时可能会遇到性能瓶颈。这些模型往往涉及重的上下文切换和资源分配，特别是在频繁的 I&#x2F;O 操作下。</p><p><strong>简化事件处理</strong>：在 I&#x2F;O 多路复用模型中，虽然可以高效地监控多个 I&#x2F;O 流，但在事件分发和处理方面往往缺乏组织和结构。Reactor 模式提供了一种清晰的框架来处理多个并发 I&#x2F;O 事件，简化了事件驱动程序的开发。</p><h4 id="Reactor-模式详解"><a href="#Reactor-模式详解" class="headerlink" title="Reactor 模式详解"></a>Reactor 模式详解</h4><p><strong>Reactor 是什么？</strong></p><p>Reactor 模式可以理解为一种在网络编程中常用的设计模式，用于高效地处理多个并发 I&#x2F;O 事件，如用户请求或网络通信。它的核心概念是使用一个中心化的处理器（称为 Reactor）来监控所有的 I&#x2F;O 请求。当一个 I&#x2F;O 事件发生时（例如，新的客户端连接或者数据到达），Reactor 会捕获这个事件，并将其分派给相应的处理程序进行处理。</p><p><strong>核心组件：</strong></p><p><strong>1.Handles (句柄)：</strong></p><p><strong>定义</strong>：句柄是对操作系统资源的引用，通常是<strong>文件描述符</strong>（file descriptor）。在网络编程中，这通常是指代网络套接字（sockets）。</p><p><strong>用途</strong>：它用于标识一个特定的网络连接或其他 I&#x2F;O 资源，如打开的文件、管道等。</p><p><strong>示例</strong>：当一个客户端连接到服务器，服务器会为这个连接创建一个套接字，并为其分配一个文件描述符，这个文件描述符就是一个句柄。</p><p><strong>2.Synchronous Event Demultiplexer (事件多路分发器)：</strong></p><p><strong>定义</strong>：事件多路分发器是负责等待多个句柄上事件发生的组件。它可以同时监控多个句柄，如网络套接字上的可读或可写事件。</p><p><strong>实现</strong>：在 Linux 中，这通常通过系统调用如 select, poll 或 epoll 实现。</p><p><strong>功能</strong>：当一个或多个句柄上发生事件时（例如，新的客户端连接、数据到达等），事件多路分发器通知 Reactor。</p><p><strong>3.Event Handler (事件处理器)：</strong></p><p><strong>定义：</strong> 它是一个定义了处理不同类型事件所需接口或协议的抽象概念。通常包含一系列的方法或函数，用于处理各种事件，如读取数据（可读事件）、写入数据（可写事件）或处理错误（错误事件）。事件处理器定义了在发生特定事件时应当调用哪些方法，但不涉及这些方法的具体实现。</p><p><strong>例如：</strong> 一个事件处理器接口可能有一个 handle_read 方法用于处理可读事件，但它并不实现该方法。</p><p><strong>4.Concrete Event Handlers (具体事件处理器)：</strong></p><p><strong>定义：</strong> 具体事件处理器实现了定义在事件处理器接口中的所有方法，提供了如何处理特定事件的具体逻辑。</p><p>例如，一个具体事件处理器可能实现 handle_read 方法来从套接字中读取数据并处理这些数据。又或者实现 handle_accept 方法来处理客户端的连接请求。</p><p>具体事件处理器是实际工作的组件，每个具体的事件处理器实例通常与应用程序中的一个特定资源（一个socket 文件描述符）关联。</p><p><strong>5.Initiation Dispatcher (初始化分发器)：</strong></p><p><strong>定义</strong>：初始化分发器是 Reactor 模式的核心组件，负责管理事件循环、监听事件并将它们分发到相应的具体事件处理器。</p><p><strong>职责</strong>：它初始化事件多路分发器，注册事件处理器，并在事件发生时调用相应的具体事件处理器。</p><p><strong>事件循环</strong>：在整个应用程序的生命周期内，初始化分发器运行一个循环，等待和分发事件。</p><p><strong>select 实现的 Reactor 网络服务器程序</strong></p><p>这里只是提供一个简单示例，但以上的5个组件都包含。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 8080</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_CLIENTS 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">handler_t</span> handlers[MAX_CLIENTS];</span><br><span class="line"><span class="type">int</span> num_clients = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">handler_t</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> handle; <span class="comment">//句柄：在我们的上下文中就是套接字描述符。</span></span><br><span class="line">    <span class="type">void</span> (*handle_func)(<span class="type">int</span> handle, <span class="type">void</span> *arg);  <span class="comment">//事件处理器</span></span><br><span class="line">&#125; <span class="type">handler_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体事件处理器 ： 处理客户端的连接请求</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">acceptor_handler_func</span><span class="params">(<span class="type">int</span> handle, <span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> client_len = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line">    <span class="type">int</span> client_fd = accept(handle, (<span class="keyword">struct</span> sockaddr*)&amp;client_addr, &amp;client_len);</span><br><span class="line">    <span class="keyword">if</span> (client_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Accepted connection from %s\n&quot;</span>, inet_ntoa(client_addr.sin_addr));</span><br><span class="line">    <span class="comment">// 将新客户端加入到 handlers 中</span></span><br><span class="line">    handlers[num_clients].handle = client_fd;</span><br><span class="line">    handlers[num_clients].handle_func = client_handler_func;</span><br><span class="line">    num_clients++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体事件处理器：处理客户端的数据处理请求</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">client_handler_func</span><span class="params">(<span class="type">int</span> handle, <span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="type">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">    <span class="type">int</span> nbytes = recv(handle, buffer, <span class="keyword">sizeof</span>(buffer), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nbytes &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        close(handle);</span><br><span class="line">        <span class="comment">// 将handle从handlers数组中移除</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_clients; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (handlers[i].handle == handle) &#123;</span><br><span class="line">                handlers[i] = handlers[num_clients - <span class="number">1</span>];</span><br><span class="line">                num_clients--;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        send(handle, buffer, nbytes, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">event_demultiplexer</span><span class="params">()</span> &#123;</span><br><span class="line">    fd_set read_fds;</span><br><span class="line">    <span class="type">int</span> fd_max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    FD_ZERO(&amp;read_fds);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_clients; i++) &#123;</span><br><span class="line">        FD_SET(handlers[i].handle, &amp;read_fds);</span><br><span class="line">        <span class="keyword">if</span> (handlers[i].handle &gt; fd_max) &#123;</span><br><span class="line">            fd_max = handlers[i].handle;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待 socket 上的可读事件</span></span><br><span class="line">    <span class="keyword">if</span> (select(fd_max + <span class="number">1</span>, &amp;read_fds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;select&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分发事件</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_clients; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(handlers[i].handle, &amp;read_fds)) &#123;</span><br><span class="line">            handlers[i].handle_func(handlers[i].handle, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Initiation Dispatcher (初始化分发器)</span></span><br><span class="line"><span class="comment">Initiation Dispatcher 是 Reactor 模式的核心，允许应用程序注册事件、注销事件。并且它负责启动事件循环，等待事件并分发事件。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">run_reactor</span><span class="params">(<span class="type">int</span> listen_fd)</span> &#123;</span><br><span class="line">    <span class="comment">// 注册事件</span></span><br><span class="line">    handlers[num_clients].handle = listen_fd;</span><br><span class="line">    handlers[num_clients].handle_func = acceptor_handler_func;</span><br><span class="line">    num_clients++;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 启动事件循环</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        event_demultiplexer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> listen_fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    listen_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_port = htons(PORT);</span><br><span class="line">    server_addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    bind(listen_fd, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr);</span><br><span class="line">    listen(listen_fd, <span class="number">10</span>);</span><br><span class="line">  </span><br><span class="line">    run_reactor(listen_fd);</span><br><span class="line">    close(listen_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于 <strong>epoll</strong> 的高效性，我们一般会基于 epoll 去实现 reactor。<strong>具体实现可参考这篇文章：</strong><br><a href="https://zhuanlan.zhihu.com/p/539556726">https://zhuanlan.zhihu.com/p/539556726</a></p><p><strong>Reactor 事件处理流程</strong></p><p>下面通过时序图来图示上述代码的执行过程，方便大家理解：</p><p><img src="/images/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/15.png"></p><h4 id="Reactor-模式的优势和应用场景"><a href="#Reactor-模式的优势和应用场景" class="headerlink" title="Reactor 模式的优势和应用场景"></a>Reactor 模式的优势和应用场景</h4><p><strong>Reactor 模式的主要优势包括：</strong></p><ul><li><strong>高效的资源利用</strong>：<br>通过单线程或少量线程来管理多个并发连接，减少了线程上下文切换和资源消耗，提高了资源利用效率。</li><li><strong>快速响应能力</strong>：<br>非阻塞和事件驱动机制确保了快速响应外部事件，提高了程序的响应速度。</li><li><strong>更好的可扩展性</strong>：<br>能够处理成千上万的并发连接，而不会遇到传统多线程或多进程模型中线程资源限制的问题。</li></ul><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>这种模式特别适合于需要高并发处理的网络服务器，如 Web 服务器、数据库服务器等。</p><p><strong>结论：</strong><br>Reactor 模式是现代高性能网络编程的基石之一。它通过事件驱动和非阻塞 I&#x2F;O 机制有效地解决了传统并发模型在高并发环境下的限制，为构建可扩展的网络应用提供了强大的工具。</p><h4 id="Proactor-模式详解"><a href="#Proactor-模式详解" class="headerlink" title="Proactor 模式详解"></a>Proactor 模式详解</h4><p>在前面的讲解中，我们探讨了 Reactor 模式。该模式主要依赖于同步 I&#x2F;O，然而，随着并发需求的增加，尤其在高负载环境下，同步 I&#x2F;O 的局限性逐渐凸显。</p><p>应对这一挑战，异步编程模型的 <strong>Proactor 模式</strong>提供了一种全新的解决方案。它区别于 Reactor 的同步等待，转而采用<strong>完全异步的 I&#x2F;O 操作</strong>。在这个模式下，应用程序无需在 I&#x2F;O 完成前等待，而是在 I&#x2F;O 完成后接收通知。Proactor 模式有效减少了等待时间，提高了对并发连接的处理效率，尤其适合于构建<strong>高性能</strong>、<strong>I&#x2F;O 密集型</strong>的网络应用。这一模式不仅提升了性能，也代表了网络编程范式的一次重要转变，为开发高效和可扩展的网络服务提供了新思路。</p><p><strong>Proactor 是什么？</strong></p><p>Proactor 模式是一种高级的异步编程模型，用于处理 I&#x2F;O 操作。与传统的同步 I&#x2F;O 操作（如 Reactor 模式）不同，Proactor 模式允许应用程序在不阻塞主执行线程的情况下执行 I&#x2F;O 操作。应用程序发起异步 I&#x2F;O 请求后可以继续执行其他任务，而无需阻塞等待 I&#x2F;O 操作的完成。当 I&#x2F;O 操作实际完成时，操作系统会通知应用程序，并触发预定义的回调函数或事件处理程序来处理 I&#x2F;O 操作的结果。</p><p><strong>核心组件</strong></p><p><strong>异步操作对象：</strong> 该对象代表了单个的异步 I&#x2F;O 操作，如异步读取或写入。它 们通常封装了操作的细节，如操作类型、目标资源(文件描述符)、缓冲区地址等。</p><p><strong>异步操作对象的定义</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    ADD_TYPE_ACCEPT,</span><br><span class="line">    ADD_TYPE_READ,</span><br><span class="line">    ADD_TYPE_WRITE</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_data</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> type; <span class="comment">// ADD_TYPE_ACCEPT, ADD_TYPE_READ, ADD_TYPE_WRITE 等</span></span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">size_t</span> bytes_read;</span><br><span class="line">    <span class="type">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p><strong>Proactor 初始器（Proactor Initiator）</strong> ：<br>Proactor 初始器是负责启动和配置异步 I&#x2F;O 操作流程的组件。它通常由用户空间的代码执行，负责准备和提交异步 I&#x2F;O 请求到内核。</p><p>在 io_uring 中，Proactor 初始器 对应的是用户空间代码，特别是负责初始化 io_uring 实例、以及提交异步 I&#x2F;O 请求到内核的逻辑。</p><p><strong>来看下在 io_uring 中， Proactor Initiator 的代码示例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化 io_uring实例</span></span><br><span class="line"><span class="type">int</span> ret = io_uring_queue_init(<span class="number">256</span>, &amp;ring, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交一个异步读取请求</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">submit_async_read</span><span class="params">(<span class="keyword">struct</span> io_uring *ring, <span class="type">int</span> fd)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_data</span> *<span class="title">data</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span>  io_data));</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> *<span class="title">sqe</span>  =</span> io_uring_get_sqe(ring); </span><br><span class="line">    data-&gt;fd = fd;</span><br><span class="line">    data-&gt;type = ADD_TYPE_READ;</span><br><span class="line">    io_uring_prep_read(sqe, fd, data-&gt;buffer, BUFFER_SIZE, <span class="number">0</span>);      <span class="comment">// 准备读取请求</span></span><br><span class="line">    io_uring_sqe_set_data(sqe, data); <span class="comment">// 设置用户数据</span></span><br><span class="line">    io_uring_submit(ring);  <span class="comment">// 提交请求</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>异步操作处理器（Asynchronous Operation Processor）</strong>：<br>异步操作处理器是 Proactor 模式的核心，在内核中执行，负责启动异步 I&#x2F;O 操作并在操作完成时通知用户空间的 Proactor 实例。</p><p>在 io_uring 中，异步操作处理器 实际上是 io_uring 的内核组件。这包括提交队列（SQ）和完成队列（CQ），以及内核中负责处理这些队列的逻辑。</p><p><strong>完成处理器（Completion Handler）</strong></p><p>完成处理器是由应用程序定义的回调函数，它们在异步 I&#x2F;O 操作完成时被调用以处理 I&#x2F;O 操作的结果。</p><p>在 io_uring 中，完成处理器 对应于那些被提交到 io_uring 并在 I&#x2F;O 操作完成后执行的回调函数。这些回调函数处理 io_uring 从完成队列中获取的 CQEs(多个完成队列条目)。</p><p><strong>异步读取回调函数代码示例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">handle_read</span><span class="params">(<span class="keyword">struct</span> io_uring *ring, <span class="keyword">struct</span> io_uring_cqe *cqe)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_data</span> *<span class="title">data</span> =</span> io_uring_cqe_get_data(cqe);</span><br><span class="line">    <span class="keyword">if</span> (!data) &#123;</span><br><span class="line">        <span class="keyword">return</span>;  <span class="comment">// 数据为空则直接返回</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cqe-&gt;res &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 客户端断开连接或读取错误</span></span><br><span class="line">        close(data-&gt;fd);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 读取数据，准备回写(data-&gt;buffer缓冲区已经有数据了)</span></span><br><span class="line">        data-&gt;bytes_read = cqe-&gt;res;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Received: %.*s\n&quot;</span>, (<span class="type">int</span>)data-&gt;bytes_read, data-&gt;buffer);</span><br><span class="line">        <span class="comment">// 可以在这里添加写回逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(data);  <span class="comment">// 释放内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Proactor 实例</strong>：<br>Proactor 实例是负责管理整个异步 I&#x2F;O 流程的组件，它管理着异步操作处理器和完成处理器，调度完成处理器，并处理所有的异步事件。</p><p>在 io_uring 中，Proactor 实例 对应的是用户空间中维护 io_uring 接口和逻辑的部分，<strong>其实就是一个事件循环</strong>，它负责监控完成队列（CQ），确定哪些 I&#x2F;O 操作已经完成，并触发相应的完成处理器。</p><p><strong>Proactor 实例代码示例：</strong></p><pre><code class="c">// 运行事件循环以处理异步 I/O 操作void run_io_uring_loop(struct io_uring *ring) &#123;    struct io_uring_cqe *cqe;    unsigned head;    while (1) &#123;        // 提交所有挂起的请求并等待至少一个请求完成        io_uring_submit_and_wait(ring, 1);        // 处理所有已完成的事件        io_uring_for_each_cqe(ring, head, cqe) &#123;            if (cqe-&gt;res &lt; 0) &#123;                fprintf(stderr, &quot;IO operation failed: %s\n&quot;, strerror(-cqe-&gt;res));            &#125; else &#123;                handle_read(ring, cqe); // 调用完成处理器            &#125;            // 标记该事件已处理            io_uring_cqe_seen(ring, cqe);        &#125;    &#125;&#125;</code></pre><p><strong>Proactor 事件处理流程</strong></p><p><strong>启动异步操作（Proactor 初始器）</strong>：</p><p>你的程序（通过 Proactor 初始器）准备一个异步 I&#x2F;O 操作，比如说读取文件或接收网络数据。这个准备过程涉及指定要进行的操作类型（例如读取或写入）、哪个文件或网络连接，以及数据存放的位置。</p><p>一旦准备好，这个异步操作被提交给操作系统。如果使用 io_uring，这意味着将操作请求放入 io_uring 的提交队列（SQ）。操作系统内核处理异步操作（由异步操作处理器执行）。</p><p>一旦异步操作被提交，操作系统接管这个任务。在 io_uring 中，内核会处理这些 I&#x2F;O 请求。<strong>与此同时，你的程序可以继续执行其他任务，不必等待 I&#x2F;O 操作完成。</strong></p><p><strong>通知 Proactor实例</strong> ：</p><p>当操作系统完成了一个异步 I&#x2F;O 操作，它会将此操作的结果放入完成队列（CQ）。</p><p>你的程序中的 Proactor 实例会定期检查这个完成队列，看看是否有任何操作已经完成。</p><p><strong>处理完成的操作（完成处理器）：</strong></p><p>对于每一个已经完成的操作，Proactor 实例会调用相应的完成处理器。完成处理器是你事先定义好的，专门用来处理异步操作完成后的数据的函数。比如说，如果操作对象是网络套接字，处理器可能会处理读取到的数据。</p><p><strong>清理和准备下一步操作</strong>：</p><p>一旦完成处理器运行完毕，Proactor 实例会进行必要的清理工作，并准备接收和处理更多的完成事件。</p><p><strong>总结一下</strong>：Proactor 模式允许你的程序异步地执行 I&#x2F;O 操作，同时继续进行其他任务。操作系统在后台处理这些 I&#x2F;O 请求，当它们完成时，你的程序会得到通知，并调用相应的回调函数来处理结果。这个过程优化了资源的使用，提高了应用程序的响应性和效率。</p><h4 id="Proactor-模式的优势"><a href="#Proactor-模式的优势" class="headerlink" title="Proactor 模式的优势"></a>Proactor 模式的优势</h4><p><strong>完全的异步处理：</strong></p><p>Proactor 模式实现了真正的异步 I&#x2F;O。在 Proactor 模式中，所有的 I&#x2F;O 操作（包括读写）都是异步完成的。这意味着应用程序可以在 I&#x2F;O 操作进行时继续执行其他任务，而无需等待 I&#x2F;O 操作的完成。<br>相比之下，Reactor 模式通常只能异步地处理 I&#x2F;O 请求的准备阶段（例如等待数据到达或可发送状态），而实际的读写操作仍然是同步进行的。</p><p><strong>减少线程阻塞：</strong></p><p>在 Proactor 模式中，由于 I&#x2F;O 操作完全异步，应用程序线程不会因等待 I&#x2F;O 操作而阻塞，这对于保持高性能和响应性是非常重要的。<br>Reactor 模式虽然减少了直接的 I&#x2F;O 等待（例如等待数据到达），但在处理数据时仍然可能出现阻塞（如：数据处理操作耗时较长）。</p><p><strong>简化编程模型：</strong></p><p>Proactor 模式通过预定义的回调或事件处理器简化了异步 I&#x2F;O 的编程模型，使得代码更加清晰和易于维护。<br>在 Reactor 模式中，编程者需要显式处理 I&#x2F;O 事件的分发和响应，可能导致更复杂的事件处理逻辑。</p><h4 id="Proactor-模式的应用场景"><a href="#Proactor-模式的应用场景" class="headerlink" title="Proactor 模式的应用场景"></a>Proactor 模式的应用场景</h4><p><strong>高性能网络服务器</strong>：</p><p>如 Web 服务器、数据库服务器等，特别是在需要处理大量并发网络请求的场景。</p><p><strong>文件 I&#x2F;O 密集型应用</strong>：</p><p>例如日志处理、大数据分析，以及任何需要频繁读写大型文件的应用。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在本系列文章中，我们深入探讨了Linux下的套接字编程，一个在网络通信中不可或缺的核心技术-<strong>套接字</strong>。套接字作为网络通信的基石，使得不同主机间的数据交换变得可能。</p><p><strong>套接字的本质</strong></p><p>我们首先解析了套接字的概念，它是支持TCP&#x2F;IP网络通信的基础API，为应用层与网络层之间提供了一个抽象层。通过套接字，应用程序可以不用关心底层的网络细节，就能进行网络通信。</p><p><strong>套接字类型</strong></p><p>接着，我们探讨了<strong>套接字的三种基本类型</strong>：</p><ul><li><strong>流式套接字（SOCK_STREAM</strong>）：提供序列化的、可靠的、双向的连接通信。</li><li><strong>数据报套接字（SOCK_DGRAM）</strong>：提供非连接的、不可靠的通信。</li><li><strong>原始套接字（SOCK_RAW）</strong>：允许直接访问底层协议，用于需要细粒度控制的场景。</li></ul><p><strong>关键API与结构</strong></p><p>我们详细介绍了套接字编程中的关键API，如 <strong>socket、bind、listen、accept、connect以及send和recv函数</strong>，以及套接字地址结构（如sockaddr）和地址转换API，这些是进行套接字编程的基础。</p><p><strong>数据处理</strong></p><p>字节序转换API的讨论，帮助我们处理跨平台的数据一致性问题。</p><p><strong>Linux的IO模型</strong></p><p>本系列文章还覆盖了Linux系统中的多种IO模型，包括阻塞IO、非阻塞IO、I&#x2F;O多路复用、信号驱动IO和异步IO，它们各有优势，适用于不同的场景。</p><p><strong>网络I&#x2F;O性能优化</strong></p><p>在网络I&#x2F;O性能优化部分，我们讨论了<strong>硬件优化和软件优化</strong>策略，强调了应用程序设计的重要性和内核参数调整的作用。</p><p><strong>服务器模型</strong></p><p>最后，我们探讨了 Linux 环境下常见的服务器模型，包括单进程、多进程、多线程、线程池和I&#x2F;O多路复用模型以及异步I&#x2F;O服务器模型，每种模型都有其应用场景和优缺点。</p><p><strong>架构模式</strong></p><p>服务器架构模式，如 <strong>Reactor</strong> 和 <strong>Proactor</strong>，提供了高效处理并发网络事件的方法，是构建高性能网络应用的关键。</p><p><strong>至此：</strong> 我们已经探索了 Linux 网络编程的核心领域，涵盖了从基本套接字类型与 API 的使用，到复杂的 I&#x2F;O 模型和服务器架构设计等关键知识点。这些内容构成了搭建高可用网络服务的基础框架。本篇文章主要是帮助大家提供一个清晰的 Linux 网络编程学习指南，希望这篇文章能够为你们学习编程提供帮助。</p><p>如果你对 <strong>Linux 网络编程</strong>有更深的兴趣，或者<strong>想要探索更多关于Linux编程、以及计算机基础相关的知识，不妨关注我的公众号「跟着小康学编程」</strong>。这里不仅有丰富的学习资源，还有持续更新的技术文章。</p><p><img src="https://files.mdnice.com/user/48364/36723102-908b-438f-9fda-c776eb83e2d4.png"></p><p>另外，小康最近创建了一个技术交流群，专门用来探讨技术相关或者解答读者的问题。大家在阅读这篇文章的时候，如果觉得有问题的或者有不理解的知识点，欢迎大家加群或者评论区询问。我能够解决的，尽量给大家回复。</p><p><img src="https://files.mdnice.com/user/48364/f65058cf-a987-4229-84b0-3fe005838a52.png"></p>]]></content>
      
      
      <categories>
          
          <category> Linux网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux网络编程 </tag>
            
            <tag> Linux 网络I/O模型 </tag>
            
            <tag> Linux 服务器模型 </tag>
            
            <tag> Linux 网络IO性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 系统编程从入门到进阶 学习指南</title>
      <link href="/systemprog/"/>
      <url>/systemprog/</url>
      
        <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>大家好，我是小康 ，今天我们来学习一下 Linux 系统编程相关的知识。Linux 系统编程是连接高级语言和硬件的桥梁，它对深入理解计算机系统至关重要。无论你是打算构建高性能服务器还是开发嵌入式设备，掌握 Linux 系统编程是 C 和 C++ 开发者的基本技能。</p><p>本文旨在为初学者提供一个清晰的 Linux 系统编程入门指南，带你步入 Linux 系统编程的世界，从基本概念到实用技能，一步步建立起您的知识体系。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>什么是系统编程？</strong></p><p>系统编程，指的是开发那些直接与计算机硬件或操作系统进行交互的程序。这些程序负责管理和控制计算机系统的资源，包括但不限于进程、内存、文件系统和设备驱动。确保为应用程序提供一个稳定、高效的运行环境。</p><p><strong>系统编程与应用编程的主要区别</strong>：</p><ul><li><strong>目的性</strong>：系统编程旨在为计算机或操作系统本身提供功能和服务，而应用编程是为了满足最终用户的特定需求。</li><li><strong>交互对象</strong>：系统编程直接与硬件或操作系统交互，而应用编程与操作系统或其他应用交互。</li><li><strong>复杂性</strong>：由于系统编程需要管理和控制计算机的底层资源，因此通常比应用编程更为复杂。</li><li><strong>开发工具</strong>：系统编程通常使用低级语言，如 C 或汇编，因为这些语言提供了直接访问硬件的能力。而应用编程可能使用更高级的语言，如 Python 或 Java，以提高开发效率。</li></ul><h2 id="Linux系统编程核心技术概览"><a href="#Linux系统编程核心技术概览" class="headerlink" title="Linux系统编程核心技术概览"></a>Linux系统编程核心技术概览</h2><p>在电脑的世界中，操作系统起到桥梁的作用，连接用户与计算机硬件。其中，Linux 由于其开源、稳定和安全的特点，成为了许多工程师的首选。为了更深入地理解它，我们首先需要了解其系统架构的神秘面纱。</p><p><img src="/images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/1.jpg"></p><h3 id="Linux-系统架构解析"><a href="#Linux-系统架构解析" class="headerlink" title="Linux 系统架构解析"></a>Linux 系统架构解析</h3><h4 id="用户空间和内核空间的布局"><a href="#用户空间和内核空间的布局" class="headerlink" title="用户空间和内核空间的布局"></a>用户空间和内核空间的布局</h4><p><img src="/images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/2.jpg"></p><p><strong>各个内核组件说明</strong>:</p><ul><li><p><strong>系统调用 （Syscalls）</strong>：</p><p>当应用程序需要访问硬件资源时，它们使用系统调用来与内核通信。</p></li><li><p><strong>进程管理</strong>：</p><p>负责处理进程创建、调度和终止。确保系统中的进程公平、有效地获得 CPU 时间，并管理进程间的通信和同步。</p></li><li><p><strong>内存管理</strong>：</p><p>管理物理内存，提供虚拟内存和分页功能。确保每个进程都有它自己的地址空间，同时保护进程间的内存不被非法访问。</p></li><li><p><strong>文件系统</strong>：</p><p>提供文件和目录的创建、读取、写入和删除功能。它抽象了物理存储设备，为用户和应用程序提供了一个统一的文件访问接口。</p></li><li><p><strong>虚拟文件系统（VFS）</strong>：</p><p>用户和应用程序不直接与各种文件系统交互。而是通过 VFS（虚拟文件系统）进行操作。VFS为各种不同的文件系统（如EXT4, FAT, NFS等）提供一个统一的接口。这样，无论底层使用的是哪种文件系统，用户和应用的文件访问方式都保持一致，实现在 Linux 中的无缝集成。</p></li><li><p><strong>网络协议栈</strong>：</p><p>负责处理计算机之间的通信，使设备能够在网络上发送和接收数据。它包含了多层协议，如 <strong>TCP&#x2F;IP</strong>，使计算机能够连接到互联网和其他网络，并与其他计算机进行数据交换。</p></li><li><p><strong>设备驱动</strong>：</p><p>设备驱动是一种特殊的软件程序，它允许 Linux 内核和计算机的硬件组件进行交互。这些硬件组件可以是任何物理设备，如显卡、声卡、网络适配器、硬盘或其他输入&#x2F;输出设备。设备驱动为硬件设备提供了一个抽象层，使得内核和应用程序不需要知道硬件的具体细节，就能与其进行通信和控制。<strong>简而言之，设备驱动是硬件和操作系统之间通信的桥梁。</strong></p></li></ul><h4 id="用户空间-User-Space"><a href="#用户空间-User-Space" class="headerlink" title="用户空间 (User Space)"></a>用户空间 (User Space)</h4><p>所有的应用程序，如浏览器、文档编辑器或音乐播放器都运行在这个空间。</p><ul><li><strong>安全性</strong>：用户空间的程序运行在受限的环境中，它们只能访问分配给它们的资源，不能直接访问硬件或其他程序的数据。</li><li><strong>稳定性</strong>：如果一个应用程序崩溃，它不会影响其他应用程序或系统的核心功能。</li></ul><h4 id="内核空间-Kernel-Space"><a href="#内核空间-Kernel-Space" class="headerlink" title="内核空间 (Kernel Space)"></a>内核空间 (Kernel Space)</h4><p>内核空间是操作系统的核心。</p><ul><li><strong>权限</strong>：内核可以直接访问硬件，并有权执行任何命令。</li><li><strong>安全性</strong>：虽然内核拥有广泛的权限，但只有那些已知且经过严格测试和验证的代码才被允许在内核空间执行。</li><li><strong>稳定性</strong>：如果内核遇到问题，整个系统可能会崩溃。</li></ul><h3 id="系统调用与库函数"><a href="#系统调用与库函数" class="headerlink" title="系统调用与库函数"></a>系统调用与库函数</h3><p>在 <strong>Linux</strong> 编程中，我们经常听到“系统调用”和“库函数”这两个词，但你知道它们之间的区别吗？接下来就让我们来详细了解一下。</p><h4 id="什么是系统调用？"><a href="#什么是系统调用？" class="headerlink" title="什么是系统调用？"></a>什么是系统调用？</h4><p>系统调用是一个程序向操作系统发出的请求。当应用程序需要访问某些资源（如磁盘、网络或其他硬件设备）或执行某些特定的操作（如创建进程或线程）时，它通常会通过系统调用来完成。</p><p><strong>工作原理</strong></p><ul><li><strong>模式切换</strong>：应用程序在用户空间运行，而操作系统内核在内核空间运行。系统调用涉及从用户空间切换到内核空间。</li><li><strong>参数传递</strong>：程序将参数传递给系统调用，通常通过特定的寄存器。</li><li><strong>执行</strong>：内核根据传递的参数执行相应的操作。</li><li><strong>返回结果</strong>：操作完成后，内核将结果返回给应用程序，并将控制权返回给应用程序。</li></ul><p><strong>常见的系统调用函数：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">read() 和 write()：分别用于读取和写入文件。</span><br><span class="line">open() 和 close()：打开和关闭文件。</span><br><span class="line">fork()：创建一个新的进程。</span><br><span class="line">wait()：等待进程结束。</span><br><span class="line">exec()：执行一个新程序。</span><br></pre></td></tr></table></figure><p>这只是系统调用的冰山一角。<strong>Linux</strong> 提供了上百个系统调用，每个都有其特定的功能。</p><h4 id="什么是库函数？"><a href="#什么是库函数？" class="headerlink" title="什么是库函数？"></a>什么是库函数？</h4><p>库函数是预编写的代码，存储在库文件中，供程序员使用。它们通过系统调用和操作系统的内核通信。例如，printf（） 是 C 语言的一个库函数，它内部使用 write（） 系统调用来和内核进行交互。</p><h3 id="文件-IO"><a href="#文件-IO" class="headerlink" title="文件 IO"></a>文件 IO</h3><p>文件IO（输入&#x2F;输出）是计算机程序与文件系统交互的基本方式，允许程序读取和写入文件。要深入理解和使用文件IO，首先需要了解一些关键概念和操作。</p><p><img src="/images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/20.jpg"></p><h4 id="文件描述符是什么？"><a href="#文件描述符是什么？" class="headerlink" title="文件描述符是什么？"></a>文件描述符是什么？</h4><p>文件描述符「 fd 」是一个整数，它代表了一个打开的文件。在 Linux 中，每次我们打开或创建一个文件时，系统都会返回一个文件描述符。而应用程序正是通过这个文件描述符「 fd 」来进行文件的读写的。</p><p><strong>特殊的文件描述符</strong>:</p><ul><li>标准输入<strong>「stdin」</strong> 是 0</li><li>标准输出<strong>「stdout」</strong> 是 1</li><li>标准错误 <strong>「stderr」</strong> 是 2</li></ul><h4 id="常见的文件操作"><a href="#常见的文件操作" class="headerlink" title="常见的文件操作"></a>常见的文件操作</h4><p>当应用程序要与文件交互时，最基本的操作包括打开、读取、写入和关闭文件。这可以通过以下函数来实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">打开文件：open()</span><br><span class="line">读取文件：read()</span><br><span class="line">写入文件：write()</span><br><span class="line">关闭文件：close()</span><br><span class="line"></span><br><span class="line"><span class="meta"># demo</span></span><br><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;example.txt&quot;</span>, O_RDWR | O_CREAT);</span><br><span class="line">write(fd, <span class="string">&quot;Hello, File!&quot;</span>, <span class="number">12</span>);</span><br><span class="line">close(fd);</span><br></pre></td></tr></table></figure><h4 id="文件位置与移动"><a href="#文件位置与移动" class="headerlink" title="文件位置与移动"></a>文件位置与移动</h4><p>有时，我们可能需要移动到文件的特定位置进行读写。使用 lseek（） 可以实现这一点。举个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">假设我们有一个名为 &quot;data.txt&quot; 的文件，内容为：Hello World!</span></span><br><span class="line"><span class="comment"> 现在我们有一个简单需求：我们想将文件中的&quot;World&quot;替换为&quot;Linux&quot;，但不想重写整个文件。 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># demo 展示：</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buffer[<span class="number">6</span>];  <span class="comment">// 存放从文件中读取的数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;data.txt&quot;</span>, O_RDWR);  # 以读写模式打开文件</span><br><span class="line">lseek(fd, <span class="number">6</span>, SEEK_SET);  <span class="comment">// 使用 lseek() 移动到&quot;World&quot;的开头位置</span></span><br><span class="line">read(fd, buffer, <span class="number">5</span>);     <span class="comment">// 读取5个字符（&quot;World&quot;的长度）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(buffer, <span class="string">&quot;World&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 重新定位文件指针以替换&quot;World&quot;,这里需要重新定位的原因是：上面 read 操作使得文件指针已经指向文件末尾了，因此需要重新定位。</span></span><br><span class="line">    lseek(fd, <span class="number">6</span>, SEEK_SET);</span><br><span class="line">    write(fd, <span class="string">&quot;Linux&quot;</span>, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line">close(fd) ; </span><br></pre></td></tr></table></figure><h4 id="高级文件-I-O"><a href="#高级文件-I-O" class="headerlink" title="高级文件 I&#x2F;O"></a>高级文件 I&#x2F;O</h4><p>有时，简单的读写操作无法满足我们的需求，尤其当我们追求高效率或特殊功能时。为了更优雅、高效地处理文件数据，我们引入了一些高级文件 I&#x2F;O 技巧。</p><p><strong>分散读取和集中写入</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 读取操作</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">readv</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec *iov, <span class="type">int</span> iovcnt)</span>;</span><br><span class="line"><span class="comment">// 写入操作</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">writev</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec *iov, <span class="type">int</span> iovcnt)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta"># iovec 结构的定义如下：</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> &#123;</span></span><br><span class="line">    <span class="type">void</span>  *iov_base;  </span><br><span class="line">    <span class="type">size_t</span> iov_len; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">iov_base 是指向缓冲区起始地址的指针。</span><br><span class="line">iov_len 是缓冲区的大小。</span><br></pre></td></tr></table></figure><p>这两个函数主要用于多缓冲区的输入&#x2F;输出操作，允许您在单次系统调用中，从文件读取到多个缓冲区或从多个缓冲区写入文件。</p><p>它们的主要目的是提高效率，因为常规的读&#x2F;写函数每次只能在一个缓冲区进行操作。</p><p><strong>内存映射文件I&#x2F;O</strong></p><p>内存映射文件 I&#x2F;O 允许程序员将文件的一部分直接映射到进程的内存中。这样，程序可以通过直接访问这块内存来访问文件的内容，而不是使用传统的 read 、write 系统调用。这可以提高效率，特别是对于大文件的访问。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 相关函数声明</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">mmap</span><span class="params">(<span class="type">void</span>* addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span>* addr, <span class="type">size_t</span> length)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// demo 举例:</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;example.txt&quot;</span>, O_RDWR);</span><br><span class="line"><span class="comment">// 获取文件的大小</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sb</span>;</span></span><br><span class="line"><span class="keyword">if</span> (fstat(fd, &amp;sb) == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;fstat&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> *mapped = mmap(<span class="literal">NULL</span>, sb.st_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后续的所有对文件的操作就可以通过 mapped 指针来进行。</span></span><br><span class="line"><span class="comment">// 例如：将第一个字符改为 &#x27;J&#x27;）</span></span><br><span class="line">mapped[<span class="number">0</span>] = <span class="string">&#x27;J&#x27;</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>使用 mmap ，你可以直接在内存中访问文件内容，如同访问数组或其他数据结构一样。</p><p><strong>同步文件操作</strong></p><p>当您向文件写入数据时，操作系统可能会缓存这些数据，而不是立即写入磁盘,这样可以提高效率。 但在某些情况下，您可能需要确保数据确实已经写入磁盘。这就是同步文件操作的用处。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">msync</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fsync</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fdatasync</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sync</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><ul><li>msync  用于同步内存映射（通过 mmap 函数创建）文件的内容。它将内存中的更改写回到映射的文件中。</li><li>fsync 函数用于将指定文件描述符（fd）关联的文件的所有修改（包括数据和元数据）同步到磁盘</li><li>fdatasync 函数类似于 fsync，但它只同步文件的数据部分，而不同步元数据。</li><li>sync 同步整个文件系统的所有修改的数据到磁盘，包括所有打开的文件。</li></ul><h4 id="文件锁定"><a href="#文件锁定" class="headerlink" title="文件锁定"></a>文件锁定</h4><p><strong>什么是文件锁定？</strong></p><p>文件锁定是一个在多个进程或线程之间协调对共享资源访问的机制。在这里，这个”共享资源”指的是文件。简单说，<strong>文件锁</strong>就是确保当一个进程正在使用一个文件时，其他进程不能修改它。</p><p><strong>为什么需要文件锁定？</strong></p><p>考虑这样一个场景：两个程序同时写入一个文件。不锁定文件可能会导致数据混乱。例如，一个进程可能会覆盖另一个进程的更改。所以，文件锁定是确保数据完整性的关键。</p><p><strong>文件锁的两种模式</strong>：</p><ul><li><p><strong>共享锁（Shared Locks）</strong>：也被称为读锁。当一个进程持有共享锁时，其他进程可以获得该文件的共享锁以进行读取，但不能获得独占锁进行写入。</p></li><li><p><strong>独占锁（Exclusive Locks）</strong>：也被称为写锁。当一个进程持有独占锁时，其他进程不能获得该文件的任何类型的锁。这意味着其他进程不可以读取或写入该文件。</p></li></ul><p><strong>如何实现文件锁定？</strong></p><p>在 Linux  编程中，文件锁定可以使用以下函数实现：</p><p><code>fcntl()</code> : 允许对文件中的特定部分进行锁定。</p><p><code>flock()</code> ：提供了一个简化的锁定机制，直接锁定整个文件。</p><h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><p><strong>什么是重定向？</strong></p><p><strong>重定向</strong>，顾名思义，指的是改变数据流的方向。在 <strong>Linux</strong> 系统编程中，程序通常与三种标准I&#x2F;O 流进行交互：标准输入（stdin）、标准输出（stdout）、和标准错误输出（stderr）。</p><ul><li>标准输入（stdin）         : 来自键盘的输入。</li><li>标准输出（stdout）        : 显示到屏幕上。</li><li>标准错误输出（stderr)     : 也显示到屏幕上。</li></ul><p><strong>重定向的核心是将这些标准的 I&#x2F;O 流改变到其他地方，如文件或其他程序。</strong></p><p>例如，当我们在命令行中执行命令并将结果保存到文件中，或者从文件中获取命令的输入而不是从键盘中获取，我们都是在使用重定向。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 将 ls -l 命令的输出（即当前目录的详细列表）重定向到 filelist.txt 文件中</span><br><span class="line">ls -l &gt; filelist.txt   </span><br></pre></td></tr></table></figure><p>重定向不仅局限于命令行界面，它在程序中也很有用，允许我们动态地更改程序的输入和输出来源，为构建更复杂、灵活的应用程序提供了基础。</p><p>在 <strong>Linux</strong> 系统编程中，实现重定向的一个核心函数是 <strong>dup2</strong> 函数。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup2</span><span class="params">(<span class="type">int</span> oldfd, <span class="type">int</span> newfd)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">其中：</span></span><br><span class="line"><span class="comment">oldfd 是原始文件描述符。</span></span><br><span class="line"><span class="comment">newfd 是要复制到的目标文件描述符。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># demo 举例:</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 打开一个文件用于写入</span></span><br><span class="line">    <span class="type">int</span> file_fd = open(<span class="string">&quot;output.txt&quot;</span>, O_WRONLY | O_CREAT | O_TRUNC, <span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span> (file_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 错误处理</span></span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 dup2 将标准输出重定向到文件</span></span><br><span class="line">    <span class="keyword">if</span> (dup2(file_fd, STDOUT_FILENO) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="comment">// 错误处理</span></span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在，所有标准输出都会被写入文件</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This will be written to the file &#x27;output.txt&#x27;\n&quot;</span>);</span><br><span class="line">    close(file_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Linux-进程"><a href="#Linux-进程" class="headerlink" title="Linux 进程"></a>Linux 进程</h3><p>你有没有想过，当你在 <strong>Linux</strong> 操作系统上运行一个程序时，都发生了哪些神奇的事情？接下来，我们将一步一步地深入探讨 Linux 进程的世界。</p><p><img src="/images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/3.jpg"></p><h4 id="进程究竟是什么？"><a href="#进程究竟是什么？" class="headerlink" title="进程究竟是什么？"></a>进程究竟是什么？</h4><p>每当你启动一个程序，<strong>Linux</strong> 系统都会创建一个新的进程。这个进程有它自己的内存地址、系统资源和状态。简而言之，进程是程序的一个运行实例。</p><h4 id="进程的创建和终止"><a href="#进程的创建和终止" class="headerlink" title="进程的创建和终止"></a>进程的创建和终止</h4><p><code>fork()</code>：当调用 fork 函数时，它会创建一个新的子进程。这个子进程几乎是父进程的复制品，包括父进程的内存、程序计数器等。</p><p><code>wait() &amp; waitpid()</code>：这些函数允许父进程等待子进程的结束，并收集子进程的退出状态。防止出现僵尸进程。</p><p><code>exec() 系列函数</code>：<strong>exec</strong> 系列函数 允许一个进程运行另一个程序，它实际上替换了当前进程的内容。</p><h4 id="进程的状态转换图"><a href="#进程的状态转换图" class="headerlink" title="进程的状态转换图"></a>进程的状态转换图</h4><p><img src="/images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/4.jpg"></p><p><strong>五态简要说明</strong>:</p><ul><li><p><strong>新建状态</strong>: 这是进程刚被创建时的状态。在这个状态下，操作系统为进程分配了一个唯一的进程标识符（PID）和必要的资源。但进程还没有开始执行任何代码。新建状态通常非常短暂，用户很难观察到，因为进程很快就会转移到 <strong>「就绪状态」</strong>。</p></li><li><p><strong>就绪状态</strong> : 进程已准备好运行并等待操作系统的调度器分配 CPU 时间片。在这个状态下，进程已经加载了所有必要的代码和数据到内存中，且已准备好执行。</p></li><li><p><strong>运行状态</strong> : 进程正在 CPU 上执行。一个进程只有在运行状态时才能执行其指令。</p></li><li><p><strong>阻塞状态</strong> : 进程不能执行，因为它在等待一些事件发生，例如 I&#x2F;O 操作的完成、信号的接收等。在此状态下，即使 CPU 空闲，进程也不能执行。</p></li><li><p><strong>终止状态</strong> : 进程已完成执行或被终止。在这个状态下，进程的资源通常被回收，进程退出。</p></li></ul><h4 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h4><p>在 Linux 的世界里，进程是操作系统进行资源分配的基本单位。但是，进程并不是孤立的存在。当你的应用分成多个独立运行的进程时，这些进程之间如何有效地交换信息呢？这正是通过进程间通信的方式来实现的。</p><p><strong>Linux 提供了以下几种进程间通信的方式</strong>：</p><p>1.管道 （Pipe）</p><p>管道是 Linux 中用于进程间通信的一种机制。它们分为两种类型：<strong>匿名管道</strong>和<strong>有名管道</strong>。</p><p><strong>匿名管道</strong>   : </p><p>  <strong>概念</strong>：匿名管道是一种在有亲缘关系的进程间（如父子进程）进行单向数据传输的通信机制，存在于内存中，通常用于临时通信。如果需要双向通信，则一般需要两个管道。</p><p>  <strong>简单图解：</strong></p><p>  <img src="/images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/5.jpg"></p><p>  <strong>使用场景</strong>：适用于有亲缘关系的进程间的简单数据传输。</p><p>  <strong>简单示例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">  pipe(pipefd); <span class="comment">// 创建匿名管道</span></span><br><span class="line">  <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123; <span class="comment">// 子进程</span></span><br><span class="line">      close(pipefd[<span class="number">1</span>]); <span class="comment">// 关闭写端</span></span><br><span class="line">      <span class="comment">//读取数据</span></span><br><span class="line">      read(pipefd[<span class="number">0</span>],buf,<span class="number">5</span>);</span><br><span class="line">      <span class="comment">// ... </span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 父进程</span></span><br><span class="line">      close(pipefd[<span class="number">0</span>]); <span class="comment">// 关闭读端</span></span><br><span class="line">      <span class="comment">// 写入数据</span></span><br><span class="line">      write(pipefd[<span class="number">1</span>],<span class="string">&quot;hello&quot;</span>,<span class="number">5</span>);</span><br><span class="line">      <span class="comment">// ... </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>有名管道</strong>   ：</p><p><strong>概念：</strong> <strong>有名管道（FIFO，First-In-First-Out）</strong> 是一种特殊类型的文件，用于在不相关的进程之间实现通信。与匿名管道不同，有名管道在文件系统中具有一个实际的路径名。这允许任何具有适当权限的进程打开和使用它，而不仅限于有亲缘关系的进程。</p><p><strong>简单图解：</strong></p><p><img src="/images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/6.jpg"></p><p><strong>简单说明</strong>：</p><p>有名管道是 Linux 中一种特殊的文件，它允许不同的进程通过读写这个文件来相互通信。</p><p><strong>使用场景</strong>：用于本机任何两个进程间的通信，特别是当这些进程没有血缘关系时。</p><p><strong>简单示例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *fifoPath = <span class="string">&quot;/tmp/my_fifo&quot;</span>;</span><br><span class="line">    mkfifo(fifoPath, <span class="number">0666</span>); <span class="comment">// 创建有名管道</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="comment">// 永久循环，持续监听有名管道</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        fd = open(fifoPath, O_RDONLY); <span class="comment">// 打开管道进行读取</span></span><br><span class="line">        read(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印接收到的消息</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Received: %s\n&quot;</span>, buf);</span><br><span class="line">        close(fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// client.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *fifoPath = <span class="string">&quot;/tmp/my_fifo&quot;</span>;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter message: &quot;</span>);    <span class="comment">// 获取要发送的消息</span></span><br><span class="line">    fgets(buf, <span class="keyword">sizeof</span>(buf), <span class="built_in">stdin</span>);</span><br><span class="line">    fd = open(fifoPath, O_WRONLY); <span class="comment">// 打开管道进行写入</span></span><br><span class="line">    write(fd, buf, <span class="built_in">strlen</span>(buf) + <span class="number">1</span>);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.信号 (Signals)</strong></p><p><strong>概念</strong>：<br>在 Linux 中，信号是一种用于进程间通信（IPC）的机制，允许操作系统或一个进程向另一个进程发送简单的消息。信号主要用于传递关于系统事件的通知，例如中断请求、程序异常、或其他重要事件。每个信号代表了一个特定类型的事件，并且进程可以根据收到的信号执行相应的动作。</p><p>信号是异步的，意味着它们可以在任何时间点被发送到进程，通常与进程的正常控制流无关。信号的使用为进程提供了一种处理外部事件和错误的方式。</p><p>可以使用命令 <code>kill -l</code> 来查看 Linux 系统支持的信号有哪些？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">~$ kill -l</span><br><span class="line"> 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP</span><br><span class="line"> 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1</span><br><span class="line">11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>使用场景</strong>：</p><ul><li><strong>异常处理</strong>：当程序遇到运行时错误，比如除以零、非法内存访问等，操作系统会向该进程发送一个适当的信号，如SIGFPE（浮点异常）、SIGSEGV（段错误）。默认情况下：都会使程序终止。</li><li><strong>外部中断</strong>：用户可以通过特定的键盘输入（最常见的是Ctrl+C）来中断正在终端上运行的进程。这会生成 SIGINT 信号，通常导致程序终止。</li><li><strong>进程控制</strong>：如使用 kill 命令发送信号来终止或暂停某个进程。</li><li><strong>定时器和超时</strong>： 程序可以设置定时器，当定时器到期时，会收到 SIGALRM 信号。这常用于限制某些操作的执行时间，确保它们不会占用过多时间。</li><li><strong>子进程状态变化</strong>：当一个子进程结束或停止时，它的父进程会收到 SIGCHLD 信号。这使得父进程可以监控其子进程的状态变化（从运行到正常退出）。</li></ul><p><strong>简单示例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">signal_handler</span><span class="params">(<span class="type">int</span> signal_num)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Received signal: %d\n&quot;</span>, signal_num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    signal(SIGINT, signal_handler);  <span class="comment">// 注册信号处理函数</span></span><br><span class="line">    <span class="comment">// 无限循环，等待信号</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        sleep(<span class="number">1</span>); <span class="comment">// 暂停一秒</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，程序设置了一个信号处理函数来处理 SIGINT 信号（通常由 Ctrl+C 产生）。当收到该信号时，signal_handler 函数会被调用。</p><p><strong>以下是对上述代码执行流程的简单图解说明，方便大家理解</strong>：</p><p><img src="/images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/7.jpg"></p><p><strong>3.文件(Files)</strong></p><p><strong>概念</strong>：</p><p>文件在 Linux 系统中是一种基本的持久化存储机制，可用于<strong>进程间通信</strong>。多个进程可以通过对同一个文件的读取和写入来共享信息。</p><p><strong>简单图解：</strong></p><p><img src="/images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/8.jpg"></p><p><strong>使用场景：</strong></p><ul><li><p><strong>数据交换：</strong></p><p>进程之间可以通过读写同一文件来交换数据。例如，一个进程写入结果数据，另一个进程读取这些数据进行进一步处理。</p></li><li><p><strong>持久化存储：</strong></p><p>文件用于保存需要在应用程序重启后依然保留的数据，例如用户数据、应用状态等。</p></li></ul><p><strong>简单示例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写进程: 向文件中写入数据</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *file = <span class="string">&quot;/tmp/ipc_file&quot;</span>;</span><br><span class="line">    <span class="type">int</span> fd = open(file, O_RDWR | O_CREAT, <span class="number">0666</span>);</span><br><span class="line">    write(fd, <span class="string">&quot;Hello from Process A&quot;</span>, <span class="number">20</span>);  <span class="comment">// 向文件写入数据</span></span><br><span class="line">    close(fd);     <span class="comment">// 关闭文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 读进程: 从文件中读取数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *file = <span class="string">&quot;/tmp/ipc_file&quot;</span>;</span><br><span class="line">    <span class="type">int</span> fd = open(file, O_RDWR | O_CREAT, <span class="number">0666</span>);</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">50</span>];</span><br><span class="line">    read(fd, buf, <span class="number">20</span>);  <span class="comment">// 从文件中读取数据</span></span><br><span class="line">    close(fd);     <span class="comment">// 关闭文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> <strong>注意：</strong><br>  如果存在多个写进程同时操作同一个文件，那么会引发数据竞态和一致性问题。为了解决这个问题，可以使用文件锁或其他同步机制来协调对文件的访问，确保数据的完整性和一致性。</p></blockquote><p><strong>文件锁的作用:</strong></p><ul><li><p><strong>防止数据覆盖</strong>：<br>当一个进程正在写文件时，文件锁可以防止其他进程同时写入，从而避免数据被覆盖。</p></li><li><p><strong>保证写操作的完整性</strong>：</p><p>通过锁定文件，确保每次只有一个进程能够执行写操作，这有助于保持写入数据的完整性。</p></li></ul><p><strong>实现文件锁:</strong></p><p>在 Linux 中，可以使用 fcntl 或 flock 系统调用来实现文件锁。</p><p><strong>示例代码</strong> </p><p>使用 fcntl 实现文件锁，从而保证多个进程在操作同一文件时不会相互干扰，维护数据的一致性和完整性。以下是一个具体的示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *file = <span class="string">&quot;/tmp/ipc_file&quot;</span>;</span><br><span class="line">    <span class="type">int</span> fd = open(file, O_RDWR | O_CREAT, <span class="number">0666</span>);</span><br><span class="line">    <span class="comment">// 设置文件锁</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">flock</span> <span class="title">fl</span>;</span></span><br><span class="line">    fl.l_type = F_WRLCK;  <span class="comment">// 设置写锁</span></span><br><span class="line">    fl.l_whence = SEEK_SET;</span><br><span class="line">    fl.l_start = <span class="number">0</span>;</span><br><span class="line">    fl.l_len = <span class="number">0</span>;  <span class="comment">// 锁定整个文件</span></span><br><span class="line">    <span class="keyword">if</span> (fcntl(fd, F_SETLKW, &amp;fl) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Error locking file&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    write(fd, <span class="string">&quot;Hello from Process A&quot;</span>, <span class="number">20</span>); <span class="comment">// 执行写操作</span></span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    fl.l_type = F_UNLCK;</span><br><span class="line">    fcntl(fd, F_SETLK, &amp;fl);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>4.信号量(Semaphores)</strong></p><p><strong>概念</strong>:<br>信号量是一种在进程间或同一进程的不同线程间提供同步的机制。它是一个计数器，用于控制对共享资源的访问。当计数器值大于0时，表示资源可用；当值为0时，表示资源被占用。进程在访问共享资源前必须减少（wait）信号量，访问后必须增加（post）信号量。</p><p>信号量有两种，一种是 POSIX 信号量，另一种是 System V 信号量。由于 POSIX 信号量提供了更简洁、更易于理解和使用的 API，并且在现代操作系统中得到了广泛支持和优化，所以这里我重点讲解 POSIX 信号量。</p><p>  <strong>简单图解：</strong></p><p><img src="/images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/9.jpg"></p><p>  <strong>分类：</strong></p><p> <strong>匿名信号量</strong></p><p><strong>概念:</strong></p><p> 匿名信号量是内存中的信号量，不与任何文件系统的名称关联。它们通常用于单一进程内不同线程间的同步，或在具有共同祖先的进程之间进行同步。</p><p> <strong>特点：</strong></p><ul><li><strong>作用域</strong>：限于创建它的进程内部或其子进程之间。</li><li><strong>生命周期</strong>：与创建它们的进程的生命周期相同，进程终止时信号量也会消失。</li></ul><p><strong>使用场景</strong>：</p><ul><li><strong>互斥访问</strong>：在多线程程序中，确保同一时刻只有一个线程可以访问某个共享资源。</li><li><strong>同步操作</strong>：协调多个线程的执行顺序，一个线程在另一个线程完成其任务之后再开始执行。如：线程池中的任务队列没任务时，线程必须等待，而当有有线程向队列添加任务时，需要唤醒其他线程来进行消费任务。</li></ul><p> <strong>有名信号量</strong></p><p> <strong>概念:</strong>  有名信号量在文件系统中具有一个唯一的名称，允许不同的独立进程通过这个名称访问同一个信号量，实现进程间同步。</p><p> <strong>特点：</strong></p><ul><li><strong>作用域</strong>：可以跨不同的进程使用。它们在文件系统中具有一个全局唯一的名称，任何知道这个名称的进程都可以访问同一个信号量。</li><li><strong>生命周期</strong>：生命周期可以超过创建它们的进程。即使创建它们的进程已经结束，只要有名信号量的名称存在于文件系统中，它们就继续存在。</li></ul><p><strong>使用场景</strong>：</p><ul><li><strong>进程间互斥：</strong> 多个独立进程共享资源，如文件或内存映射区域，需要互斥访问以避免冲突。</li><li><strong>同步操作</strong>：协调多个进程的执行顺序，一个进程在另一个进程完成其任务之后再开始执行。如：在生产者消费者模型中，只要当生产者向队列添加数据，队列不为空的时候，消费者才能消费数据，否则只能等待。</li></ul><p><strong>来看一个进程互斥的例子：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设日志文件已经打开</span></span><br><span class="line">FILE* logFile;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">writeToLog</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span> &#123;</span><br><span class="line">    <span class="type">sem_t</span>* sem = sem_open(<span class="string">&quot;/log_semaphore&quot;</span>, O_CREAT, <span class="number">0644</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    sem_wait(sem);  <span class="comment">// 获取信号量</span></span><br><span class="line">    <span class="built_in">fprintf</span>(logFile, <span class="string">&quot;%s\n&quot;</span>, message);  <span class="comment">// 写入日志</span></span><br><span class="line">    fflush(logFile);</span><br><span class="line">    sem_post(sem);  <span class="comment">// 释放信号量</span></span><br><span class="line"></span><br><span class="line">    sem_close(sem);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ... 进程的其它操作 ...</span></span><br><span class="line">    writeToLog(<span class="string">&quot;Log message from Process&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>匿名信号量和有名信号量 API 接口区别：</strong></p><p><img src="/images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/10.jpg"></p><p><strong>5.共享内存(Shared Memory)</strong></p><p><strong>概念</strong>：<br>在 Linux 中，共享内存是进程间通信（IPC）的一种形式。当多个进程需要访问相同的数据时，使用共享内存是一种高效的方式。它允许两个或多个进程访问同一个物理内存区域，这使得数据传输不需要通过内核空间，从而提高了通信效率。</p><p>在讲解共享内存前，我们需要了解内存映射技术？</p><p><strong>内存映射技术（Memory Mapping）</strong> 是一种将文件或设备的数据映射到进程内存地址空间的技术，它允许进程直接对这部分内存进行读写操作，就像访问普通内存一样。这种技术不仅可以用于文件I&#x2F;O操作，提高文件访问效率，而且是实现共享内存的基础。</p><p>在 Linux 系统中，内存映射可以通过 <strong>mmap</strong> 系统调用来实现。<strong>mmap</strong> 允许将文件映射到进程的地址空间，也可以用来创建匿名映射（即不基于任何文件的共享内存区域）。</p><p>在 Linux 中，共享内存可以分为如下几类。</p><p><strong>匿名共享内存</strong></p><p><strong>工作原理</strong>：</p><p>匿名共享内存不与任何具体的文件系统文件直接关联，其内容仅在内存中存在。这意味着当所有使用它的进程都结束时，该内存区域的数据就会消失。这种特性使得匿名共享内存非常适合于那些需要临时共享数据但又不需要将数据持久存储到磁盘的场景。</p><p><strong>简单图解：</strong></p><p><img src="/images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/11.jpg"></p><p><strong>注意</strong>：在 Linux 中，<strong>匿名共享内存主要被设计用于有亲缘关系的进程间通信，如父子进程间</strong>。这是因为匿名共享内存的引用（例如，通过 mmap 创建时返回的内存地址）不会自动出现在其他进程中，而是需要通过某种进程间通信的方式（如Unix域套接字）传递给相关的进程。而通过 Unix 域套接字来实现又稍显复杂，所以我们一般推荐匿名共享内存适用于有亲缘关系的进程间通信。</p><p><strong>创建和使用</strong>：</p><p>在 Linux 系统中，匿名共享内存通常是通过 mmap()函数创建的，调用时需指定MAP_ANONYMOUS标志。此外，还需要设置 PROT_READ 和 PROT_WRITE 权限，以确保内存区域可读写。创建时也可以选择 MAP_SHARED 标志，以便在多个进程间共享这块内存。</p><p><strong>示例代码片段如下：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="type">void</span>* shared_memory = mmap(<span class="literal">NULL</span>, size, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOU</span><br></pre></td></tr></table></figure><p>在这里，size是希望映射的内存区域大小，mmap()调用成功后，返回指向共享内存区域的指针。</p><p><strong>使用场景</strong>：</p><p><strong>大量数据交换</strong> ：当两个或多个进程需要交换大量数据时，使用共享内存比传统的进程间通信方法（如管道或消息队列）更有效率。</p><p><strong>而谈到共享内存，又不得不探讨下关于共享内存的同步问题？</strong></p><p>在使用共享内存时，由于多个进程可以直接并且同时访问同一个物理内存区域，不加以适当控制就可能引起数据竞态和一致性问题。</p><p><strong>数据竞态</strong>：当多个进程尝试同时修改共享内存中的同一数据项时，最终结果可能依赖于各进程操作的具体顺序，可能导致不符合预期的结果。</p><p><strong>一致性问题</strong>：在没有合适同步机制的情况下，一个进程可能在另一个进程写入数据的同时读取共享内存，导致获取到不完整或不一致的数据。</p><p><strong>解决策略：使用信号量</strong></p><p>信号量是一种常用的同步机制，用于控制对共享资源的并发访问。通过增加（释放资源）或减少（占用资源）信号量的值，可以有效地控制对共享内存区域的访问，防止数据竞态和确保数据一致性。</p><p><strong>使用信号量来解决匿名共享内存同步问题的简单示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建或打开有名信号量</span></span><br><span class="line">    <span class="type">sem_t</span> *sem = sem_open(<span class="string">&quot;/mysemaphore&quot;</span>, O_CREAT, <span class="number">0666</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (sem == SEM_FAILED) &#123;</span><br><span class="line">        <span class="comment">// 错误处理，退出程序</span></span><br><span class="line">        perror(<span class="string">&quot;sem_open failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建匿名共享内存</span></span><br><span class="line">    <span class="type">void</span>* shared_memory = mmap(<span class="literal">NULL</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>), PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (shared_memory == MAP_FAILED) &#123;</span><br><span class="line">      <span class="comment">// 错误处理，退出程序</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>* counter = (<span class="type">int</span>*)shared_memory;</span><br><span class="line">    *counter = <span class="number">0</span>; <span class="comment">// 初始化计数器</span></span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">            sem_wait(sem); <span class="comment">// 等待信号量</span></span><br><span class="line">            (*counter)++;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Child process increments counter to %d\n&quot;</span>, *counter);</span><br><span class="line">            sem_post(sem); <span class="comment">// 释放信号量</span></span><br><span class="line">            sleep(<span class="number">1</span>); <span class="comment">// 暂停一段时间，模拟工作负载</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">            sem_wait(sem);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Parent process reads counter as %d\n&quot;</span>, *counter);</span><br><span class="line">            sem_post(sem);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// fork失败</span></span><br><span class="line">        perror(<span class="string">&quot;fork failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理资源</span></span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123; <span class="comment">// 父进程等待子进程完成</span></span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        sem_close(sem);</span><br><span class="line">        sem_unlink(<span class="string">&quot;/mysemaphore&quot;</span>);</span><br><span class="line">        munmap(shared_memory, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>基于文件的共享内存</strong></p><p><strong>工作原理:</strong></p><p>基于文件的共享内存通过将磁盘上的实际文件映射到一个或多个进程的地址空间中来实现。当文件被映射到内存后，进程就可以像访问普通内存一样直接读写文件内容，操作系统负责同步内存修改回磁盘文件。这种机制既提高了数据访问的效率，也实现了数据的持久化存储。</p><p>相比匿名共享内存只能适合有亲缘关系的进程，<strong>基于文件的共享内存特别适合于实现非亲缘关系进程间的数据共享</strong>。</p><p><strong>简单图解：</strong></p><p><img src="/images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/12.jpg"></p><p><strong>创建和使用:</strong></p><p>要创建基于文件的共享内存，首先需要打开（或创建）一个文件，然后使用 mmap()将文件映射到内存中。与匿名共享内存不同，这里需要提供<strong>文件描述符</strong>而不是 MAP_ANONYMOUS 标志。</p><p><strong>示例代码片段如下：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> size = <span class="number">4096</span>; <span class="comment">// 共享内存区域大小</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;shared_file&quot;</span>, O_RDWR | O_CREAT, <span class="number">0666</span>);</span><br><span class="line">ftruncate(fd, size); <span class="comment">// 设置文件大小</span></span><br><span class="line"><span class="type">void</span>* shared_memory = mmap(<span class="literal">NULL</span>, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>在这里，shared_file 是被映射的文件名，size 是文件的预期大小。通过 ftruncate() 调整文件大小以匹配共享内存的需求。mmap()成功后返回指向共享内存区域的指针。</p><p><strong>使用场景：</strong></p><p><strong>大量数据交换</strong> ：基于文件的共享内存同样适用于多个进程需要进行大量数据交换的场景。与匿名共享内存不同的是，这些数据可以持久化存储到磁盘上。</p><p>在使用基于文件的共享内存时，同样需要解决多个进程共享数据的同步问题，以保证数据的一致性和完整性。</p><p><strong>解决方案</strong>：</p><ul><li><p><strong>信号量</strong>：<br>信号量可以理解是一个计数器，用来控制同时访问共享资源（如共享内存）的进程数量。如果信号量计数大于0，表示资源可用，进程可以访问资源并将计数减1；如果信号量计数为0，表示资源不可用，进程必须等待。当资源使用完毕后，进程会增加信号量计数，表示资源再次可用。</p></li><li><p><strong>文件锁</strong>：<br>文件锁允许进程对共享内存所基于的文件加锁，防止其他进程同时访问。如果一个进程要写入共享内存，它可以加一个排他锁，这时其他进程既不能读也不能写；如果只需要读取，进程可以加一个共享锁，这样其他进程也可以加共享锁来读取数据，但不能写入。在 Linux 中，文件锁的实现主要依赖于两个系统调用：fcntl 和 flock。而关于 fcntl 和 flock 的讲解，我在前文也有提到过。</p></li></ul><p><strong>简单来说</strong>：</p><ul><li>使用信号量是为了确保在同一时间只有限定数量的进程可以操作共享内存。</li><li>使用文件锁是为了防止在某个进程读写共享内存时，其他进程进行干扰。</li></ul><p>下面来看一个使用<strong>有名信号量解决基于文件的共享内存同步问题的示例</strong>，这个简单的示例演示了两个进程：一个进程向共享内存写入数据，另一个进程从共享内存读取数据。这两个进程使用同一个有名信号量来同步对共享内存区域的访问。</p><p><strong>示例代码：</strong></p><p>首先，确保你有一个名为 shared_file 的文件和一个名为 &#x2F;mysemaphore 的信号量。</p><p><strong>写入进程</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* filename = <span class="string">&quot;shared_file&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> size = <span class="number">4096</span>;</span><br><span class="line">    <span class="comment">// 打开文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(filename, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 错误处理并退出</span></span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 映射文件</span></span><br><span class="line">    <span class="type">void</span>* addr = mmap(<span class="literal">NULL</span>, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (addr == MAP_FAILED) &#123;</span><br><span class="line">        <span class="comment">// 错误处理并退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打开有名信号量</span></span><br><span class="line">    <span class="type">sem_t</span> *sem = sem_open(<span class="string">&quot;/mysemaphore&quot;</span>, O_CREAT, <span class="number">0666</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (sem == SEM_FAILED) &#123;</span><br><span class="line">        <span class="comment">// 错误处理并退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待信号量，开始写入数据</span></span><br><span class="line">    sem_wait(sem);</span><br><span class="line">    <span class="built_in">strcpy</span>((<span class="type">char</span>*)addr, <span class="string">&quot;Hello, Shared Memory!&quot;</span>);</span><br><span class="line">    sem_post(sem);</span><br><span class="line">    <span class="comment">// 清理</span></span><br><span class="line">    munmap(addr, size);</span><br><span class="line">    close(fd);</span><br><span class="line">    sem_close(sem);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>读取进程：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* filename = <span class="string">&quot;shared_file&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> size = <span class="number">4096</span>;</span><br><span class="line">    <span class="comment">// 打开文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(filename, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 错误处理并退出</span></span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 映射文件</span></span><br><span class="line">    <span class="type">void</span>* addr = mmap(<span class="literal">NULL</span>, size, PROT_READ, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (addr == MAP_FAILED) &#123;</span><br><span class="line">       <span class="comment">// 错误处理并退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打开有名信号量</span></span><br><span class="line">    <span class="type">sem_t</span> *sem = sem_open(<span class="string">&quot;/mysemaphore&quot;</span>, O_CREAT, <span class="number">0666</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (sem == SEM_FAILED) &#123;</span><br><span class="line">        <span class="comment">// 错误处理并退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待信号量，开始读取数据</span></span><br><span class="line">    sem_wait(sem);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Read from shared memory: %s\n&quot;</span>, (<span class="type">char</span>*)addr);</span><br><span class="line">    sem_post(sem);</span><br><span class="line">    <span class="comment">// 清理</span></span><br><span class="line">    munmap(addr, size);</span><br><span class="line">    close(fd);</span><br><span class="line">    sem_close(sem);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明</strong>：上面的信号量初始值为 1 ，实际上信号量在这里充当的就是互斥锁。</p><p><strong>Posix 共享内存</strong></p><p>POSIX 共享内存提供了一种高效的方式，允许多个进程通过共享内存区域进行通信。与基于文件的共享内存相比，POSIX 共享内存不需要直接映射磁盘上的文件，而是通过创建命名的共享内存对象来实现进程间的数据共享。这些对象虽然在逻辑上类似于文件（因为可以通过shm_open创建和打开），但实质上直接存在于内存中，提供了更快的数据访问速度。</p><p><strong>Posix 共享内存接口</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">shm_open()        <span class="comment">// 创建或打开一个共享内存对象</span></span><br><span class="line">shm_unlink()      <span class="comment">// 删除一个共享内存对象的名称</span></span><br><span class="line">ftruncate()       <span class="comment">// 调整共享内存对象的大小</span></span><br><span class="line">mmap()            <span class="comment">// 将共享内存对象映射到调用进程的地址空间</span></span><br><span class="line">munmap()          <span class="comment">// 解除共享内存对象的映射</span></span><br></pre></td></tr></table></figure><p><strong>示例演示</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SHM_NAME <span class="string">&quot;/example_shm&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHM_SIZE 4096</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> shm_fd;</span><br><span class="line">    <span class="type">void</span> *ptr;</span><br><span class="line">    <span class="comment">// 创建共享内存对象</span></span><br><span class="line">    shm_fd = shm_open(SHM_NAME, O_CREAT | O_RDWR, <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span> (shm_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 错误处理并退出</span></span><br><span class="line">        perror(<span class="string">&quot;shm_open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置共享内存大小</span></span><br><span class="line">    <span class="keyword">if</span> (ftruncate(shm_fd, SHM_SIZE) == <span class="number">-1</span>) &#123;</span><br><span class="line">       <span class="comment">// 错误处理并退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 映射共享内存</span></span><br><span class="line">    ptr = mmap(<span class="number">0</span>, SHM_SIZE, PROT_WRITE, MAP_SHARED, shm_fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ptr == MAP_FAILED) &#123;</span><br><span class="line">        <span class="comment">// 错误处理并退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 写入数据到共享内存</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *message = <span class="string">&quot;Hello, POSIX Shared Memory!&quot;</span>;</span><br><span class="line">    <span class="built_in">sprintf</span>(ptr, <span class="string">&quot;%s&quot;</span>, message);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Data written to shared memory: %s\n&quot;</span>, message);</span><br><span class="line">    <span class="comment">// 解除映射</span></span><br><span class="line">    munmap(ptr, SHM_SIZE);</span><br><span class="line">    <span class="comment">// 关闭共享内存对象</span></span><br><span class="line">    close(shm_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>System V共享内存</strong></p><p>System V共享内存是一种传统的进程间通信（IPC）机制，它允许多个进程通过共享内存区域进行通信。与POSIX共享内存不同，System V共享内存使用IPC键值key_t来标识和管理共享内存段，而不是通过命名的方式。这种机制提供了一套底层控制共享内存的API，允许进行更细粒度的操作，如权限控制、共享内存状态的查询和管理等。</p><p><strong>System V共享内存接口</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shmget()         <span class="comment">// 创建或获取共享内存段的标识符</span></span><br><span class="line">shmat()          <span class="comment">// 将共享内存段附加到进程的地址空间</span></span><br><span class="line">shmdt()          <span class="comment">// 分离共享内存段和进程的地址空间</span></span><br><span class="line">shmctl()         <span class="comment">// 对共享内存段执行控制操作</span></span><br></pre></td></tr></table></figure><p><strong>示例演示</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">key_t</span> key = ftok(<span class="string">&quot;somefile&quot;</span>, <span class="number">65</span>); <span class="comment">// 创建IPC键</span></span><br><span class="line">    <span class="type">int</span> shm_id;</span><br><span class="line">    <span class="type">void</span> *ptr;</span><br><span class="line">    <span class="comment">// 创建共享内存段</span></span><br><span class="line">    shm_id = shmget(key, <span class="number">1024</span>, <span class="number">0666</span>|IPC_CREAT);</span><br><span class="line">    <span class="keyword">if</span> (shm_id &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;shmget&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将共享内存段附加到进程的地址空间</span></span><br><span class="line">    ptr = shmat(shm_id, (<span class="type">void</span>*)<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ptr == (<span class="type">void</span>*) <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;shmat&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在共享内存上操作，例如写入数据</span></span><br><span class="line">    <span class="comment">// 示例：写入一个字符串</span></span><br><span class="line">    <span class="built_in">strcpy</span>(ptr, <span class="string">&quot;Hello, System V Shared Memory!&quot;</span>);</span><br><span class="line">    <span class="comment">// 分离共享内存段</span></span><br><span class="line">    <span class="keyword">if</span> (shmdt(ptr) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;shmdt&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除共享内存段</span></span><br><span class="line">    shmctl(shm_id, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>6.消息队列 (Message Queues)</strong></p><p><strong>概念</strong>：</p><p>消息队列是一种允许一个或多个进程向其写入消息，并由一个或多个进程读取消息的 IPC 机制。每条消息都由一个消息队列标识符（ID）识别， 且可以携带一个特定的类型。消息队列允许不同进程非阻塞地发送和接收记录或数据块，这些记录可以是不同类型和大小的。</p><p><strong>消息队列图解：</strong></p><p><img src="/images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/13.jpg"></p><p><strong>使用场景</strong>：</p><ul><li><p><strong>进程间通信：</strong><br>在涉及多个运行进程的应用中，消息队列提供了一种高效的方式来传递信息。它允许进程之间无需直接相互连接就能交换数据，从而简化了通信过程。</p></li><li><p><strong>异步数据处理：</strong><br>消息队列使进程能够异步处理信息。一个进程（即生产者）可以发送任务或数据至队列，并继续其他操作，而另一进程（即消费者）可以在准备就绪时从队列中取出并处理这些数据。这种模式有效地分离了数据的生成和消费过程，提高了应用的效率和响应速度。实际的应用比如：日志记录，某些系统可能有一个专门的进程负责记录日志，其他进程可以将日志消息发送到消息队列，由该专门进程异步地写入日志文件。</p></li></ul><p><strong>以下是使用 System V IPC 消息队列的一个简单示例:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">message</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;</span><br><span class="line">    <span class="type">char</span> mtext[<span class="number">100</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送消息至消息队列</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">key_t</span> key = ftok(<span class="string">&quot;queuefile&quot;</span>, <span class="number">65</span>);  <span class="comment">// 生成唯一键</span></span><br><span class="line">    <span class="type">int</span> msgid = msgget(key, <span class="number">0666</span> | IPC_CREAT); <span class="comment">// 创建消息队列</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">message</span> <span class="title">msg</span>;</span></span><br><span class="line">    msg.mtype = <span class="number">1</span>; <span class="comment">// 设置消息类型</span></span><br><span class="line">    <span class="built_in">sprintf</span>(msg.mtext, <span class="string">&quot;Hello World&quot;</span>); <span class="comment">// 消息内容</span></span><br><span class="line">    msgsnd(msgid, &amp;msg, <span class="keyword">sizeof</span>(msg.mtext), <span class="number">0</span>); <span class="comment">// 发送消息</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sent message: %s\n&quot;</span>, msg.mtext);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从消息队列中获取消息</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">key_t</span> key = ftok(<span class="string">&quot;queuefile&quot;</span>, <span class="number">65</span>);</span><br><span class="line">    <span class="type">int</span> msgid = msgget(key, <span class="number">0666</span> | IPC_CREAT);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">message</span> <span class="title">msg</span>;</span></span><br><span class="line">    msgrcv(msgid, &amp;msg, <span class="keyword">sizeof</span>(msg.mtext), <span class="number">1</span>, <span class="number">0</span>); <span class="comment">// 接收消息</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Received message: %s\n&quot;</span>, msg.mtext);</span><br><span class="line">    msgctl(msgid, IPC_RMID, <span class="literal">NULL</span>); <span class="comment">// 销毁消息队列</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>7.套接字 (Sockets)</strong></p><p><strong>概念</strong>：</p><p>套接字是一种在不同进程间进行数据交换的通信机制。在 Linux 中，套接字可以用于同一台机器上的进程间通信（IPC）或不同机器上的网络通信。套接字支持多种通信协议，最常见的是TCP（可靠的、连接导向的协议）和UDP（无连接的、不可靠的协议）。</p><p><strong>简单图解：</strong></p><p><img src="/images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/14.jpg"></p><p><strong>使用场景：</strong></p><p><strong>网络通信</strong>：<br>同一台主机或不同主机上的进程之间通过网络套接字进行数据交换。</p><p><strong>简单示例：</strong> - 使用 TCP 套接字进行通信</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务器端（监听和接收数据）:</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> server_fd, new_socket;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    <span class="type">int</span> addrlen = <span class="keyword">sizeof</span>(address);</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    server_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);  <span class="comment">// 创建套接字</span></span><br><span class="line">    <span class="comment">// 定义套接字地址</span></span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    address.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    address.sin_port = htons(<span class="number">8080</span>);</span><br><span class="line">    <span class="comment">// 绑定套接字</span></span><br><span class="line">    bind(server_fd, (<span class="keyword">struct</span> sockaddr *)&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    listen(server_fd, <span class="number">3</span>);    <span class="comment">// 监听套接字</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 接受连接</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Waiting for a connection...\n&quot;</span>);</span><br><span class="line">        new_socket = accept(server_fd, (<span class="keyword">struct</span> sockaddr *)&amp;address, (<span class="type">socklen_t</span>*)&amp;addrlen);</span><br><span class="line">        <span class="comment">// 读取数据</span></span><br><span class="line">        read(new_socket, buffer, <span class="number">1024</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Message: %s\n&quot;</span>, buffer);</span><br><span class="line">        <span class="comment">// 可以在这里处理收到的消息或执行其他任务</span></span><br><span class="line">        close(new_socket);  <span class="comment">// 关闭这次连接的套接字</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭监听的套接字</span></span><br><span class="line">    <span class="comment">// 注意：由于 while(1)，这行代码不会执行，除非在循环中加入退出条件</span></span><br><span class="line">    close(server_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端进程（发送数据）:</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> sock = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">    sock = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>); <span class="comment">// 创建套接字</span></span><br><span class="line">    serv_addr.sin_family = AF_INET; <span class="comment">// 定义套接字地址</span></span><br><span class="line">    serv_addr.sin_port = htons(<span class="number">8080</span>);</span><br><span class="line">    connect(sock, (<span class="keyword">struct</span> sockaddr *)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));    <span class="comment">// 连接到服务器</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 发送数据</span></span><br><span class="line">    <span class="type">char</span> *message = <span class="string">&quot;Hello from the client!&quot;</span>;</span><br><span class="line">    send(sock, message, <span class="built_in">strlen</span>(message), <span class="number">0</span>);</span><br><span class="line">    close(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>8.域套接字 (Unix Domain Sockets)</strong></p><p><strong>概念</strong>：</p><p>域套接字（Unix Domain Sockets）是一种在同一台机器上的进程间进行数据通信的机制。相对于网络套接字，它们提供了更高效的本地通信方式，<strong>因为数据不需要经过网络协议栈</strong>。域套接字支持流（类似TCP）和数据报（类似UDP）两种模式。</p><p><strong>特别说明</strong>：在域套接字通信中，<strong>“不经过网络协议栈”</strong> 指的是数据传输不需要IP层的路由、不需要TCP&#x2F;UDP等传输层协议的封包与解包处理，也不需要网络接口层的参与。这一点与网络套接字不同，后者用于跨网络的通信，需要经过完整的网络协议栈处理，包括数据的封装、传输、路由和解封装等。</p><p><strong>简单图解：</strong></p><p><img src="/images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/15.jpg"></p><p><strong>使用场景：</strong></p><ul><li><p><strong>本地进程间通信</strong>：</p><p>当需要在同一台机器上的不同进程间高效地交换数据时。</p></li><li><p><strong>替代管道和消息队列</strong>：</p><p>当需要比管道和消息队列更复杂的双向通信时。</p></li></ul><p><strong>简单示例：</strong> - 使用 Unix 域套接字进行通信</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务器端（监听和接收数据）:</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> server_fd, client_socket;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">address</span>;</span></span><br><span class="line">    server_fd = socket(AF_UNIX, SOCK_STREAM, <span class="number">0</span>);  <span class="comment">// 创建套接字</span></span><br><span class="line">    address.sun_family = AF_UNIX;     <span class="comment">// 设置套接字地址</span></span><br><span class="line">    <span class="built_in">strcpy</span>(address.sun_path, <span class="string">&quot;/tmp/unix_socket&quot;</span>);</span><br><span class="line">    <span class="comment">// 绑定和监听</span></span><br><span class="line">    bind(server_fd, (<span class="keyword">struct</span> sockaddr *)&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    listen(server_fd, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// 接受连接</span></span><br><span class="line">        client_socket = accept(server_fd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理数据</span></span><br><span class="line">        <span class="type">char</span> buffer[<span class="number">100</span>];</span><br><span class="line">        read(client_socket, buffer, <span class="number">100</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Received: %s\n&quot;</span>, buffer);</span><br><span class="line">        <span class="comment">// 进行其他的业务处理</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        </span><br><span class="line">        close(client_socket);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清理</span></span><br><span class="line">    close(server_fd);</span><br><span class="line">    unlink(<span class="string">&quot;/tmp/unix_socket&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端（发送数据）:</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> sock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">address</span>;</span></span><br><span class="line">    sock = socket(AF_UNIX, SOCK_STREAM, <span class="number">0</span>); <span class="comment">// 创建套接字</span></span><br><span class="line">    address.sun_family = AF_UNIX;           <span class="comment">// 设置套接字地址</span></span><br><span class="line">    <span class="built_in">strcpy</span>(address.sun_path, <span class="string">&quot;/tmp/unix_socket&quot;</span>);</span><br><span class="line">    <span class="comment">// 连接到服务器</span></span><br><span class="line">    connect(sock, (<span class="keyword">struct</span> sockaddr *)&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    <span class="comment">// 发送数据</span></span><br><span class="line">    <span class="type">char</span> *message = <span class="string">&quot;Hello from the client!&quot;</span>;</span><br><span class="line">    write(sock, message, <span class="built_in">strlen</span>(message));</span><br><span class="line">    <span class="comment">// 清理</span></span><br><span class="line">    close(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong>：</p><ul><li>Unix 域套接字的地址是文件系统中的路径，而不是IP地址和端口。</li><li>Unix 域套接字通常用于同一台机器上的进程间通信，而不适用于网络通信。</li><li>使用 Unix 域套接字时，需要确保套接字文件的路径是可访问的，并在通信完成后清理套接字文件。</li></ul><h3 id="Linux-线程"><a href="#Linux-线程" class="headerlink" title="Linux 线程"></a>Linux 线程</h3><p><img src="/images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/16.jpg"></p><h4 id="什么是线程？"><a href="#什么是线程？" class="headerlink" title="什么是线程？"></a>什么是线程？</h4><p>线程，有时被称为“轻量级进程”，是程序执行流的最小单位。它允许多任务在单个进程内部并发执行。</p><h4 id="线程与进程的区别："><a href="#线程与进程的区别：" class="headerlink" title="线程与进程的区别："></a>线程与进程的区别：</h4><ul><li><strong>进程</strong>: 拥有独立的地址空间和资源。</li><li><strong>线程</strong>: 共享其所在进程的资源，但有自己的堆栈空间。</li></ul><h4 id="创建你的第一个线程"><a href="#创建你的第一个线程" class="headerlink" title="创建你的第一个线程"></a>创建你的第一个线程</h4><p>在 Linux 下，我们使用 POSIX Threads （简称 Pthreads）库来操作线程。以下是一个简单的例子，创建并运行两个线程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Thread 1 function</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">func1</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello from thread 1!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thread 2 function</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">func2</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello from thread 2!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> thread1, thread2;</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;thread1, <span class="literal">NULL</span>, func1, <span class="literal">NULL</span>);    <span class="comment">// Create thread 1</span></span><br><span class="line">    pthread_create(&amp;thread2, <span class="literal">NULL</span>, func2, <span class="literal">NULL</span>);    <span class="comment">// Create thread 2</span></span><br><span class="line"></span><br><span class="line">    pthread_join(thread1, <span class="literal">NULL</span>); <span class="comment">// Wait for thread 1 to finish</span></span><br><span class="line">    pthread_join(thread2, <span class="literal">NULL</span>); <span class="comment">// Wait for thread 2 to finish</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="线程同步：何时使用？"><a href="#线程同步：何时使用？" class="headerlink" title="线程同步：何时使用？"></a>线程同步：何时使用？</h4><p>当两个或多个线程想要访问同一个资源时，问题就来了！如何确保资源的安全访问？有以下三种线程同步的方式。</p><ul><li><strong>互斥锁</strong>: 一个线程在使用资源时，锁住它，其他线程等待。一般用在临界区的保护。</li><li><strong>条件变量</strong>: 线程等待直到某个条件满足。一般和互斥锁搭配使用来实现线程同步 。</li><li><strong>信号量</strong>: 一种高级的同步方式，可以控制资源的访问数量。</li></ul><p> <strong>信号量更为通用</strong>，因为它不仅可以用作互斥锁，还可以用来同步线程，例如 ：确保线程按特定的顺序执行或控制对有限资源的访问。</p><p><strong>确保线程按特定的顺序执行</strong>：</p><p>在某些场景下，您可能希望线程以特定的顺序执行。例如，线程 A 必须在线程 B 之前执行。这可以通过使用信号量来实现。</p><p><strong>控制对有限资源的访问</strong>：</p><p>信号量也可用于控制对有限资源的访问。例如，数据库连接池，其中只有一定数量的连接可供线程使用，可以使用信号量来确保只有固定数量的线程可以同时访问这些资源。</p><p><strong>确保线程按特定的顺序执行的示例代码</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">sem_t</span> semA;</span><br><span class="line"><span class="comment">// 线程A</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">threadA</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread A is running\n&quot;</span>);</span><br><span class="line">    sem_post(&amp;semA); <span class="comment">// 释放信号量A</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程B</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">threadB</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    sem_wait(&amp;semA); <span class="comment">// 等待信号量A</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread B is running\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> tA, tB;</span><br><span class="line">    <span class="comment">// 初始化信号量</span></span><br><span class="line">    sem_init(&amp;semA, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">    pthread_create(&amp;tA, <span class="literal">NULL</span>, threadA, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tB, <span class="literal">NULL</span>, threadB, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 等待线程结束</span></span><br><span class="line">    pthread_join(tA, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tB, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 清理资源</span></span><br><span class="line">    sem_destroy(&amp;semA);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线程的优点与缺点"><a href="#线程的优点与缺点" class="headerlink" title="线程的优点与缺点:"></a>线程的优点与缺点:</h4><p><strong>优点</strong>:</p><ul><li>线程之间的切换成本比进程之间的切换成本低。</li><li>线程间的通信速度比进程间的通信速度快，因为线程共享同一地址空间。</li><li>利用多线程可以很容易地在单进程应用中实现并发。</li></ul><p><strong>缺点</strong>:</p><ul><li>因为线程共享同一地址空间，一个线程的错误可能会破坏其他线程的数据或状态。</li><li>需要复杂的同步操作来避免竞争条件。</li></ul><h4 id="常见问题与挑战"><a href="#常见问题与挑战" class="headerlink" title="常见问题与挑战"></a>常见问题与挑战</h4><p><strong>死锁</strong>:</p><p>死锁发生在两个或多个线程永久地等待对方释放锁的情况。它通常发生在多个线程需要多个锁时，如果不按相同的顺序获取锁，就可能陷入互相等待的状态。</p><p><strong>解决方案</strong>：</p><ul><li>确保所有线程以相同的顺序获取锁。</li><li>使用层次结构的锁定系统，其中线程必须按特定顺序获取锁。</li><li>设置超时，以便在等待锁的时间过长时，线程可以放弃等待，尝试其他操作。</li></ul><p><strong>线程安全</strong>：</p><p>线程安全是指确保代码可以在多线程环境中安全运行，不会因为多个线程同时访问共享资源而导致数据损坏或不一致。</p><p><strong>解决方案：</strong></p><ul><li><strong>使用同步机制</strong>，如互斥锁或信号量，来控制对共享资源的访问。</li><li><strong>编写无状态的代码，或者确保状态信息不在多个线程间共享。</strong> 无状态的代码指的是不保存任何与特定实例相关的数据（状态）的代码。在多线程环境中，这意味着代码不依赖于或不修改任何外部状态，如全局变量或类的成员变量。</li><li><strong>使用不可变对象</strong>，这些对象一旦创建就不会更改，因此可以安全地在多个线程间共享。不可变对象是指一旦被创建就不能被修改的对象(如字符串)，这些对象的状态在创建后是固定的，因此在多线程环境中安全。</li></ul><blockquote><p><strong>总结</strong>：编写无状态的代码和使用不可变对象都是避免多线程环境中的数据冲突和竞争条件的策略。无状态代码避免了共享数据，而不可变对象则确保了即使数据被共享，它们也不会被修改，从而保证线程安全。</p></blockquote><h4 id="进一步探索"><a href="#进一步探索" class="headerlink" title="进一步探索"></a>进一步探索</h4><p><strong>线程池</strong>: </p><p>线程池通过重用一组预先创建的线程来处理任务，减少了线程创建和销毁的开销。</p><p><strong>应用</strong>：线程池广泛用于网络服务器应用，特别是在需要处理大量短暂任务的场景中。</p><p><strong>高级同步原语</strong>: </p><p><strong>读写锁（Read-Write Locks）</strong></p><p>读写锁是一种特殊类型的锁，它允许多个线程同时读取共享资源，但写入操作需要独占访问。这意味着只要没有线程正在写入共享资源，多个线程可以同时读取资源而不会被阻塞。</p><p><strong>应用场景</strong>：适用于读操作远多于写操作的情况，比如缓存系统。</p><p><strong>优点</strong>：提高了在读多写少场景下的并发性能。</p><p><strong>实现</strong>：在 POSIX 线程库中，通过 pthread_rwlock_t 类型提供。</p><p><strong>简单示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_rwlock_t</span> rwlock = PTHREAD_RWLOCK_INITIALIZER;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">reader</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    pthread_rwlock_rdlock(&amp;rwlock);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Reader is reading...\n&quot;</span>);</span><br><span class="line">    sleep(<span class="number">1</span>); <span class="comment">// 模拟读取操作</span></span><br><span class="line">    pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">writer</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    pthread_rwlock_wrlock(&amp;rwlock);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Writer is writing...\n&quot;</span>);</span><br><span class="line">    sleep(<span class="number">1</span>); <span class="comment">// 模拟写入操作</span></span><br><span class="line">    pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> t1, t2;</span><br><span class="line">    pthread_rwlock_init(&amp;rwlock, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;t1, <span class="literal">NULL</span>, reader, <span class="literal">NULL</span>);</span><br><span class="line">    sleep(<span class="number">2</span>); <span class="comment">// 确保读者先运行</span></span><br><span class="line">    pthread_create(&amp;t2, <span class="literal">NULL</span>, writer, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(t1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(t2, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_rwlock_destroy(&amp;rwlock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>屏障（Barriers）</strong></p><p>屏障用于同步多个线程在程序中的特定点。当线程到达一个屏障时，它会等待，直到所有其他线程也都到达这个屏障。然后所有线程才能继续执行。</p><p><strong>应用场景</strong>：用于并行算法，确保所有线程完成某个阶段的工作后才开始下一个阶段。</p><p><strong>优点</strong>：确保所有线程同步进行，避免数据不一致。</p><p><strong>实现</strong>：在 POSIX 线程库中，通过 pthread_barrier_t 类型提供。</p><p><strong>简单示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NUM_THREADS 5</span></span><br><span class="line"><span class="type">pthread_barrier_t</span> barrier;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">task</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread %ld waiting at barrier\n&quot;</span>, (<span class="type">long</span>)arg);</span><br><span class="line">    pthread_barrier_wait(&amp;barrier);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread %ld passed barrier\n&quot;</span>, (<span class="type">long</span>)arg);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> threads[NUM_THREADS];</span><br><span class="line">    pthread_barrier_init(&amp;barrier, <span class="literal">NULL</span>, NUM_THREADS);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> i = <span class="number">0</span>; i &lt; NUM_THREADS; i++) &#123;</span><br><span class="line">        pthread_create(&amp;threads[i], <span class="literal">NULL</span>, task, (<span class="type">void</span>*)i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_THREADS; i++) &#123;</span><br><span class="line">        pthread_join(threads[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_barrier_destroy(&amp;barrier);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明</strong>：这个程序演示了如何使用屏障来同步多个线程，确保所有线程都到达一个执行点后才一起继续执行。在这个例子中，所有线程都会在打印“等待”信息后等待，直到它们全部到达 pthread_barrier_wait 调用处。只有当所有线程都到达这个点时，它们才会继续执行并打印“通过”信息。</p><p><strong>原子操作（Atomic Operations）</strong></p><p>原子操作是指在多线程环境中，一系列操作作为一个单独的不可中断的单位执行，确保在读取、修改和更新变量时的原子性。这些操作在执行的全过程中不会被线程调度机制中断。</p><p><strong>应用场景</strong>：</p><p>非常适合于计数器、标志位更新等简单状态的更新场景，其中对单一变量的读取、修改和更新必须作为一个整体来执行，以避免数据竞争和保证数据一致性。</p><p><strong>优点</strong>：</p><ul><li><strong>效率</strong>：相比锁机制，原子操作通常更高效，因为它们避免了锁的开销和潜在的上下文切换。</li><li><strong>简化编程模型</strong>：对于简单的同步需求，原子操作提供了一种简单直接的解决方案，避免了使用锁的复杂性。</li></ul><p><strong>实现</strong>：在 POSIX 线程库中，原子操作并非直接提供，但可以通过 GCC 提供的内建原子操作函数，如__sync_fetch_and_add、__sync_lock_test_and_set等。C++11及更高版本的标准也提供了原子操作的支持，如 std::atomic 类型。</p><p><strong>简单示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个全局计数器</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 线程函数，用于增加计数器</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">increment_counter</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i) &#123;</span><br><span class="line">        <span class="comment">// 使用GCC的内建原子操作函数进行原子增加</span></span><br><span class="line">        __sync_fetch_and_add(&amp;counter, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> t1, t2;</span><br><span class="line">    <span class="comment">// 创建两个线程，都执行increment_counter函数</span></span><br><span class="line">    pthread_create(&amp;t1, <span class="literal">NULL</span>, increment_counter, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;t2, <span class="literal">NULL</span>, increment_counter, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 等待线程完成</span></span><br><span class="line">    pthread_join(t1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(t2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 打印最终的计数器值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Final counter value: %d\n&quot;</span>, counter);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>自旋锁（Spinlocks）</strong></p><p>自旋锁是一种忙等待的锁，当一个线程尝试获取一个已经被其他线程持有的锁时，它会在一个循环中不断检查锁的状态。这意味着线程会一直占用 CPU，直到它能够获取到锁。</p><p><strong>应用场景</strong>：</p><p>特别适合锁持有时间非常短的场景，因为它避免了线程从运行态转为等待态的开销，这在多核处理器上尤其有用。</p><p><strong>实现</strong>：在 POSIX 线程库中，自旋锁通过 pthread_spinlock_t 类型提供，相关的操作包括 pthread_spin_lock、pthread_spin_unlock等。自旋锁的使用和管理相对简单，但需要谨慎使用以避免过度占用 CPU 资源。</p><p><strong>简单示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_spinlock_t</span> spinlock;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">task</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    pthread_spin_lock(&amp;spinlock);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread %ld got the lock\n&quot;</span>, (<span class="type">long</span>)arg);</span><br><span class="line">    sleep(<span class="number">1</span>); <span class="comment">// 模拟任务执行</span></span><br><span class="line">    pthread_spin_unlock(&amp;spinlock);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> t1, t2;</span><br><span class="line">    pthread_spin_init(&amp;spinlock, PTHREAD_PROCESS_PRIVATE);</span><br><span class="line">    pthread_create(&amp;t1, <span class="literal">NULL</span>, task, (<span class="type">void</span>*)<span class="number">1L</span>);</span><br><span class="line">    pthread_create(&amp;t2, <span class="literal">NULL</span>, task, (<span class="type">void</span>*)<span class="number">2L</span>);</span><br><span class="line">    pthread_join(t1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(t2, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_spin_destroy(&amp;spinlock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内存管理入门"><a href="#内存管理入门" class="headerlink" title="内存管理入门"></a>内存管理入门</h3><p>在前面的讲解中，我们已经学习了进程和线程的基本概念，了解了它们是操作系统进行资源分配和任务调度的基本单位。而无论是进程还是线程，它们的运行都离不开一个关键的系统资源——内存。这自然引出了一个重要的问题：操作系统是如何管理这些内存资源的？这正是我们接下来要讨论的主题— <strong>Linux内存管理</strong>。</p><h4 id="内存分配与释放"><a href="#内存分配与释放" class="headerlink" title="内存分配与释放"></a>内存分配与释放</h4><p>首先，我们先来看下内存的分配与释放，常见的内存分配方式包含以下两种：</p><p><strong>静态内存分配</strong> ： 是在编译时完成的，通常用于固定大小的数据结构，比如：普通数组。</p><p><strong>动态内存分配</strong> ： 则在运行时进行，允许程序根据需要分配任意大小的内存块，比如：动态数组。</p><p>我们一般使用 <strong>malloc和free</strong> 来进行动态内存分配与释放。</p><p>来看个动态内存分配的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int *array = malloc(10 * sizeof(int)); # 分配内存</span><br><span class="line">    if (array == NULL) &#123;</span><br><span class="line">        perror(&quot;malloc failed&quot;);</span><br><span class="line">        return EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">    #使用动态内存 array ...</span><br><span class="line"></span><br><span class="line">    free(array); # 释放内存</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h4><p>应用程序如果没有正确的管理内存的分配与回收，就有可能出现内存泄漏，严重点的有可能导致程序异常退出。</p><p><strong>那什么是内存泄露？</strong></p><p>内存泄露是指程序中动态分配的内存没有及时释放，导致这部分内存在程序执行过程中一直占用，无法被再次利用。在长时间运行的程序中，内存泄露可能会导致内存使用不断增加，最终耗尽所有可用内存，影响程序性能甚至引发程序崩溃。</p><p><strong>如何避免内存泄露？</strong></p><ul><li><p><strong>合理设计程序结构</strong>：确保每次 malloc 后都有对应的 free 操作。可以通过使用自动化工具，如 Valgrind 等，来检测程序运行中的内存泄露问题。</p></li><li><p><strong>使用智能指针</strong>：在支持 C++ 等高级语言中，使用智能指针（如 std::unique_ptr, std::shared_ptr 等）可以帮助管理动态内存的生命周期，智能指针会在适当的时候自动释放内存。</p></li><li><p><strong>及时释放内存</strong>：在不需要动态分配的内存后，应立即释放。尤其是在异常处理、错误处理的代码路径中，也不要忘记释放内存。</p></li><li><p><strong>规范化资源管理</strong>：使用 RAII（Resource Acquisition Is Initialization）原则管理资源，<strong>确保资源的获取即是初始化，随着对象的销毁资源被释放</strong>。</p></li></ul><h4 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a>虚拟内存管理</h4><p><strong>虚拟内存概念：</strong></p><p>虚拟内存是计算机系统内存管理的一种技术。它使得应用程序认为它拥有很大连续的、可用的内存空间，即使这些内存可能被分散存储在物理内存和磁盘上。</p><p><strong>虚拟内存的主要好处是</strong>：</p><ul><li>它提供了比实际物理内存更大的地址空间。</li><li>保证每个程序在内存中有一个连续的地址空间。</li><li>允许系统运行大于物理内存的程序。</li><li>通过内存隔离，提高了程序间的安全性。</li></ul><p>操作系统通过使用硬盘上的一块称为“交换空间”的区域来实现这一点，它作为物理内存的一个扩展。当系统的物理 RAM 不足时，它可以将当前不活跃的内存页面移动到磁盘上，从而为需要更多内存的进程腾出空间。</p><p><strong>分页机制</strong></p><p>分页是虚拟内存管理中最常用的技术之一。它将虚拟内存和物理内存分成大小相等的块，这些块在虚拟内存中被称为“页”(pages)，在物理内存中被称为“页框”(page frames)。每个程序都有一个页表，页表将程序的虚拟地址映射到物理内存的页框。</p><p><strong>分页机制如何工作：</strong></p><p>1.当程序试图访问虚拟内存中的地址时，它首先会检查页表。</p><p>2.如果找到了对应的物理地址，那么数据的存取操作就会继续。</p><p>3.如果没有找到，会触发一个缺页中断，由操作系统处理。</p><p><strong>缺页中断</strong></p><p>缺页中断（Page Fault）是分页系统中的一项关键机制，当一个进程访问的虚拟页不在物理内存中时触发。这时候，操作系统会分配一个物理页框，并将该虚拟页所对应的磁盘数据加载至页框中，并在页表中建立虚拟页和物理页的映射关系。这样，当下一次进程在访问相同虚拟页的时候，就可以直接访问内存中的数据了。</p><p>通过以上机制，虚拟内存管理提供了高效灵活的内存使用方式，允许操作系统优化内存分配，同时也给应用程序提供了简单的内存管理模型。</p><h3 id="文件系统：探索-Linux-中的数据管理"><a href="#文件系统：探索-Linux-中的数据管理" class="headerlink" title="文件系统：探索 Linux 中的数据管理"></a>文件系统：探索 Linux 中的数据管理</h3><p>前面我们探讨了 Linux 系统中的内存管理，包括内存分配与释放、内存泄漏和虚拟内存等概念，这些都是操作系统保证程序正常运行的基础。内存管理使得多个应用能够高效、安全地共享系统的物理内存资源，同时还提供了数据的临时存储能力。然而，内存只能提供临时存储，当系统断电或重启时，内存中的数据就会丢失。这就引出了我们下一个重要话题：<strong>文件系统</strong>。</p><p>在谈文件系统之前，我们先来了解下虚拟文件系统。</p><h4 id="虚拟文件系统（VFS）"><a href="#虚拟文件系统（VFS）" class="headerlink" title="虚拟文件系统（VFS）"></a>虚拟文件系统（VFS）</h4><p><strong>什么是VFS？</strong></p><p>Linux内核中的虚拟文件系统（VFS）是一个关键的抽象层，它为各种不同的文件系统提供了一个统一的操作接口。这意味着，不管数据实际上存储在哪个文件系统中（比如EXT4、XFS等），VFS都能提供一致的访问方式。</p><p><strong>VFS的作用</strong></p><p><strong>兼容性</strong>：使得不同的文件系统都能在 Linux 上工作。</p><p><strong>统一性</strong>：它为应用程序提供了一个标准的文件操作接口，简化了文件访问和管理。</p><p>接下来让我们来看下文件系统。</p><p><strong>Linux 的文件系统是什么？</strong></p><p>Linux 文件系统是 Linux 操作系统用于存储、管理和访问文件和目录的一套规则和结构。它提供了一个层次化的目录结构，让用户和程序能够以一致的方式组织和访问数据。Linux 文件系统支持多种类型，如 EXT4、XFS 和 Btrfs，每种都有其特定的优势和用途。文件系统管理文件的存储细节，包括文件的创建、读取、写入和删除操作，同时也处理文件的权限和安全性。通过虚拟文件系统（VFS）层，Linux 能够提供一个统一的接口来访问这些不同的文件系统，使得文件操作对用户和应用程序透明。</p><p><strong>文件系统核心组件:</strong></p><p><strong>超级块（Superblock）</strong></p><p>超级块是文件系统的元数据的一部分，它包含了关于整个文件系统的全局信息，如文件系统的类型、大小、状态、空闲和已用的块和Inode数量等。超级块的主要作用是提供文件系统的关键信息，以便操作系统能够正确地管理和访问文件系统。</p><p><strong>Inode</strong></p><p>Inode 是文件系统中的一个关键数据结构，每个文件和目录都有一个唯一的Inode。它包含了文件的元数据（如文件大小、所有者、权限、时间戳）和指向实际存储文件数据的数据块的指针。Inode 不存储文件名，文件名存储在目录文件中，这些目录文件将文件名映射到 Inode 号。<strong>inode</strong> 号是文件的唯一标识，而不是文件名。</p><p><strong>目录项（Dentry）</strong></p><p>目录项（或Dentry缓存）是内核用来维护文件名与其对应Inode之间映射的结构。目录项缓存是一个重要的性能优化机制，它减少了从文件名到文件内容的查找时间。</p><p><strong>文件数据块</strong></p><p>文件数据块是存储文件实际内容的磁盘空间。Linux文件系统将磁盘空间分割成一系列的块，这些块可以直接被Inode指向，或者通过间接块来存储较大文件的数据。</p><p><strong>文件和目录</strong></p><p>文件和目录是用户与文件系统交互的基本单元。在 Linux 中，一切皆文件：传统的数据文件、目录、设备（如字符设备和块设备）等都通过文件或文件系统的接口来访问。</p><p><strong>下面是文件、目录、inode 、以及数据块之间的映射关系图</strong>：</p><p><img src="/images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/17.jpg"></p><p>我以程序访问磁盘文件为例，来给大家说明下具体的访问过程，方便大家理解上述图示。</p><p><strong>操作系统会执行以下几个步骤</strong>：</p><ul><li><p><strong>解析文件路径</strong>：操作系统首先解析完整的文件路径，确定文件在文件系统中的位置。</p></li><li><p><strong>查找目录项</strong>：利用文件路径，操作系统在文件系统的目录结构中查找对应的目录项（Dentry）。目录项将文件名映射到一个唯一的Inode编号。</p></li><li><p><strong>访问Inode</strong>：每个文件都有一个Inode，其中包含该文件的元数据（如所有者、权限）和指向文件实际数据块的指针。操作系统使用目录项提供的 Inode 编号来访问 Inode Table，进而访问对应的 inode。</p></li><li><p><strong>读取数据块</strong>：通过 Inode 中的信息，操作系统找到存储文件数据的磁盘块位置，然后读取这些数据块以获取文件内容。</p></li></ul><p>除此之外，在 Linux 中，还存在两种特殊的引用文件的方式：<strong>硬链接和软链接</strong></p><h4 id="硬链接和软链接"><a href="#硬链接和软链接" class="headerlink" title="硬链接和软链接"></a>硬链接和软链接</h4><p><strong>什么是硬链接？</strong></p><p>硬链接实际上是目标文件的另一个名称。它与原文件共享相同的 <strong>inode</strong> 号，因此，无论通过哪个名称访问，内容都是一致的。</p><p><strong>图示</strong>：</p><p><img src="/images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/18.jpg"></p><p>这里，“file1”和“link1”都是硬链接，它们指向同一个inode。这意味着它们共享相同的数据块和文件属性。</p><p><strong>如何创建硬链接？</strong></p><p><strong>命令</strong>：<code> ln 源文件 目标文件</code></p><p>例如，创建一个名为 file1 的文件的硬链接 link1，你可以使用：ln file1 link1。</p><p><strong>特点</strong>：</p><ul><li>硬链接不能跨文件系统。</li><li>不能为目录创建硬链接。</li><li>删除原始文件或硬链接中的任何一个不会影响其他文件，因为它们共享相同的数据块。</li></ul><p><strong>什么是软链接？</strong></p><p>与硬链接不同，软链接是一个独立的文件，它并不包含实际的文件内容，而是指向另一个文件或目录的路径。</p><p><strong>图示</strong>：</p><p><img src="/images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/19.jpg"></p><p>在这里，“link1”是一个指向“file1”的软链接。与硬链接不同，软链接只是一个指向另一个文件或目录的路径。当我们访问软链接时，系统会自动重定向我们到它所指向的实际文件。</p><p><strong>如何创建软链接？</strong></p><p><strong>命令</strong>：<code> ln -s 源文件 目标文件</code></p><p>例如，为 file1 创建一个软链接 link1，你可以使用：ln -s file1 link1。</p><p><strong>特点</strong>：</p><ul><li>软链接可以跨文件系统。</li><li>可以为目录创建软链接。</li><li>如果删除了目标文件，软链接会变为死链接，无法再访问原始内容。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章主要是为想学习 Linux 系统编程的初学者提供一个学习指南，从基本概念到高级功能，我们不仅揭示了 Linux 系统的核心技术和架构，还探讨了用户空间与内核空间的关键区别，系统调用与库函数的基本理解，以及文件IO的多样化操作。我们学习了进程和线程的基础，理解了它们之间的差异，以及如何有效地使用线程同步技术来编写稳定的多线程程序。此外，我们还涵盖了内存管理的基础知识，从内存分配与释放到虚拟内存管理，最后学习了 Linux 文件系统的基本概念及其核心组件，以及硬链接和软链接的使用和区别。</p><p>无论你是刚开始接触 Linux 系统编程的新手，还是希望巩固现有知识的经验开发者，本文都提供了宝贵指南。</p><p>通过本文的学习，我希望读者能够：</p><ul><li>掌握 Linux 系统架构的关键组成部分，包括用户空间和内核空间的区别。</li><li>理解系统调用和库函数的作用，以及它们在系统编程中的重要性。</li><li>熟练进行文件IO操作，包括文件描述符的使用，文件位置的移动，以及高级文件I&#x2F;O技术的应用。</li><li>了解进程和线程的基本概念，包括它们的创建、终止和状态转换，以及进程间通信的方法。</li><li>掌握线程同步的技巧，了解线程的优缺点以及在实际编程中的应用。</li><li>建立内存管理的基本知识框架，包括内存分配释放、虚拟内存管理以及如何避免内存泄露。</li><li>探索 Linux 文件系统，理解虚拟文件系统（VFS）的概念，以及硬链接和软链接的使用和区别。</li></ul><h2 id="最后："><a href="#最后：" class="headerlink" title="最后："></a>最后：</h2><p>如果你对 Linux 系统编程以及计算机编程领域相关知识感兴趣，不妨关注我的公众号—<strong>「跟着小康学编程」</strong>。这里会定时更新相关的技术文章，感兴趣的读者可以关注一下：</p><p><img src="/images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/21.jpg"></p><p>另外，小康最近新创建了一个技术交流群，大家如果在阅读的过程中有遇到问题或者有不理解的地方，欢迎大家加群询问或者评论区询问，我能解决的都尽可能给大家回复。</p><p>扫一扫小康的个人微信，备注「<strong>加群</strong>」即可。</p><p><img src="/images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/22.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> Linux系统编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux系统编程 </tag>
            
            <tag> Linux I/O </tag>
            
            <tag> Linux 进程和线程 </tag>
            
            <tag> Linux 内存管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何快速注册 OpenAI 账号</title>
      <link href="/register/"/>
      <url>/register/</url>
      
        <content type="html"><![CDATA[<h1 id="一分钟教你快速注册-OpenAI-账号"><a href="#一分钟教你快速注册-OpenAI-账号" class="headerlink" title="一分钟教你快速注册 OpenAI 账号"></a>一分钟教你快速注册 OpenAI 账号</h1><h4 id="首先，你必须得能科学上网（能够正常访问谷歌），即可注册。"><a href="#首先，你必须得能科学上网（能够正常访问谷歌），即可注册。" class="headerlink" title="首先，你必须得能科学上网（能够正常访问谷歌），即可注册。"></a>首先，你必须得能科学上网（能够正常访问谷歌），即可注册。</h4><p>（如果还不会科学上网，可以用这个： <a href="https://www.52xcjs.xyz/auth/register">科学稳定访问 openai</a>)</p><h2 id="快速注册步骤："><a href="#快速注册步骤：" class="headerlink" title="快速注册步骤："></a>快速注册步骤：</h2><p>国内的邮箱都不再允许注册 ChatGPT，建议申请一个免费的海外邮箱 Proton 来注册，其他海外邮箱，如 Gmail 也可以，但是注册难度高一些，步骤繁琐。</p><h3 id="第一步：注册-proton-邮箱"><a href="#第一步：注册-proton-邮箱" class="headerlink" title="第一步：注册 proton 邮箱"></a>第一步：注册 proton 邮箱</h3><h4 id="1-1-访问-proton"><a href="#1-1-访问-proton" class="headerlink" title="1.1 访问 proton"></a>1.1 访问 proton</h4><p><a href="https://proton.me/">https://proton.me/</a></p><p>选择右上角的 「Create a free account」</p><p><img src="/images/%E6%B3%A8%E5%86%8COpenAI%E8%B4%A6%E5%8F%B7/001.png"></p><h4 id="1-2-选择免费套餐"><a href="#1-2-选择免费套餐" class="headerlink" title="1.2 选择免费套餐"></a>1.2 选择免费套餐</h4><p><img src="/images/%E6%B3%A8%E5%86%8COpenAI%E8%B4%A6%E5%8F%B7/002.png"></p><h4 id="1-3-选择邮箱后缀，设置用户名和密码"><a href="#1-3-选择邮箱后缀，设置用户名和密码" class="headerlink" title="1.3 选择邮箱后缀，设置用户名和密码"></a>1.3 选择邮箱后缀，设置用户名和密码</h4><p>推荐选择 proton.me</p><p><img src="/images/%E6%B3%A8%E5%86%8COpenAI%E8%B4%A6%E5%8F%B7/003.png"></p><h4 id="1-4-通过真人验证"><a href="#1-4-通过真人验证" class="headerlink" title="1.4 通过真人验证"></a>1.4 通过真人验证</h4><p>依次拖动验证码，然后下一步即可</p><p><img src="/images/%E6%B3%A8%E5%86%8COpenAI%E8%B4%A6%E5%8F%B7/004.png"></p><p><img src="/images/%E6%B3%A8%E5%86%8COpenAI%E8%B4%A6%E5%8F%B7/005.png"></p><p><strong>注册完后，可以去登陆邮箱</strong>，方便接收验证码：</p><p><a href="https://proton.me/">https://proton.me/</a></p><h3 id="第二步：注册-OpenAI-账号"><a href="#第二步：注册-OpenAI-账号" class="headerlink" title="第二步：注册 OpenAI 账号"></a>第二步：注册 OpenAI 账号</h3><h4 id="2-1-首先打开-OpenAI-的账户注册页面，然后输入-proton-邮箱。"><a href="#2-1-首先打开-OpenAI-的账户注册页面，然后输入-proton-邮箱。" class="headerlink" title="2.1 首先打开 OpenAI 的账户注册页面，然后输入 proton 邮箱。"></a>2.1 首先打开 OpenAI 的账户注册页面，然后输入 proton 邮箱。</h4><p><a href="https://chat.openai.com/">https://chat.openai.com/</a></p><p><img src="/images/%E6%B3%A8%E5%86%8COpenAI%E8%B4%A6%E5%8F%B7/006.png"></p><p><img src="/images/%E6%B3%A8%E5%86%8COpenAI%E8%B4%A6%E5%8F%B7/007.png"></p><h4 id="2-2-接着设置-OpenAi-密码-如下就是你的-openai-账号和密码"><a href="#2-2-接着设置-OpenAi-密码-如下就是你的-openai-账号和密码" class="headerlink" title="2.2 接着设置 OpenAi 密码(如下就是你的 openai 账号和密码)"></a>2.2 接着设置 OpenAi 密码(如下就是你的 openai 账号和密码)</h4><p><img src="/images/%E6%B3%A8%E5%86%8COpenAI%E8%B4%A6%E5%8F%B7/008.png"></p><p>  <br><br><br>点击继续，接着点击 Resend email <br><br> </p><p><img src="/images/%E6%B3%A8%E5%86%8COpenAI%E8%B4%A6%E5%8F%B7/009.png"></p><p>  <br><br><br>接着验证邮箱，去 Proton.me 收件箱里点击「Verify email address」即可。<br><br> </p><p><img src="/images/%E6%B3%A8%E5%86%8COpenAI%E8%B4%A6%E5%8F%B7/010.png"><br><br><br><br>然后提供你的名和姓及生日，并点击 <strong>Agee</strong> 即可。</p>]]></content>
      
      
      <categories>
          
          <category> ChatGPT </category>
          
          <category> OpenAI 账号注册 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenAI 账号注册 </tag>
            
            <tag> ChatGPT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跟着小康学编程</title>
      <link href="/xiaokangvx/"/>
      <url>/xiaokangvx/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康！</p><p>🌟 如果你对计算机编程感兴趣，想要从基础到进阶系统地学习编程语言和技术，那么你来对地方了！<strong>「跟着小康学编程」</strong>是你的最佳起点！</p><p>👨‍💻 这里是你的一站式编程学习平台，内容涵盖：</p><ul><li><strong>C&#x2F;C++、Java、Go 语言</strong>：无论你是初学者还是希望深化技能的开发者，这里都有适合你的资源。</li><li><strong>计算机基础</strong>：全面理解计算机基本原理，包括操作系统、算法、数据结构、网络和数据库。</li><li><strong>Linux系统和网络编程</strong>：掌握操作系统的核心技术和网络编程的高级技巧。</li><li><strong>MySQL数据库技术</strong>：学习如何利用MySQL进行高效的数据存储和复杂的数据管理。</li><li><strong>Redis高速缓存</strong>：掌握Redis在高速数据处理和缓存方面的应用，让你的应用运行得更快。</li><li><strong>RabbitMQ消息队列</strong>：了解RabbitMQ的高效消息传递机制，确保应用组件间的数据一致性和可靠性。</li><li><strong>微服务架构</strong>：探索将复杂应用分解为更小、更易管理的微服务的策略，使整个应用更容易管理和扩展。</li><li><strong>容器技术</strong>：深入Docker和Kubernetes，掌握现代容器化和自动化部署的关键技术</li><li><strong>未完待续</strong>。。。</li></ul><p>目前，公众号只提供了上述提到的部分技术文章。其他技术相关文章后续会依次补上。<strong>目标就是：为广大编程爱好者提供更加全面的编程指南。</strong></p><p>另外，后续也会增加计算机编程各个领域的面试题，包括：C&#x2F;C++、Java、Go、以及操作系统、计算机网络以及数据结构等面试题。为大家面试提供帮助。</p><p><strong>总之：本号的定位就是 C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习 + 计算机基础原理 + Linux编程 + 容器技术等。</strong> 文章尽可能的通俗易懂，而且文章都会有代码示例，方便初学者理解，有兴趣的朋友可以关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p><br><br> </p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/gzh.png"></p><p><br><br> </p><p><strong>注</strong>：上面提到的计算机学习资料包括<strong>C&#x2F;C++、Java、Go语言，计算机组成原理、操作系统、数据结构与算法、计算机网络以及 Linux 系统编程和网络编程、Linux 内核、数据库</strong>等书籍的电子档 pdf。</p><p><br><br> </p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p><br><br> </p><p>另外，小康最近创建了一个技术交流群，专门用来探讨技术相关或者解答读者的问题。大家在阅读技术文章的时候，如果觉得有问题的或者有不理解的知识点，欢迎大家加群询问。我能够解决的，尽量给大家回复。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 小康的联系方式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 我的公众号 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何快速升级到 GPT-4</title>
      <link href="/upgrade-gpt4/"/>
      <url>/upgrade-gpt4/</url>
      
        <content type="html"><![CDATA[<h1 id="【保姆级】如何升级-GPT-4？快速升级至ChatGPT-Plus指南-，ChatGPT4-0-注册及升级攻略指南"><a href="#【保姆级】如何升级-GPT-4？快速升级至ChatGPT-Plus指南-，ChatGPT4-0-注册及升级攻略指南" class="headerlink" title="【保姆级】如何升级 GPT-4？快速升级至ChatGPT Plus指南 ，ChatGPT4.0 注册及升级攻略指南"></a>【保姆级】如何升级 GPT-4？快速升级至ChatGPT Plus指南 ，ChatGPT4.0 注册及升级攻略指南</h1><p>首先，你必须得能科学上网（能够正常访问谷歌），如果你还不会，请了解这个：<a href="https://www.52xcjs.xyz/auth/register">科学稳定访问 openai</a></p><h2 id="升级-ChatGPT-Plus-的步骤："><a href="#升级-ChatGPT-Plus-的步骤：" class="headerlink" title="升级 ChatGPT Plus 的步骤："></a>升级 ChatGPT Plus 的步骤：</h2><p>（PS：如果不会操作，也可以提供代充、GPT 账号注册等服务，有需要加微信：<strong>jkfwdkf</strong>，备注：<strong>chatgpt</strong></p><h3 id="方法一：自己充值升级"><a href="#方法一：自己充值升级" class="headerlink" title="方法一：自己充值升级"></a>方法一：自己充值升级</h3><h4 id="步骤指南：轻松升级至-ChatGPT-Plus"><a href="#步骤指南：轻松升级至-ChatGPT-Plus" class="headerlink" title="步骤指南：轻松升级至 ChatGPT Plus"></a>步骤指南：轻松升级至 ChatGPT Plus</h4><p>之前了解到一种升级方式，非常方便和迅速，大概 2 分钟之内就可以搞定，它主要是通过虚拟信用卡 WildCard 来进行升级的！</p><p><strong>通过专属链接</strong> <a href="https://bewildcard.com/i/666GPT">WildCard | 一分钟开卡，轻松订阅海外软件服务 即可快速升级 ChatGPT Plus</a><br>（<strong>PS：大家可以使用我的邀请链接：<a href="https://bewildcard.com/i/666GPT">https://bewildcard.com/i/666GPT</a>  ， 邀请码：666GPT</strong>，开卡的时候需要填写邀请码）</p><p><strong>具体操作过程：</strong><br><strong>第一步：点击上述链接，先开卡</strong></p><p>1.立即注册</p><p><img src="/images/%E5%BF%AB%E9%80%9F%E5%8D%87%E7%BA%A7GPT4/001.png"><br><br><br> </p><p>2.填写手机号（你自己的手机号就行）</p><p><img src="/images/%E5%BF%AB%E9%80%9F%E5%8D%87%E7%BA%A7GPT4/002.png"><br><br><br> </p><p>3.下一步之后，填写你自己的个人身份信息【邮箱地址：你就填你容易记得的就行，比如：你叫张三，你就填zhangsan 即可】，然后点击下一步。</p><p><img src="/images/%E5%BF%AB%E9%80%9F%E5%8D%87%E7%BA%A7GPT4/003.png"></p><p>4.接着进行支付宝验证以及支付卡费即可。</p><p><strong>说明：</strong> 开卡的时候是需要支付卡费的，有 1 年和 2 年有效期的选择的。1年是 11.99 美元，2年是 13.99美元，折合人民币不到 100 左右，也没有其他的月租等费用。开1年和2年均可以。 </p><p><strong>第二步：注册 OpenAI 账户</strong>，得到 OpenAI 账号和密码。（这个需要1美元购买账号，比较方便）.</p><p><img src="/images/%E5%BF%AB%E9%80%9F%E5%8D%87%E7%BA%A7GPT4/004.png"><br><br><br> </p><p>然后购买一个账号（不到1美元），支持支付宝付款</p><p><img src="/images/%E5%BF%AB%E9%80%9F%E5%8D%87%E7%BA%A7GPT4/005.png"><br><br><br><br><strong>第三步：充值 GPT Plus 月费用 20 美元，大概 140 多人民币。</strong></p><p><strong>第四步：</strong> 最后点击 <strong>一键升级 GPT Plus</strong>，接着根据它的教程来完成最后一步升级操作。<br><br><br><br><img src="/images/%E5%BF%AB%E9%80%9F%E5%8D%87%E7%BA%A7GPT4/006.png"><br><br><br> </p><p><strong>第五步： 登录 ChatGPT 网站</strong>，<a href="https://chat.openai.com/">ChatGPT 网站链接</a>，登录的账号(电子邮件)和密码就是上面第二步注册的 OpenAI 账号和密码。</p><ul><li>登录成功之后，就直接点击下方红色箭头的 Upgrade Plan</li></ul><p><img src="/images/%E5%BF%AB%E9%80%9F%E5%8D%87%E7%BA%A7GPT4/007.png"><br><br><br>  </p><ul><li>接着点击 Upgrade to Plus</li></ul><p><img src="/images/%E5%BF%AB%E9%80%9F%E5%8D%87%E7%BA%A7GPT4/008.png"></p><p><br><br> </p><ul><li>然后全选复制下图的支付链接，粘贴至相应位置，点击确定支付并升级</li></ul><p><img src="/images/%E5%BF%AB%E9%80%9F%E5%8D%87%E7%BA%A7GPT4/009.png"></p><p><strong>完成上述步骤之后，你就可以愉快的体验 ChatGPT-PLUS 呢！</strong></p><p><strong>其他问题：</strong></p><p><strong>1.是否安全？</strong></p><p>这家国内的公司是<strong>专门解决支付问题</strong>的，会使用支付宝进行实名认证，大家不用担心安全问题。<br><strong>而且，它是支持随时提现的，大家不用担心充进去多余的钱取不出来，我亲自提现过，秒提支付宝！！。</strong></p><p><img src="/images/%E5%BF%AB%E9%80%9F%E5%8D%87%E7%BA%A7GPT4/010.png"></p><p><strong>关键是！！</strong>，该卡不仅可以用来订阅 ChatGPT，一些常见的国外付费订阅软件如 Midjourney，OnlyFans 都可以使用，强烈推荐开一个~</p><h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><p>如果你还嫌麻烦或者嫌贵，你可以直接找我代充，相比通过方法一自己充优惠些，你也不需要自己操作，省事。</p><p><strong>我的联系方式： 微信号：jkfwdkf 或者 扫码加微信</strong></p><p><img src="/images/%E5%BF%AB%E9%80%9F%E5%8D%87%E7%BA%A7GPT4/011.png"></p>]]></content>
      
      
      <categories>
          
          <category> ChatGPT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ChatGPT </tag>
            
            <tag> GPT-4 </tag>
            
            <tag> OpenAI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>侯捷 C++ 视频系列合集</title>
      <link href="/stl/"/>
      <url>/stl/</url>
      
        <content type="html"><![CDATA[<h2 id="侯捷-C-视频系列合集，包括：C-面向对象高级开发、STL源码剖析、STL标准库与泛型编程、C-11、C-14、C-内存管理"><a href="#侯捷-C-视频系列合集，包括：C-面向对象高级开发、STL源码剖析、STL标准库与泛型编程、C-11、C-14、C-内存管理" class="headerlink" title="侯捷 C++ 视频系列合集，包括：C++面向对象高级开发、STL源码剖析、STL标准库与泛型编程、C++11、C++14、C++内存管理"></a>侯捷 C++ 视频系列合集，包括：C++面向对象高级开发、STL源码剖析、STL标准库与泛型编程、C++11、C++14、C++内存管理</h2><p>想要搞定C++？看侯捷老师的视频就对了。侯捷不仅是C++界的大佬，还特别会把复杂的东西讲得简单明了。他的课从C++的ABC一直讲到那些让人头大的高级话题，比如怎么用STL，C++11和C++14有哪些酷炫的新特性，还有怎么管理内存不让程序崩溃等等。</p><p>这套视频适合所有人，不管你是C++新手，还是想要提升自己的老司机。侯捷老师用他那一套能让你边学边笑的方式，让你不仅学到东西，学习的过程也会变得超有趣。</p><p>总之，如果你想提升或者巩固你的C++技能，侯捷老师的视频绝对值得一看。跟着他学，C++不再难！</p><p>我之前在网上找过侯捷老师的 C++ 视频，发现不太全，于是我最近专门找了下，找到了相对比较全的视频，以供大家学习。</p><p><strong>包括</strong> :</p><ul><li>侯捷 C++面向对象高级开发</li><li>侯捷 C++ 标准 11 -14</li><li>侯捷 STL 和 泛型编程</li><li>侯捷 C++ 内存管理</li><li>侯捷 STL 与泛型编程</li></ul><p><img src="/images/STL/STL.png"></p><p><br><br> </p><blockquote><p>在这里分享给大家，我放在公众号后台了，大家可以扫下方二维码关注「<strong>跟着小康学编程</strong>」公众号，后台回复「<strong>STL</strong>」，即可获取。</p></blockquote><p><br><br> </p><p><img src="/images/STL/xkvxgzh.png"></p><p><br><br> </p><p><img src="/images/STL/gzh.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程视频合集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL 源码视频 </tag>
            
            <tag> 侯捷 C++ 视频合集 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
