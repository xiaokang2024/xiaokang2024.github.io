<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux 系统编程从入门到进阶 学习指南</title>
      <link href="/systemprog/"/>
      <url>/systemprog/</url>
      
        <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>大家好，我是小康 ，今天我们来学习一下 Linux 系统编程相关的知识。Linux 系统编程是连接高级语言和硬件的桥梁，它对深入理解计算机系统至关重要。无论你是打算构建高性能服务器还是开发嵌入式设备，掌握 Linux 系统编程是 C 和 C++ 开发者的基本技能。</p><p>本文旨在为初学者提供一个清晰的 Linux 系统编程入门指南，带你步入 Linux 系统编程的世界，从基本概念到实用技能，一步步建立起您的知识体系。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>什么是系统编程？</strong></p><p>系统编程，指的是开发那些直接与计算机硬件或操作系统进行交互的程序。这些程序负责管理和控制计算机系统的资源，包括但不限于进程、内存、文件系统和设备驱动。确保为应用程序提供一个稳定、高效的运行环境。</p><p><strong>系统编程与应用编程的主要区别</strong>：</p><ul><li><strong>目的性</strong>：系统编程旨在为计算机或操作系统本身提供功能和服务，而应用编程是为了满足最终用户的特定需求。</li><li><strong>交互对象</strong>：系统编程直接与硬件或操作系统交互，而应用编程与操作系统或其他应用交互。</li><li><strong>复杂性</strong>：由于系统编程需要管理和控制计算机的底层资源，因此通常比应用编程更为复杂。</li><li><strong>开发工具</strong>：系统编程通常使用低级语言，如 C 或汇编，因为这些语言提供了直接访问硬件的能力。而应用编程可能使用更高级的语言，如 Python 或 Java，以提高开发效率。</li></ul><h2 id="Linux系统编程核心技术概览"><a href="#Linux系统编程核心技术概览" class="headerlink" title="Linux系统编程核心技术概览"></a>Linux系统编程核心技术概览</h2><p>在电脑的世界中，操作系统起到桥梁的作用，连接用户与计算机硬件。其中，Linux 由于其开源、稳定和安全的特点，成为了许多工程师的首选。为了更深入地理解它，我们首先需要了解其系统架构的神秘面纱。</p><p><img src="/images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/1.jpg"></p><h3 id="Linux-系统架构解析"><a href="#Linux-系统架构解析" class="headerlink" title="Linux 系统架构解析"></a>Linux 系统架构解析</h3><h4 id="用户空间和内核空间的布局"><a href="#用户空间和内核空间的布局" class="headerlink" title="用户空间和内核空间的布局"></a>用户空间和内核空间的布局</h4><p><img src="/images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/2.jpg"></p><p><strong>各个内核组件说明</strong>:</p><ul><li><p><strong>系统调用 （Syscalls）</strong>：</p><p>当应用程序需要访问硬件资源时，它们使用系统调用来与内核通信。</p></li><li><p><strong>进程管理</strong>：</p><p>负责处理进程创建、调度和终止。确保系统中的进程公平、有效地获得 CPU 时间，并管理进程间的通信和同步。</p></li><li><p><strong>内存管理</strong>：</p><p>管理物理内存，提供虚拟内存和分页功能。确保每个进程都有它自己的地址空间，同时保护进程间的内存不被非法访问。</p></li><li><p><strong>文件系统</strong>：</p><p>提供文件和目录的创建、读取、写入和删除功能。它抽象了物理存储设备，为用户和应用程序提供了一个统一的文件访问接口。</p></li><li><p><strong>虚拟文件系统（VFS）</strong>：</p><p>用户和应用程序不直接与各种文件系统交互。而是通过 VFS（虚拟文件系统）进行操作。VFS为各种不同的文件系统（如EXT4, FAT, NFS等）提供一个统一的接口。这样，无论底层使用的是哪种文件系统，用户和应用的文件访问方式都保持一致，实现在 Linux 中的无缝集成。</p></li><li><p><strong>网络协议栈</strong>：</p><p>负责处理计算机之间的通信，使设备能够在网络上发送和接收数据。它包含了多层协议，如 <strong>TCP&#x2F;IP</strong>，使计算机能够连接到互联网和其他网络，并与其他计算机进行数据交换。</p></li><li><p><strong>设备驱动</strong>：</p><p>设备驱动是一种特殊的软件程序，它允许 Linux 内核和计算机的硬件组件进行交互。这些硬件组件可以是任何物理设备，如显卡、声卡、网络适配器、硬盘或其他输入&#x2F;输出设备。设备驱动为硬件设备提供了一个抽象层，使得内核和应用程序不需要知道硬件的具体细节，就能与其进行通信和控制。<strong>简而言之，设备驱动是硬件和操作系统之间通信的桥梁。</strong></p></li></ul><h4 id="用户空间-User-Space"><a href="#用户空间-User-Space" class="headerlink" title="用户空间 (User Space)"></a>用户空间 (User Space)</h4><p>所有的应用程序，如浏览器、文档编辑器或音乐播放器都运行在这个空间。</p><ul><li><strong>安全性</strong>：用户空间的程序运行在受限的环境中，它们只能访问分配给它们的资源，不能直接访问硬件或其他程序的数据。</li><li><strong>稳定性</strong>：如果一个应用程序崩溃，它不会影响其他应用程序或系统的核心功能。</li></ul><h4 id="内核空间-Kernel-Space"><a href="#内核空间-Kernel-Space" class="headerlink" title="内核空间 (Kernel Space)"></a>内核空间 (Kernel Space)</h4><p>内核空间是操作系统的核心。</p><ul><li><strong>权限</strong>：内核可以直接访问硬件，并有权执行任何命令。</li><li><strong>安全性</strong>：虽然内核拥有广泛的权限，但只有那些已知且经过严格测试和验证的代码才被允许在内核空间执行。</li><li><strong>稳定性</strong>：如果内核遇到问题，整个系统可能会崩溃。</li></ul><h3 id="系统调用与库函数"><a href="#系统调用与库函数" class="headerlink" title="系统调用与库函数"></a>系统调用与库函数</h3><p>在 <strong>Linux</strong> 编程中，我们经常听到“系统调用”和“库函数”这两个词，但你知道它们之间的区别吗？接下来就让我们来详细了解一下。</p><h4 id="什么是系统调用？"><a href="#什么是系统调用？" class="headerlink" title="什么是系统调用？"></a>什么是系统调用？</h4><p>系统调用是一个程序向操作系统发出的请求。当应用程序需要访问某些资源（如磁盘、网络或其他硬件设备）或执行某些特定的操作（如创建进程或线程）时，它通常会通过系统调用来完成。</p><p><strong>工作原理</strong></p><ul><li><strong>模式切换</strong>：应用程序在用户空间运行，而操作系统内核在内核空间运行。系统调用涉及从用户空间切换到内核空间。</li><li><strong>参数传递</strong>：程序将参数传递给系统调用，通常通过特定的寄存器。</li><li><strong>执行</strong>：内核根据传递的参数执行相应的操作。</li><li><strong>返回结果</strong>：操作完成后，内核将结果返回给应用程序，并将控制权返回给应用程序。</li></ul><p><strong>常见的系统调用函数：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">read() 和 write()：分别用于读取和写入文件。</span><br><span class="line">open() 和 close()：打开和关闭文件。</span><br><span class="line">fork()：创建一个新的进程。</span><br><span class="line">wait()：等待进程结束。</span><br><span class="line">exec()：执行一个新程序。</span><br></pre></td></tr></table></figure><p>这只是系统调用的冰山一角。<strong>Linux</strong> 提供了上百个系统调用，每个都有其特定的功能。</p><h4 id="什么是库函数？"><a href="#什么是库函数？" class="headerlink" title="什么是库函数？"></a>什么是库函数？</h4><p>库函数是预编写的代码，存储在库文件中，供程序员使用。它们通过系统调用和操作系统的内核通信。例如，printf（） 是 C 语言的一个库函数，它内部使用 write（） 系统调用来和内核进行交互。</p><h3 id="文件-IO"><a href="#文件-IO" class="headerlink" title="文件 IO"></a>文件 IO</h3><p>文件IO（输入&#x2F;输出）是计算机程序与文件系统交互的基本方式，允许程序读取和写入文件。要深入理解和使用文件IO，首先需要了解一些关键概念和操作。</p><p><img src="/images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/20.jpg"></p><h4 id="文件描述符是什么？"><a href="#文件描述符是什么？" class="headerlink" title="文件描述符是什么？"></a>文件描述符是什么？</h4><p>文件描述符「 fd 」是一个整数，它代表了一个打开的文件。在 Linux 中，每次我们打开或创建一个文件时，系统都会返回一个文件描述符。而应用程序正是通过这个文件描述符「 fd 」来进行文件的读写的。</p><p><strong>特殊的文件描述符</strong>:</p><ul><li>标准输入<strong>「stdin」</strong> 是 0</li><li>标准输出<strong>「stdout」</strong> 是 1</li><li>标准错误 <strong>「stderr」</strong> 是 2</li></ul><h4 id="常见的文件操作"><a href="#常见的文件操作" class="headerlink" title="常见的文件操作"></a>常见的文件操作</h4><p>当应用程序要与文件交互时，最基本的操作包括打开、读取、写入和关闭文件。这可以通过以下函数来实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">打开文件：open()</span><br><span class="line">读取文件：read()</span><br><span class="line">写入文件：write()</span><br><span class="line">关闭文件：close()</span><br><span class="line"></span><br><span class="line"><span class="meta"># demo</span></span><br><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;example.txt&quot;</span>, O_RDWR | O_CREAT);</span><br><span class="line">write(fd, <span class="string">&quot;Hello, File!&quot;</span>, <span class="number">12</span>);</span><br><span class="line">close(fd);</span><br></pre></td></tr></table></figure><h4 id="文件位置与移动"><a href="#文件位置与移动" class="headerlink" title="文件位置与移动"></a>文件位置与移动</h4><p>有时，我们可能需要移动到文件的特定位置进行读写。使用 lseek（） 可以实现这一点。举个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">假设我们有一个名为 &quot;data.txt&quot; 的文件，内容为：Hello World!</span></span><br><span class="line"><span class="comment"> 现在我们有一个简单需求：我们想将文件中的&quot;World&quot;替换为&quot;Linux&quot;，但不想重写整个文件。 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># demo 展示：</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buffer[<span class="number">6</span>];  <span class="comment">// 存放从文件中读取的数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;data.txt&quot;</span>, O_RDWR);  # 以读写模式打开文件</span><br><span class="line">lseek(fd, <span class="number">6</span>, SEEK_SET);  <span class="comment">// 使用 lseek() 移动到&quot;World&quot;的开头位置</span></span><br><span class="line">read(fd, buffer, <span class="number">5</span>);     <span class="comment">// 读取5个字符（&quot;World&quot;的长度）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(buffer, <span class="string">&quot;World&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 重新定位文件指针以替换&quot;World&quot;,这里需要重新定位的原因是：上面 read 操作使得文件指针已经指向文件末尾了，因此需要重新定位。</span></span><br><span class="line">    lseek(fd, <span class="number">6</span>, SEEK_SET);</span><br><span class="line">    write(fd, <span class="string">&quot;Linux&quot;</span>, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line">close(fd) ; </span><br></pre></td></tr></table></figure><h4 id="高级文件-I-O"><a href="#高级文件-I-O" class="headerlink" title="高级文件 I&#x2F;O"></a>高级文件 I&#x2F;O</h4><p>有时，简单的读写操作无法满足我们的需求，尤其当我们追求高效率或特殊功能时。为了更优雅、高效地处理文件数据，我们引入了一些高级文件 I&#x2F;O 技巧。</p><p><strong>分散读取和集中写入</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 读取操作</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">readv</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec *iov, <span class="type">int</span> iovcnt)</span>;</span><br><span class="line"><span class="comment">// 写入操作</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">writev</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec *iov, <span class="type">int</span> iovcnt)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta"># iovec 结构的定义如下：</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> &#123;</span></span><br><span class="line">    <span class="type">void</span>  *iov_base;  </span><br><span class="line">    <span class="type">size_t</span> iov_len; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">iov_base 是指向缓冲区起始地址的指针。</span><br><span class="line">iov_len 是缓冲区的大小。</span><br></pre></td></tr></table></figure><p>这两个函数主要用于多缓冲区的输入&#x2F;输出操作，允许您在单次系统调用中，从文件读取到多个缓冲区或从多个缓冲区写入文件。</p><p>它们的主要目的是提高效率，因为常规的读&#x2F;写函数每次只能在一个缓冲区进行操作。</p><p><strong>内存映射文件I&#x2F;O</strong></p><p>内存映射文件 I&#x2F;O 允许程序员将文件的一部分直接映射到进程的内存中。这样，程序可以通过直接访问这块内存来访问文件的内容，而不是使用传统的 read 、write 系统调用。这可以提高效率，特别是对于大文件的访问。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 相关函数声明</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">mmap</span><span class="params">(<span class="type">void</span>* addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span>* addr, <span class="type">size_t</span> length)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// demo 举例:</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;example.txt&quot;</span>, O_RDWR);</span><br><span class="line"><span class="comment">// 获取文件的大小</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sb</span>;</span></span><br><span class="line"><span class="keyword">if</span> (fstat(fd, &amp;sb) == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;fstat&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> *mapped = mmap(<span class="literal">NULL</span>, sb.st_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后续的所有对文件的操作就可以通过 mapped 指针来进行。</span></span><br><span class="line"><span class="comment">// 例如：将第一个字符改为 &#x27;J&#x27;）</span></span><br><span class="line">mapped[<span class="number">0</span>] = <span class="string">&#x27;J&#x27;</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>使用 mmap ，你可以直接在内存中访问文件内容，如同访问数组或其他数据结构一样。</p><p><strong>同步文件操作</strong></p><p>当您向文件写入数据时，操作系统可能会缓存这些数据，而不是立即写入磁盘,这样可以提高效率。 但在某些情况下，您可能需要确保数据确实已经写入磁盘。这就是同步文件操作的用处。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">msync</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fsync</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fdatasync</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sync</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><ul><li>msync  用于同步内存映射（通过 mmap 函数创建）文件的内容。它将内存中的更改写回到映射的文件中。</li><li>fsync 函数用于将指定文件描述符（fd）关联的文件的所有修改（包括数据和元数据）同步到磁盘</li><li>fdatasync 函数类似于 fsync，但它只同步文件的数据部分，而不同步元数据。</li><li>sync 同步整个文件系统的所有修改的数据到磁盘，包括所有打开的文件。</li></ul><h4 id="文件锁定"><a href="#文件锁定" class="headerlink" title="文件锁定"></a>文件锁定</h4><p><strong>什么是文件锁定？</strong></p><p>文件锁定是一个在多个进程或线程之间协调对共享资源访问的机制。在这里，这个”共享资源”指的是文件。简单说，<strong>文件锁</strong>就是确保当一个进程正在使用一个文件时，其他进程不能修改它。</p><p><strong>为什么需要文件锁定？</strong></p><p>考虑这样一个场景：两个程序同时写入一个文件。不锁定文件可能会导致数据混乱。例如，一个进程可能会覆盖另一个进程的更改。所以，文件锁定是确保数据完整性的关键。</p><p><strong>文件锁的两种模式</strong>：</p><ul><li><p><strong>共享锁（Shared Locks）</strong>：也被称为读锁。当一个进程持有共享锁时，其他进程可以获得该文件的共享锁以进行读取，但不能获得独占锁进行写入。</p></li><li><p><strong>独占锁（Exclusive Locks）</strong>：也被称为写锁。当一个进程持有独占锁时，其他进程不能获得该文件的任何类型的锁。这意味着其他进程不可以读取或写入该文件。</p></li></ul><p><strong>如何实现文件锁定？</strong></p><p>在 Linux  编程中，文件锁定可以使用以下函数实现：</p><p><code>fcntl()</code> : 允许对文件中的特定部分进行锁定。</p><p><code>flock()</code> ：提供了一个简化的锁定机制，直接锁定整个文件。</p><h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><p><strong>什么是重定向？</strong></p><p><strong>重定向</strong>，顾名思义，指的是改变数据流的方向。在 <strong>Linux</strong> 系统编程中，程序通常与三种标准I&#x2F;O 流进行交互：标准输入（stdin）、标准输出（stdout）、和标准错误输出（stderr）。</p><ul><li>标准输入（stdin）         : 来自键盘的输入。</li><li>标准输出（stdout）        : 显示到屏幕上。</li><li>标准错误输出（stderr)     : 也显示到屏幕上。</li></ul><p><strong>重定向的核心是将这些标准的 I&#x2F;O 流改变到其他地方，如文件或其他程序。</strong></p><p>例如，当我们在命令行中执行命令并将结果保存到文件中，或者从文件中获取命令的输入而不是从键盘中获取，我们都是在使用重定向。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 将 ls -l 命令的输出（即当前目录的详细列表）重定向到 filelist.txt 文件中</span><br><span class="line">ls -l &gt; filelist.txt   </span><br></pre></td></tr></table></figure><p>重定向不仅局限于命令行界面，它在程序中也很有用，允许我们动态地更改程序的输入和输出来源，为构建更复杂、灵活的应用程序提供了基础。</p><p>在 <strong>Linux</strong> 系统编程中，实现重定向的一个核心函数是 <strong>dup2</strong> 函数。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup2</span><span class="params">(<span class="type">int</span> oldfd, <span class="type">int</span> newfd)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">其中：</span></span><br><span class="line"><span class="comment">oldfd 是原始文件描述符。</span></span><br><span class="line"><span class="comment">newfd 是要复制到的目标文件描述符。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># demo 举例:</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 打开一个文件用于写入</span></span><br><span class="line">    <span class="type">int</span> file_fd = open(<span class="string">&quot;output.txt&quot;</span>, O_WRONLY | O_CREAT | O_TRUNC, <span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span> (file_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 错误处理</span></span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 dup2 将标准输出重定向到文件</span></span><br><span class="line">    <span class="keyword">if</span> (dup2(file_fd, STDOUT_FILENO) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="comment">// 错误处理</span></span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在，所有标准输出都会被写入文件</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This will be written to the file &#x27;output.txt&#x27;\n&quot;</span>);</span><br><span class="line">    close(file_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Linux-进程"><a href="#Linux-进程" class="headerlink" title="Linux 进程"></a>Linux 进程</h3><p>你有没有想过，当你在 <strong>Linux</strong> 操作系统上运行一个程序时，都发生了哪些神奇的事情？接下来，我们将一步一步地深入探讨 Linux 进程的世界。</p><p><img src="/images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/3.jpg"></p><h4 id="进程究竟是什么？"><a href="#进程究竟是什么？" class="headerlink" title="进程究竟是什么？"></a>进程究竟是什么？</h4><p>每当你启动一个程序，<strong>Linux</strong> 系统都会创建一个新的进程。这个进程有它自己的内存地址、系统资源和状态。简而言之，进程是程序的一个运行实例。</p><h4 id="进程的创建和终止"><a href="#进程的创建和终止" class="headerlink" title="进程的创建和终止"></a>进程的创建和终止</h4><p><code>fork()</code>：当调用 fork 函数时，它会创建一个新的子进程。这个子进程几乎是父进程的复制品，包括父进程的内存、程序计数器等。</p><p><code>wait() &amp; waitpid()</code>：这些函数允许父进程等待子进程的结束，并收集子进程的退出状态。防止出现僵尸进程。</p><p><code>exec() 系列函数</code>：<strong>exec</strong> 系列函数 允许一个进程运行另一个程序，它实际上替换了当前进程的内容。</p><h4 id="进程的状态转换图"><a href="#进程的状态转换图" class="headerlink" title="进程的状态转换图"></a>进程的状态转换图</h4><p><img src="/images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/4.jpg"></p><p><strong>五态简要说明</strong>:</p><ul><li><p><strong>新建状态</strong>: 这是进程刚被创建时的状态。在这个状态下，操作系统为进程分配了一个唯一的进程标识符（PID）和必要的资源。但进程还没有开始执行任何代码。新建状态通常非常短暂，用户很难观察到，因为进程很快就会转移到 <strong>「就绪状态」</strong>。</p></li><li><p><strong>就绪状态</strong> : 进程已准备好运行并等待操作系统的调度器分配 CPU 时间片。在这个状态下，进程已经加载了所有必要的代码和数据到内存中，且已准备好执行。</p></li><li><p><strong>运行状态</strong> : 进程正在 CPU 上执行。一个进程只有在运行状态时才能执行其指令。</p></li><li><p><strong>阻塞状态</strong> : 进程不能执行，因为它在等待一些事件发生，例如 I&#x2F;O 操作的完成、信号的接收等。在此状态下，即使 CPU 空闲，进程也不能执行。</p></li><li><p><strong>终止状态</strong> : 进程已完成执行或被终止。在这个状态下，进程的资源通常被回收，进程退出。</p></li></ul><h4 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h4><p>在 Linux 的世界里，进程是操作系统进行资源分配的基本单位。但是，进程并不是孤立的存在。当你的应用分成多个独立运行的进程时，这些进程之间如何有效地交换信息呢？这正是通过进程间通信的方式来实现的。</p><p><strong>Linux 提供了以下几种进程间通信的方式</strong>：</p><p>1.管道 （Pipe）</p><p>管道是 Linux 中用于进程间通信的一种机制。它们分为两种类型：<strong>匿名管道</strong>和<strong>有名管道</strong>。</p><p><strong>匿名管道</strong>   : </p><p>  <strong>概念</strong>：匿名管道是一种在有亲缘关系的进程间（如父子进程）进行单向数据传输的通信机制，存在于内存中，通常用于临时通信。如果需要双向通信，则一般需要两个管道。</p><p>  <strong>简单图解：</strong></p><p>  <img src="/images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/5.jpg"></p><p>  <strong>使用场景</strong>：适用于有亲缘关系的进程间的简单数据传输。</p><p>  <strong>简单示例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">  pipe(pipefd); <span class="comment">// 创建匿名管道</span></span><br><span class="line">  <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123; <span class="comment">// 子进程</span></span><br><span class="line">      close(pipefd[<span class="number">1</span>]); <span class="comment">// 关闭写端</span></span><br><span class="line">      <span class="comment">//读取数据</span></span><br><span class="line">      read(pipefd[<span class="number">0</span>],buf,<span class="number">5</span>);</span><br><span class="line">      <span class="comment">// ... </span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 父进程</span></span><br><span class="line">      close(pipefd[<span class="number">0</span>]); <span class="comment">// 关闭读端</span></span><br><span class="line">      <span class="comment">// 写入数据</span></span><br><span class="line">      write(pipefd[<span class="number">1</span>],<span class="string">&quot;hello&quot;</span>,<span class="number">5</span>);</span><br><span class="line">      <span class="comment">// ... </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>有名管道</strong>   ：</p><p><strong>概念：</strong> <strong>有名管道（FIFO，First-In-First-Out）</strong> 是一种特殊类型的文件，用于在不相关的进程之间实现通信。与匿名管道不同，有名管道在文件系统中具有一个实际的路径名。这允许任何具有适当权限的进程打开和使用它，而不仅限于有亲缘关系的进程。</p><p><strong>简单图解：</strong></p><p><img src="/images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/6.jpg"></p><p><strong>简单说明</strong>：</p><p>有名管道是 Linux 中一种特殊的文件，它允许不同的进程通过读写这个文件来相互通信。</p><p><strong>使用场景</strong>：用于本机任何两个进程间的通信，特别是当这些进程没有血缘关系时。</p><p><strong>简单示例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *fifoPath = <span class="string">&quot;/tmp/my_fifo&quot;</span>;</span><br><span class="line">    mkfifo(fifoPath, <span class="number">0666</span>); <span class="comment">// 创建有名管道</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="comment">// 永久循环，持续监听有名管道</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        fd = open(fifoPath, O_RDONLY); <span class="comment">// 打开管道进行读取</span></span><br><span class="line">        read(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印接收到的消息</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Received: %s\n&quot;</span>, buf);</span><br><span class="line">        close(fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// client.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *fifoPath = <span class="string">&quot;/tmp/my_fifo&quot;</span>;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter message: &quot;</span>);    <span class="comment">// 获取要发送的消息</span></span><br><span class="line">    fgets(buf, <span class="keyword">sizeof</span>(buf), <span class="built_in">stdin</span>);</span><br><span class="line">    fd = open(fifoPath, O_WRONLY); <span class="comment">// 打开管道进行写入</span></span><br><span class="line">    write(fd, buf, <span class="built_in">strlen</span>(buf) + <span class="number">1</span>);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.信号 (Signals)</strong></p><p><strong>概念</strong>：<br>在 Linux 中，信号是一种用于进程间通信（IPC）的机制，允许操作系统或一个进程向另一个进程发送简单的消息。信号主要用于传递关于系统事件的通知，例如中断请求、程序异常、或其他重要事件。每个信号代表了一个特定类型的事件，并且进程可以根据收到的信号执行相应的动作。</p><p>信号是异步的，意味着它们可以在任何时间点被发送到进程，通常与进程的正常控制流无关。信号的使用为进程提供了一种处理外部事件和错误的方式。</p><p>可以使用命令 <code>kill -l</code> 来查看 Linux 系统支持的信号有哪些？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">~$ kill -l</span><br><span class="line"> 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP</span><br><span class="line"> 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1</span><br><span class="line">11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>使用场景</strong>：</p><ul><li><strong>异常处理</strong>：当程序遇到运行时错误，比如除以零、非法内存访问等，操作系统会向该进程发送一个适当的信号，如SIGFPE（浮点异常）、SIGSEGV（段错误）。默认情况下：都会使程序终止。</li><li><strong>外部中断</strong>：用户可以通过特定的键盘输入（最常见的是Ctrl+C）来中断正在终端上运行的进程。这会生成 SIGINT 信号，通常导致程序终止。</li><li><strong>进程控制</strong>：如使用 kill 命令发送信号来终止或暂停某个进程。</li><li><strong>定时器和超时</strong>： 程序可以设置定时器，当定时器到期时，会收到 SIGALRM 信号。这常用于限制某些操作的执行时间，确保它们不会占用过多时间。</li><li><strong>子进程状态变化</strong>：当一个子进程结束或停止时，它的父进程会收到 SIGCHLD 信号。这使得父进程可以监控其子进程的状态变化（从运行到正常退出）。</li></ul><p><strong>简单示例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">signal_handler</span><span class="params">(<span class="type">int</span> signal_num)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Received signal: %d\n&quot;</span>, signal_num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    signal(SIGINT, signal_handler);  <span class="comment">// 注册信号处理函数</span></span><br><span class="line">    <span class="comment">// 无限循环，等待信号</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        sleep(<span class="number">1</span>); <span class="comment">// 暂停一秒</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，程序设置了一个信号处理函数来处理 SIGINT 信号（通常由 Ctrl+C 产生）。当收到该信号时，signal_handler 函数会被调用。</p><p><strong>以下是对上述代码执行流程的简单图解说明，方便大家理解</strong>：</p><p><img src="/images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/7.jpg"></p><p><strong>3.文件(Files)</strong></p><p><strong>概念</strong>：</p><p>文件在 Linux 系统中是一种基本的持久化存储机制，可用于<strong>进程间通信</strong>。多个进程可以通过对同一个文件的读取和写入来共享信息。</p><p><strong>简单图解：</strong></p><p><img src="/images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/8.jpg"></p><p><strong>使用场景：</strong></p><ul><li><p><strong>数据交换：</strong></p><p>进程之间可以通过读写同一文件来交换数据。例如，一个进程写入结果数据，另一个进程读取这些数据进行进一步处理。</p></li><li><p><strong>持久化存储：</strong></p><p>文件用于保存需要在应用程序重启后依然保留的数据，例如用户数据、应用状态等。</p></li></ul><p><strong>简单示例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写进程: 向文件中写入数据</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *file = <span class="string">&quot;/tmp/ipc_file&quot;</span>;</span><br><span class="line">    <span class="type">int</span> fd = open(file, O_RDWR | O_CREAT, <span class="number">0666</span>);</span><br><span class="line">    write(fd, <span class="string">&quot;Hello from Process A&quot;</span>, <span class="number">20</span>);  <span class="comment">// 向文件写入数据</span></span><br><span class="line">    close(fd);     <span class="comment">// 关闭文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 读进程: 从文件中读取数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *file = <span class="string">&quot;/tmp/ipc_file&quot;</span>;</span><br><span class="line">    <span class="type">int</span> fd = open(file, O_RDWR | O_CREAT, <span class="number">0666</span>);</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">50</span>];</span><br><span class="line">    read(fd, buf, <span class="number">20</span>);  <span class="comment">// 从文件中读取数据</span></span><br><span class="line">    close(fd);     <span class="comment">// 关闭文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> <strong>注意：</strong><br>  如果存在多个写进程同时操作同一个文件，那么会引发数据竞态和一致性问题。为了解决这个问题，可以使用文件锁或其他同步机制来协调对文件的访问，确保数据的完整性和一致性。</p></blockquote><p><strong>文件锁的作用:</strong></p><ul><li><p><strong>防止数据覆盖</strong>：<br>当一个进程正在写文件时，文件锁可以防止其他进程同时写入，从而避免数据被覆盖。</p></li><li><p><strong>保证写操作的完整性</strong>：</p><p>通过锁定文件，确保每次只有一个进程能够执行写操作，这有助于保持写入数据的完整性。</p></li></ul><p><strong>实现文件锁:</strong></p><p>在 Linux 中，可以使用 fcntl 或 flock 系统调用来实现文件锁。</p><p><strong>示例代码</strong> </p><p>使用 fcntl 实现文件锁，从而保证多个进程在操作同一文件时不会相互干扰，维护数据的一致性和完整性。以下是一个具体的示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *file = <span class="string">&quot;/tmp/ipc_file&quot;</span>;</span><br><span class="line">    <span class="type">int</span> fd = open(file, O_RDWR | O_CREAT, <span class="number">0666</span>);</span><br><span class="line">    <span class="comment">// 设置文件锁</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">flock</span> <span class="title">fl</span>;</span></span><br><span class="line">    fl.l_type = F_WRLCK;  <span class="comment">// 设置写锁</span></span><br><span class="line">    fl.l_whence = SEEK_SET;</span><br><span class="line">    fl.l_start = <span class="number">0</span>;</span><br><span class="line">    fl.l_len = <span class="number">0</span>;  <span class="comment">// 锁定整个文件</span></span><br><span class="line">    <span class="keyword">if</span> (fcntl(fd, F_SETLKW, &amp;fl) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Error locking file&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    write(fd, <span class="string">&quot;Hello from Process A&quot;</span>, <span class="number">20</span>); <span class="comment">// 执行写操作</span></span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    fl.l_type = F_UNLCK;</span><br><span class="line">    fcntl(fd, F_SETLK, &amp;fl);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>4.信号量(Semaphores)</strong></p><p><strong>概念</strong>:<br>信号量是一种在进程间或同一进程的不同线程间提供同步的机制。它是一个计数器，用于控制对共享资源的访问。当计数器值大于0时，表示资源可用；当值为0时，表示资源被占用。进程在访问共享资源前必须减少（wait）信号量，访问后必须增加（post）信号量。</p><p>信号量有两种，一种是 POSIX 信号量，另一种是 System V 信号量。由于 POSIX 信号量提供了更简洁、更易于理解和使用的 API，并且在现代操作系统中得到了广泛支持和优化，所以这里我重点讲解 POSIX 信号量。</p><p>  <strong>简单图解：</strong></p><p><img src="/images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/9.jpg"></p><p>  <strong>分类：</strong></p><p> <strong>匿名信号量</strong></p><p><strong>概念:</strong></p><p> 匿名信号量是内存中的信号量，不与任何文件系统的名称关联。它们通常用于单一进程内不同线程间的同步，或在具有共同祖先的进程之间进行同步。</p><p> <strong>特点：</strong></p><ul><li><strong>作用域</strong>：限于创建它的进程内部或其子进程之间。</li><li><strong>生命周期</strong>：与创建它们的进程的生命周期相同，进程终止时信号量也会消失。</li></ul><p><strong>使用场景</strong>：</p><ul><li><strong>互斥访问</strong>：在多线程程序中，确保同一时刻只有一个线程可以访问某个共享资源。</li><li><strong>同步操作</strong>：协调多个线程的执行顺序，一个线程在另一个线程完成其任务之后再开始执行。如：线程池中的任务队列没任务时，线程必须等待，而当有有线程向队列添加任务时，需要唤醒其他线程来进行消费任务。</li></ul><p> <strong>有名信号量</strong></p><p> <strong>概念:</strong>  有名信号量在文件系统中具有一个唯一的名称，允许不同的独立进程通过这个名称访问同一个信号量，实现进程间同步。</p><p> <strong>特点：</strong></p><ul><li><strong>作用域</strong>：可以跨不同的进程使用。它们在文件系统中具有一个全局唯一的名称，任何知道这个名称的进程都可以访问同一个信号量。</li><li><strong>生命周期</strong>：生命周期可以超过创建它们的进程。即使创建它们的进程已经结束，只要有名信号量的名称存在于文件系统中，它们就继续存在。</li></ul><p><strong>使用场景</strong>：</p><ul><li><strong>进程间互斥：</strong> 多个独立进程共享资源，如文件或内存映射区域，需要互斥访问以避免冲突。</li><li><strong>同步操作</strong>：协调多个进程的执行顺序，一个进程在另一个进程完成其任务之后再开始执行。如：在生产者消费者模型中，只要当生产者向队列添加数据，队列不为空的时候，消费者才能消费数据，否则只能等待。</li></ul><p><strong>来看一个进程互斥的例子：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设日志文件已经打开</span></span><br><span class="line">FILE* logFile;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">writeToLog</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span> &#123;</span><br><span class="line">    <span class="type">sem_t</span>* sem = sem_open(<span class="string">&quot;/log_semaphore&quot;</span>, O_CREAT, <span class="number">0644</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    sem_wait(sem);  <span class="comment">// 获取信号量</span></span><br><span class="line">    <span class="built_in">fprintf</span>(logFile, <span class="string">&quot;%s\n&quot;</span>, message);  <span class="comment">// 写入日志</span></span><br><span class="line">    fflush(logFile);</span><br><span class="line">    sem_post(sem);  <span class="comment">// 释放信号量</span></span><br><span class="line"></span><br><span class="line">    sem_close(sem);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ... 进程的其它操作 ...</span></span><br><span class="line">    writeToLog(<span class="string">&quot;Log message from Process&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>匿名信号量和有名信号量 API 接口区别：</strong></p><p><img src="/images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/10.jpg"></p><p><strong>5.共享内存(Shared Memory)</strong></p><p><strong>概念</strong>：<br>在 Linux 中，共享内存是进程间通信（IPC）的一种形式。当多个进程需要访问相同的数据时，使用共享内存是一种高效的方式。它允许两个或多个进程访问同一个物理内存区域，这使得数据传输不需要通过内核空间，从而提高了通信效率。</p><p>在讲解共享内存前，我们需要了解内存映射技术？</p><p><strong>内存映射技术（Memory Mapping）</strong> 是一种将文件或设备的数据映射到进程内存地址空间的技术，它允许进程直接对这部分内存进行读写操作，就像访问普通内存一样。这种技术不仅可以用于文件I&#x2F;O操作，提高文件访问效率，而且是实现共享内存的基础。</p><p>在 Linux 系统中，内存映射可以通过 <strong>mmap</strong> 系统调用来实现。<strong>mmap</strong> 允许将文件映射到进程的地址空间，也可以用来创建匿名映射（即不基于任何文件的共享内存区域）。</p><p>在 Linux 中，共享内存可以分为如下几类。</p><p><strong>匿名共享内存</strong></p><p><strong>工作原理</strong>：</p><p>匿名共享内存不与任何具体的文件系统文件直接关联，其内容仅在内存中存在。这意味着当所有使用它的进程都结束时，该内存区域的数据就会消失。这种特性使得匿名共享内存非常适合于那些需要临时共享数据但又不需要将数据持久存储到磁盘的场景。</p><p><strong>简单图解：</strong></p><p><img src="/images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/11.jpg"></p><p><strong>注意</strong>：在 Linux 中，<strong>匿名共享内存主要被设计用于有亲缘关系的进程间通信，如父子进程间</strong>。这是因为匿名共享内存的引用（例如，通过 mmap 创建时返回的内存地址）不会自动出现在其他进程中，而是需要通过某种进程间通信的方式（如Unix域套接字）传递给相关的进程。而通过 Unix 域套接字来实现又稍显复杂，所以我们一般推荐匿名共享内存适用于有亲缘关系的进程间通信。</p><p><strong>创建和使用</strong>：</p><p>在 Linux 系统中，匿名共享内存通常是通过 mmap()函数创建的，调用时需指定MAP_ANONYMOUS标志。此外，还需要设置 PROT_READ 和 PROT_WRITE 权限，以确保内存区域可读写。创建时也可以选择 MAP_SHARED 标志，以便在多个进程间共享这块内存。</p><p><strong>示例代码片段如下：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="type">void</span>* shared_memory = mmap(<span class="literal">NULL</span>, size, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOU</span><br></pre></td></tr></table></figure><p>在这里，size是希望映射的内存区域大小，mmap()调用成功后，返回指向共享内存区域的指针。</p><p><strong>使用场景</strong>：</p><p><strong>大量数据交换</strong> ：当两个或多个进程需要交换大量数据时，使用共享内存比传统的进程间通信方法（如管道或消息队列）更有效率。</p><p><strong>而谈到共享内存，又不得不探讨下关于共享内存的同步问题？</strong></p><p>在使用共享内存时，由于多个进程可以直接并且同时访问同一个物理内存区域，不加以适当控制就可能引起数据竞态和一致性问题。</p><p><strong>数据竞态</strong>：当多个进程尝试同时修改共享内存中的同一数据项时，最终结果可能依赖于各进程操作的具体顺序，可能导致不符合预期的结果。</p><p><strong>一致性问题</strong>：在没有合适同步机制的情况下，一个进程可能在另一个进程写入数据的同时读取共享内存，导致获取到不完整或不一致的数据。</p><p><strong>解决策略：使用信号量</strong></p><p>信号量是一种常用的同步机制，用于控制对共享资源的并发访问。通过增加（释放资源）或减少（占用资源）信号量的值，可以有效地控制对共享内存区域的访问，防止数据竞态和确保数据一致性。</p><p><strong>使用信号量来解决匿名共享内存同步问题的简单示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建或打开有名信号量</span></span><br><span class="line">    <span class="type">sem_t</span> *sem = sem_open(<span class="string">&quot;/mysemaphore&quot;</span>, O_CREAT, <span class="number">0666</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (sem == SEM_FAILED) &#123;</span><br><span class="line">        <span class="comment">// 错误处理，退出程序</span></span><br><span class="line">        perror(<span class="string">&quot;sem_open failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建匿名共享内存</span></span><br><span class="line">    <span class="type">void</span>* shared_memory = mmap(<span class="literal">NULL</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>), PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (shared_memory == MAP_FAILED) &#123;</span><br><span class="line">      <span class="comment">// 错误处理，退出程序</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>* counter = (<span class="type">int</span>*)shared_memory;</span><br><span class="line">    *counter = <span class="number">0</span>; <span class="comment">// 初始化计数器</span></span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">            sem_wait(sem); <span class="comment">// 等待信号量</span></span><br><span class="line">            (*counter)++;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Child process increments counter to %d\n&quot;</span>, *counter);</span><br><span class="line">            sem_post(sem); <span class="comment">// 释放信号量</span></span><br><span class="line">            sleep(<span class="number">1</span>); <span class="comment">// 暂停一段时间，模拟工作负载</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">            sem_wait(sem);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Parent process reads counter as %d\n&quot;</span>, *counter);</span><br><span class="line">            sem_post(sem);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// fork失败</span></span><br><span class="line">        perror(<span class="string">&quot;fork failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理资源</span></span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123; <span class="comment">// 父进程等待子进程完成</span></span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        sem_close(sem);</span><br><span class="line">        sem_unlink(<span class="string">&quot;/mysemaphore&quot;</span>);</span><br><span class="line">        munmap(shared_memory, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>基于文件的共享内存</strong></p><p><strong>工作原理:</strong></p><p>基于文件的共享内存通过将磁盘上的实际文件映射到一个或多个进程的地址空间中来实现。当文件被映射到内存后，进程就可以像访问普通内存一样直接读写文件内容，操作系统负责同步内存修改回磁盘文件。这种机制既提高了数据访问的效率，也实现了数据的持久化存储。</p><p>相比匿名共享内存只能适合有亲缘关系的进程，<strong>基于文件的共享内存特别适合于实现非亲缘关系进程间的数据共享</strong>。</p><p><strong>简单图解：</strong></p><p><img src="/images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/12.jpg"></p><p><strong>创建和使用:</strong></p><p>要创建基于文件的共享内存，首先需要打开（或创建）一个文件，然后使用 mmap()将文件映射到内存中。与匿名共享内存不同，这里需要提供<strong>文件描述符</strong>而不是 MAP_ANONYMOUS 标志。</p><p><strong>示例代码片段如下：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> size = <span class="number">4096</span>; <span class="comment">// 共享内存区域大小</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;shared_file&quot;</span>, O_RDWR | O_CREAT, <span class="number">0666</span>);</span><br><span class="line">ftruncate(fd, size); <span class="comment">// 设置文件大小</span></span><br><span class="line"><span class="type">void</span>* shared_memory = mmap(<span class="literal">NULL</span>, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>在这里，shared_file 是被映射的文件名，size 是文件的预期大小。通过 ftruncate() 调整文件大小以匹配共享内存的需求。mmap()成功后返回指向共享内存区域的指针。</p><p><strong>使用场景：</strong></p><p><strong>大量数据交换</strong> ：基于文件的共享内存同样适用于多个进程需要进行大量数据交换的场景。与匿名共享内存不同的是，这些数据可以持久化存储到磁盘上。</p><p>在使用基于文件的共享内存时，同样需要解决多个进程共享数据的同步问题，以保证数据的一致性和完整性。</p><p><strong>解决方案</strong>：</p><ul><li><p><strong>信号量</strong>：<br>信号量可以理解是一个计数器，用来控制同时访问共享资源（如共享内存）的进程数量。如果信号量计数大于0，表示资源可用，进程可以访问资源并将计数减1；如果信号量计数为0，表示资源不可用，进程必须等待。当资源使用完毕后，进程会增加信号量计数，表示资源再次可用。</p></li><li><p><strong>文件锁</strong>：<br>文件锁允许进程对共享内存所基于的文件加锁，防止其他进程同时访问。如果一个进程要写入共享内存，它可以加一个排他锁，这时其他进程既不能读也不能写；如果只需要读取，进程可以加一个共享锁，这样其他进程也可以加共享锁来读取数据，但不能写入。在 Linux 中，文件锁的实现主要依赖于两个系统调用：fcntl 和 flock。而关于 fcntl 和 flock 的讲解，我在前文也有提到过。</p></li></ul><p><strong>简单来说</strong>：</p><ul><li>使用信号量是为了确保在同一时间只有限定数量的进程可以操作共享内存。</li><li>使用文件锁是为了防止在某个进程读写共享内存时，其他进程进行干扰。</li></ul><p>下面来看一个使用<strong>有名信号量解决基于文件的共享内存同步问题的示例</strong>，这个简单的示例演示了两个进程：一个进程向共享内存写入数据，另一个进程从共享内存读取数据。这两个进程使用同一个有名信号量来同步对共享内存区域的访问。</p><p><strong>示例代码：</strong></p><p>首先，确保你有一个名为 shared_file 的文件和一个名为 &#x2F;mysemaphore 的信号量。</p><p><strong>写入进程</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* filename = <span class="string">&quot;shared_file&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> size = <span class="number">4096</span>;</span><br><span class="line">    <span class="comment">// 打开文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(filename, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 错误处理并退出</span></span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 映射文件</span></span><br><span class="line">    <span class="type">void</span>* addr = mmap(<span class="literal">NULL</span>, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (addr == MAP_FAILED) &#123;</span><br><span class="line">        <span class="comment">// 错误处理并退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打开有名信号量</span></span><br><span class="line">    <span class="type">sem_t</span> *sem = sem_open(<span class="string">&quot;/mysemaphore&quot;</span>, O_CREAT, <span class="number">0666</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (sem == SEM_FAILED) &#123;</span><br><span class="line">        <span class="comment">// 错误处理并退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待信号量，开始写入数据</span></span><br><span class="line">    sem_wait(sem);</span><br><span class="line">    <span class="built_in">strcpy</span>((<span class="type">char</span>*)addr, <span class="string">&quot;Hello, Shared Memory!&quot;</span>);</span><br><span class="line">    sem_post(sem);</span><br><span class="line">    <span class="comment">// 清理</span></span><br><span class="line">    munmap(addr, size);</span><br><span class="line">    close(fd);</span><br><span class="line">    sem_close(sem);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>读取进程：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* filename = <span class="string">&quot;shared_file&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> size = <span class="number">4096</span>;</span><br><span class="line">    <span class="comment">// 打开文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(filename, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 错误处理并退出</span></span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 映射文件</span></span><br><span class="line">    <span class="type">void</span>* addr = mmap(<span class="literal">NULL</span>, size, PROT_READ, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (addr == MAP_FAILED) &#123;</span><br><span class="line">       <span class="comment">// 错误处理并退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打开有名信号量</span></span><br><span class="line">    <span class="type">sem_t</span> *sem = sem_open(<span class="string">&quot;/mysemaphore&quot;</span>, O_CREAT, <span class="number">0666</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (sem == SEM_FAILED) &#123;</span><br><span class="line">        <span class="comment">// 错误处理并退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待信号量，开始读取数据</span></span><br><span class="line">    sem_wait(sem);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Read from shared memory: %s\n&quot;</span>, (<span class="type">char</span>*)addr);</span><br><span class="line">    sem_post(sem);</span><br><span class="line">    <span class="comment">// 清理</span></span><br><span class="line">    munmap(addr, size);</span><br><span class="line">    close(fd);</span><br><span class="line">    sem_close(sem);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明</strong>：上面的信号量初始值为 1 ，实际上信号量在这里充当的就是互斥锁。</p><p><strong>Posix 共享内存</strong></p><p>POSIX 共享内存提供了一种高效的方式，允许多个进程通过共享内存区域进行通信。与基于文件的共享内存相比，POSIX 共享内存不需要直接映射磁盘上的文件，而是通过创建命名的共享内存对象来实现进程间的数据共享。这些对象虽然在逻辑上类似于文件（因为可以通过shm_open创建和打开），但实质上直接存在于内存中，提供了更快的数据访问速度。</p><p><strong>Posix 共享内存接口</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">shm_open()        <span class="comment">// 创建或打开一个共享内存对象</span></span><br><span class="line">shm_unlink()      <span class="comment">// 删除一个共享内存对象的名称</span></span><br><span class="line">ftruncate()       <span class="comment">// 调整共享内存对象的大小</span></span><br><span class="line">mmap()            <span class="comment">// 将共享内存对象映射到调用进程的地址空间</span></span><br><span class="line">munmap()          <span class="comment">// 解除共享内存对象的映射</span></span><br></pre></td></tr></table></figure><p><strong>示例演示</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SHM_NAME <span class="string">&quot;/example_shm&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHM_SIZE 4096</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> shm_fd;</span><br><span class="line">    <span class="type">void</span> *ptr;</span><br><span class="line">    <span class="comment">// 创建共享内存对象</span></span><br><span class="line">    shm_fd = shm_open(SHM_NAME, O_CREAT | O_RDWR, <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span> (shm_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 错误处理并退出</span></span><br><span class="line">        perror(<span class="string">&quot;shm_open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置共享内存大小</span></span><br><span class="line">    <span class="keyword">if</span> (ftruncate(shm_fd, SHM_SIZE) == <span class="number">-1</span>) &#123;</span><br><span class="line">       <span class="comment">// 错误处理并退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 映射共享内存</span></span><br><span class="line">    ptr = mmap(<span class="number">0</span>, SHM_SIZE, PROT_WRITE, MAP_SHARED, shm_fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ptr == MAP_FAILED) &#123;</span><br><span class="line">        <span class="comment">// 错误处理并退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 写入数据到共享内存</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *message = <span class="string">&quot;Hello, POSIX Shared Memory!&quot;</span>;</span><br><span class="line">    <span class="built_in">sprintf</span>(ptr, <span class="string">&quot;%s&quot;</span>, message);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Data written to shared memory: %s\n&quot;</span>, message);</span><br><span class="line">    <span class="comment">// 解除映射</span></span><br><span class="line">    munmap(ptr, SHM_SIZE);</span><br><span class="line">    <span class="comment">// 关闭共享内存对象</span></span><br><span class="line">    close(shm_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>System V共享内存</strong></p><p>System V共享内存是一种传统的进程间通信（IPC）机制，它允许多个进程通过共享内存区域进行通信。与POSIX共享内存不同，System V共享内存使用IPC键值key_t来标识和管理共享内存段，而不是通过命名的方式。这种机制提供了一套底层控制共享内存的API，允许进行更细粒度的操作，如权限控制、共享内存状态的查询和管理等。</p><p><strong>System V共享内存接口</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shmget()         <span class="comment">// 创建或获取共享内存段的标识符</span></span><br><span class="line">shmat()          <span class="comment">// 将共享内存段附加到进程的地址空间</span></span><br><span class="line">shmdt()          <span class="comment">// 分离共享内存段和进程的地址空间</span></span><br><span class="line">shmctl()         <span class="comment">// 对共享内存段执行控制操作</span></span><br></pre></td></tr></table></figure><p><strong>示例演示</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">key_t</span> key = ftok(<span class="string">&quot;somefile&quot;</span>, <span class="number">65</span>); <span class="comment">// 创建IPC键</span></span><br><span class="line">    <span class="type">int</span> shm_id;</span><br><span class="line">    <span class="type">void</span> *ptr;</span><br><span class="line">    <span class="comment">// 创建共享内存段</span></span><br><span class="line">    shm_id = shmget(key, <span class="number">1024</span>, <span class="number">0666</span>|IPC_CREAT);</span><br><span class="line">    <span class="keyword">if</span> (shm_id &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;shmget&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将共享内存段附加到进程的地址空间</span></span><br><span class="line">    ptr = shmat(shm_id, (<span class="type">void</span>*)<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ptr == (<span class="type">void</span>*) <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;shmat&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在共享内存上操作，例如写入数据</span></span><br><span class="line">    <span class="comment">// 示例：写入一个字符串</span></span><br><span class="line">    <span class="built_in">strcpy</span>(ptr, <span class="string">&quot;Hello, System V Shared Memory!&quot;</span>);</span><br><span class="line">    <span class="comment">// 分离共享内存段</span></span><br><span class="line">    <span class="keyword">if</span> (shmdt(ptr) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;shmdt&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除共享内存段</span></span><br><span class="line">    shmctl(shm_id, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>6.消息队列 (Message Queues)</strong></p><p><strong>概念</strong>：</p><p>消息队列是一种允许一个或多个进程向其写入消息，并由一个或多个进程读取消息的 IPC 机制。每条消息都由一个消息队列标识符（ID）识别， 且可以携带一个特定的类型。消息队列允许不同进程非阻塞地发送和接收记录或数据块，这些记录可以是不同类型和大小的。</p><p><strong>消息队列图解：</strong></p><p><img src="/images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/13.jpg"></p><p><strong>使用场景</strong>：</p><ul><li><p><strong>进程间通信：</strong><br>在涉及多个运行进程的应用中，消息队列提供了一种高效的方式来传递信息。它允许进程之间无需直接相互连接就能交换数据，从而简化了通信过程。</p></li><li><p><strong>异步数据处理：</strong><br>消息队列使进程能够异步处理信息。一个进程（即生产者）可以发送任务或数据至队列，并继续其他操作，而另一进程（即消费者）可以在准备就绪时从队列中取出并处理这些数据。这种模式有效地分离了数据的生成和消费过程，提高了应用的效率和响应速度。实际的应用比如：日志记录，某些系统可能有一个专门的进程负责记录日志，其他进程可以将日志消息发送到消息队列，由该专门进程异步地写入日志文件。</p></li></ul><p><strong>以下是使用 System V IPC 消息队列的一个简单示例:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">message</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;</span><br><span class="line">    <span class="type">char</span> mtext[<span class="number">100</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送消息至消息队列</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">key_t</span> key = ftok(<span class="string">&quot;queuefile&quot;</span>, <span class="number">65</span>);  <span class="comment">// 生成唯一键</span></span><br><span class="line">    <span class="type">int</span> msgid = msgget(key, <span class="number">0666</span> | IPC_CREAT); <span class="comment">// 创建消息队列</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">message</span> <span class="title">msg</span>;</span></span><br><span class="line">    msg.mtype = <span class="number">1</span>; <span class="comment">// 设置消息类型</span></span><br><span class="line">    <span class="built_in">sprintf</span>(msg.mtext, <span class="string">&quot;Hello World&quot;</span>); <span class="comment">// 消息内容</span></span><br><span class="line">    msgsnd(msgid, &amp;msg, <span class="keyword">sizeof</span>(msg.mtext), <span class="number">0</span>); <span class="comment">// 发送消息</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sent message: %s\n&quot;</span>, msg.mtext);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从消息队列中获取消息</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">key_t</span> key = ftok(<span class="string">&quot;queuefile&quot;</span>, <span class="number">65</span>);</span><br><span class="line">    <span class="type">int</span> msgid = msgget(key, <span class="number">0666</span> | IPC_CREAT);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">message</span> <span class="title">msg</span>;</span></span><br><span class="line">    msgrcv(msgid, &amp;msg, <span class="keyword">sizeof</span>(msg.mtext), <span class="number">1</span>, <span class="number">0</span>); <span class="comment">// 接收消息</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Received message: %s\n&quot;</span>, msg.mtext);</span><br><span class="line">    msgctl(msgid, IPC_RMID, <span class="literal">NULL</span>); <span class="comment">// 销毁消息队列</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>7.套接字 (Sockets)</strong></p><p><strong>概念</strong>：</p><p>套接字是一种在不同进程间进行数据交换的通信机制。在 Linux 中，套接字可以用于同一台机器上的进程间通信（IPC）或不同机器上的网络通信。套接字支持多种通信协议，最常见的是TCP（可靠的、连接导向的协议）和UDP（无连接的、不可靠的协议）。</p><p><strong>简单图解：</strong></p><p><img src="/images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/14.jpg"></p><p><strong>使用场景：</strong></p><p><strong>网络通信</strong>：<br>同一台主机或不同主机上的进程之间通过网络套接字进行数据交换。</p><p><strong>简单示例：</strong> - 使用 TCP 套接字进行通信</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务器端（监听和接收数据）:</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> server_fd, new_socket;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    <span class="type">int</span> addrlen = <span class="keyword">sizeof</span>(address);</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    server_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);  <span class="comment">// 创建套接字</span></span><br><span class="line">    <span class="comment">// 定义套接字地址</span></span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    address.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    address.sin_port = htons(<span class="number">8080</span>);</span><br><span class="line">    <span class="comment">// 绑定套接字</span></span><br><span class="line">    bind(server_fd, (<span class="keyword">struct</span> sockaddr *)&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    listen(server_fd, <span class="number">3</span>);    <span class="comment">// 监听套接字</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 接受连接</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Waiting for a connection...\n&quot;</span>);</span><br><span class="line">        new_socket = accept(server_fd, (<span class="keyword">struct</span> sockaddr *)&amp;address, (<span class="type">socklen_t</span>*)&amp;addrlen);</span><br><span class="line">        <span class="comment">// 读取数据</span></span><br><span class="line">        read(new_socket, buffer, <span class="number">1024</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Message: %s\n&quot;</span>, buffer);</span><br><span class="line">        <span class="comment">// 可以在这里处理收到的消息或执行其他任务</span></span><br><span class="line">        close(new_socket);  <span class="comment">// 关闭这次连接的套接字</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭监听的套接字</span></span><br><span class="line">    <span class="comment">// 注意：由于 while(1)，这行代码不会执行，除非在循环中加入退出条件</span></span><br><span class="line">    close(server_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端进程（发送数据）:</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> sock = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">    sock = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>); <span class="comment">// 创建套接字</span></span><br><span class="line">    serv_addr.sin_family = AF_INET; <span class="comment">// 定义套接字地址</span></span><br><span class="line">    serv_addr.sin_port = htons(<span class="number">8080</span>);</span><br><span class="line">    connect(sock, (<span class="keyword">struct</span> sockaddr *)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));    <span class="comment">// 连接到服务器</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 发送数据</span></span><br><span class="line">    <span class="type">char</span> *message = <span class="string">&quot;Hello from the client!&quot;</span>;</span><br><span class="line">    send(sock, message, <span class="built_in">strlen</span>(message), <span class="number">0</span>);</span><br><span class="line">    close(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>8.域套接字 (Unix Domain Sockets)</strong></p><p><strong>概念</strong>：</p><p>域套接字（Unix Domain Sockets）是一种在同一台机器上的进程间进行数据通信的机制。相对于网络套接字，它们提供了更高效的本地通信方式，<strong>因为数据不需要经过网络协议栈</strong>。域套接字支持流（类似TCP）和数据报（类似UDP）两种模式。</p><p><strong>特别说明</strong>：在域套接字通信中，<strong>“不经过网络协议栈”</strong> 指的是数据传输不需要IP层的路由、不需要TCP&#x2F;UDP等传输层协议的封包与解包处理，也不需要网络接口层的参与。这一点与网络套接字不同，后者用于跨网络的通信，需要经过完整的网络协议栈处理，包括数据的封装、传输、路由和解封装等。</p><p><strong>简单图解：</strong></p><p><img src="/images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/15.jpg"></p><p><strong>使用场景：</strong></p><ul><li><p><strong>本地进程间通信</strong>：</p><p>当需要在同一台机器上的不同进程间高效地交换数据时。</p></li><li><p><strong>替代管道和消息队列</strong>：</p><p>当需要比管道和消息队列更复杂的双向通信时。</p></li></ul><p><strong>简单示例：</strong> - 使用 Unix 域套接字进行通信</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务器端（监听和接收数据）:</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> server_fd, client_socket;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">address</span>;</span></span><br><span class="line">    server_fd = socket(AF_UNIX, SOCK_STREAM, <span class="number">0</span>);  <span class="comment">// 创建套接字</span></span><br><span class="line">    address.sun_family = AF_UNIX;     <span class="comment">// 设置套接字地址</span></span><br><span class="line">    <span class="built_in">strcpy</span>(address.sun_path, <span class="string">&quot;/tmp/unix_socket&quot;</span>);</span><br><span class="line">    <span class="comment">// 绑定和监听</span></span><br><span class="line">    bind(server_fd, (<span class="keyword">struct</span> sockaddr *)&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    listen(server_fd, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// 接受连接</span></span><br><span class="line">        client_socket = accept(server_fd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理数据</span></span><br><span class="line">        <span class="type">char</span> buffer[<span class="number">100</span>];</span><br><span class="line">        read(client_socket, buffer, <span class="number">100</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Received: %s\n&quot;</span>, buffer);</span><br><span class="line">        <span class="comment">// 进行其他的业务处理</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        </span><br><span class="line">        close(client_socket);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清理</span></span><br><span class="line">    close(server_fd);</span><br><span class="line">    unlink(<span class="string">&quot;/tmp/unix_socket&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端（发送数据）:</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> sock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">address</span>;</span></span><br><span class="line">    sock = socket(AF_UNIX, SOCK_STREAM, <span class="number">0</span>); <span class="comment">// 创建套接字</span></span><br><span class="line">    address.sun_family = AF_UNIX;           <span class="comment">// 设置套接字地址</span></span><br><span class="line">    <span class="built_in">strcpy</span>(address.sun_path, <span class="string">&quot;/tmp/unix_socket&quot;</span>);</span><br><span class="line">    <span class="comment">// 连接到服务器</span></span><br><span class="line">    connect(sock, (<span class="keyword">struct</span> sockaddr *)&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    <span class="comment">// 发送数据</span></span><br><span class="line">    <span class="type">char</span> *message = <span class="string">&quot;Hello from the client!&quot;</span>;</span><br><span class="line">    write(sock, message, <span class="built_in">strlen</span>(message));</span><br><span class="line">    <span class="comment">// 清理</span></span><br><span class="line">    close(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong>：</p><ul><li>Unix 域套接字的地址是文件系统中的路径，而不是IP地址和端口。</li><li>Unix 域套接字通常用于同一台机器上的进程间通信，而不适用于网络通信。</li><li>使用 Unix 域套接字时，需要确保套接字文件的路径是可访问的，并在通信完成后清理套接字文件。</li></ul><h3 id="Linux-线程"><a href="#Linux-线程" class="headerlink" title="Linux 线程"></a>Linux 线程</h3><p><img src="/images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/16.jpg"></p><h4 id="什么是线程？"><a href="#什么是线程？" class="headerlink" title="什么是线程？"></a>什么是线程？</h4><p>线程，有时被称为“轻量级进程”，是程序执行流的最小单位。它允许多任务在单个进程内部并发执行。</p><h4 id="线程与进程的区别："><a href="#线程与进程的区别：" class="headerlink" title="线程与进程的区别："></a>线程与进程的区别：</h4><ul><li><strong>进程</strong>: 拥有独立的地址空间和资源。</li><li><strong>线程</strong>: 共享其所在进程的资源，但有自己的堆栈空间。</li></ul><h4 id="创建你的第一个线程"><a href="#创建你的第一个线程" class="headerlink" title="创建你的第一个线程"></a>创建你的第一个线程</h4><p>在 Linux 下，我们使用 POSIX Threads （简称 Pthreads）库来操作线程。以下是一个简单的例子，创建并运行两个线程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Thread 1 function</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">func1</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello from thread 1!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thread 2 function</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">func2</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello from thread 2!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> thread1, thread2;</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;thread1, <span class="literal">NULL</span>, func1, <span class="literal">NULL</span>);    <span class="comment">// Create thread 1</span></span><br><span class="line">    pthread_create(&amp;thread2, <span class="literal">NULL</span>, func2, <span class="literal">NULL</span>);    <span class="comment">// Create thread 2</span></span><br><span class="line"></span><br><span class="line">    pthread_join(thread1, <span class="literal">NULL</span>); <span class="comment">// Wait for thread 1 to finish</span></span><br><span class="line">    pthread_join(thread2, <span class="literal">NULL</span>); <span class="comment">// Wait for thread 2 to finish</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="线程同步：何时使用？"><a href="#线程同步：何时使用？" class="headerlink" title="线程同步：何时使用？"></a>线程同步：何时使用？</h4><p>当两个或多个线程想要访问同一个资源时，问题就来了！如何确保资源的安全访问？有以下三种线程同步的方式。</p><ul><li><strong>互斥锁</strong>: 一个线程在使用资源时，锁住它，其他线程等待。一般用在临界区的保护。</li><li><strong>条件变量</strong>: 线程等待直到某个条件满足。一般和互斥锁搭配使用来实现线程同步 。</li><li><strong>信号量</strong>: 一种高级的同步方式，可以控制资源的访问数量。</li></ul><p> <strong>信号量更为通用</strong>，因为它不仅可以用作互斥锁，还可以用来同步线程，例如 ：确保线程按特定的顺序执行或控制对有限资源的访问。</p><p><strong>确保线程按特定的顺序执行</strong>：</p><p>在某些场景下，您可能希望线程以特定的顺序执行。例如，线程 A 必须在线程 B 之前执行。这可以通过使用信号量来实现。</p><p><strong>控制对有限资源的访问</strong>：</p><p>信号量也可用于控制对有限资源的访问。例如，数据库连接池，其中只有一定数量的连接可供线程使用，可以使用信号量来确保只有固定数量的线程可以同时访问这些资源。</p><p><strong>确保线程按特定的顺序执行的示例代码</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">sem_t</span> semA;</span><br><span class="line"><span class="comment">// 线程A</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">threadA</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread A is running\n&quot;</span>);</span><br><span class="line">    sem_post(&amp;semA); <span class="comment">// 释放信号量A</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程B</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">threadB</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    sem_wait(&amp;semA); <span class="comment">// 等待信号量A</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread B is running\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> tA, tB;</span><br><span class="line">    <span class="comment">// 初始化信号量</span></span><br><span class="line">    sem_init(&amp;semA, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">    pthread_create(&amp;tA, <span class="literal">NULL</span>, threadA, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tB, <span class="literal">NULL</span>, threadB, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 等待线程结束</span></span><br><span class="line">    pthread_join(tA, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tB, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 清理资源</span></span><br><span class="line">    sem_destroy(&amp;semA);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线程的优点与缺点"><a href="#线程的优点与缺点" class="headerlink" title="线程的优点与缺点:"></a>线程的优点与缺点:</h4><p><strong>优点</strong>:</p><ul><li>线程之间的切换成本比进程之间的切换成本低。</li><li>线程间的通信速度比进程间的通信速度快，因为线程共享同一地址空间。</li><li>利用多线程可以很容易地在单进程应用中实现并发。</li></ul><p><strong>缺点</strong>:</p><ul><li>因为线程共享同一地址空间，一个线程的错误可能会破坏其他线程的数据或状态。</li><li>需要复杂的同步操作来避免竞争条件。</li></ul><h4 id="常见问题与挑战"><a href="#常见问题与挑战" class="headerlink" title="常见问题与挑战"></a>常见问题与挑战</h4><p><strong>死锁</strong>:</p><p>死锁发生在两个或多个线程永久地等待对方释放锁的情况。它通常发生在多个线程需要多个锁时，如果不按相同的顺序获取锁，就可能陷入互相等待的状态。</p><p><strong>解决方案</strong>：</p><ul><li>确保所有线程以相同的顺序获取锁。</li><li>使用层次结构的锁定系统，其中线程必须按特定顺序获取锁。</li><li>设置超时，以便在等待锁的时间过长时，线程可以放弃等待，尝试其他操作。</li></ul><p><strong>线程安全</strong>：</p><p>线程安全是指确保代码可以在多线程环境中安全运行，不会因为多个线程同时访问共享资源而导致数据损坏或不一致。</p><p><strong>解决方案：</strong></p><ul><li><strong>使用同步机制</strong>，如互斥锁或信号量，来控制对共享资源的访问。</li><li><strong>编写无状态的代码，或者确保状态信息不在多个线程间共享。</strong> 无状态的代码指的是不保存任何与特定实例相关的数据（状态）的代码。在多线程环境中，这意味着代码不依赖于或不修改任何外部状态，如全局变量或类的成员变量。</li><li><strong>使用不可变对象</strong>，这些对象一旦创建就不会更改，因此可以安全地在多个线程间共享。不可变对象是指一旦被创建就不能被修改的对象(如字符串)，这些对象的状态在创建后是固定的，因此在多线程环境中安全。</li></ul><blockquote><p><strong>总结</strong>：编写无状态的代码和使用不可变对象都是避免多线程环境中的数据冲突和竞争条件的策略。无状态代码避免了共享数据，而不可变对象则确保了即使数据被共享，它们也不会被修改，从而保证线程安全。</p></blockquote><h4 id="进一步探索"><a href="#进一步探索" class="headerlink" title="进一步探索"></a>进一步探索</h4><p><strong>线程池</strong>: </p><p>线程池通过重用一组预先创建的线程来处理任务，减少了线程创建和销毁的开销。</p><p><strong>应用</strong>：线程池广泛用于网络服务器应用，特别是在需要处理大量短暂任务的场景中。</p><p><strong>高级同步原语</strong>: </p><p><strong>读写锁（Read-Write Locks）</strong></p><p>读写锁是一种特殊类型的锁，它允许多个线程同时读取共享资源，但写入操作需要独占访问。这意味着只要没有线程正在写入共享资源，多个线程可以同时读取资源而不会被阻塞。</p><p><strong>应用场景</strong>：适用于读操作远多于写操作的情况，比如缓存系统。</p><p><strong>优点</strong>：提高了在读多写少场景下的并发性能。</p><p><strong>实现</strong>：在 POSIX 线程库中，通过 pthread_rwlock_t 类型提供。</p><p><strong>简单示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_rwlock_t</span> rwlock = PTHREAD_RWLOCK_INITIALIZER;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">reader</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    pthread_rwlock_rdlock(&amp;rwlock);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Reader is reading...\n&quot;</span>);</span><br><span class="line">    sleep(<span class="number">1</span>); <span class="comment">// 模拟读取操作</span></span><br><span class="line">    pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">writer</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    pthread_rwlock_wrlock(&amp;rwlock);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Writer is writing...\n&quot;</span>);</span><br><span class="line">    sleep(<span class="number">1</span>); <span class="comment">// 模拟写入操作</span></span><br><span class="line">    pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> t1, t2;</span><br><span class="line">    pthread_rwlock_init(&amp;rwlock, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;t1, <span class="literal">NULL</span>, reader, <span class="literal">NULL</span>);</span><br><span class="line">    sleep(<span class="number">2</span>); <span class="comment">// 确保读者先运行</span></span><br><span class="line">    pthread_create(&amp;t2, <span class="literal">NULL</span>, writer, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(t1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(t2, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_rwlock_destroy(&amp;rwlock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>屏障（Barriers）</strong></p><p>屏障用于同步多个线程在程序中的特定点。当线程到达一个屏障时，它会等待，直到所有其他线程也都到达这个屏障。然后所有线程才能继续执行。</p><p><strong>应用场景</strong>：用于并行算法，确保所有线程完成某个阶段的工作后才开始下一个阶段。</p><p><strong>优点</strong>：确保所有线程同步进行，避免数据不一致。</p><p><strong>实现</strong>：在 POSIX 线程库中，通过 pthread_barrier_t 类型提供。</p><p><strong>简单示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NUM_THREADS 5</span></span><br><span class="line"><span class="type">pthread_barrier_t</span> barrier;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">task</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread %ld waiting at barrier\n&quot;</span>, (<span class="type">long</span>)arg);</span><br><span class="line">    pthread_barrier_wait(&amp;barrier);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread %ld passed barrier\n&quot;</span>, (<span class="type">long</span>)arg);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> threads[NUM_THREADS];</span><br><span class="line">    pthread_barrier_init(&amp;barrier, <span class="literal">NULL</span>, NUM_THREADS);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> i = <span class="number">0</span>; i &lt; NUM_THREADS; i++) &#123;</span><br><span class="line">        pthread_create(&amp;threads[i], <span class="literal">NULL</span>, task, (<span class="type">void</span>*)i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_THREADS; i++) &#123;</span><br><span class="line">        pthread_join(threads[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_barrier_destroy(&amp;barrier);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明</strong>：这个程序演示了如何使用屏障来同步多个线程，确保所有线程都到达一个执行点后才一起继续执行。在这个例子中，所有线程都会在打印“等待”信息后等待，直到它们全部到达 pthread_barrier_wait 调用处。只有当所有线程都到达这个点时，它们才会继续执行并打印“通过”信息。</p><p><strong>原子操作（Atomic Operations）</strong></p><p>原子操作是指在多线程环境中，一系列操作作为一个单独的不可中断的单位执行，确保在读取、修改和更新变量时的原子性。这些操作在执行的全过程中不会被线程调度机制中断。</p><p><strong>应用场景</strong>：</p><p>非常适合于计数器、标志位更新等简单状态的更新场景，其中对单一变量的读取、修改和更新必须作为一个整体来执行，以避免数据竞争和保证数据一致性。</p><p><strong>优点</strong>：</p><ul><li><strong>效率</strong>：相比锁机制，原子操作通常更高效，因为它们避免了锁的开销和潜在的上下文切换。</li><li><strong>简化编程模型</strong>：对于简单的同步需求，原子操作提供了一种简单直接的解决方案，避免了使用锁的复杂性。</li></ul><p><strong>实现</strong>：在 POSIX 线程库中，原子操作并非直接提供，但可以通过 GCC 提供的内建原子操作函数，如__sync_fetch_and_add、__sync_lock_test_and_set等。C++11及更高版本的标准也提供了原子操作的支持，如 std::atomic 类型。</p><p><strong>简单示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个全局计数器</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 线程函数，用于增加计数器</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">increment_counter</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i) &#123;</span><br><span class="line">        <span class="comment">// 使用GCC的内建原子操作函数进行原子增加</span></span><br><span class="line">        __sync_fetch_and_add(&amp;counter, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> t1, t2;</span><br><span class="line">    <span class="comment">// 创建两个线程，都执行increment_counter函数</span></span><br><span class="line">    pthread_create(&amp;t1, <span class="literal">NULL</span>, increment_counter, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;t2, <span class="literal">NULL</span>, increment_counter, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 等待线程完成</span></span><br><span class="line">    pthread_join(t1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(t2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 打印最终的计数器值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Final counter value: %d\n&quot;</span>, counter);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>自旋锁（Spinlocks）</strong></p><p>自旋锁是一种忙等待的锁，当一个线程尝试获取一个已经被其他线程持有的锁时，它会在一个循环中不断检查锁的状态。这意味着线程会一直占用 CPU，直到它能够获取到锁。</p><p><strong>应用场景</strong>：</p><p>特别适合锁持有时间非常短的场景，因为它避免了线程从运行态转为等待态的开销，这在多核处理器上尤其有用。</p><p><strong>实现</strong>：在 POSIX 线程库中，自旋锁通过 pthread_spinlock_t 类型提供，相关的操作包括 pthread_spin_lock、pthread_spin_unlock等。自旋锁的使用和管理相对简单，但需要谨慎使用以避免过度占用 CPU 资源。</p><p><strong>简单示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_spinlock_t</span> spinlock;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">task</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    pthread_spin_lock(&amp;spinlock);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread %ld got the lock\n&quot;</span>, (<span class="type">long</span>)arg);</span><br><span class="line">    sleep(<span class="number">1</span>); <span class="comment">// 模拟任务执行</span></span><br><span class="line">    pthread_spin_unlock(&amp;spinlock);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> t1, t2;</span><br><span class="line">    pthread_spin_init(&amp;spinlock, PTHREAD_PROCESS_PRIVATE);</span><br><span class="line">    pthread_create(&amp;t1, <span class="literal">NULL</span>, task, (<span class="type">void</span>*)<span class="number">1L</span>);</span><br><span class="line">    pthread_create(&amp;t2, <span class="literal">NULL</span>, task, (<span class="type">void</span>*)<span class="number">2L</span>);</span><br><span class="line">    pthread_join(t1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(t2, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_spin_destroy(&amp;spinlock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内存管理入门"><a href="#内存管理入门" class="headerlink" title="内存管理入门"></a>内存管理入门</h3><p>在前面的讲解中，我们已经学习了进程和线程的基本概念，了解了它们是操作系统进行资源分配和任务调度的基本单位。而无论是进程还是线程，它们的运行都离不开一个关键的系统资源——内存。这自然引出了一个重要的问题：操作系统是如何管理这些内存资源的？这正是我们接下来要讨论的主题— <strong>Linux内存管理</strong>。</p><h4 id="内存分配与释放"><a href="#内存分配与释放" class="headerlink" title="内存分配与释放"></a>内存分配与释放</h4><p>首先，我们先来看下内存的分配与释放，常见的内存分配方式包含以下两种：</p><p><strong>静态内存分配</strong> ： 是在编译时完成的，通常用于固定大小的数据结构，比如：普通数组。</p><p><strong>动态内存分配</strong> ： 则在运行时进行，允许程序根据需要分配任意大小的内存块，比如：动态数组。</p><p>我们一般使用 <strong>malloc和free</strong> 来进行动态内存分配与释放。</p><p>来看个动态内存分配的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int *array = malloc(10 * sizeof(int)); # 分配内存</span><br><span class="line">    if (array == NULL) &#123;</span><br><span class="line">        perror(&quot;malloc failed&quot;);</span><br><span class="line">        return EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">    #使用动态内存 array ...</span><br><span class="line"></span><br><span class="line">    free(array); # 释放内存</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h4><p>应用程序如果没有正确的管理内存的分配与回收，就有可能出现内存泄漏，严重点的有可能导致程序异常退出。</p><p><strong>那什么是内存泄露？</strong></p><p>内存泄露是指程序中动态分配的内存没有及时释放，导致这部分内存在程序执行过程中一直占用，无法被再次利用。在长时间运行的程序中，内存泄露可能会导致内存使用不断增加，最终耗尽所有可用内存，影响程序性能甚至引发程序崩溃。</p><p><strong>如何避免内存泄露？</strong></p><ul><li><p><strong>合理设计程序结构</strong>：确保每次 malloc 后都有对应的 free 操作。可以通过使用自动化工具，如 Valgrind 等，来检测程序运行中的内存泄露问题。</p></li><li><p><strong>使用智能指针</strong>：在支持 C++ 等高级语言中，使用智能指针（如 std::unique_ptr, std::shared_ptr 等）可以帮助管理动态内存的生命周期，智能指针会在适当的时候自动释放内存。</p></li><li><p><strong>及时释放内存</strong>：在不需要动态分配的内存后，应立即释放。尤其是在异常处理、错误处理的代码路径中，也不要忘记释放内存。</p></li><li><p><strong>规范化资源管理</strong>：使用 RAII（Resource Acquisition Is Initialization）原则管理资源，<strong>确保资源的获取即是初始化，随着对象的销毁资源被释放</strong>。</p></li></ul><h4 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a>虚拟内存管理</h4><p><strong>虚拟内存概念：</strong></p><p>虚拟内存是计算机系统内存管理的一种技术。它使得应用程序认为它拥有很大连续的、可用的内存空间，即使这些内存可能被分散存储在物理内存和磁盘上。</p><p><strong>虚拟内存的主要好处是</strong>：</p><ul><li>它提供了比实际物理内存更大的地址空间。</li><li>保证每个程序在内存中有一个连续的地址空间。</li><li>允许系统运行大于物理内存的程序。</li><li>通过内存隔离，提高了程序间的安全性。</li></ul><p>操作系统通过使用硬盘上的一块称为“交换空间”的区域来实现这一点，它作为物理内存的一个扩展。当系统的物理 RAM 不足时，它可以将当前不活跃的内存页面移动到磁盘上，从而为需要更多内存的进程腾出空间。</p><p><strong>分页机制</strong></p><p>分页是虚拟内存管理中最常用的技术之一。它将虚拟内存和物理内存分成大小相等的块，这些块在虚拟内存中被称为“页”(pages)，在物理内存中被称为“页框”(page frames)。每个程序都有一个页表，页表将程序的虚拟地址映射到物理内存的页框。</p><p><strong>分页机制如何工作：</strong></p><p>1.当程序试图访问虚拟内存中的地址时，它首先会检查页表。</p><p>2.如果找到了对应的物理地址，那么数据的存取操作就会继续。</p><p>3.如果没有找到，会触发一个缺页中断，由操作系统处理。</p><p><strong>缺页中断</strong></p><p>缺页中断（Page Fault）是分页系统中的一项关键机制，当一个进程访问的虚拟页不在物理内存中时触发。这时候，操作系统会分配一个物理页框，并将该虚拟页所对应的磁盘数据加载至页框中，并在页表中建立虚拟页和物理页的映射关系。这样，当下一次进程在访问相同虚拟页的时候，就可以直接访问内存中的数据了。</p><p>通过以上机制，虚拟内存管理提供了高效灵活的内存使用方式，允许操作系统优化内存分配，同时也给应用程序提供了简单的内存管理模型。</p><h3 id="文件系统：探索-Linux-中的数据管理"><a href="#文件系统：探索-Linux-中的数据管理" class="headerlink" title="文件系统：探索 Linux 中的数据管理"></a>文件系统：探索 Linux 中的数据管理</h3><p>前面我们探讨了 Linux 系统中的内存管理，包括内存分配与释放、内存泄漏和虚拟内存等概念，这些都是操作系统保证程序正常运行的基础。内存管理使得多个应用能够高效、安全地共享系统的物理内存资源，同时还提供了数据的临时存储能力。然而，内存只能提供临时存储，当系统断电或重启时，内存中的数据就会丢失。这就引出了我们下一个重要话题：<strong>文件系统</strong>。</p><p>在谈文件系统之前，我们先来了解下虚拟文件系统。</p><h4 id="虚拟文件系统（VFS）"><a href="#虚拟文件系统（VFS）" class="headerlink" title="虚拟文件系统（VFS）"></a>虚拟文件系统（VFS）</h4><p><strong>什么是VFS？</strong></p><p>Linux内核中的虚拟文件系统（VFS）是一个关键的抽象层，它为各种不同的文件系统提供了一个统一的操作接口。这意味着，不管数据实际上存储在哪个文件系统中（比如EXT4、XFS等），VFS都能提供一致的访问方式。</p><p><strong>VFS的作用</strong></p><p><strong>兼容性</strong>：使得不同的文件系统都能在 Linux 上工作。</p><p><strong>统一性</strong>：它为应用程序提供了一个标准的文件操作接口，简化了文件访问和管理。</p><p>接下来让我们来看下文件系统。</p><p><strong>Linux 的文件系统是什么？</strong></p><p>Linux 文件系统是 Linux 操作系统用于存储、管理和访问文件和目录的一套规则和结构。它提供了一个层次化的目录结构，让用户和程序能够以一致的方式组织和访问数据。Linux 文件系统支持多种类型，如 EXT4、XFS 和 Btrfs，每种都有其特定的优势和用途。文件系统管理文件的存储细节，包括文件的创建、读取、写入和删除操作，同时也处理文件的权限和安全性。通过虚拟文件系统（VFS）层，Linux 能够提供一个统一的接口来访问这些不同的文件系统，使得文件操作对用户和应用程序透明。</p><p><strong>文件系统核心组件:</strong></p><p><strong>超级块（Superblock）</strong></p><p>超级块是文件系统的元数据的一部分，它包含了关于整个文件系统的全局信息，如文件系统的类型、大小、状态、空闲和已用的块和Inode数量等。超级块的主要作用是提供文件系统的关键信息，以便操作系统能够正确地管理和访问文件系统。</p><p><strong>Inode</strong></p><p>Inode 是文件系统中的一个关键数据结构，每个文件和目录都有一个唯一的Inode。它包含了文件的元数据（如文件大小、所有者、权限、时间戳）和指向实际存储文件数据的数据块的指针。Inode 不存储文件名，文件名存储在目录文件中，这些目录文件将文件名映射到 Inode 号。<strong>inode</strong> 号是文件的唯一标识，而不是文件名。</p><p><strong>目录项（Dentry）</strong></p><p>目录项（或Dentry缓存）是内核用来维护文件名与其对应Inode之间映射的结构。目录项缓存是一个重要的性能优化机制，它减少了从文件名到文件内容的查找时间。</p><p><strong>文件数据块</strong></p><p>文件数据块是存储文件实际内容的磁盘空间。Linux文件系统将磁盘空间分割成一系列的块，这些块可以直接被Inode指向，或者通过间接块来存储较大文件的数据。</p><p><strong>文件和目录</strong></p><p>文件和目录是用户与文件系统交互的基本单元。在 Linux 中，一切皆文件：传统的数据文件、目录、设备（如字符设备和块设备）等都通过文件或文件系统的接口来访问。</p><p><strong>下面是文件、目录、inode 、以及数据块之间的映射关系图</strong>：</p><p><img src="/images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/17.jpg"></p><p>我以程序访问磁盘文件为例，来给大家说明下具体的访问过程，方便大家理解上述图示。</p><p><strong>操作系统会执行以下几个步骤</strong>：</p><ul><li><p><strong>解析文件路径</strong>：操作系统首先解析完整的文件路径，确定文件在文件系统中的位置。</p></li><li><p><strong>查找目录项</strong>：利用文件路径，操作系统在文件系统的目录结构中查找对应的目录项（Dentry）。目录项将文件名映射到一个唯一的Inode编号。</p></li><li><p><strong>访问Inode</strong>：每个文件都有一个Inode，其中包含该文件的元数据（如所有者、权限）和指向文件实际数据块的指针。操作系统使用目录项提供的 Inode 编号来访问 Inode Table，进而访问对应的 inode。</p></li><li><p><strong>读取数据块</strong>：通过 Inode 中的信息，操作系统找到存储文件数据的磁盘块位置，然后读取这些数据块以获取文件内容。</p></li></ul><p>除此之外，在 Linux 中，还存在两种特殊的引用文件的方式：<strong>硬链接和软链接</strong></p><h4 id="硬链接和软链接"><a href="#硬链接和软链接" class="headerlink" title="硬链接和软链接"></a>硬链接和软链接</h4><p><strong>什么是硬链接？</strong></p><p>硬链接实际上是目标文件的另一个名称。它与原文件共享相同的 <strong>inode</strong> 号，因此，无论通过哪个名称访问，内容都是一致的。</p><p><strong>图示</strong>：</p><p><img src="/images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/18.jpg"></p><p>这里，“file1”和“link1”都是硬链接，它们指向同一个inode。这意味着它们共享相同的数据块和文件属性。</p><p><strong>如何创建硬链接？</strong></p><p><strong>命令</strong>：<code> ln 源文件 目标文件</code></p><p>例如，创建一个名为 file1 的文件的硬链接 link1，你可以使用：ln file1 link1。</p><p><strong>特点</strong>：</p><ul><li>硬链接不能跨文件系统。</li><li>不能为目录创建硬链接。</li><li>删除原始文件或硬链接中的任何一个不会影响其他文件，因为它们共享相同的数据块。</li></ul><p><strong>什么是软链接？</strong></p><p>与硬链接不同，软链接是一个独立的文件，它并不包含实际的文件内容，而是指向另一个文件或目录的路径。</p><p><strong>图示</strong>：</p><p><img src="/images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/19.jpg"></p><p>在这里，“link1”是一个指向“file1”的软链接。与硬链接不同，软链接只是一个指向另一个文件或目录的路径。当我们访问软链接时，系统会自动重定向我们到它所指向的实际文件。</p><p><strong>如何创建软链接？</strong></p><p><strong>命令</strong>：<code> ln -s 源文件 目标文件</code></p><p>例如，为 file1 创建一个软链接 link1，你可以使用：ln -s file1 link1。</p><p><strong>特点</strong>：</p><ul><li>软链接可以跨文件系统。</li><li>可以为目录创建软链接。</li><li>如果删除了目标文件，软链接会变为死链接，无法再访问原始内容。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章主要是为想学习 Linux 系统编程的初学者提供一个学习指南，从基本概念到高级功能，我们不仅揭示了 Linux 系统的核心技术和架构，还探讨了用户空间与内核空间的关键区别，系统调用与库函数的基本理解，以及文件IO的多样化操作。我们学习了进程和线程的基础，理解了它们之间的差异，以及如何有效地使用线程同步技术来编写稳定的多线程程序。此外，我们还涵盖了内存管理的基础知识，从内存分配与释放到虚拟内存管理，最后学习了 Linux 文件系统的基本概念及其核心组件，以及硬链接和软链接的使用和区别。</p><p>无论你是刚开始接触 Linux 系统编程的新手，还是希望巩固现有知识的经验开发者，本文都提供了宝贵指南。</p><p>通过本文的学习，我希望读者能够：</p><ul><li>掌握 Linux 系统架构的关键组成部分，包括用户空间和内核空间的区别。</li><li>理解系统调用和库函数的作用，以及它们在系统编程中的重要性。</li><li>熟练进行文件IO操作，包括文件描述符的使用，文件位置的移动，以及高级文件I&#x2F;O技术的应用。</li><li>了解进程和线程的基本概念，包括它们的创建、终止和状态转换，以及进程间通信的方法。</li><li>掌握线程同步的技巧，了解线程的优缺点以及在实际编程中的应用。</li><li>建立内存管理的基本知识框架，包括内存分配释放、虚拟内存管理以及如何避免内存泄露。</li><li>探索 Linux 文件系统，理解虚拟文件系统（VFS）的概念，以及硬链接和软链接的使用和区别。</li></ul><h2 id="最后："><a href="#最后：" class="headerlink" title="最后："></a>最后：</h2><p>如果你对 Linux 系统编程以及计算机编程领域相关知识感兴趣，不妨关注我的公众号—<strong>「跟着小康学编程」</strong>。这里会定时更新相关的技术文章，感兴趣的读者可以关注一下：</p><p><img src="/images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/21.jpg"></p><p>另外，小康最近新创建了一个技术交流群，大家如果在阅读的过程中有遇到问题或者有不理解的地方，欢迎大家加群询问或者评论区询问，我能解决的都尽可能给大家回复。</p><p>扫一扫小康的个人微信，备注「<strong>加群</strong>」即可。</p><p><img src="/images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/22.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> Linux系统编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux系统编程 </tag>
            
            <tag> Linux I/O </tag>
            
            <tag> Linux 进程和线程 </tag>
            
            <tag> Linux 内存管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>侯捷 C++ 视频系列合集</title>
      <link href="/stl/"/>
      <url>/stl/</url>
      
        <content type="html"><![CDATA[<h2 id="侯捷-C-视频系列合集，包括：C-面向对象高级开发、STL源码剖析、STL标准库与泛型编程、C-11、C-14、C-内存管理"><a href="#侯捷-C-视频系列合集，包括：C-面向对象高级开发、STL源码剖析、STL标准库与泛型编程、C-11、C-14、C-内存管理" class="headerlink" title="侯捷 C++ 视频系列合集，包括：C++面向对象高级开发、STL源码剖析、STL标准库与泛型编程、C++11、C++14、C++内存管理"></a>侯捷 C++ 视频系列合集，包括：C++面向对象高级开发、STL源码剖析、STL标准库与泛型编程、C++11、C++14、C++内存管理</h2><p>想要搞定C++？看侯捷老师的视频就对了。侯捷不仅是C++界的大佬，还特别会把复杂的东西讲得简单明了。他的课从C++的ABC一直讲到那些让人头大的高级话题，比如怎么用STL，C++11和C++14有哪些酷炫的新特性，还有怎么管理内存不让程序崩溃等等。</p><p>这套视频适合所有人，不管你是C++新手，还是想要提升自己的老司机。侯捷老师用他那一套能让你边学边笑的方式，让你不仅学到东西，学习的过程也会变得超有趣。</p><p>总之，如果你想提升或者巩固你的C++技能，侯捷老师的视频绝对值得一看。跟着他学，C++不再难！</p><p>我之前在网上找过侯捷老师的 C++ 视频，发现不太全，于是我最近专门找了下，找到了相对比较全的视频，以供大家学习。</p><p><strong>包括</strong> :</p><ul><li>侯捷 C++面向对象高级开发</li><li>侯捷 C++ 标准 11 -14</li><li>侯捷 STL 和 泛型编程</li><li>侯捷 C++ 内存管理</li><li>侯捷 STL 与泛型编程</li></ul><p><img src="/images/STL/STL.png"></p><p><br><br> </p><blockquote><p>在这里分享给大家，我放在公众号后台了，大家可以扫下方二维码关注「<strong>跟着小康学编程</strong>」公众号，后台回复「<strong>STL</strong>」，即可获取。</p></blockquote><p><br><br> </p><p><img src="/images/STL/xkvxgzh.png"></p><p><br><br> </p><p><img src="/images/STL/gzh.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程视频合集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL 源码视频 </tag>
            
            <tag> 侯捷 C++ 视频合集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何快速升级到 GPT-4</title>
      <link href="/upgrade-gpt4/"/>
      <url>/upgrade-gpt4/</url>
      
        <content type="html"><![CDATA[<h1 id="【保姆级】如何升级-GPT-4？快速升级至ChatGPT-Plus指南-，ChatGPT4-0-注册及升级攻略指南"><a href="#【保姆级】如何升级-GPT-4？快速升级至ChatGPT-Plus指南-，ChatGPT4-0-注册及升级攻略指南" class="headerlink" title="【保姆级】如何升级 GPT-4？快速升级至ChatGPT Plus指南 ，ChatGPT4.0 注册及升级攻略指南"></a>【保姆级】如何升级 GPT-4？快速升级至ChatGPT Plus指南 ，ChatGPT4.0 注册及升级攻略指南</h1><p>首先，你必须得能科学上网（能够正常访问谷歌），如果你还不会，请了解这个：<a href="https://www.52xcjs.xyz/auth/register">科学稳定访问 openai</a></p><h2 id="升级-ChatGPT-Plus-的步骤："><a href="#升级-ChatGPT-Plus-的步骤：" class="headerlink" title="升级 ChatGPT Plus 的步骤："></a>升级 ChatGPT Plus 的步骤：</h2><p>（PS：如果不会操作，也可以提供代充、GPT 账号注册等服务，有需要加微信：<strong>jkfwdkf</strong>，备注：<strong>chatgpt</strong></p><h3 id="方法一：自己充值升级"><a href="#方法一：自己充值升级" class="headerlink" title="方法一：自己充值升级"></a>方法一：自己充值升级</h3><h4 id="步骤指南：轻松升级至-ChatGPT-Plus"><a href="#步骤指南：轻松升级至-ChatGPT-Plus" class="headerlink" title="步骤指南：轻松升级至 ChatGPT Plus"></a>步骤指南：轻松升级至 ChatGPT Plus</h4><p>之前了解到一种升级方式，非常方便和迅速，大概 2 分钟之内就可以搞定，它主要是通过虚拟信用卡 WildCard 来进行升级的！</p><p><strong>通过专属链接</strong> <a href="https://bewildcard.com/i/666GPT">WildCard | 一分钟开卡，轻松订阅海外软件服务 即可快速升级 ChatGPT Plus</a><br>（<strong>PS：大家可以使用我的邀请链接：<a href="https://bewildcard.com/i/666GPT">https://bewildcard.com/i/666GPT</a>  ， 邀请码：666GPT</strong>，开卡的时候需要填写邀请码）</p><p><strong>具体操作过程：</strong><br><strong>第一步：点击上述链接，先开卡</strong></p><p>1.立即注册</p><p><img src="/images/%E5%BF%AB%E9%80%9F%E5%8D%87%E7%BA%A7GPT4/001.png"><br><br><br> </p><p>2.填写手机号（你自己的手机号就行）</p><p><img src="/images/%E5%BF%AB%E9%80%9F%E5%8D%87%E7%BA%A7GPT4/002.png"><br><br><br> </p><p>3.下一步之后，填写你自己的个人身份信息【邮箱地址：你就填你容易记得的就行，比如：你叫张三，你就填zhangsan 即可】，然后点击下一步。</p><p><img src="/images/%E5%BF%AB%E9%80%9F%E5%8D%87%E7%BA%A7GPT4/003.png"></p><p>4.接着进行支付宝验证以及支付卡费即可。</p><p><strong>说明：</strong> 开卡的时候是需要支付卡费的，有 1 年和 2 年有效期的选择的。1年是 11.99 美元，2年是 13.99美元，折合人民币不到 100 左右，也没有其他的月租等费用。开1年和2年均可以。 </p><p><strong>第二步：注册 OpenAI 账户</strong>，得到 OpenAI 账号和密码。（这个需要1美元购买账号，比较方便）.</p><p><img src="/images/%E5%BF%AB%E9%80%9F%E5%8D%87%E7%BA%A7GPT4/004.png"><br><br><br> </p><p>然后购买一个账号（不到1美元），支持支付宝付款</p><p><img src="/images/%E5%BF%AB%E9%80%9F%E5%8D%87%E7%BA%A7GPT4/005.png"><br><br><br><br><strong>第三步：充值 GPT Plus 月费用 20 美元，大概 140 多人民币。</strong></p><p><strong>第四步：</strong> 最后点击 <strong>一键升级 GPT Plus</strong>，接着根据它的教程来完成最后一步升级操作。<br><br><br><br><img src="/images/%E5%BF%AB%E9%80%9F%E5%8D%87%E7%BA%A7GPT4/006.png"><br><br><br> </p><p><strong>第五步： 登录 ChatGPT 网站</strong>，<a href="https://chat.openai.com/">ChatGPT 网站链接</a>，登录的账号(电子邮件)和密码就是上面第二步注册的 OpenAI 账号和密码。</p><ul><li>登录成功之后，就直接点击下方红色箭头的 Upgrade Plan</li></ul><p><img src="/images/%E5%BF%AB%E9%80%9F%E5%8D%87%E7%BA%A7GPT4/007.png"><br><br><br>  </p><ul><li>接着点击 Upgrade to Plus</li></ul><p><img src="/images/%E5%BF%AB%E9%80%9F%E5%8D%87%E7%BA%A7GPT4/008.png"></p><p><br><br> </p><ul><li>然后全选复制下图的支付链接，粘贴至相应位置，点击确定支付并升级</li></ul><p><img src="/images/%E5%BF%AB%E9%80%9F%E5%8D%87%E7%BA%A7GPT4/009.png"></p><p><strong>完成上述步骤之后，你就可以愉快的体验 ChatGPT-PLUS 呢！</strong></p><p><strong>其他问题：</strong></p><p><strong>1.是否安全？</strong></p><p>这家国内的公司是<strong>专门解决支付问题</strong>的，会使用支付宝进行实名认证，大家不用担心安全问题。<br><strong>而且，它是支持随时提现的，大家不用担心充进去多余的钱取不出来，我亲自提现过，秒提支付宝！！。</strong></p><p><img src="/images/%E5%BF%AB%E9%80%9F%E5%8D%87%E7%BA%A7GPT4/010.png"></p><p><strong>关键是！！</strong>，该卡不仅可以用来订阅 ChatGPT，一些常见的国外付费订阅软件如 Midjourney，OnlyFans 都可以使用，强烈推荐开一个~</p><h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><p>如果你还嫌麻烦或者嫌贵，你可以直接找我代充，相比通过方法一自己充优惠些，你也不需要自己操作，省事。</p><p><strong>我的联系方式： 微信号：jkfwdkf 或者 扫码加微信</strong></p><p><img src="/images/%E5%BF%AB%E9%80%9F%E5%8D%87%E7%BA%A7GPT4/011.png"></p>]]></content>
      
      
      <categories>
          
          <category> ChatGPT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ChatGPT </tag>
            
            <tag> GPT-4 </tag>
            
            <tag> OpenAI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 网络编程从入门到进阶 学习指南</title>
      <link href="/netprog/"/>
      <url>/netprog/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>大家好，我是小康。在上一篇文章中，我们探讨了 Linux 系统编程的诸多基础构件，包括文件操作、进程管理和线程同步等，接下来，我们将视野扩展到网络世界。在这个新篇章里，我们要让应用跳出单机限制，学会在网络上跨机器交流信息。</p><p>接下来，我们要深入套接字（sockets）和 TCP&#x2F;IP 协议，揭示如何在 Linux 下构建通信和网络服务。我们会从基础说起，逐步深入。目标是为初学者提供一个 <strong>Linux 网络编程从入门到进阶</strong>的学习指南！</p><h1 id="网络通信基础"><a href="#网络通信基础" class="headerlink" title="网络通信基础"></a>网络通信基础</h1><p>思考一下，如果计算机想要“交朋友”，它们需要怎样互相沟通？正如人们交流需要使用语言一样，计算机通信也必须遵守一套规则 — 这就是<strong>网络协议</strong>。</p><p>协议确保信息可以在不同的设备和平台之间清晰、准确地传递。要深入理解协议，我们首先要熟悉两个基础的通信模型：OSI 和 TCP&#x2F;IP 模型。</p><h2 id="OSI-模型和-TCP-IP-模型"><a href="#OSI-模型和-TCP-IP-模型" class="headerlink" title="OSI 模型和 TCP&#x2F;IP 模型"></a>OSI 模型和 TCP&#x2F;IP 模型</h2><p>在网络通信的世界里，OSI（开放式系统互联通信参考模型）和 TCP&#x2F;IP（传输控制协议&#x2F;网际协议）模型扮演着基础框架的角色。它们各自描述了网络通信的多个层次和阶段，但以不同的方式来分类和处理数据传输的细节。</p><ul><li><p><strong>OSI模型</strong> </p><p>OSI（Open Systems Interconnection）模型是一个概念性框架，用于描述网络中不同操作层次的功能。由七层组成，从物理硬件的电气信号（物理层），到应用层（如网页浏览器），每一层都有其独特的功能和协议。</p></li><li><p><strong>TCP&#x2F;IP模型</strong></p><p>TCP&#x2F;IP 模型，则更加贴近实际网络中的运作。Linux 的网络协议栈就是基于该模型实现的。它是基于四层架构，将网络通信过程简化并集中在协议族上，如传输控制协议（TCP）和互联网协议（IP），这两种协议是现代网络通信中最为核心的部分。</p></li></ul><h3 id="简单图示："><a href="#简单图示：" class="headerlink" title="简单图示："></a>简单图示：</h3><p><img src="https://files.mdnice.com/user/48364/9938d8b4-0e6d-4b91-a1cc-23e3b873def5.png"></p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="地址簿：IP地址和MAC地址"><a href="#地址簿：IP地址和MAC地址" class="headerlink" title="地址簿：IP地址和MAC地址"></a>地址簿：IP地址和MAC地址</h3><p>想象一下，互联网是一个巨大的数字城市，而每台计算机或网络设备就像是住在这个城市里的居民。</p><p><strong>IP地址：数字世界的“家庭住址”</strong></p><p>每台设备的 IP 地址就像是它在这个数字城市里的家庭住址。当计算机需要发送信息或访问网络资源时，它会使用目的地设备的 IP 地址来确保信息正确地送达。这个地址有点像是我们现实世界中的邮寄地址，可以根据网络环境的变化而变化（例如，当设备从家庭网络移动到办公室网络时）。</p><p><strong>MAC地址：网络中的“身份证”</strong></p><p>然后，我们有 MAC 地址，这是网络设备的另一个关键标识。每台设备的 MAC 地址都是独一无二的，类似于每个人的身份证号码。它是在设备制造时就被分配的，并且在大多数情况下，这个地址是固定不变的。MAC 地址在本地网络（如家庭或办公室网络）内起着重要作用，它帮助确保信息被准确地送达到特定设备，就像邮递员需要知道收件人的详细身份信息才能将包裹准确递交。</p><p><strong>总结一下</strong>：ip 地址可以让数据包找到目的主机所在的网络，而 MAC 地址确保数据包能准确送到目的主机上。</p><h4 id="导航路线：子网掩码和网关"><a href="#导航路线：子网掩码和网关" class="headerlink" title="导航路线：子网掩码和网关"></a>导航路线：子网掩码和网关</h4><p><strong>子网掩码：定位网络的“区域地图”</strong></p><p>子网掩码可以被视为定位网络内部和外部地址的“区域地图”。就像在一个大城市中，你需要知道哪些街道属于你的社区，哪些通往城市的其他部分。子网掩码帮助计算机确定一个 IP 地址是属于本地网络（即同一个子网）还是位于外部网络。</p><ul><li><strong>内部导航</strong>：如果目的地IP地址与计算机所在的子网相匹配（根据子网掩码判断），则数据包在本地网络内传送。</li><li><strong>外部导航</strong>：如果目的地不在本地子网内，计算机知道它需要将数据发送到更远的目的地。</li></ul><p><strong>网关：网络间的“中转站”</strong></p><p>网关在网络通信中扮演中转站的角色。当你的数据包需要从一个网络（比如你的家庭网络）发送到另一个网络（比如你的工作地点的网络）时，网关是这个旅程的第一站。</p><ul><li><strong>路由决策</strong>：网关检查数据包的目的 IP 地址，然后使用它的路由表来决定最佳的路径将数据包发送到目标网络。</li></ul><p><strong>总结：</strong> 子网掩码和网关共同协作，帮助数据包在复杂的网络结构中找到最有效的路径。子网掩码确定数据包是否在本地网络内，而网关指导跨网络的数据传输。</p><h4 id="端口-：确保数据到达正确的“应用程序门牌号”"><a href="#端口-：确保数据到达正确的“应用程序门牌号”" class="headerlink" title="端口 ：确保数据到达正确的“应用程序门牌号”"></a>端口 ：确保数据到达正确的“应用程序门牌号”</h4><p>好了，现在我们的数据包已经知道了去哪里，但它如何确保被正确的程序接收呢？这就是端口登场的时候了。端口号就像是收件人的门牌号，确保数据不只是送到了正确的地址，而且被正确的应用程序接收。</p><h2 id="Linux-套接字编程"><a href="#Linux-套接字编程" class="headerlink" title="Linux 套接字编程"></a>Linux 套接字编程</h2><h3 id="套接字是什么"><a href="#套接字是什么" class="headerlink" title="套接字是什么"></a>套接字是什么</h3><p>在网络编程中，<strong>套接字</strong>就像是网络世界的<strong>通信端口</strong>。每一个联网的应用程序，为了能够互发消息，都会使用到这样一个端口。这个端口允许数据从一个程序流向另一个程序。简而言之，套接字是应用程序用来在网络上交流的桥梁。</p><p>想象一下，你要用手机给朋友发一条信息。你只需要知道他们的手机号码，这样信息就可以直接发送到他们的手机上。在网络编程中，套接字的作用类似。它使用IP地址 （类似于手机号码） 来确定数据发送的目标位置，而端口号则像是确定信息应该送达到对方手机中的哪个应用程序。这样，套接字（使用 ip 地址和端口）确保了数据能够准确地发送给正在监听那个特定端口的程序。</p><p><strong>套接字的工作原理</strong>：</p><p>套接字的工作原理就像是电话通话的过程。首先，你需要拨打一个号码（即IP地址+端口号）来建立连接。一旦连接建立，电话线（网络连接）就激活了，你的声音（数据）就可以通过它传送。</p><p>在这个过程中：</p><p><strong>拨号</strong>对应于网络编程中的<strong>连接建立</strong>，这是通过调用套接字API来完成的，比如 connect( )函数。</p><p><strong>通话</strong>对应于<strong>数据传输</strong>，你可以通过套接字发送 send( ) 和接收 recv( )数据。</p><p><strong>挂断</strong>对应于<strong>结束连接</strong>，完成通信后，你需要关闭套接字 close( )函数，以结束会话并清理资源。</p><p>在整个通信过程中，套接字保证了数据从一个程序准确地传送到另一个程序，无论这两个程序是在同一台计算机上还是跨越了广阔的互联网。</p><p>在 Linux 中，套接字其实就是一系列的编程接口，Linux 提供了很多特定的 API 来创建和使用套接字，接下来，让我们学习如何使用 Linux 套接字 api 来编写各种网络服务程序。</p><h3 id="套接字类型"><a href="#套接字类型" class="headerlink" title="套接字类型"></a>套接字类型</h3><p>在 Linux 中，有三种套接字类型，<strong>前两种是重点掌握的</strong>，第三种了解即可。</p><p><strong>TCP套接字 (SOCK_STREAM):</strong> </p><ul><li>这是一种可靠的套接字连接，保证数据传输的完整性和顺序。</li><li>必须先建立连接，才能传输数据。</li><li>常用于需要准确数据传输的应用，如网页浏览和文件传输。</li></ul><p><strong>UDP套接字 (SOCK_DGRAM):</strong></p><ul><li>不需要建立连接，但是数据传输可能会丢失，没有先后顺序。</li><li>适用于视频流和在线游戏，这些应用可以容忍一定的数据丢失。</li></ul><p><strong>原始套接字 (SOCK_RAW):</strong></p><ul><li>允许直接对较低层次的协议如 IP 或 ICMP 进行访问和操作，它绕过了 TCP 和 UDP 的处理。</li><li>开发者可以使用原始套接字来构建自定义的协议或直接处理来自网络的数据包。</li><li>通常用于需要进行网络诊断或网络安全应用，如自定义的ping实现，或者网络嗅探器。</li></ul><p>选择哪种类型取决于你的应用需求—是否需要可靠传输（TCP），还是速度更快但可能丢失数据也没关系（UDP）。</p><p>选择使用原始套接字通常意味着你需要对网络协议有深入的理解，因为你将直接与网络层面的数据交互。这比处理 TCP 和 UDP 套接字更复杂，通常只在特殊情况下使用，例如网络工具的开发或定制协议的实现。</p><h3 id="套接字常用-API"><a href="#套接字常用-API" class="headerlink" title="套接字常用 API"></a>套接字常用 API</h3><p>接下来，看下常用的套接字 API：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">socket()                    : 创建套接字</span><br><span class="line">bind()                      : 绑定套接字到本地地址</span><br><span class="line">listen()                    : 监听网络连接</span><br><span class="line">accept()                    : 接受网络连接</span><br><span class="line">connect()                   : 连接到远程主机</span><br><span class="line">send(), recv()              : 发送和接收数据（面向连接的套接字）</span><br><span class="line">sendto(), recvfrom()        : 发送和接收数据（无连接的套接字）</span><br><span class="line">close() ,shutdown()         : 关闭套接字</span><br><span class="line">getsockopt(), setsockopt()  : 获取和设置套接字选项</span><br></pre></td></tr></table></figure><h3 id="套接字地址结构以及地址转换-API"><a href="#套接字地址结构以及地址转换-API" class="headerlink" title="套接字地址结构以及地址转换 API"></a>套接字地址结构以及地址转换 API</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sockaddr 是一个通用的套接字地址结构，它通常与特定的地址族结构（如 sockaddr_in ）一起使用。</span></span><br><span class="line"><span class="comment"> 这是因为多数套接字函数，如 bind(), connect(), 和 accept()，需要使用指向 sockaddr 结构的指针的参数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">   <span class="type">sa_family_t</span>     sa_family;      <span class="comment">/* Address family */</span></span><br><span class="line">   <span class="type">char</span>            sa_data[];      <span class="comment">/* Socket address */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 套接字地址结构（适用于IPv4网络通信的地址结构）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">sa_family_t</span>    sin_family; <span class="meta"># address family: AF_INET </span></span><br><span class="line">    <span class="type">in_port_t</span>      sin_port;   <span class="meta"># port in network byte order </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>   <span class="meta"># ip address </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     <span class="type">uint32_t</span>       s_addr;    <span class="meta"># address in network byte order </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">网络地址转换函数 (用于将IP地址在可打印的格式和二进制结构之间转换)</span></span><br><span class="line"><span class="comment">将点分十进制的IP地址（如&quot;192.168.1.1&quot;）转换成网络字节顺序的二进制形式</span></span><br><span class="line"><span class="comment">inet_pton()   </span></span><br><span class="line"><span class="comment">将网络字节顺序的二进制IP地址转换为点分十进制字符串格式</span></span><br><span class="line"><span class="comment">inet_ntop()   </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># demo 示例:</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INET_ADDRSTRLEN 16；</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str[INET_ADDRSTRLEN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">ipv4addr</span>;</span></span><br><span class="line">inet_pton(AF_INET, <span class="string">&quot;192.168.1.1&quot;</span>, &amp;ipv4addr);</span><br><span class="line">inet_ntop(AF_INET, &amp;ipv4addr, str, INET_ADDRSTRLEN);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The IPv4 address is: %s\n&quot;</span>, str);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="字节序转换-API"><a href="#字节序转换-API" class="headerlink" title="字节序转换 API"></a>字节序转换 API</h3><p>在网络编程中，字节序（也称为端序）指的是数值在内存中保存的顺序。不同的计算机体系结构可能会采用不同的字节序来表示数据。最常见的两种字节序是<strong>大端字节序</strong>（Big-Endian）和<strong>小端字节序</strong>（Little-Endian）。在网络通信中，为了确保数据在不同的系统间正确传输和解释，定义了一个统一的字节序，即：<strong>网络字节序</strong>，它采用<strong>大端字节序</strong>。</p><p>由于主机字节序与网络字节序可能不同，因此在发送数据前，发送方需要将其主机字节序的数值转换为网络字节序；接收方收到数据后，需要将网络字节序的数值转换回主机字节序。</p><p>Linux 提供了一组 API 来处理字节序的转换：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将无符号长整型数/无符号短整型数从主机字节顺序转换为网络字节顺序。</span></span><br><span class="line">htonl() 和 htons()  </span><br><span class="line"><span class="comment">// 将一个无符号长整型数/无符号短整型数从网络字节顺序转换为主机字节顺序。</span></span><br><span class="line">ntohl() 和 ntohs()  </span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">为了方便记忆，大家可以这样理解：h 代表 host(主机)，n 代表 network(网络)，</span></span><br><span class="line"><span class="comment">l 代表 long(四字节：代表ip)，s 代表 short（两字节：代表端口） 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">以 htons() 举例，host to network short 即：将端口从主机字节序转成网络字节序。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>注意：htonl 和 ntohl 一般处理的是 IP 地址，而 htons 和 ntohs 一般处理的是端口。</strong></p><h3 id="Linux-常见的-IO-模型"><a href="#Linux-常见的-IO-模型" class="headerlink" title="Linux 常见的 IO 模型"></a>Linux 常见的 IO 模型</h3><p>前面我们已经学习了 Linux 基础的 socket API，这样我们便可以编写简单的网络服务程序。但现在，我们面临一个新挑战：如何利用有限的服务器资源，来同时高效处理大量的并发请求呢？</p><p>传统的单线程处理方式在现代网络服务中已不合时宜，因为它无法同时处理多个请求，导致效率低下。为了突破这一限制，我们需探究 Linux 提供的各种 I&#x2F;O 模型。这些模型提供了从阻塞到非阻塞，从多路复用到完全异步的不同解决方案，以适应各种网络应用场景，确保服务器在面对大量请求时也能保持高效运行。</p><p><strong>在讨论这些 IO 模型之前，我们先简单回顾一下 I&#x2F;O 是什么</strong>：</p><p>在计算机中，“I&#x2F;O”就是输入和输出的简称，它描述了数据在计算机系统和外部世界之间的流动。具体来说：</p><ul><li><p><strong>输入</strong>：数据进入计算机，比如你在键盘上敲击字母时，字母被读入计算机。</p></li><li><p><strong>输出</strong>：数据离开计算机，例如屏幕上显示信息。</p></li></ul><p>当提到网络时，“I&#x2F;O”扩展了含义：</p><ul><li><p><strong>网络输入</strong>：从外部网络接收数据到你的本地计算机，如通过网络下载文件到你的计算机。</p></li><li><p><strong>网络输出</strong>：这是指将数据从你的本地计算机发送到外部网络，比如通过计算机发送文件给你的好友。</p></li></ul><p>简而言之，I&#x2F;O 是数据在计算机和其他设备或网络之间传递的方式。</p><p><strong>用户进程如何进行 IO 操作？</strong></p><p>让我们通过一个示意图来直观展示用户进程如何从网络获取数据并将其存储到磁盘的整个过程：</p><p><img src="https://files.mdnice.com/user/48364/4f840eb6-5983-4eee-a62e-dd77ae730335.png"></p><p>从上图我们也能够清楚的看到，进程进行一次 I&#x2F;O 操作需要经过两个步骤:</p><p>以 read 读操作为例：</p><p><strong>第一步：等待网络数据的到来</strong></p><p>当网络数据到达时，网络接口卡（NIC）首先通过直接内存访问（DMA）将数据传输到内核空间分配的 socket 接收缓冲区中，无需 CPU 参与。</p><p><strong>第二步：CPU 复制数据至用户空间</strong></p><p>一旦数据通过 DMA 传输到内核的 socket 接收缓冲区，用户进程的 read 系统调用会被唤醒（如果它在等待数据的话）。接下来，CPU 会介入，将数据从内核缓冲区复制到用户空间提供的缓冲区中。</p><p>也就是说，在 I&#x2F;O 操作的过程中，<strong>存在两个潜在的等待时间点 ：一个是等待网络数据到达 socket 接收缓冲区，另一个是等待 CPU 复制数据至用户空间。</strong></p><p>为了减少这些等待时间对应用程序性能的影响，Linux 提供了五种 I&#x2F;O 模型，它们分别针对这两个步骤的效率问题提供不同的解决方案。</p><p><strong>接下来，我们将深入了解 Linux 支持的五种 I&#x2F;O 模型:</strong></p><h4 id="阻塞IO（Blocking-I-O）"><a href="#阻塞IO（Blocking-I-O）" class="headerlink" title="阻塞IO（Blocking I&#x2F;O）"></a>阻塞IO（Blocking I&#x2F;O）</h4><p><strong>简单图示</strong>：</p><p><img src="https://files.mdnice.com/user/48364/f453c53b-2340-4615-9ab9-664586c46833.png"></p><p>在阻塞 I&#x2F;O 中，<strong>进程在等待网络数据到达和内核复制数据到用户空间这两个步骤中都需要等待</strong>。当一个进程发起 I&#x2F;O 请求时，它会一直等待直到数据被复制到它的应用层缓冲区中，然后才继续执行。</p><h4 id="非阻塞I-O（Non-blocking-I-O）"><a href="#非阻塞I-O（Non-blocking-I-O）" class="headerlink" title="非阻塞I&#x2F;O（Non-blocking I&#x2F;O）"></a>非阻塞I&#x2F;O（Non-blocking I&#x2F;O）</h4><p><strong>简单图示</strong>：</p><p><img src="https://files.mdnice.com/user/48364/79bfe42e-6f12-4961-a1e4-33bbc9d94a82.png"></p><p>在非阻塞 I&#x2F;O 模型中，当进程尝试从 socket 读取数据时，如果数据尚未到达，read调用不会阻塞进程。相反，它会立即返回一个 EWOULDBLOCK 或 EAGAIN 错误。也就是说，进程不需要等待网络数据到达 socket 接收缓冲区就可以返回继续执行其他任务。</p><p>一旦数据到达并存储在内核缓冲区中，而当进程尝试再次读取，这次 read 操作将成功，并将数据从内核空间复制到用户空间，但这里的数据复制过程是需要等待的。</p><p><strong>总结一下</strong>：<strong>在非阻塞 I&#x2F;O 模型中，进程需要等待 socket 数据从内核空间复制到用户空间。</strong> 而在等待网络数据到达 socket 接收缓冲区这个时间点是不需要等待的。但是进程需要不断地“轮询”文件描述符，检查 socket 接收缓冲区是否有数据，频繁的轮询可能会导致 CPU 资源的浪费。</p><h4 id="I-O多路复用（I-O-Multiplexing）"><a href="#I-O多路复用（I-O-Multiplexing）" class="headerlink" title="I&#x2F;O多路复用（I&#x2F;O Multiplexing）"></a>I&#x2F;O多路复用（I&#x2F;O Multiplexing）</h4><p><strong>简单图示</strong>：</p><p><img src="https://files.mdnice.com/user/48364/8aca955e-0c9b-4241-b34b-7a29945900a3.png"></p><p><strong>工作原理：</strong></p><p>I&#x2F;O 多路复用允许一个进程或线程同时监控多个网络 sockets 的状态。它通过单个系统调用（select）来检查多个 sockets 是否有数据可读、可写或是否有异常。Linux 提供了多种 I&#x2F;O 复用技术，包括上面提到的 select、以及 poll、epoll。</p><p><strong>那 I&#x2F;O 多路复用是如何减少上述提到的两个潜在的等待时间的？</strong></p><p><strong>等待网络数据到达</strong></p><ul><li><p>在 I&#x2F;O 多路复用模式下，进程不会在单个 socket 上阻塞等待数据到达。相反，当任何一个被监控的 socket 接收到数据，系统调用（如select）会返回。当 select 返回时，它指示一个或多个 sockets 已接收到数据。这意味着数据已经被网络接口卡（NIC）通过 DMA 操作传输到相应的 socket 接收缓冲区中。</p></li><li><p>这样，进程不必在每个 socket 上分别等待，而是在多个sockets上集中等待，提高了效率。</p></li></ul><p><strong>但是，在 I&#x2F;O 多路复用中， select、poll 或 epoll 系统调用依然会阻塞等待网络数据的到达</strong></p><p><strong>等待CPU复制数据至用户空间</strong></p><p>进程随后可以立即对准备就绪的 socket fd 进行 read 操作。因为数据已经在内核的缓冲区中，CPU 只需要将数据从内核空间复制到用户空间。但这个拷贝数据的完成</p><p>也就是说在 I&#x2F;O 多路复用中，<strong>select、poll 或 epoll 系统调用依然会阻塞等待网络数据的到达</strong>，但是他的<strong>优势在于可以监控多个 sockets 的接收缓冲区是否有数据到来</strong>。当多个 sockets 的接收缓冲区有数据到来，<strong>进程会一直等待 CPU 复制数据至用户空间才能干其他任务</strong>。</p><h4 id="信号驱动I-O（Signal-driven-I-O）"><a href="#信号驱动I-O（Signal-driven-I-O）" class="headerlink" title="信号驱动I&#x2F;O（Signal-driven I&#x2F;O）"></a>信号驱动I&#x2F;O（Signal-driven I&#x2F;O）</h4><p><strong>简单图示</strong>：</p><p><img src="https://files.mdnice.com/user/48364/fcc15954-724a-42fe-80e2-39939a0d612d.png"></p><p>信号驱动 I&#x2F;O 也是属于Linux 中的一种 IO 模型，它允许应用程序在不阻塞等待 I&#x2F;O 操作完成的情况下继续执行其他任务。当 I&#x2F;O 操作（如数据的读取或写入）准备就绪时，操作系统会向应用程序发送一个信号，通知它可以开始执行 I&#x2F;O 操作了。这种模式主要通过使用信号（如 SIGIO）来实现。</p><p><strong>两个等待时间点对信号驱动 I&#x2F;O 的影响</strong> :</p><p><strong>等待网络数据到达</strong>：在信号驱动 I&#x2F;O 模型中，应用程序在等待数据到达时<strong>不需要阻塞等待</strong>。它可以继续执行其他任务或处于休眠状态，直到操作系统发出数据已准备就绪的信号（如 SIGIO）。</p><p><strong>等待内核复制数据到用户空间</strong>：当应用程序收到信号并开始实际的 I&#x2F;O 操作（如 read）时，<strong>它仍然需要等待操作系统将数据从内核空间复制到用户空间</strong>。</p><p>尽管信号驱动 I&#x2F;O 提供了一种异步通知机制，使得应用程序能够在I&#x2F;O事件准备好时接收通知，但它在实践中不如其他模型（如IO复用）那么广泛使用，原因包括：</p><ul><li><p><strong>编程复杂性</strong>：使用信号驱动I&#x2F;O要求程序员熟悉信号处理和非阻塞I&#x2F;O操作，这增加了编程的复杂性。</p></li><li><p><strong>信号合并和丢失</strong><br>Linux 信号处理机制通常不会为同一类型的信号排队。这意味着如果在处理一个信号时另一个相同类型的信号发生，后者可能不会触发额外的信号处理调用，导致应用程序可能错过一些I&#x2F;O事件的通知。这种信号的合并行为限制了信号驱动I&#x2F;O模型在高并发场景下准确响应每个I&#x2F;O事件的能力。</p></li><li><p><strong>更好的替代方案</strong>：对于需要处理多个并发I&#x2F;O操作的应用程序，I&#x2F;O复用（特别是epoll）提供了更高的效率和更好的控制。epoll特别适用于高并发场景，并且相对于信号驱动I&#x2F;O更易于管理和使用。</p></li></ul><h4 id="异步I-O（Asynchronous-I-O）"><a href="#异步I-O（Asynchronous-I-O）" class="headerlink" title="异步I&#x2F;O（Asynchronous I&#x2F;O）"></a>异步I&#x2F;O（Asynchronous I&#x2F;O）</h4><p><strong>简单图示</strong>：</p><p><img src="https://files.mdnice.com/user/48364/6a75989d-b8c4-4b57-afb3-8dd96281fd1d.png"></p><p>aio_read 是 POSIX 异步 I&#x2F;O 接口的一部分，它专门用于执行异步文件读取操作。不太适用于网络 I&#x2F;O 。因此上面的图示是基于文件读取对异步 IO 的工作过程进行说明的。</p><p><strong>工作原理：</strong></p><p>在异步 I&#x2F;O 模型中，当应用程序发起一个I&#x2F;O操作（例如 aio_read 读取）时，它不需要等待操作完成就可以继续执行其他任务。应用程序仅仅是向操作系统发出 I&#x2F;O 请求，并且当 I&#x2F;O 操作真正完成时，操作系统会通知应用程序。这种方式允许应用程序更有效地利用 CPU 时间，因为它不需要在 I&#x2F;O 操作完成前空闲等待。</p><p>那前面提到的两个潜在等待时间对异步 IO 是否会有影响呢？</p><p><strong>等待内核 PageCache 数据准备好：</strong></p><p>在异步 I&#x2F;O 中，应用程序在发出读写请求后立即返回，不需要等待数据在内核中准备好。这意味着应用程序可以继续执行其他任务，而内核会异步的从磁盘读取数据至内核缓存 PageCache 中。</p><p><strong>注意：</strong> 上面我是通过 aio_read 系统调用来说明异步 I&#x2F;O 的工作原理的，aio_read 是 Linux 的 POSIX 异步 I&#x2F;O (AIO) 库提供的接口，主要设计用于文件和块设备的异步读写操作，而不支持网络 I&#x2F;O。因此这里是等待内核的 PageCache 数据准备好而不是等待网络数据准备好，但都可以归纳为等待数据准备好。</p><p><strong>等待CPU复制数据至用户空间</strong>：</p><p> 一旦数据在 pagecache 中准备好，操作系统负责将这些数据从内核空间复制到用户空间指定的缓冲区。<strong>这个复制过程是由内核自动执行的，而不是由用户进程主动复制的。</strong> 用户程序不需要等待这一过程的完成，可以继续进行其他工作。只有在数据完全复制到用户空间后，应用程序才会收到一个完成的信号或通知。进而处理拷贝至用户空间的数据。</p><p><strong>也就是说：在异步 IO 中，不管是等待数据准备好还是等待 CPU 复制数据至用户空间，用户进程都不需要等待。</strong></p><h4 id="Linux-网络-I-O-性能优化"><a href="#Linux-网络-I-O-性能优化" class="headerlink" title="Linux 网络 I&#x2F;O 性能优化"></a>Linux 网络 I&#x2F;O 性能优化</h4><p>在前面的部分，我们探讨了 Linux的 各种I&#x2F;O模型。每种模型都有其独特的使用场景和性能特点。特别是在网络编程中，选择合适的I&#x2F;O模型对于提高服务器的处理能力至关重要。但是，仅仅选择合适的I&#x2F;O模型并不足以确保最佳性能。实际上，网络I&#x2F;O性能还受到许多其他因素的影响，比如<strong>网卡配置、带宽、服务器的并发处理能力</strong>等。因此，我们需要进一步优化 Linux 网络 I&#x2F;O 性能，以确保我们的应用可以充分利用服务器资源，提供更快、更可靠的服务。</p><p><strong>那么，如何优化 Linux 网络 I&#x2F;O 性能呢？</strong></p><p>网络 I&#x2F;O 性能优化主要就是从硬件和软件两个方面来进行：</p><p><strong>首先来看下硬件优化：</strong><br>硬件优化无非就是提升服务器硬件性能，包括 CPU、网卡配置升级、内存配置升级等。</p><ul><li><strong>使用多核 CPU</strong> ：确保服务器有足够的CPU核心来处理高网络负载。</li><li><strong>内存升级</strong>：增加足够的内存以支持高速网络操作，特别是对于需要大量内存缓存的应用。</li><li><strong>网络接口卡</strong>：升级NIC：使用更高速率的NIC，例如从1Gbps升级到10Gbps或更高。<br>或者使用 NIC 多队列（Multi-queue）：使用支持多队列的NIC，以便分散处理负载到多个CPU核心。</li></ul><p><strong>接下来来看下软件优化：</strong></p><p> <strong>1.首先来看下应用程序设计，应用程序本身的设计对网络 I&#x2F;O 性能有着重大影响：</strong></p><ul><li><p><strong>选择合适的 I&#x2F;O 模型</strong>：<br>选择合适的 I&#x2F;O 模型，根据应用的特点和需求选择合适的 I&#x2F;O 模型。对于高并发的网络服务，I&#x2F;O 多路复用（如 epoll、kqueue）通常是最佳选择。它们允许单个线程高效地监控和处理多个网络连接，减少了线程切换的开销。而对于 I&#x2F;O 密集型的应用，异步 I&#x2F;O模型可能会更高效，异步 I&#x2F;O （如 io_uring、libaio）提供了一种不阻塞应用程序主逻辑的方式来处理 I&#x2F;O 请求。这种模型允许应用程序在 I&#x2F;O 请求正在处理时继续执行其他任务。</p></li><li><p><strong>使用零拷贝技术</strong>：<br>传统的数据传输过程涉及多次数据拷贝，包括从内核缓冲区到用户缓冲区。零拷贝技术（如 sendfile）可以减少这些拷贝操作，直接在内核中处理数据，从而减少 CPU 使用和提高效率。</p></li><li><p><strong>批量处理和缓冲</strong> : 聚集数据，以减少网络交互和磁盘操作的次数。</p><p> <strong>a:聚集数据</strong>：通过累积数据到达一定量后再进行处理，而不是每次接收到数据就立即处理。以读取网络数据下载至本地磁盘为例：可以等待数据积累到一定量的时候在写入磁盘，这样可以减少磁盘 I&#x2F;O 次数。</p><p><strong>b.缓冲区管理</strong>：需要合理管理缓冲区，以避免溢出，并在适当的时候重置或清空缓冲区。</p><p><strong>c.适用场景</strong>：这种模式适合于数据量大、数据频繁到达的场景，如日志收集、批量数据处理等。</p></li><li><p><strong>并发和并行处理</strong>：利用多核处理器的优势，通过多线程或多进程来提高并发处理能力。</p></li></ul><p> <strong>2. 接下来看下关于操作系统方面的调整，操作系统级别的调整对于优化网络 I&#x2F;O 也是至关重要的</strong></p><ul><li><p><strong>增加文件描述符限制</strong>：对于高并发的网络服务器，提高文件描述符的限制是必要的，以避免因达到文件描述符上限而无法接受新连接。你可以通过 ulimit -n 命令或修改 &#x2F;etc&#x2F;security&#x2F;limits.conf 文件来增加这个限制。</p></li><li><p><strong>调整 TCP 协议栈参数</strong>：常见的 TCP协议栈参数有如下的几类：</p><p><strong>a：缓冲区大小和资源管理</strong>：<br>这些参数控制 TCP 缓冲区的大小和整体 TCP 缓冲区的资源管理，以优化数据传输性能和内存使用。</p><p><strong>tcp_rmem 和 tcp_wmem</strong> ：分别控制 TCP 接收和发送缓冲区的大小。</p><p><strong>tcp_mem</strong> ：控制整体 TCP 缓冲区在系统范围内的使用情况。</p><p><strong>b: 连接建立和终止：</strong><br>这类参数涉及 TCP 连接的建立过程和连接终止时的行为。</p><p><strong>tcp_syn_retries 和 tcp_synack_retries</strong> : 分别控制 TCP SYN 连接请求和 SYN-ACK 包的重试次数。</p><p> <strong>tcp_fin_timeout</strong> ： tcp_fin_timeout 参数设置了 TCP 连接在 FIN-WAIT-2 状态下的超时时间。这个参数定义了在一个 TCP 连接被本地端关闭后，系统等待对方发送 FIN 包以完成连接终止过程的最长时间。如果在这个超时时间内没有收到对方的 FIN 包，连接将被强制关闭。</p><p><strong>c :连接保活和状态管理：</strong><br>这些参数用于检测和维持空闲连接，以及管理连接状态。</p><p><strong>tcp_keepalive_time</strong> ：设置在开始发送 keepalive 探测之前，一个 TCP 连接必须处于空闲状态的时间。</p><p><strong>tcp_keepalive_probes</strong> ：设置在断开连接之前，最多发送多少个 keepalive 探测包。</p><p><strong>tcp_keepalive_intvl</strong> ： 设置两个连续 keepalive 探测包之间的时间间隔。</p><p><strong>tcp_tw_reuse</strong> :  设置允许在 TIME_WAIT 状态的套接字上的端口被重新用于新的连接。</p><p><strong>d:性能优化 :</strong> 这些参数用于提升网络性能，减少延迟。</p><p><strong>tcp_nodelay</strong> : 禁用 Nagle 算法，减少发送小块数据的延迟。（Nagle 算法是一种为了减少网络上小数据包数量而设计的 TCP 特性。它通过累积较小的数据包并将它们组合成更大的数据块来发送，从而减少了网络上的总数据包数量）。</p><p><strong>tcp_max_syn_backlog</strong> : 设置 SYN 接收队列的最大长度，优化高并发连接的接收。</p><p>除了 SYN 接收队列，TCP 连接还涉及到一个“已连接队列”（也称为 accept 队列），该队列用于存储已经完成三次握手、等待应用程序 accept 的连接。</p><p><strong>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;somaxconn</strong>： 该参数控制着已连接队列的最大长度。 </p><p><strong>调整方法:</strong><br>这些参数通常通过修改 &#x2F;etc&#x2F;sysctl.conf 文件或使用 sysctl 命令进行调整。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sysctl -w net.ipv4.tcp_rmem=&#x27;4096 87380 6291456&#x27;</span><br><span class="line">sysctl -w net.ipv4.tcp_wmem=&#x27;4096 16384 4194304&#x27;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 调整这些参数时，应谨慎考虑系统的整体资源和应用的具体需求。不恰当的设置可能导致性能下降或系统资源耗尽。在生产环境中应用更改前，最好在测试环境中进行充分的测试。</p></li></ul><h3 id="Linux-常见的服务器模型"><a href="#Linux-常见的服务器模型" class="headerlink" title="Linux 常见的服务器模型"></a>Linux 常见的服务器模型</h3><p>服务器模型是网络服务器程序设计的基石，它决定了服务器如何管理多个客户端的连接和请求。接下来，让我们来看看 <strong>Linux</strong> 下的几种常见的服务器模型是怎样工作的？</p><h4 id="单进程服务器：一对一服务"><a href="#单进程服务器：一对一服务" class="headerlink" title="单进程服务器：一对一服务"></a>单进程服务器：一对一服务</h4><p>在单进程服务器模型中。服务器使用一个主进程来逐个处理客户端的连接请求。这意味着，当服务器正在服务一个客户端时，其他客户端必须等待直到当前客户端服务结束。</p><p><strong>图示</strong>：</p><p><img src="https://files.mdnice.com/user/48364/23f888f1-0060-43f9-b9fa-f4f15c3b3eb6.png"></p><p><strong>单进程回射服务器示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">server_fd = socket();</span><br><span class="line">bind();</span><br><span class="line">listen();</span><br><span class="line"><span class="comment">// The main server loop</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    newsockfd = accept(server_fd，...);</span><br><span class="line">    <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="number">256</span>);</span><br><span class="line">    <span class="comment">// Read and write to the connection in a loop</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        n = read(newsockfd, buffer, <span class="number">255</span>);</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">// If read returns 0, the client has closed the connection</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// printf(&quot;Client: %s\n&quot;, buffer);</span></span><br><span class="line">        write(newsockfd, buffer, <span class="built_in">strlen</span>(buffer));</span><br><span class="line">    &#125;</span><br><span class="line">    close(newsockfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>缺点</strong>：</p><ul><li><p><strong>无法实现并发</strong>： 单进程服务器在任何时刻只能处理一个客户端的请求。这意味着如果有多个客户端同时请求服务，除了第一个之外的所有请求都必须等待，这限制了服务器的并发处理能力。</p></li><li><p><strong>性能瓶颈</strong>： 由于服务器在处理当前请求时无法接受新的连接，这会导致服务器对其他客户端的响应时间延长，特别是在高流量的情况下，效率低下。</p></li><li><p><strong>资源利用不充分</strong>： 在多核心处理器上，单进程模型无法充分利用多核的优势，因为它只在一个核心上运行，没有并行处理能力。</p></li></ul><h4 id="多进程服务器"><a href="#多进程服务器" class="headerlink" title="多进程服务器"></a>多进程服务器</h4><p>了解了单进程服务器模型的缺点后，我们自然会寻求更高效的方案来处理多客户端并发的情况。这就引出了多进程服务器模型，它是解决单进程模型限制的常见方案。</p><p>在多进程模型中，服务器为每个新的客户端连接创建一个独立的进程。这允许服务器同时处理多个客户端请求，极大地提高了并发处理能力和资源利用率。</p><p><strong>图示</strong>：</p><p><img src="https://files.mdnice.com/user/48364/9defc556-9b32-4c68-af28-04764244200e.png"></p><p><strong>多进程回射服务器示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">server_fd = socket();</span><br><span class="line">bind();</span><br><span class="line">listen();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="type">int</span> new_socket =accept(server_fd, ...);    </span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        close(new_socket);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">      close(server_fd); <span class="comment">// Child does not need the listener</span></span><br><span class="line">      handle_client(new_socket);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        close(new_socket); <span class="comment">// Parent does not need this socket</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">handle_client</span><span class="params">(<span class="type">int</span> new_socket)</span> &#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> bytes_read;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        bytes_read = read(new_socket, buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">        <span class="keyword">if</span> (bytes_read &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// Break the loop if read error or end of file</span></span><br><span class="line">        &#125;</span><br><span class="line">        write(new_socket, buffer, bytes_read);</span><br><span class="line">    &#125;</span><br><span class="line">    close(new_socket);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>多进程服务器优点</strong>：</p><ul><li><p><strong>稳定性</strong>: 多进程服务器中，每个进程是独立的。如果一个进程崩溃，通常不会影响到其他进程，从而提高了服务器的整体稳定性。</p></li><li><p><strong>隔离性</strong>: 每个进程有自己的地址空间，这意味着进程之间的内存是隔离的。这样可以防止某个进程的错误操作影响到其他进程。</p></li><li><p><strong>利用多核优势</strong>: 多进程模型能够在多核处理器上运行，每个进程可以被操作系统调度到不同的CPU核心上，充分利用硬件资源。</p></li></ul><p><strong>缺点</strong>：</p><ul><li><p><strong>资源消耗</strong>: 每个进程都需要一定量的内存和系统资源，如果进程数过多，会占用大量的系统资源，这可能导致服务器的性能下降。</p></li><li><p><strong>上下文切换开销</strong>: 多进程意味着操作系统需要频繁地在进程之间进行上下文切换，这个过程涉及到保存和加载寄存器、更新各种表等操作，会消耗一定的CPU时间。</p></li></ul><h4 id="多线程服务器"><a href="#多线程服务器" class="headerlink" title="多线程服务器"></a>多线程服务器</h4><p>虽然多进程模型提高了服务器的稳定性和隔离性，但它也带来了<strong>资源消耗、上下文切换开销</strong>等限制。针对多进程模型的这些限制，多线程服务器模型提供了一个更为高效的解决方案。</p><p>多线程服务器模型在同一个进程内创建多个线程来处理客户端请求，每个线程能够独立执行，<strong>它们共享进程的资源，如内存空间等资源。而且上下文切换也更快。</strong></p><p><strong>图示</strong>：<br><img src="https://files.mdnice.com/user/48364/6d70fc57-353d-438b-81e2-3026ea946dd5.png"></p><p><strong>多线程回射服务器的示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">server_fd = socket();</span><br><span class="line">bind(server_fd, ...);</span><br><span class="line">listen(server_fd, ...);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="type">int</span> new_socket = accept(server_fd, ...);</span><br><span class="line">    <span class="type">pthread_t</span> thread_id;</span><br><span class="line">    <span class="keyword">if</span> (pthread_create(&amp;thread_id, <span class="literal">NULL</span>, handle_client, (<span class="type">void</span>*)&amp;new_socket) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Handle error</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">handle_client</span><span class="params">(<span class="type">void</span>* socket)</span> &#123;</span><br><span class="line">    <span class="type">int</span> new_socket = *(<span class="type">int</span>*)socket;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> bytes_read;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        bytes_read = read(new_socket, buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">        <span class="keyword">if</span> (bytes_read &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// Break the loop if read error or end of file</span></span><br><span class="line">        &#125;</span><br><span class="line">        write(new_socket, buffer, bytes_read);</span><br><span class="line">    &#125;</span><br><span class="line">    close(new_socket);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>多线程服务器优缺点</strong>：</p><ul><li><strong>资源效率</strong>: 线程共享进程的内存空间，相较于多进程模型，多线程服务器在内存和资源上的开销更小。</li><li><strong>上下文切换效率</strong>: 线程间的上下文切换比进程间的切换要快，因为线程共享许多资源，切换时所需的资源较少（<strong>线程切换一般只需要切换各自寄存器和栈上的数据</strong>）。</li><li><strong>利用多核优势</strong>: 线程可以分布在多个 CPU 核心上运行，这使得多线程服务器能够充分利用多核 CPU 的计算能力。</li></ul><p><strong>缺点</strong>：</p><ul><li><strong>同步复杂性</strong>: 因为线程共享内存和资源，所以必须仔细设计同步机制来避免竞态条件和其他并发问题。</li><li><strong>稳定性风险</strong>: 一个线程的错误可能影响整个进程，因为它们共享同一内存空间。这可能导致整个服务器程序崩溃。</li><li><strong>资源限制</strong>: 虽然线程比进程轻量，但大量线程仍然会消耗大量系统资源，尤其是在高并发情况下。</li><li><strong>调试困难</strong>: 多线程程序的调试较为复杂，尤其是当出现了线程安全问题时，这些问题可能难以重现和定位。</li></ul><h4 id="线程池模型"><a href="#线程池模型" class="headerlink" title="线程池模型"></a>线程池模型</h4><p>在多线程服务器模型中，每个客户端请求都由一个新的线程来处理。这种方法虽然有效，<strong>但在面对大量并发请求时，频繁地创建和销毁线程会导致服务器的性能下降。</strong> 特别是在请求数量剧增的情况下，线程创建和销毁的开销会变得显著，同时过多的活跃线程也会竞争有限的CPU和内存资源，进一步影响服务的响应时间和吞吐量。</p><p>而在线程池模型中，服务器启动时会预先创建一定数量的线程，这些线程存放在池中，并不立即执行任务。当客户端请求到达时，请求会被分配给线程池中的一个空闲线程，该线程负责处理整个请求过程。处理完毕后，线程并不销毁，而是返回到池中等待处理下一个请求。</p><p><strong>图示</strong>：</p><p><img src="https://files.mdnice.com/user/48364/6f26895d-1634-44d2-b815-e8bee6b99f70.png"></p><p><strong>说明</strong>：</p><p><strong>服务器（Server）</strong>：这是整个流程开始的地方。服务器初始化一个线程池，并不断监听客户端的连接请求。当一个客户端连接请求到来时，服务器接受这个连接（accept()），然后把相应的任务（job：一般是读写客户端数据的逻辑）添加到线程池的任务队列中去。最终，当服务器不再需要线程池时，会销毁它。</p><p><strong>线程池（ThreadPool</strong>）：线程池是预先创建的线程集合，用于执行多个任务。它分为两个主要部分：</p><ul><li><strong>任务队列（Job Queue）</strong>：这里存放所有待处理的任务（jobs）。当服务器接受一个客户端的连接，它会创建一个任务，并将其添加到这个队列中。</li><li><strong>线程队列（Thread Queue）</strong>：这里存放的是线程池中所有可用的线程。当任务队列中有任务时，线程池会分配一个线程去执行这个任务。</li></ul><p><strong>客户端（Clients）</strong>：客户端通过网络连接与服务器进行通信。</p><h4 id="I-O多路复用服务器"><a href="#I-O多路复用服务器" class="headerlink" title="I&#x2F;O多路复用服务器"></a>I&#x2F;O多路复用服务器</h4><p><strong>什么是 I&#x2F;O 多路复用？</strong></p><p>在 Linux 中，I&#x2F;O 多路复用是一种允许<strong>单个进程或线程同时监控多个文件描述符</strong>（通常是网络套接字）上的读写就绪状态的技术。这使得程序能够在一个或多个文件描述符上发生 I&#x2F;O 事件时被通知，从而对这些事件作出响应（比如进行读写操作）。这种机制极大地提高了处理多个并发网络连接的效率，因为它允许使用较少的系统资源（如进程和线程）来管理大量的连接。</p><p>上面我们在讲解 I&#x2F;O 模型的时候，提到了 IO 多路复用，而在讲解服务器模型我们又再次提到了IO 多路复用。<strong>可能大家会有疑问：IO 多路复用到底属于 I&#x2F;O 模型还是服务器模型？</strong></p><p>其实 I&#x2F;O 多路复用技术是两者之间的桥梁：它是一种有效的 I&#x2F;O 处理方式，同时也是构建服务器模型的基础。</p><ul><li>I&#x2F;O 多路复用作为 I&#x2F;O 模型，关注的是如何有效地管理和执行 I&#x2F;O 操作，特别是在涉及多个 I&#x2F;O 源（如网络套接字）时。</li><li>I&#x2F;O 多路复用作为服务器模型，则是在这种 I&#x2F;O 操作的管理方式基础上构建整个服务器的架构，决定如何接收和处理多个客户端请求，如何分配处理程序来响应这些请求，以及如何利用系统资源。</li></ul><p><strong>简单来说，I&#x2F;O 模型是关于”如何执行 I&#x2F;O”的，而服务器模型是基于某种 I&#x2F;O 模型来构建服务的，以及如何组织服务器程序以响应客户端请求。</strong></p><p><strong>常见的 I&#x2F;O 多路复用技术</strong>：</p><p>Linux 提供了多种 I&#x2F;O 多路复用的机制，如 select, poll, 和 epoll。这些技术的主要区别在于它们处理大量文件描述符的方式和效率。</p><p><strong>IO 复用之 Select</strong>：</p><p><strong>基本概念</strong>：<br>Linux 中的 select 函数是一种常用的 I&#x2F;O 复用技术。它允许程序监视多个文件描述符（FDs），以检测是否有任何一个或多个 FD 准备好进行读取、写入或是否有异常发生。这种技术特别适用于同时处理多个网络连接或其他类型的 I&#x2F;O 操作（如：文件I&#x2F;O）。</p><p><strong>函数声明</strong></p><p>select 函数的基本声明如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, <span class="keyword">struct</span> timeval *timeout)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数结构</span></span><br><span class="line"><span class="comment">nfds：监视的文件描述符集合中最大的文件描述符加一。</span></span><br><span class="line"><span class="comment">readfds：一个指向 fd_set 结构的指针，用于监视哪些 FD 准备好进行读操作。</span></span><br><span class="line"><span class="comment">writefds：一个指向 fd_set 结构的指针，用于监视哪些 FD 准备好进行写操作。</span></span><br><span class="line"><span class="comment">exceptfds：一个指向 fd_set 结构的指针，用于监视哪些 FD 有异常发生。</span></span><br><span class="line"><span class="comment">timeout：指定 select 等待准备就绪的 FD 的最长时间。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>fd_set 结构图解展示</strong>：</p><p>fd_set 是一个文件描述符数组，用于指示 select 函数应该监视的 FDs。</p><p><strong>fd_set 结构图解展示</strong>：</p><p><img src="https://files.mdnice.com/user/48364/dd170da3-cc3e-4b3f-86ec-e6fbf8a39285.png"></p><p><strong>说明</strong>：</p><p>参数 readfds、writefds、exceptfds 从用户空间传入内核空间和从内核空间返回用户空间，文件描述符数组中的值代表的含义不同：</p><p><strong>以可读事件 readfds 为例</strong>：</p><p><strong>从用户空间传入内核空间</strong>：数组值为 0 代表不监控该文件描述符（fd），数组值为 1 代表要监控该文件描述符（fd）。</p><p><strong>从内核空间返回用户空间</strong>：数组值为 0 代表该文件描述符数据未准备就绪，数组值为 1 代表该文件描述符数据准备就绪。用户进程可以进行读操作了。</p><p><strong>select 并发回射服务器程序示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 8080</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_CLIENTS 30</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> server_fd, new_socket, client_socket[MAX_CLIENTS];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    <span class="type">int</span> addrlen = <span class="keyword">sizeof</span>(address);</span><br><span class="line">    fd_set readfds;</span><br><span class="line">    <span class="type">int</span> max_sd, sd, activity, i, valread;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">1025</span>];  <span class="comment">// 数据缓冲区</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化所有客户端套接字</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_CLIENTS; i++) &#123;</span><br><span class="line">        client_socket[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建套接字</span></span><br><span class="line">    server_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 绑定套接字</span></span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    address.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    address.sin_port = htons(PORT);</span><br><span class="line">    bind(server_fd, (<span class="keyword">struct</span> sockaddr *)&amp;address, <span class="keyword">sizeof</span>(address))&lt;<span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听套接字</span></span><br><span class="line">    listen(server_fd, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        FD_ZERO(&amp;readfds);<span class="comment">// 清空 fd_set</span></span><br><span class="line">        FD_SET(server_fd, &amp;readfds); <span class="comment">// 添加 server_fd 到 fd_set</span></span><br><span class="line">        max_sd = server_fd;</span><br><span class="line">        <span class="comment">// 添加客户端套接字到 fd_set</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_CLIENTS; i++) &#123;</span><br><span class="line">            sd = client_socket[i];</span><br><span class="line">            <span class="keyword">if</span> (sd &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                FD_SET(sd, &amp;readfds);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sd &gt; max_sd) &#123;</span><br><span class="line">                max_sd = sd;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 select 监听套接字</span></span><br><span class="line">        activity = select(max_sd + <span class="number">1</span>, &amp;readfds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接受新连接</span></span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(server_fd, &amp;readfds)) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((new_socket = accept(server_fd, (<span class="keyword">struct</span> sockaddr *)&amp;address, (<span class="type">socklen_t</span>*)&amp;addrlen))&lt;<span class="number">0</span>) &#123;</span><br><span class="line">              <span class="comment">// 错误处理并退出</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将新套接字添加到数组</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_CLIENTS; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (client_socket[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                    client_socket[i] = new_socket;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     <span class="comment">// 其他套接字的数据处理</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_CLIENTS; i++) &#123;</span><br><span class="line">        sd = client_socket[i];</span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(sd, &amp;readfds)) &#123;</span><br><span class="line">            <span class="comment">// 检查是否是断开连接，否则接收数据</span></span><br><span class="line">            <span class="keyword">if</span> ((valread = read(sd, buffer, <span class="number">1024</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">                close(sd);</span><br><span class="line">                client_socket[i] = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                buffer[valread] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                <span class="comment">// 将接收到的数据发送回客户端</span></span><br><span class="line">                send(sd, buffer, <span class="built_in">strlen</span>(buffer), <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>select优缺点</strong>：</p><p><strong>优点</strong>:</p><ul><li><p><strong>能够同时监视多个套接字</strong>:  select 允许服务器以单线程的方式监视多个套接字，来检测它们是否有可读、可写或异常条件发生。</p></li><li><p><strong>无需多线程或多进程</strong>：select 采用单线程的处理方式，使用 select 可以避免复杂的多线程或多进程管理，减少了上下文切换的开销，简化了并发处理。</p></li><li><p><strong>适用于小到中等规模的负载</strong>：对于不是很高的并发连接数（几百的连接数），select 通常可以满足需求，且效率不错。</p></li></ul><p><strong>缺点</strong>:</p><ul><li><p><strong>文件描述符限制</strong>：select 可以监视的文件描述符数量是有限的，通常由 <strong>FD_SETSIZE</strong> 常量决定，这在很多系统上默认是1024。这限制了服务器可以处理的最大并发连接数。当然 select 也会受限于系统级别的文件描述符数量限制。</p></li><li><p><strong>效率问题</strong>：随着文件描述符数量的增加，select 的性能会线性下降。每次调用select时，都需要重新传入整个文件描述符集合，内核需要遍历这个集合来更新状态，这在文件描述符很多时会成为瓶颈。</p></li><li><p><strong>响应时间变长</strong>：在 select 返回的文件描述符列表集合中，如果有多个文件描述符同时变为活跃状态，服务器通常会按顺序处理它们。这可能导致对列表前面的连接有偏见，使得后面的连接等待时间较长。</p></li></ul><p><strong>IO 复用之 Poll</strong>：</p><p><strong>基本概念</strong>：<br>poll 也是一种 IO 复用技术，用于监视多个文件描述符（通常是网络套接字）的可读性、可写性和异常状态。与 select 类似，poll 允许您的程序监视多个文件描述符，直到一个或多个文件描述符准备好进行 IO 操作。这使得您可以同时管理多个网络连接，而不是逐个阻塞地处理它们。</p><p><strong>函数声明</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span>;</span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">fds：指向一个 pollfd 结构数组的指针，该数组包含要监视的文件描述符及其请求的事件（如 POLLIN 表示可读，POLLOUT 表示可写）。</span></span><br><span class="line"><span class="comment">nfds：指定数组 fds 中的元素数量。</span></span><br><span class="line"><span class="comment">timeout：指定等待时间（毫秒）。特殊值有：0 立即返回（非阻塞），-1 无限等待直到某个事件发生。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>pollfd 结构</strong></p><p>poll 函数使用 pollfd 结构来指定要监视的文件描述符和事件类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> fd;         <span class="comment">// 文件描述符</span></span><br><span class="line">    <span class="type">short</span> events;   <span class="comment">// 请求的事件</span></span><br><span class="line">    <span class="type">short</span> revents;  <span class="comment">// 实际发生的事件</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">fd：文件描述符</span><br><span class="line">events：要监视的事件，如 POLLIN、POLLOUT</span><br><span class="line">revents：由 poll 函数设置，表明哪些事件实际发生了</span><br></pre></td></tr></table></figure><p><strong>Poll 底层采用的数据结构图解</strong></p><p><img src="https://files.mdnice.com/user/48364/d1671185-039f-414d-b4b1-0784e571ae96.png"></p><p><strong>底层数据结构：</strong></p><p><strong>用户空间数组</strong>：用户空间程序使用数组（类型为 struct pollfd）来提供要监视的文件描述符及其感兴趣的事件</p><p>但在内核中，为了有效地处理这些文件描述符，poll 的实现转而使用链表。</p><p><strong>内核空间链表</strong>：</p><ul><li>当 poll 系统调用被执行时，内核首先将这个数组中的数据复制到内核空间。</li><li>在内核中，为了更灵活地处理可能的大量文件描述符，这些 pollfd 结构被组织成链表形式。</li><li>链表的每个节点可能包含一个或多个 pollfd 结构，具体取决于可用的内存和文件描述符的数量。</li></ul><p><strong>poll 优缺点</strong>：</p><p><strong>优点</strong>：</p><p><strong>无内置文件描述符限制</strong>：与 select 不同，poll 不受文件描述符数量的限制。select 通常受限于 FD_SETSIZE，这在处理大量并发连接时可能成为瓶颈。<strong>但它仍然受限于系统级别的文件描述符限制。</strong></p><p><strong>简化的接口</strong>：poll 使用单个结构体数组来表示所有监视的文件描述符和相关事件，相比 select 需要使用三个文件描述符集（读、写、异常），接口更为简洁。</p><p><strong>更直观的事件模型</strong>：poll 使用位字段来表示不同的事件类型，这使得事件模型比 select 的方式更直观和易于理解。</p><p><strong>缺点</strong>：</p><p><strong>线性扫描开销</strong>：poll 在处理文件描述符时，需要对整个数组进行线性扫描。当监视的文件描述符数量非常大时，这可能导致性能下降。</p><p>总的来说，poll 是 select 的一种改进，特别是在可处理的文件描述符数量上没有限制，但在高性能和大规模并发处理方面，epoll 在现代 Linux 系统上通常是更佳的选择。</p><p><strong>poll 并发回射服务器程序示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 8080</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_CLIENTS 30</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> listen_fd, new_socket, valread;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    <span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> addrlen = <span class="keyword">sizeof</span>(address);</span><br><span class="line">    <span class="type">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">client_fds</span>[<span class="title">MAX_CLIENTS</span>];</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建监听套接字</span></span><br><span class="line">   listen_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)；</span><br><span class="line">    <span class="comment">// 绑定套接字</span></span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    address.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    address.sin_port = htons(PORT);</span><br><span class="line"></span><br><span class="line">    bind(listen_fd, (<span class="keyword">struct</span> sockaddr *)&amp;address, <span class="keyword">sizeof</span>(address)</span><br><span class="line">    listen(listen_fd, <span class="number">3</span>); <span class="comment">// 开始监听</span></span><br><span class="line">    <span class="comment">// 初始化 pollfd 结构</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_CLIENTS; i++) &#123;</span><br><span class="line">        client_fds[i].fd = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    client_fds[<span class="number">0</span>].fd = listen_fd;</span><br><span class="line">    client_fds[<span class="number">0</span>].events = POLLIN;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主循环</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> activity = poll(client_fds, MAX_CLIENTS, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (activity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">//出错处理并退出</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查是否有新的连接</span></span><br><span class="line">        <span class="keyword">if</span> (client_fds[<span class="number">0</span>].revents &amp; POLLIN) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((new_socket = accept(listen_fd, (<span class="keyword">struct</span> sockaddr *)&amp;address, (<span class="type">socklen_t</span>*)&amp;addrlen)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="comment">//出错处理并退出</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加新的套接字到数组</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; MAX_CLIENTS; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (client_fds[i].fd == <span class="number">-1</span>) &#123;</span><br><span class="line">                    client_fds[i].fd = new_socket;</span><br><span class="line">                    client_fds[i].events = POLLIN;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查客户端活动</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; MAX_CLIENTS; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (client_fds[i].fd &gt; <span class="number">0</span> &amp;&amp; (client_fds[i].revents &amp; POLLIN)) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((valread = read(client_fds[i].fd, buffer, BUFFER_SIZE)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    buffer[valread] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                    send(client_fds[i].fd, buffer, valread, <span class="number">0</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    close(client_fds[i].fd);</span><br><span class="line">                    client_fds[i].fd = <span class="number">-1</span>; <span class="comment">// 标记为可用</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>IO 复用之 Epoll</strong></p><p><strong>基本概念</strong>：<br>epoll 是 Linux 系统中一种高效的 I&#x2F;O 事件通知机制，特别适用于处理大量并发网络连接。与传统的 select 或 poll 方法相比，epoll 的独特之处在于其对活跃连接的高效处理能力。它通过维护一个活跃事件集合，避免了对所有文件描述符的遍历，显著提升了性能。这使得 epoll 成为构建高性能网络应用程序的理想选择。</p><p><strong>函数声明</strong></p><p>epoll 主要涉及三个系统调用：epoll_create、epoll_ctl 和 epoll_wait。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// epoll_create：创建一个 epoll 实例。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>;</span><br><span class="line"><span class="comment">// poll_ctl：管理（添加、修改或删除）监视的文件描述符。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">epfd：由 epoll_create 返回的 epoll 实例文件描述符。</span></span><br><span class="line"><span class="comment">op：要执行的操作，如 EPOLL_CTL_ADD（添加）、EPOLL_CTL_MOD（修改）、EPOLL_CTL_DEL（删除）。</span></span><br><span class="line"><span class="comment">fd：关联的文件描述符。</span></span><br><span class="line"><span class="comment">event：指向 epoll_event 结构的指针，指定感兴趣的事件和任何关联的用户数据。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 待在 epoll 文件描述符上注册的事件发生</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event *events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">epfd：epoll 实例的文件描述符。</span></span><br><span class="line"><span class="comment">events：用于从内核获取事件的 epoll_event 结构数组。</span></span><br><span class="line"><span class="comment">maxevents：指示数组中可以返回的最大事件数。</span></span><br><span class="line"><span class="comment">timeout：等待事件的最大时间（毫秒），-1 表示无限等待。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>epoll_event 结构</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span>     events;    <span class="comment">/* Epoll events */</span></span><br><span class="line">    <span class="type">epoll_data_t</span> data;      <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">events 字段用于指定感兴趣的事件类型，例如 EPOLLIN（可读）、EPOLLOUT（可写）等。</span></span><br><span class="line"><span class="comment">data 字段通常用于存储用户定义的数据，如文件描述符、指向对象的指针等。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//epoll_data_t 是一个联合（union），它用于存储用户定义的数据，可以是文件描述符、指针或任何其他用户需要的数据类型。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *ptr;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">uint32_t</span> u32;</span><br><span class="line">    <span class="type">uint64_t</span> u64;</span><br><span class="line">&#125; <span class="type">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">例如，您可以在 epoll_ctl 调用时，使用 epoll_data_t 的 fd 字段来存储正在监视的文件描述符，</span></span><br><span class="line"><span class="comment">或者使用 ptr 字段来存储指向某个对象或结构的指针。这样，在事件发生时，您可以快速访问与该事件相关联的数据。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>Epoll 的两种触发模式</strong>：</p><p>在 Linux 中，epoll 提供了两种触发模式：<strong>水平触发（Level-Triggered, LT）和边缘触发（Edge-Triggered, ET）</strong>。理解这两种模式对于使用 epoll 来说非常关键，因为它们决定了在文件描述符（FD）上发生事件时，epoll 如何通知应用程序。</p><p><strong>水平触发（Level-Triggered, LT）</strong></p><p><strong>触发条件</strong>：只要文件描述符关联的 socket 缓冲区上有数据可读或有空间可写，epoll_wait 就会返回该文件描述符。这意味着，只要有未处理的数据（如缓冲区中还有数据未读），epoll_wait 会不断地通知应用程序去读数据至用户空间缓存，从而进行处理。</p><p><strong>处理方式</strong>：这种模式更加容易处理，因为即使应用程序没有一次性处理所有的可用数据，epoll_wait 会再次通知你该文件描述符上仍有待处理的数据。</p><p><strong>水平触发的优点</strong>：</p><ul><li><p><strong>简单易懂</strong>：水平触发的行为更直观，容易理解和实现，尤其是对于那些不太熟悉非阻塞 I&#x2F;O 编程的开发者。</p></li><li><p><strong>容错性高</strong>：在水平触发模式下，只要文件描述符的状态仍满足条件（如有数据可读），epoll_wait 会持续通知应用程序，减少了因遗漏事件处理导致的错误。</p></li></ul><p><strong>水平触发的缺点</strong>：</p><ul><li><p><strong>可能的性能开销</strong>：在高负载或大量并发连接的情况下，水平触发可能导致频繁的 epoll_wait 响应。因为只要文件描述符仍然处于活跃状态（例如，仍有数据可读），它就会不断地触发事件。</p></li><li><p><strong>资源使用效率</strong>：由于频繁的事件触发，水平触发模式可能导致更高的CPU使用率，尤其是当有大量活跃的文件描述符时。</p></li></ul><p><strong>水平触发示例代码：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line"><span class="type">int</span> epoll_fd, fd;</span><br><span class="line"></span><br><span class="line">event.events = EPOLLIN; <span class="comment">// LT 是默认模式</span></span><br><span class="line">event.data.fd = fd;</span><br><span class="line">epoll_ctl(epoll_fd, EPOLL_CTL_ADD, fd, &amp;event);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件循环</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[<span class="title">MAX_EVENTS</span>];</span></span><br><span class="line">    <span class="type">int</span> n = epoll_wait(epoll_fd, events, MAX_EVENTS, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (events[i].data.fd == fd) &#123;</span><br><span class="line">            <span class="comment">// 可以读取部分数据，即使不全部读取完，该 FD 仍然会再次报告</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>边缘触发（Edge-Triggered, ET）</strong></p><p><strong>触发条件</strong>：只有文件描述符的状态发生改变时，epoll_wait 才会通知应用进程来读写数据（只通知一次），直到文件描述符的状态再次发生变化。</p><p><strong>那什么才是文件描述符的状态发生改变呢？</strong></p><p>文件描述符的状态发生改变指的是 <strong>fd 从不可读的状态改变成可读的状态或者fd 从不可写的状态改变成可写的状态。</strong></p><p><strong>对于 socket 可读事件来说</strong>：</p><p>fd 从不可读的状态改变成可读的状态，简单理解就是：<strong>fd 对应的 socket 接收缓冲区从无数据到有数据。</strong> </p><p><strong>具体点</strong>：就是当数据首次到达一个空的 socket 接收缓冲区时，epoll_wait 会通知应用程序一次。此时，缓冲区状态从“无数据可读”变为“有数据可读”。又或者应用程序开始读取数据，并将缓冲区中的数据读完（读操作返回 EAGAIN），然后又有新数据到达。这两种情况都是属于 socket 接收缓冲区从无数据到有数据的例子。</p><p><strong>再来看个特殊情况：</strong></p><p>在 ET 模式下，一旦应用程序开始读取数据，如果没有一次性将缓冲区中的所有数据都读取完（即仍有未读取的数据留在缓冲区中），此时不会触发新的 epoll_wait 通知。但是如果此时接收缓冲区又来了新数据，即使文件描述符的状态并没有发生改变，但也会触发新的 epoll_wait 通知的。</p><p><strong>对于 socket 可写事件来说</strong>：</p><p>文件描述符的状态发生改变指的是：fd 从不可写的状态改变成可写的状态。简单理解就是：<strong>fd 对应的 socket 发送缓冲区从满到不满。</strong> 对于可写事件，存在以下两个场景：</p><h4 id="场景一：持续有空间"><a href="#场景一：持续有空间" class="headerlink" title="场景一：持续有空间"></a>场景一：持续有空间</h4><p>假设你有一个socket连接，你正在向它发送数据。在边缘触发（ET）模式下：</p><ul><li><strong>初始状态</strong>：连接建立后，发送缓冲区为空，所以你可以开始发送数据。</li><li><strong>持续发送</strong>：只要发送缓冲区有空间，你可以继续发送数据。在这个过程中，如果缓冲区从未真正变满过（即，你的发送速度不超过网络层处理和发送数据的速度），epoll_wait不会因为缓冲区有空间而特别通知你，因为从epoll的角度看，这不是一个“状态变化”。</li></ul><h4 id="场景二：缓冲区满后又有空间"><a href="#场景二：缓冲区满后又有空间" class="headerlink" title="场景二：缓冲区满后又有空间"></a>场景二：缓冲区满后又有空间</h4><p>现在，让我们看一个缓冲区实际变满的情况：</p><p><strong>1.发送直至满</strong>：你继续发送数据，直到达到一个点，发送缓冲区满了，这时，尝试再发送数据会失败（通常返回EAGAIN或EWOULDBLOCK）。</p><p><strong>2.等待可写</strong>：这时，你应该停止发送数据，等待 epoll_wait 通知你 socket 再次可写。</p><p><strong>3.缓冲区部分清空</strong>：随着时间的推移，网络层将缓冲区中的数据发送出去，缓冲区从“满”变为“有空间”（即，部分数据被发送出去，为新数据腾出了空间）。</p><p><strong>4.收到通知</strong>：因为缓冲区的状态从“满”变为“有空间”，这是一个状态变化，epoll_wait 会通知你 socket 现在可写。</p><p><strong>处理方式</strong>：ET 模式要求你必须一次性处理所有可用的数据。如果处理不完全，epoll_wait 不会再次通知你该文件描述符上的事件，除非新的数据到达或再次变为可写。</p><p><strong>边缘触发示例代码：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line"><span class="type">int</span> epoll_fd, fd;</span><br><span class="line"></span><br><span class="line">event.events = EPOLLIN | EPOLLET; <span class="comment">// 启用 ET 模式</span></span><br><span class="line">event.data.fd = fd;</span><br><span class="line">epoll_ctl(epoll_fd, EPOLL_CTL_ADD, fd, &amp;event);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件循环</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[<span class="title">MAX_EVENTS</span>];</span></span><br><span class="line">    <span class="type">int</span> n = epoll_wait(epoll_fd, events, MAX_EVENTS, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (events[i].data.fd == fd) &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">ssize_t</span> count = read(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                <span class="keyword">if</span> (count == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (errno != EAGAIN) &#123;</span><br><span class="line">                        <span class="comment">// 处理非 EAGAIN 错误</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>; <span class="comment">// 没有更多数据可读</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 处理读取的数据</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>边缘触发的优缺点：</strong></p><p><strong>优点：</strong></p><p><strong>减少通知频率：</strong></p><p>在 ET 模式中，epoll_wait 只在文件描述符（如套接字）的状态发生变化时通知一次（例如，从不可读变为可读）。这减少了系统不断检查状态的需要，尤其在管理大量连接时非常有效。</p><p><strong>提高事件处理效率：</strong></p><p>由于减少了频繁的事件通知，应用程序可以更集中地处理每次通知的事件。这在同时处理许多连接时提升了效率。每次事件都得到了充分的处理，而不是浪费资源在重复或不必要的检查上，从而整体提高了处理大量并发连接的效率。</p><p><strong>降低资源占用：</strong></p><p>ET 模式通过减少频繁的事件检查和处理，有助于减少 CPU 和内存的使用，尤其在高负载下。</p><p><strong>更好的扩展性：</strong></p><p>对于需要处理大量并发连接的高性能服务器，ET 模式能够更高效地利用资源，使服务器能够承载更多的连接，从而提升整体的扩展能力。</p><p><strong>缺点：</strong></p><p><strong>处理逻辑更加复杂：</strong></p><p>在 ET 模式下，必须在每次通知时尽可能完整地处理 I&#x2F;O 事件（读取或写入所有数据），因为相同条件下不会再次收到通知。这要求程序能够有效地一次性处理大量数据。</p><p><strong>可能会错过一些数据：</strong></p><p>如果在处理通知时没有完全读取或写入所有数据，剩余的数据可能不会触发新的通知，导致程序错过一些重要数据。</p><p><strong>依赖于非阻塞 I&#x2F;O：</strong></p><p>ET 模式通常和非阻塞 I&#x2F;O 结合使用。在这种模式下，编程变得更复杂，因为需要处理非阻塞调用可能遇到的特殊情况，如 EAGAIN 或 EWOULDBLOCK。</p><p><strong>总结：</strong></p><p><strong>水平触发</strong>：更易于使用和理解，但可能会导致更多的 epoll_wait 调用，尤其是在高负载下。</p><p><strong>边缘触发</strong>：更高的性能潜力，减少了 epoll_wait 调用的次数，但需要更谨慎的缓冲区管理和错误处理。</p><p><strong>Epoll 优缺点</strong></p><p><strong>优点：</strong></p><p><strong>1.高效的文件描述符管理</strong></p><p>在 epoll 中，高效的文件描述符管理首先依赖于高效的数据结构（红黑树和链表）以及回调函数。epoll 使用红黑树来组织所有监控的文件描述符，提供快速的查找、插入和删除操作。链表则用于存储准备就绪的事件，使得 epoll_wait 能迅速返回这些事件。每当监控的文件描述符发生状态变化（例如，socket 上有数据到来）时，与之关联的回调函数被内核自动触发。这些回调函数直接将就绪的文件描述符事件添加到 epoll 的就绪链表中。使得 epoll_wait 快速返回，这种集成了回调机制和高效数据结构的方法，使 epoll 在处理大量并发连接时比传统的 select 和 poll 方法更高效。</p><p>  相比之下，select 和 poll 每次调用时都需要遍历整个文件描述符集合，以检查每个描述符的状态。当文件描述符数量很大时，这种方法的效率显著降低。</p><p><strong>2.更好的可扩展性</strong></p><p>epoll 能够处理的文件描述符数量远超过 select 的 FD_SETSIZE 限制（通常为1024），使其能够更有效地处理成千上万的并发连接。这使 epoll 成为高并发网络应用的理想选择，例如大型网站的服务器。</p><p><strong>3.减少复制操作</strong></p><p>在传统的 select 和 poll 方法中，应用程序需要在每次调用时将整个文件描述符集合从用户空间复制到内核空间，内核处理完后再将结果复制回用户空间。这种来回复制操作效率比较低。</p><p>而在 epoll 中，只需要将就绪事件从内核空间的就绪链表复制到用户空间，而非整个被监控的文件描述符集合。这种机制大大减少了数据在用户空间和内核空间之间频繁来回复制的需求，特别是在只有少数文件描述符就绪的大规模并发连接场景中，显著降低了上下文切换和数据复制的开销，从而提高了整体的效率和性能。</p><p><strong>4.支持边缘触发（ET）和水平触发（LT）</strong></p><ul><li><strong>两种触发模式</strong>：epoll 提供了边缘触发（ET）和水平触发（LT）两种模式。边缘触发仅在文件描述符状态发生变化时通知一次，而水平触发则在描述符保持某状态时持续通知。</li><li><strong>适应不同的使用场景</strong>：<br>这种灵活性使得开发者可以根据具体的应用需求和行为特点选择最合适的模式，以优化性能。</li></ul><p><strong>缺点：</strong></p><p><strong>平台依赖性：</strong> epoll 是 Linux 特有的，不具备 select 和 poll 那样的跨平台特性。这意味着基于 epoll 的应用程序不能在非 Linux 系统上直接运行，限制了其可移植性。</p><p><strong>边缘触发模式的挑战</strong></p><p>在边缘触发（ET）模式下，epoll 只在状态变化时通知一次。这意味着应用程序必须正确处理所有的数据，否则可能会丢失未处理的事件。 </p><p><strong>Epoll 并发回射服务器程序示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_EVENTS 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> READ_BUF_SIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 8080</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> listen_fd, conn_fd, epoll_fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>, <span class="title">events</span>[<span class="title">MAX_EVENTS</span>];</span></span><br><span class="line">    <span class="type">int</span> event_count, i;</span><br><span class="line">    <span class="type">char</span> read_buf[READ_BUF_SIZE];</span><br><span class="line"></span><br><span class="line">    socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    server_addr.sin_port = htons(PORT);</span><br><span class="line">    bind(listen_fd, (<span class="keyword">struct</span> sockaddr *)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr))</span><br><span class="line">    listen(listen_fd, SOMAXCONN)</span><br><span class="line"></span><br><span class="line">    epoll_fd = epoll_create1(<span class="number">0</span>);</span><br><span class="line">    event.events = EPOLLIN;</span><br><span class="line">    event.data.fd = listen_fd;</span><br><span class="line"></span><br><span class="line">    epoll_ctl(epoll_fd, EPOLL_CTL_ADD, listen_fd, &amp;event)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        event_count = epoll_wait(epoll_fd, events, MAX_EVENTS, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; event_count; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (events[i].data.fd == listen_fd) &#123;</span><br><span class="line">                conn_fd = accept(listen_fd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">                <span class="keyword">if</span> (conn_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">                    perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                event.events = EPOLLIN | EPOLLET;</span><br><span class="line">                event.data.fd = conn_fd;</span><br><span class="line">                <span class="keyword">if</span> (epoll_ctl(epoll_fd, EPOLL_CTL_ADD, conn_fd, &amp;event) == <span class="number">-1</span>) &#123;</span><br><span class="line">                    perror(<span class="string">&quot;epoll_ctl&quot;</span>);</span><br><span class="line">                    close(conn_fd);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> nbytes = read(events[i].data.fd, read_buf, READ_BUF_SIZE);</span><br><span class="line">                <span class="keyword">if</span> (nbytes &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    close(events[i].data.fd);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    write(events[i].data.fd, read_buf, nbytes);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(listen_fd);</span><br><span class="line">    close(epoll_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="异步I-O服务器模型"><a href="#异步I-O服务器模型" class="headerlink" title="异步I&#x2F;O服务器模型"></a>异步I&#x2F;O服务器模型</h4><p>在讲述了 I&#x2F;O 多路复用服务器模型后，我们看到它如何使单个进程能够有效地管理多个网络连接。通过 select、poll 或 epoll，进程可以在多个连接上同时等待数据，而无需为每个连接阻塞等待。这种方法提升了并发处理的效率，<strong>但它有一个局限性：一旦某个连接的 I&#x2F;O 操作开始，该进程必须等待该操作完成才能继续处理下一个连接。</strong> 简单理解就是：处理各个连接的 IO 读写是同步的，是串行的。</p><p>为了解决这一问题，引入了异步I&#x2F;O服务器模型。这种模型极大提升了服务器的任务处理能力，它允许进程在发起I&#x2F;O操作后立即转而执行其他工作，而无需等待I&#x2F;O操作的完成。这一过程由操作系统在后台管理，一旦I&#x2F;O操作完成，进程便会收到通知。进程只需要去处理已被拷贝至应用层缓冲区的数据。</p><p><strong>Linux中的异步I&#x2F;O实现</strong>：</p><p>在Linux中，异步 IO 模型主要由 <strong>Linux aio</strong>（通过libaio库）和 <strong>io_uring</strong> 两种技术来实现。</p><p><strong>Linux aio(libaio)</strong></p><p>Linux aio 是 Linux 系统中较早支持的异步I&#x2F;O机制。它通过 libaio 库提供了一系列的API，允许应用程序非阻塞地启动和管理I&#x2F;O操作。当一个I&#x2F;O请求被提交后，libaio负责将其发送到操作系统，应用程序可以继续执行而无需等待。一旦I&#x2F;O操作完成，应用程序将通过回调函数或其他机制得到通知。</p><p><strong>libaio提供的 API</strong> :</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">io_setup       ：创建一个异步I/O上下文。</span><br><span class="line">io_submit      ：向异步I/O上下文提交一个或多个I/O请求。</span><br><span class="line">io_getevents   ：从异步I/O上下文中获取已完成的事件。</span><br><span class="line">io_destroy     ：销毁一个异步I/O上下文。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>尽管 libaio 为异步 I&#x2F;O 提供了基础支持，但它有一定的局限性，<strong>比如：它只适用于文件 I&#x2F;O，并不适合用于网络 I&#x2F;O。</strong></p><p>以下是一个简洁的 libaio 使用示例，演示了如何在 Linux 系统中以异步方式进行文件读取。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libaio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/eventfd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FILE_PATH <span class="string">&quot;example_file.txt&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">io_context_t</span> ctx;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iocb</span> <span class="title">cb</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iocb</span> *<span class="title">cbs</span>[1];</span></span><br><span class="line">    <span class="type">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">    <span class="type">int</span> file_fd, efd, ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_event</span> <span class="title">events</span>[1];</span></span><br><span class="line">    <span class="type">uint64_t</span> u;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;ctx, <span class="number">0</span>, <span class="keyword">sizeof</span>(ctx));</span><br><span class="line">    io_setup(<span class="number">10</span>, &amp;ctx);</span><br><span class="line">    file_fd = open(FILE_PATH, O_RDWR | O_CREAT, <span class="number">0644</span>);</span><br><span class="line">    <span class="comment">// 创建eventfd用于通知</span></span><br><span class="line">    efd = eventfd(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 准备异步读请求</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;cb, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> iocb));</span><br><span class="line">    io_prep_pread(&amp;cb, file_fd, buffer, BUFFER_SIZE, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 设置eventfd作为完成事件的通知</span></span><br><span class="line">    cb.data = (<span class="type">void</span> *)(<span class="type">uintptr_t</span>)efd;</span><br><span class="line">    cbs[<span class="number">0</span>] = &amp;cb;</span><br><span class="line">    <span class="comment">// 提交异步I/O请求</span></span><br><span class="line">    io_submit(ctx, <span class="number">1</span>, cbs)</span><br><span class="line">    <span class="comment">// 在这里，主线程可以执行其他业务逻辑</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    read(efd, &amp;u, <span class="keyword">sizeof</span>(<span class="type">uint64_t</span>));  <span class="comment">// 在主线程中等待通知</span></span><br><span class="line">    io_getevents(ctx, <span class="number">1</span>, <span class="number">1</span>, events, <span class="literal">NULL</span>);  <span class="comment">// 读取异步I/O事件</span></span><br><span class="line">    <span class="comment">// 处理完成的I/O事件</span></span><br><span class="line">    <span class="keyword">if</span>(events[<span class="number">0</span>].data == (<span class="type">void</span> *)(<span class="type">uintptr_t</span>)efd) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Read %zd bytes: %.*s\n&quot;</span>, events[<span class="number">0</span>].res, (<span class="type">int</span>)events[<span class="number">0</span>].res, buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    close(file_fd);</span><br><span class="line">    io_destroy(ctx);</span><br><span class="line">    close(efd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>io_uring</strong>：</p><p>io_uring 是 Linux 内核 5.1 版本引入的全新异步 I&#x2F;O 框架，io_uring 旨在提供一种高效、灵活且功能丰富的方式来执行异步 I&#x2F;O 操作。与 libaio 相比，io_uring 提供了更低的系统调用开销，更简单的接口，以及更好的性能。</p><p><strong>如何工作</strong>：</p><p>io_uring 的核心思想是通过两个队列来管理异步 I&#x2F;O 请求。一个叫做提交队列（SQ），另一个叫完成队列（CQ）。</p><p>1.<strong>提交请求</strong>：当你的程序想要执行一个 I&#x2F;O 操作，比如读取网络数据，它会创建一个请求并把它放到提交队列（SQ）中。</p><p>2.<strong>内核处理</strong>：Linux 内核会查看提交队列，取出请求并处理它们。你的程序不需要等待内核完成这个操作，它可以继续做其他事情。</p><p>3.<strong>完成通知</strong>：一旦内核完成了一个请求，它会把结果放入完成队列（CQ）中。这样程序就知道该操作已经完成，可以继续处理结果了。</p><p><strong>io_uring 的优势：</strong></p><ul><li><strong>性能</strong>：它允许应用程序一次性地批量提交多个 I&#x2F;O 请求，减少了系统调用的数量，所以 io_uring 能够提供比传统的异步 I&#x2F;O 更好的性能。</li><li><strong>减少等待</strong>：应用程序不需要每次提交一个请求就等待结果，它可以继续执行其他任务，同时内核在背后处理这些 I&#x2F;O 请求。</li><li><strong>功能丰富</strong>：io_uring 支持各种类型的 I&#x2F;O 操作，包括但不限于文件读写、网络操作等。</li><li><strong>易用性</strong>：io_uring 提供了一个更为简洁和一致的接口，相比于旧的异步 I&#x2F;O 接口，它更易于使用和理解。</li></ul><p>关于异步 IO 服务器模型的学习，大家只需要理解异步IO的工作方式，以及了解在 Linux 中可以通过 libaio 和 io_uring 技术可以构建异步 IO 服务器模型。如果想深入学习 io_uring 的底层原理，则可以去官网或者谷歌搜索相关资料去深入学习。</p><p><strong>这篇文章，大家可以去了解：</strong><br><a href="https://cloud.tencent.com/developer/article/2187655">https://cloud.tencent.com/developer/article/2187655</a> </p><p><strong>关于具体的代码示例，则可以去了解 liburing 这个库的 example 代码示例</strong>：<a href="https://github.com/axboe/liburing">https://github.com/axboe/liburing</a></p><h3 id="服务器架构模式"><a href="#服务器架构模式" class="headerlink" title="服务器架构模式"></a>服务器架构模式</h3><p>在前面的介绍中，我们了解了常见的服务器模型，但是这些模型在应对高并发场景都会遇到一些挑战，特别是在处理大量并发连接和高效率 I&#x2F;O 操作方面。尽管模型如多线程、线程池和 I&#x2F;O 多路复用提供了并发处理的基础架构，但它们各自都有局限性，特别是在高并发和低延迟要求的场景中。</p><p>这些挑战促使了对一种更高效、更可扩展的并发处理模式的需求— 这就是 Reactor 模式。Reactor 模式采用事件驱动的方法，结合同步 I&#x2F;O 多路复用技术，如 select、poll 或 epoll，提供了一种不同于传统线程模型的并发处理机制。</p><p><strong>为什么需要 Reactor 模式？</strong></p><p><strong>并发和 I&#x2F;O 效率</strong>：传统的多线程和多进程模型在处理成千上万的并发连接时可能会遇到性能瓶颈。这些模型往往涉及重的上下文切换和资源分配，特别是在频繁的 I&#x2F;O 操作下。</p><p><strong>简化事件处理</strong>：在 I&#x2F;O 多路复用模型中，虽然可以高效地监控多个 I&#x2F;O 流，但在事件分发和处理方面往往缺乏组织和结构。Reactor 模式提供了一种清晰的框架来处理多个并发 I&#x2F;O 事件，简化了事件驱动程序的开发。</p><h4 id="Reactor-模式详解"><a href="#Reactor-模式详解" class="headerlink" title="Reactor 模式详解"></a>Reactor 模式详解</h4><p><strong>Reactor 是什么？</strong></p><p>Reactor 模式可以理解为一种在网络编程中常用的设计模式，用于高效地处理多个并发 I&#x2F;O 事件，如用户请求或网络通信。它的核心概念是使用一个中心化的处理器（称为 Reactor）来监控所有的 I&#x2F;O 请求。当一个 I&#x2F;O 事件发生时（例如，新的客户端连接或者数据到达），Reactor 会捕获这个事件，并将其分派给相应的处理程序进行处理。</p><p><strong>核心组件：</strong></p><p><strong>1.Handles (句柄)：</strong></p><p><strong>定义</strong>：句柄是对操作系统资源的引用，通常是<strong>文件描述符</strong>（file descriptor）。在网络编程中，这通常是指代网络套接字（sockets）。</p><p><strong>用途</strong>：它用于标识一个特定的网络连接或其他 I&#x2F;O 资源，如打开的文件、管道等。</p><p><strong>示例</strong>：当一个客户端连接到服务器，服务器会为这个连接创建一个套接字，并为其分配一个文件描述符，这个文件描述符就是一个句柄。</p><p><strong>2.Synchronous Event Demultiplexer (事件多路分发器)：</strong></p><p><strong>定义</strong>：事件多路分发器是负责等待多个句柄上事件发生的组件。它可以同时监控多个句柄，如网络套接字上的可读或可写事件。</p><p><strong>实现</strong>：在 Linux 中，这通常通过系统调用如 select, poll 或 epoll 实现。</p><p><strong>功能</strong>：当一个或多个句柄上发生事件时（例如，新的客户端连接、数据到达等），事件多路分发器通知 Reactor。</p><p><strong>3.Event Handler (事件处理器)：</strong></p><p><strong>定义：</strong> 它是一个定义了处理不同类型事件所需接口或协议的抽象概念。通常包含一系列的方法或函数，用于处理各种事件，如读取数据（可读事件）、写入数据（可写事件）或处理错误（错误事件）。事件处理器定义了在发生特定事件时应当调用哪些方法，但不涉及这些方法的具体实现。</p><p><strong>例如：</strong> 一个事件处理器接口可能有一个 handle_read 方法用于处理可读事件，但它并不实现该方法。</p><p><strong>4.Concrete Event Handlers (具体事件处理器)：</strong></p><p><strong>定义：</strong> 具体事件处理器实现了定义在事件处理器接口中的所有方法，提供了如何处理特定事件的具体逻辑。</p><p>例如，一个具体事件处理器可能实现 handle_read 方法来从套接字中读取数据并处理这些数据。又或者实现 handle_accept 方法来处理客户端的连接请求。</p><p>具体事件处理器是实际工作的组件，每个具体的事件处理器实例通常与应用程序中的一个特定资源（一个socket 文件描述符）关联。</p><p><strong>5.Initiation Dispatcher (初始化分发器)：</strong></p><p><strong>定义</strong>：初始化分发器是 Reactor 模式的核心组件，负责管理事件循环、监听事件并将它们分发到相应的具体事件处理器。</p><p><strong>职责</strong>：它初始化事件多路分发器，注册事件处理器，并在事件发生时调用相应的具体事件处理器。</p><p><strong>事件循环</strong>：在整个应用程序的生命周期内，初始化分发器运行一个循环，等待和分发事件。</p><p><strong>select 实现的 Reactor 网络服务器程序</strong></p><p>这里只是提供一个简单示例，但以上的5个组件都包含。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 8080</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_CLIENTS 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">handler_t</span> handlers[MAX_CLIENTS];</span><br><span class="line"><span class="type">int</span> num_clients = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">handler_t</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> handle; <span class="comment">//句柄：在我们的上下文中就是套接字描述符。</span></span><br><span class="line">    <span class="type">void</span> (*handle_func)(<span class="type">int</span> handle, <span class="type">void</span> *arg);  <span class="comment">//事件处理器</span></span><br><span class="line">&#125; <span class="type">handler_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体事件处理器 ： 处理客户端的连接请求</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">acceptor_handler_func</span><span class="params">(<span class="type">int</span> handle, <span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> client_len = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line">    <span class="type">int</span> client_fd = accept(handle, (<span class="keyword">struct</span> sockaddr*)&amp;client_addr, &amp;client_len);</span><br><span class="line">    <span class="keyword">if</span> (client_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Accepted connection from %s\n&quot;</span>, inet_ntoa(client_addr.sin_addr));</span><br><span class="line">    <span class="comment">// 将新客户端加入到 handlers 中</span></span><br><span class="line">    handlers[num_clients].handle = client_fd;</span><br><span class="line">    handlers[num_clients].handle_func = client_handler_func;</span><br><span class="line">    num_clients++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体事件处理器：处理客户端的数据处理请求</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">client_handler_func</span><span class="params">(<span class="type">int</span> handle, <span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="type">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">    <span class="type">int</span> nbytes = recv(handle, buffer, <span class="keyword">sizeof</span>(buffer), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nbytes &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        close(handle);</span><br><span class="line">        <span class="comment">// 将handle从handlers数组中移除</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_clients; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (handlers[i].handle == handle) &#123;</span><br><span class="line">                handlers[i] = handlers[num_clients - <span class="number">1</span>];</span><br><span class="line">                num_clients--;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        send(handle, buffer, nbytes, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">event_demultiplexer</span><span class="params">()</span> &#123;</span><br><span class="line">    fd_set read_fds;</span><br><span class="line">    <span class="type">int</span> fd_max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    FD_ZERO(&amp;read_fds);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_clients; i++) &#123;</span><br><span class="line">        FD_SET(handlers[i].handle, &amp;read_fds);</span><br><span class="line">        <span class="keyword">if</span> (handlers[i].handle &gt; fd_max) &#123;</span><br><span class="line">            fd_max = handlers[i].handle;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待 socket 上的可读事件</span></span><br><span class="line">    <span class="keyword">if</span> (select(fd_max + <span class="number">1</span>, &amp;read_fds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;select&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分发事件</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_clients; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(handlers[i].handle, &amp;read_fds)) &#123;</span><br><span class="line">            handlers[i].handle_func(handlers[i].handle, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Initiation Dispatcher (初始化分发器)</span></span><br><span class="line"><span class="comment">Initiation Dispatcher 是 Reactor 模式的核心，允许应用程序注册事件、注销事件。并且它负责启动事件循环，等待事件并分发事件。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">run_reactor</span><span class="params">(<span class="type">int</span> listen_fd)</span> &#123;</span><br><span class="line">    <span class="comment">// 注册事件</span></span><br><span class="line">    handlers[num_clients].handle = listen_fd;</span><br><span class="line">    handlers[num_clients].handle_func = acceptor_handler_func;</span><br><span class="line">    num_clients++;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 启动事件循环</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        event_demultiplexer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> listen_fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    listen_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_port = htons(PORT);</span><br><span class="line">    server_addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    bind(listen_fd, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr);</span><br><span class="line">    listen(listen_fd, <span class="number">10</span>);</span><br><span class="line">  </span><br><span class="line">    run_reactor(listen_fd);</span><br><span class="line">    close(listen_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于 <strong>epoll</strong> 的高效性，我们一般会基于 epoll 去实现 reactor。<strong>具体实现可参考这篇文章：</strong><br><a href="https://zhuanlan.zhihu.com/p/539556726">https://zhuanlan.zhihu.com/p/539556726</a></p><p><strong>Reactor 事件处理流程</strong></p><p>下面通过时序图来图示上述代码的执行过程，方便大家理解：</p><p><img src="https://files.mdnice.com/user/48364/f391c36e-06d8-4b15-9eb6-8a9704679a70.png"></p><h4 id="Reactor-模式的优势和应用场景"><a href="#Reactor-模式的优势和应用场景" class="headerlink" title="Reactor 模式的优势和应用场景"></a>Reactor 模式的优势和应用场景</h4><p><strong>Reactor 模式的主要优势包括：</strong></p><ul><li><strong>高效的资源利用</strong>：<br>通过单线程或少量线程来管理多个并发连接，减少了线程上下文切换和资源消耗，提高了资源利用效率。</li><li><strong>快速响应能力</strong>：<br>非阻塞和事件驱动机制确保了快速响应外部事件，提高了程序的响应速度。</li><li><strong>更好的可扩展性</strong>：<br>能够处理成千上万的并发连接，而不会遇到传统多线程或多进程模型中线程资源限制的问题。</li></ul><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>这种模式特别适合于需要高并发处理的网络服务器，如 Web 服务器、数据库服务器等。</p><p><strong>结论：</strong><br>Reactor 模式是现代高性能网络编程的基石之一。它通过事件驱动和非阻塞 I&#x2F;O 机制有效地解决了传统并发模型在高并发环境下的限制，为构建可扩展的网络应用提供了强大的工具。</p><h4 id="Proactor-模式详解"><a href="#Proactor-模式详解" class="headerlink" title="Proactor 模式详解"></a>Proactor 模式详解</h4><p>在前面的讲解中，我们探讨了 Reactor 模式。该模式主要依赖于同步 I&#x2F;O，然而，随着并发需求的增加，尤其在高负载环境下，同步 I&#x2F;O 的局限性逐渐凸显。</p><p>应对这一挑战，异步编程模型的 <strong>Proactor 模式</strong>提供了一种全新的解决方案。它区别于 Reactor 的同步等待，转而采用<strong>完全异步的 I&#x2F;O 操作</strong>。在这个模式下，应用程序无需在 I&#x2F;O 完成前等待，而是在 I&#x2F;O 完成后接收通知。Proactor 模式有效减少了等待时间，提高了对并发连接的处理效率，尤其适合于构建<strong>高性能</strong>、<strong>I&#x2F;O 密集型</strong>的网络应用。这一模式不仅提升了性能，也代表了网络编程范式的一次重要转变，为开发高效和可扩展的网络服务提供了新思路。</p><p><strong>Proactor 是什么？</strong></p><p>Proactor 模式是一种高级的异步编程模型，用于处理 I&#x2F;O 操作。与传统的同步 I&#x2F;O 操作（如 Reactor 模式）不同，Proactor 模式允许应用程序在不阻塞主执行线程的情况下执行 I&#x2F;O 操作。应用程序发起异步 I&#x2F;O 请求后可以继续执行其他任务，而无需阻塞等待 I&#x2F;O 操作的完成。当 I&#x2F;O 操作实际完成时，操作系统会通知应用程序，并触发预定义的回调函数或事件处理程序来处理 I&#x2F;O 操作的结果。</p><p><strong>核心组件</strong></p><p><strong>异步操作对象：</strong> 该对象代表了单个的异步 I&#x2F;O 操作，如异步读取或写入。它 们通常封装了操作的细节，如操作类型、目标资源(文件描述符)、缓冲区地址等。</p><p><strong>异步操作对象的定义</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    ADD_TYPE_ACCEPT,</span><br><span class="line">    ADD_TYPE_READ,</span><br><span class="line">    ADD_TYPE_WRITE</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_data</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> type; <span class="comment">// ADD_TYPE_ACCEPT, ADD_TYPE_READ, ADD_TYPE_WRITE 等</span></span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">size_t</span> bytes_read;</span><br><span class="line">    <span class="type">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p><strong>Proactor 初始器（Proactor Initiator）</strong> ：<br>Proactor 初始器是负责启动和配置异步 I&#x2F;O 操作流程的组件。它通常由用户空间的代码执行，负责准备和提交异步 I&#x2F;O 请求到内核。</p><p>在 io_uring 中，Proactor 初始器 对应的是用户空间代码，特别是负责初始化 io_uring 实例、以及提交异步 I&#x2F;O 请求到内核的逻辑。</p><p><strong>来看下在 io_uring 中， Proactor Initiator 的代码示例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化 io_uring实例</span></span><br><span class="line"><span class="type">int</span> ret = io_uring_queue_init(<span class="number">256</span>, &amp;ring, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交一个异步读取请求</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">submit_async_read</span><span class="params">(<span class="keyword">struct</span> io_uring *ring, <span class="type">int</span> fd)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_data</span> *<span class="title">data</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span>  io_data));</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> *<span class="title">sqe</span>  =</span> io_uring_get_sqe(ring); </span><br><span class="line">    data-&gt;fd = fd;</span><br><span class="line">    data-&gt;type = ADD_TYPE_READ;</span><br><span class="line">    io_uring_prep_read(sqe, fd, data-&gt;buffer, BUFFER_SIZE, <span class="number">0</span>);      <span class="comment">// 准备读取请求</span></span><br><span class="line">    io_uring_sqe_set_data(sqe, data); <span class="comment">// 设置用户数据</span></span><br><span class="line">    io_uring_submit(ring);  <span class="comment">// 提交请求</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>异步操作处理器（Asynchronous Operation Processor）</strong>：<br>异步操作处理器是 Proactor 模式的核心，在内核中执行，负责启动异步 I&#x2F;O 操作并在操作完成时通知用户空间的 Proactor 实例。</p><p>在 io_uring 中，异步操作处理器 实际上是 io_uring 的内核组件。这包括提交队列（SQ）和完成队列（CQ），以及内核中负责处理这些队列的逻辑。</p><p><strong>完成处理器（Completion Handler）</strong></p><p>完成处理器是由应用程序定义的回调函数，它们在异步 I&#x2F;O 操作完成时被调用以处理 I&#x2F;O 操作的结果。</p><p>在 io_uring 中，完成处理器 对应于那些被提交到 io_uring 并在 I&#x2F;O 操作完成后执行的回调函数。这些回调函数处理 io_uring 从完成队列中获取的 CQEs(多个完成队列条目)。</p><p><strong>异步读取回调函数代码示例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">handle_read</span><span class="params">(<span class="keyword">struct</span> io_uring *ring, <span class="keyword">struct</span> io_uring_cqe *cqe)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_data</span> *<span class="title">data</span> =</span> io_uring_cqe_get_data(cqe);</span><br><span class="line">    <span class="keyword">if</span> (!data) &#123;</span><br><span class="line">        <span class="keyword">return</span>;  <span class="comment">// 数据为空则直接返回</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cqe-&gt;res &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 客户端断开连接或读取错误</span></span><br><span class="line">        close(data-&gt;fd);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 读取数据，准备回写(data-&gt;buffer缓冲区已经有数据了)</span></span><br><span class="line">        data-&gt;bytes_read = cqe-&gt;res;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Received: %.*s\n&quot;</span>, (<span class="type">int</span>)data-&gt;bytes_read, data-&gt;buffer);</span><br><span class="line">        <span class="comment">// 可以在这里添加写回逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(data);  <span class="comment">// 释放内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Proactor 实例</strong>：<br>Proactor 实例是负责管理整个异步 I&#x2F;O 流程的组件，它管理着异步操作处理器和完成处理器，调度完成处理器，并处理所有的异步事件。</p><p>在 io_uring 中，Proactor 实例 对应的是用户空间中维护 io_uring 接口和逻辑的部分，<strong>其实就是一个事件循环</strong>，它负责监控完成队列（CQ），确定哪些 I&#x2F;O 操作已经完成，并触发相应的完成处理器。</p><p><strong>Proactor 实例代码示例：</strong></p><pre><code class="c">// 运行事件循环以处理异步 I/O 操作void run_io_uring_loop(struct io_uring *ring) &#123;    struct io_uring_cqe *cqe;    unsigned head;    while (1) &#123;        // 提交所有挂起的请求并等待至少一个请求完成        io_uring_submit_and_wait(ring, 1);        // 处理所有已完成的事件        io_uring_for_each_cqe(ring, head, cqe) &#123;            if (cqe-&gt;res &lt; 0) &#123;                fprintf(stderr, &quot;IO operation failed: %s\n&quot;, strerror(-cqe-&gt;res));            &#125; else &#123;                handle_read(ring, cqe); // 调用完成处理器            &#125;            // 标记该事件已处理            io_uring_cqe_seen(ring, cqe);        &#125;    &#125;&#125;</code></pre><p><strong>Proactor 事件处理流程</strong></p><p><strong>启动异步操作（Proactor 初始器）</strong>：</p><p>你的程序（通过 Proactor 初始器）准备一个异步 I&#x2F;O 操作，比如说读取文件或接收网络数据。这个准备过程涉及指定要进行的操作类型（例如读取或写入）、哪个文件或网络连接，以及数据存放的位置。</p><p>一旦准备好，这个异步操作被提交给操作系统。如果使用 io_uring，这意味着将操作请求放入 io_uring 的提交队列（SQ）。操作系统内核处理异步操作（由异步操作处理器执行）。</p><p>一旦异步操作被提交，操作系统接管这个任务。在 io_uring 中，内核会处理这些 I&#x2F;O 请求。<strong>与此同时，你的程序可以继续执行其他任务，不必等待 I&#x2F;O 操作完成。</strong></p><p><strong>通知 Proactor实例</strong> ：</p><p>当操作系统完成了一个异步 I&#x2F;O 操作，它会将此操作的结果放入完成队列（CQ）。</p><p>你的程序中的 Proactor 实例会定期检查这个完成队列，看看是否有任何操作已经完成。</p><p><strong>处理完成的操作（完成处理器）：</strong></p><p>对于每一个已经完成的操作，Proactor 实例会调用相应的完成处理器。完成处理器是你事先定义好的，专门用来处理异步操作完成后的数据的函数。比如说，如果操作对象是网络套接字，处理器可能会处理读取到的数据。</p><p><strong>清理和准备下一步操作</strong>：</p><p>一旦完成处理器运行完毕，Proactor 实例会进行必要的清理工作，并准备接收和处理更多的完成事件。</p><p><strong>总结一下</strong>：Proactor 模式允许你的程序异步地执行 I&#x2F;O 操作，同时继续进行其他任务。操作系统在后台处理这些 I&#x2F;O 请求，当它们完成时，你的程序会得到通知，并调用相应的回调函数来处理结果。这个过程优化了资源的使用，提高了应用程序的响应性和效率。</p><h4 id="Proactor-模式的优势"><a href="#Proactor-模式的优势" class="headerlink" title="Proactor 模式的优势"></a>Proactor 模式的优势</h4><p><strong>完全的异步处理：</strong></p><p>Proactor 模式实现了真正的异步 I&#x2F;O。在 Proactor 模式中，所有的 I&#x2F;O 操作（包括读写）都是异步完成的。这意味着应用程序可以在 I&#x2F;O 操作进行时继续执行其他任务，而无需等待 I&#x2F;O 操作的完成。<br>相比之下，Reactor 模式通常只能异步地处理 I&#x2F;O 请求的准备阶段（例如等待数据到达或可发送状态），而实际的读写操作仍然是同步进行的。</p><p><strong>减少线程阻塞：</strong></p><p>在 Proactor 模式中，由于 I&#x2F;O 操作完全异步，应用程序线程不会因等待 I&#x2F;O 操作而阻塞，这对于保持高性能和响应性是非常重要的。<br>Reactor 模式虽然减少了直接的 I&#x2F;O 等待（例如等待数据到达），但在处理数据时仍然可能出现阻塞（如：数据处理操作耗时较长）。</p><p><strong>简化编程模型：</strong></p><p>Proactor 模式通过预定义的回调或事件处理器简化了异步 I&#x2F;O 的编程模型，使得代码更加清晰和易于维护。<br>在 Reactor 模式中，编程者需要显式处理 I&#x2F;O 事件的分发和响应，可能导致更复杂的事件处理逻辑。</p><h4 id="Proactor-模式的应用场景"><a href="#Proactor-模式的应用场景" class="headerlink" title="Proactor 模式的应用场景"></a>Proactor 模式的应用场景</h4><p><strong>高性能网络服务器</strong>：</p><p>如 Web 服务器、数据库服务器等，特别是在需要处理大量并发网络请求的场景。</p><p><strong>文件 I&#x2F;O 密集型应用</strong>：</p><p>例如日志处理、大数据分析，以及任何需要频繁读写大型文件的应用。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在本系列文章中，我们深入探讨了Linux下的套接字编程，一个在网络通信中不可或缺的核心技术-<strong>套接字</strong>。套接字作为网络通信的基石，使得不同主机间的数据交换变得可能。</p><p><strong>套接字的本质</strong></p><p>我们首先解析了套接字的概念，它是支持TCP&#x2F;IP网络通信的基础API，为应用层与网络层之间提供了一个抽象层。通过套接字，应用程序可以不用关心底层的网络细节，就能进行网络通信。</p><p><strong>套接字类型</strong></p><p>接着，我们探讨了<strong>套接字的三种基本类型</strong>：</p><ul><li><strong>流式套接字（SOCK_STREAM</strong>）：提供序列化的、可靠的、双向的连接通信。</li><li><strong>数据报套接字（SOCK_DGRAM）</strong>：提供非连接的、不可靠的通信。</li><li><strong>原始套接字（SOCK_RAW）</strong>：允许直接访问底层协议，用于需要细粒度控制的场景。</li></ul><p><strong>关键API与结构</strong></p><p>我们详细介绍了套接字编程中的关键API，如 <strong>socket、bind、listen、accept、connect以及send和recv函数</strong>，以及套接字地址结构（如sockaddr）和地址转换API，这些是进行套接字编程的基础。</p><p><strong>数据处理</strong></p><p>字节序转换API的讨论，帮助我们处理跨平台的数据一致性问题。</p><p><strong>Linux的IO模型</strong></p><p>本系列文章还覆盖了Linux系统中的多种IO模型，包括阻塞IO、非阻塞IO、I&#x2F;O多路复用、信号驱动IO和异步IO，它们各有优势，适用于不同的场景。</p><p><strong>网络I&#x2F;O性能优化</strong></p><p>在网络I&#x2F;O性能优化部分，我们讨论了<strong>硬件优化和软件优化</strong>策略，强调了应用程序设计的重要性和内核参数调整的作用。</p><p><strong>服务器模型</strong></p><p>最后，我们探讨了 Linux 环境下常见的服务器模型，包括单进程、多进程、多线程、线程池和I&#x2F;O多路复用模型以及异步I&#x2F;O服务器模型，每种模型都有其应用场景和优缺点。</p><p><strong>架构模式</strong></p><p>服务器架构模式，如 <strong>Reactor</strong> 和 <strong>Proactor</strong>，提供了高效处理并发网络事件的方法，是构建高性能网络应用的关键。</p><p><strong>至此：</strong> 我们已经探索了 Linux 网络编程的核心领域，涵盖了从基本套接字类型与 API 的使用，到复杂的 I&#x2F;O 模型和服务器架构设计等关键知识点。这些内容构成了搭建高可用网络服务的基础框架。本篇文章主要是帮助大家提供一个清晰的 Linux 网络编程学习指南，希望这篇文章能够为你们学习编程提供帮助。</p><p>如果你对 <strong>Linux 网络编程</strong>有更深的兴趣，或者<strong>想要探索更多关于Linux编程、以及计算机基础相关的知识，不妨关注我的公众号「跟着小康学编程」</strong>。这里不仅有丰富的学习资源，还有持续更新的技术文章。</p><p><img src="https://files.mdnice.com/user/48364/36723102-908b-438f-9fda-c776eb83e2d4.png"></p><p>另外，小康最近创建了一个技术交流群，专门用来探讨技术相关或者解答读者的问题。大家在阅读这篇文章的时候，如果觉得有问题的或者有不理解的知识点，欢迎大家加群或者评论区询问。我能够解决的，尽量给大家回复。</p><p><img src="https://files.mdnice.com/user/48364/f65058cf-a987-4229-84b0-3fe005838a52.png"></p>]]></content>
      
      
      <categories>
          
          <category> Linux网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux网络编程 </tag>
            
            <tag> Linux 网络I/O模型 </tag>
            
            <tag> Linux 服务器模型 </tag>
            
            <tag> Linux 网络IO性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跟着小康学编程</title>
      <link href="/xiaokangvx/"/>
      <url>/xiaokangvx/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康！</p><p>🌟 如果你对计算机编程感兴趣，想要从基础到进阶系统地学习编程语言和技术，那么你来对地方了！<strong>「跟着小康学编程」</strong>是你的最佳起点！</p><p>👨‍💻 这里是你的一站式编程学习平台，内容涵盖：</p><ul><li><strong>C&#x2F;C++、Java、Go 语言</strong>：无论你是初学者还是希望深化技能的开发者，这里都有适合你的资源。</li><li><strong>计算机基础</strong>：全面理解计算机基本原理，包括操作系统、算法、数据结构、网络和数据库。</li><li><strong>Linux系统和网络编程</strong>：掌握操作系统的核心技术和网络编程的高级技巧。</li><li><strong>MySQL数据库技术</strong>：学习如何利用MySQL进行高效的数据存储和复杂的数据管理。</li><li><strong>Redis高速缓存</strong>：掌握Redis在高速数据处理和缓存方面的应用，让你的应用运行得更快。</li><li><strong>RabbitMQ消息队列</strong>：了解RabbitMQ的高效消息传递机制，确保应用组件间的数据一致性和可靠性。</li><li><strong>微服务架构</strong>：探索将复杂应用分解为更小、更易管理的微服务的策略，使整个应用更容易管理和扩展。</li><li><strong>容器技术</strong>：深入Docker和Kubernetes，掌握现代容器化和自动化部署的关键技术</li><li><strong>未完待续</strong>。。。</li></ul><p>目前，公众号只提供了上述提到的部分技术文章。其他技术相关文章后续会依次补上。<strong>目标就是：为广大编程爱好者提供更加全面的编程指南。</strong></p><p>另外，后续也会增加计算机编程各个领域的面试题，包括：C&#x2F;C++、Java、Go、以及操作系统、计算机网络以及数据结构等面试题。为大家面试提供帮助。</p><p><strong>总之：本号的定位就是 C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习 + 计算机基础原理 + Linux编程 + 容器技术等。</strong> 文章尽可能的通俗易懂，而且文章都会有代码示例，方便初学者理解，有兴趣的朋友可以关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p><br><br> </p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/gzh.png"></p><p><br><br> </p><p><strong>注</strong>：上面提到的计算机学习资料包括<strong>C&#x2F;C++、Java、Go语言，计算机组成原理、操作系统、数据结构与算法、计算机网络以及 Linux 系统编程和网络编程、Linux 内核、数据库</strong>等书籍的电子档 pdf。</p><p><br><br> </p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p><br><br> </p><p>另外，小康最近创建了一个技术交流群，专门用来探讨技术相关或者解答读者的问题。大家在阅读技术文章的时候，如果觉得有问题的或者有不理解的知识点，欢迎大家加群询问。我能够解决的，尽量给大家回复。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 小康的联系方式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 我的公众号 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何快速注册 OpenAI 账号</title>
      <link href="/register/"/>
      <url>/register/</url>
      
        <content type="html"><![CDATA[<h1 id="一分钟教你快速注册-OpenAI-账号"><a href="#一分钟教你快速注册-OpenAI-账号" class="headerlink" title="一分钟教你快速注册 OpenAI 账号"></a>一分钟教你快速注册 OpenAI 账号</h1><h4 id="首先，你必须得能科学上网（能够正常访问谷歌），即可注册。"><a href="#首先，你必须得能科学上网（能够正常访问谷歌），即可注册。" class="headerlink" title="首先，你必须得能科学上网（能够正常访问谷歌），即可注册。"></a>首先，你必须得能科学上网（能够正常访问谷歌），即可注册。</h4><p>（如果还不会科学上网，可以用这个： <a href="https://www.52xcjs.xyz/auth/register">科学稳定访问 openai</a>)</p><h2 id="快速注册步骤："><a href="#快速注册步骤：" class="headerlink" title="快速注册步骤："></a>快速注册步骤：</h2><p>国内的邮箱都不再允许注册 ChatGPT，建议申请一个免费的海外邮箱 Proton 来注册，其他海外邮箱，如 Gmail 也可以，但是注册难度高一些，步骤繁琐。</p><h3 id="第一步：注册-proton-邮箱"><a href="#第一步：注册-proton-邮箱" class="headerlink" title="第一步：注册 proton 邮箱"></a>第一步：注册 proton 邮箱</h3><h4 id="1-1-访问-proton"><a href="#1-1-访问-proton" class="headerlink" title="1.1 访问 proton"></a>1.1 访问 proton</h4><p><a href="https://proton.me/">https://proton.me/</a></p><p>选择右上角的 「Create a free account」</p><p><img src="/images/%E6%B3%A8%E5%86%8COpenAI%E8%B4%A6%E5%8F%B7/001.png"></p><h4 id="1-2-选择免费套餐"><a href="#1-2-选择免费套餐" class="headerlink" title="1.2 选择免费套餐"></a>1.2 选择免费套餐</h4><p><img src="/images/%E6%B3%A8%E5%86%8COpenAI%E8%B4%A6%E5%8F%B7/002.png"></p><h4 id="1-3-选择邮箱后缀，设置用户名和密码"><a href="#1-3-选择邮箱后缀，设置用户名和密码" class="headerlink" title="1.3 选择邮箱后缀，设置用户名和密码"></a>1.3 选择邮箱后缀，设置用户名和密码</h4><p>推荐选择 proton.me</p><p><img src="/images/%E6%B3%A8%E5%86%8COpenAI%E8%B4%A6%E5%8F%B7/003.png"></p><h4 id="1-4-通过真人验证"><a href="#1-4-通过真人验证" class="headerlink" title="1.4 通过真人验证"></a>1.4 通过真人验证</h4><p>依次拖动验证码，然后下一步即可</p><p><img src="/images/%E6%B3%A8%E5%86%8COpenAI%E8%B4%A6%E5%8F%B7/004.png"></p><p><img src="/images/%E6%B3%A8%E5%86%8COpenAI%E8%B4%A6%E5%8F%B7/005.png"></p><p><strong>注册完后，可以去登陆邮箱</strong>，方便接收验证码：</p><p><a href="https://proton.me/">https://proton.me/</a></p><h3 id="第二步：注册-OpenAI-账号"><a href="#第二步：注册-OpenAI-账号" class="headerlink" title="第二步：注册 OpenAI 账号"></a>第二步：注册 OpenAI 账号</h3><h4 id="2-1-首先打开-OpenAI-的账户注册页面，然后输入-proton-邮箱。"><a href="#2-1-首先打开-OpenAI-的账户注册页面，然后输入-proton-邮箱。" class="headerlink" title="2.1 首先打开 OpenAI 的账户注册页面，然后输入 proton 邮箱。"></a>2.1 首先打开 OpenAI 的账户注册页面，然后输入 proton 邮箱。</h4><p><a href="https://chat.openai.com/">https://chat.openai.com/</a></p><p><img src="/images/%E6%B3%A8%E5%86%8COpenAI%E8%B4%A6%E5%8F%B7/006.png"></p><p><img src="/images/%E6%B3%A8%E5%86%8COpenAI%E8%B4%A6%E5%8F%B7/007.png"></p><h4 id="2-2-接着设置-OpenAi-密码-如下就是你的-openai-账号和密码"><a href="#2-2-接着设置-OpenAi-密码-如下就是你的-openai-账号和密码" class="headerlink" title="2.2 接着设置 OpenAi 密码(如下就是你的 openai 账号和密码)"></a>2.2 接着设置 OpenAi 密码(如下就是你的 openai 账号和密码)</h4><p><img src="/images/%E6%B3%A8%E5%86%8COpenAI%E8%B4%A6%E5%8F%B7/008.png"></p><p>  <br><br><br>点击继续，接着点击 Resend email <br><br> </p><p><img src="/images/%E6%B3%A8%E5%86%8COpenAI%E8%B4%A6%E5%8F%B7/009.png"></p><p>  <br><br><br>接着验证邮箱，去 Proton.me 收件箱里点击「Verify email address」即可。<br><br> </p><p><img src="/images/%E6%B3%A8%E5%86%8COpenAI%E8%B4%A6%E5%8F%B7/010.png"><br><br><br><br>然后提供你的名和姓及生日，并点击 <strong>Agee</strong> 即可。</p>]]></content>
      
      
      <categories>
          
          <category> ChatGPT </category>
          
          <category> OpenAI 账号注册 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenAI 账号注册 </tag>
            
            <tag> ChatGPT </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
