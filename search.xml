<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Redis 架构解析：从主从复制到哨兵和集群模式</title>
      <link href="/RedisCluster/"/>
      <url>/RedisCluster/</url>
      
        <content type="html"><![CDATA[<p>大家好，我是小康，今天我们来聊下 Redis 的几种架构模式，包括<strong>主从复制、哨兵和集群模式</strong>。</p><h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>设想一下，你的咖啡馆在城市中太受欢迎，导致每天都人满为患。为了缓解这种压力，你决定在其他地方开设分店，这样顾客就可以在附近的分店享受咖啡，而不必涌向一个地方，这就好比 Redis 的主从复制，让数据备份并允许多个地方进行读取。</p><p>但这还不够，因为你需要确保当主要的咖啡馆遇到问题时，例如突然断电，有其他分店能够迅速接手，成为新的主要店铺，继续为顾客提供服务。这就像 Redis 的哨兵系统，它会自动检测故障并进行转移，确保服务始终在线。</p><p>最后，随着咖啡馆连锁店的增长，每家店都开始独立运作，甚至可能有自己的特色饮品和优惠活动，同时仍然保持整体的协调和一致性。这就是 Redis 集群的工作方式，它将数据分片到不同的节点，每个节点都可以独立处理请求，但都是整个系统的一部分。</p><p>现在，让我们深入探讨 Redis 如何通过<strong>主从复制、哨兵和集群</strong>来确保它的强大性能和高可靠性。</p><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p><img src="/images/RedisCluster/1.png"></p><h3 id="主从复制基本概念"><a href="#主从复制基本概念" class="headerlink" title="主从复制基本概念"></a>主从复制基本概念</h3><p>在日常工作中，我们都知道团队合作的重要性。就像团队中有领导者和执行者，Redis 也采用了一种类似的策略 —<strong>主从复制</strong>，使其能够更有效地处理数据。</p><h4 id="什么是主从复制？"><a href="#什么是主从复制？" class="headerlink" title="什么是主从复制？"></a>什么是主从复制？</h4><p>主从复制是一种允许多个 Redis 服务器（节点）协同工作的策略。其中，一个服务器作为“主节点”，负责接受所有写操作。其他服务器则作为“从节点”，复制并存储主节点的数据。这样，从节点可以为读操作服务，从而分散主节点读取压力。</p><h4 id="简单图示"><a href="#简单图示" class="headerlink" title="简单图示:"></a>简单图示:</h4><p><img src="/images/RedisCluster/02.png"></p><h3 id="主从复制的工作原理"><a href="#主从复制的工作原理" class="headerlink" title="主从复制的工作原理"></a>主从复制的工作原理</h3><p>Redis 的主从复制功能使得一个或多个从节点可以复制一个主节点的全部数据。主节点负责进行写操作，而从节点则可以用来进行读操作，从而分担读的负载。</p><h4 id="主从复制流程图"><a href="#主从复制流程图" class="headerlink" title="主从复制流程图"></a>主从复制流程图</h4><p><img src="/images/RedisCluster/03.png"></p><p><strong>步骤说明:</strong></p><p>从节点首先执行 <code>REPLICAOF ip port</code> 命令，准备复制主节点的数据。</p><p><strong>第一步：连接与同步请求</strong></p><ul><li><p>从节点与主节点建立 TCP 连接，并正式请求同步数据，发送 PSYNC ? -1。</p></li><li><p>主节点接收到请求后，向从节点回复 FULLRESYNC runid offset ，做好开始传输 RDB 数据的准备。</p></li></ul><p><strong>第二步: RDB 文件同步</strong></p><ul><li><p>主节点执行 bgsave 命令，生成当前数据的快照—也就是 RDB 文件。</p></li><li><p>主节点随后将这个 RDB 文件传输给从节点。</p></li><li><p>从节点收到 RDB 文件后，开始加载到自己的数据库中。</p></li></ul><p><strong>第三步 : 持续命令同步</strong></p><ul><li><p>之后，每当主节点有新的写命令，它都会立即传输给从节点并同时将新命令追加到复制缓冲区中。</p></li><li><p>从节点持续接收并执行这些命令，确保与主节点的数据始终保持同步。</p></li></ul><h4 id="断线重连与部分同步"><a href="#断线重连与部分同步" class="headerlink" title="断线重连与部分同步"></a>断线重连与部分同步</h4><p>在实际应用中，因为网络不稳定、系统资源限制等因素，Redis 主从节点间的连接有时会遭遇中断。为了应对这些突发情况并确保数据同步不被中断，Redis  设计了一套智能的同步恢复机制: <strong>部分同步</strong>。</p><p><strong>断线重连与部分同步流程图</strong></p><p><img src="/images/RedisCluster/04.png"></p><p><strong>步骤说明:</strong></p><ol><li><p>🔌 [<strong>连接断开</strong>]</p><p> 🚫 主从节点的连接中断。</p></li><li><p>🔄 [<strong>重连尝试</strong>]</p><p>  📡 从节点尝试重新连接主节点。</p></li><li><p>💬 [<strong>部分同步请求</strong>]</p><p> 📩 从节点发送 <code>PSYNC</code> 带有上次的运行 ID 和数据偏移量。</p></li><li><p>🤔 [<strong>主节点决策数据同步方式</strong>]</p><p>  ✅ 如果条件满足：回复 <code>CONTINUE</code>，表示进行部分数据同步。</p><p>  ❌ 否则：回复 <code>FULLRESYNC</code>，表示进行全量数据同步。</p></li><li><p>🏁 [<strong>执行命令</strong>]</p><p>  🛠 从节点执行接收到的新命令，确保数据与主节点一致。</p></li></ol><p><strong>这里重点讲解下部分数据同步的过程</strong>:</p><p>当从节点重新连接到主节点时，它会发送之前保存的主节点运行 ID 和自己的复制偏移量给主节点。</p><p>主节点在验证接收到的运行 ID 与自己的相符后，会进一步检查其复制缓冲区。如果缓冲区包含从节点缺失的所有命令，主节点仅发送这些缺失命令。否则，将进行全量同步。</p><h3 id="主从复制配置详解"><a href="#主从复制配置详解" class="headerlink" title="主从复制配置详解"></a>主从复制配置详解</h3><p>关于 Redis 主从复制的配置项，只需在 redis.conf 配置文件中搜索 replication 即可定位到。</p><p><strong>1.连接 &amp; 身份验证</strong>:  </p><ul><li><code>replicaof  masterip  masterport</code>  : 设定从节点连接到的主节点地址和端口。</li><li><code>masteruser username</code>               : 设定连接到主节点的用户名。</li><li><code>masterauth master-password</code>        : 设定连接到主节点的密码。</li></ul><p><strong>2.数据服务策略</strong></p><ul><li><p><code>replica-serve-stale-data</code> : 当与主节点断开连接时，从节点应如何响应客户端的数据请求，默认值 yes。</p><p>yes: 提供当前拥有的数据（即使可能过时）</p><p>no: 不提供任何数据，返回“正在与主节点同步”的错误。</p></li><li><p><code>replica-read-only</code> : 是否设置从节点为只读，默认值 yes。</p><p> yes : 只读，  no  : 可写。</p></li></ul><p><strong>3.同步策略</strong></p><ul><li><p><code>repl-diskless-sync </code>: 选择 RDB 数据同步方式，默认值 no。</p><p>yes : 直接通过网络同步 RDB 数据。</p><p>no  : 先将 RDB 数据写入磁盘，然后再同步。</p></li><li><p><code>repl-diskless-sync-delay timeout</code> : 当启用无磁盘同步时（repl-diskless-sync 设置为 yes），主节点在开始数据同步前的等待时间（秒），以便集合更多的从节点连接请求，从而进行高效的一次性同步。</p></li><li><p><code>repl-diskless-load disabled</code>  : 从节点如何加载 RDB 数据，默认值 disabled。</p><p><strong>disabled</strong>   : 从节点会先把接收到的RDB文件保存到磁盘，然后从磁盘读取这个文件。</p><p><strong>on-empty-db</strong> : 从节点直接从网络加载 RDB 数据，但只有当它的数据库是空的时。</p><p><strong>swapdb</strong>     : 从节点会同时保存旧数据和从主节点接收的新数据在内存中，不通过磁盘。但需要注意，这需要很多内存。</p></li></ul><p><strong>4.PING &amp; 超时</strong></p><ul><li><p><code>repl-ping-replica-period 10</code> : 从节点向主节点发送 PING 的频率，用于确认主从节点的连接状态。默认值 10s。</p></li><li><p><code>repl-timeout 60</code> : 主节点和从节点之间数据传输的超时时间（以秒为单位）。默认值 60s。</p></li><li><p><code>repl-disable-tcp-nodelay no</code> : 是否禁用 TCP_NODELAY，默认值 no。</p><p> yes: 禁用，       no: 启用。</p></li></ul><p><strong>5.积压策略</strong></p><ul><li><p><code>repl-backlog-size 1mb</code>       : 设置复制积压缓冲区大小，默认值 1MB。</p></li><li><p><code>repl-backlog-ttl 3600</code>       : 复制积压的生存时间，默认值 1h。</p></li></ul><p><strong>6.从节点属性</strong></p><ul><li><p><code>replica-priority 100</code> : 设置从节点的优先级，使用哨兵 Sentinel 进行故障转移时，就用到了这个配置。</p><p><strong>数值越小，优先级越高</strong>。设置为 0 时，该从节点不会被提升为主节点。默认值 100。</p></li><li><p><code>replica-announced yes</code>    : 该配置决定是否让其他的 Redis 工具（如哨兵 Sentinel，Redis 集群）知道这个从节点的存在。默认值 yes。</p><p>yes : 当设置为”yes”，这意味着其他 Redis工具可以看到和识别这个从节点。该节点可以进行正常的故障转移。</p><p>no: 当设置为”no”，这意味着该从节点对其他 Redis 工具是不可见的，它会”隐藏”自己。这在某些特定的部署或安全场景下可能是有用的，比如你不希望某些从节点被外部发现或被用于故障转移。</p></li><li><p><code>replica-announce-ip </code>、<code>replica-announce-port</code> : 用于指定 Redis 实例应当通告给其他节点的IP地址和端口。</p><p><strong>场景</strong>：考虑一个使用 Docker 部署的 Redis 实例。默认情况下，该Redis 实例的IP地址为容器的内部私有地址，可能不适合外部访问。</p><p><strong>replica-announce-ip</strong>   : 在这种设置下，你需要将此配置项设为外部网络可访问的地址，如宿主机的IP，以确保其他 Redis 节点或客户端可以正常连接。</p><p><strong>replica-announce-port</strong> : 若你的容器内部 Redis 实例使用的是标准端口 6379，但在宿主机上通过 7000 端口映射为外部访问，那么你应该将此配置项设置为 7000。</p><p>这样的配置确保无论是 Redis 节点还是客户端，都能使用正确的 IP 和端口与容器内的 Redis 实例进行通信。</p></li></ul><p><strong>7.写操作确认参数</strong></p><ul><li><p><code>min-replicas-to-write</code> : 它定义了主节点在执行写操作时，至少需要多少个从节点确认已经接收了这个写操作。这样，主节点才会回应客户端写操作是成功的。</p></li><li><p><code>min-replicas-max-lag</code>  : 它定义了从节点与主节点之间的最大允许数据同步延迟（以秒为单位）。如果某个从节点的同步延迟超过这个设定的时间，那么该从节点的确认将不会被计入 <strong>min-replicas-to-write</strong> 所需的确认数量。</p></li></ul><h3 id="主从复制使用场景"><a href="#主从复制使用场景" class="headerlink" title="主从复制使用场景"></a>主从复制使用场景</h3><p><strong>1.负载均衡</strong></p><p><strong>背景</strong> ：大规模的应用可能会产生大量的读请求，这些读请求如果都落到一个服务器上，可能会导致性能瓶颈，进而影响用户体验。</p><p><strong>解决方法</strong>：</p><ul><li><p>使用 Redis 的主从复制，可以将读请求负载均衡到多个从节点上，而主节点主要负责处理写请求</p></li><li><p>这种方式可以有效地分散请求，减轻主节点的负担，确保系统的流畅运行。</p></li></ul><p><strong>2.数据冗余与备份</strong></p><p><strong>背景</strong>：为了确保数据安全性，我们需要在多个地方存储数据的备份。</p><p><strong>解决方法</strong>：</p><ul><li>通过主从复制，数据在多个从节点上都有拷贝。</li><li>即使主节点遭遇故障，数据仍然安全，因为可以从任何从节点恢复。</li></ul><p><strong>3.读写分离</strong></p><p><strong>背景</strong>：当业务增长导致单一 Redis 实例的读写请求压力增大时，采用主从复制进行读写分离可以确保系统性能稳定并提高可用性。</p><p><strong>解决方法</strong>：</p><ul><li>使用主从复制进行读写分离：主节点负责所有写操作，而从节点处理大部分读操作。</li><li>这确保了即使主节点遭遇大量写入，读操作的性能仍然保持稳定。</li></ul><p><strong>4.故障恢复</strong></p><p><strong>背景</strong>：当主节点出现故障时，服务可能会中断。</p><p><strong>解决方法</strong>：</p><ul><li>通过配置主从复制和搭建哨兵集群，当主节点故障时，一个从节点可以被晋升为新的主节点，这样，服务可以快速恢复，减少停机时间。</li></ul><h3 id="主从复制的局限性及其解决策略"><a href="#主从复制的局限性及其解决策略" class="headerlink" title="主从复制的局限性及其解决策略"></a>主从复制的局限性及其解决策略</h3><p>前文详细介绍了 Redis 主从复制的基本概念及其工作原理和配置方法。但如同所有技术一样，主从复制也有其局限性。为了更全面地应用 Redis，接下来我们将探讨其局限性及其解决策略。</p><ol><li>单点故障（SPOF）</li></ol><ul><li><strong>局限性</strong>：如果主节点发生故障，整个系统的写能力会受到影响，直到手动干预恢复或切换到从节点。</li><li><strong>解决策略</strong>：部署Redis哨兵（Sentinel）系统来实现故障自动检测和主节点的自动故障转移，减少系统恢复时间，提高可用性。</li></ul><ol start="2"><li>数据一致性问题</li></ol><ul><li><p><strong>局限性</strong>：在 Redis 主从复制中，数据更新首先在主节点上进行，然后异步复制到从节点。这种异步复制是滞后的，从节点的数据状态可能落后于主节点，导致读操作可能读取到过时的数据。</p></li><li><p><strong>解决策略</strong>：</p><p><strong>a. 对于读操作</strong>：为了减少读取过时数据的风险，可以人为地在从节点上引入延迟回应读请求的机制。这意味着从节点会等待一定的时间（足以让大部分的写操作被复制）后再回应读请求。这种策略并不是 Redis直接提供的功能，而是需要通过应用逻辑或中间件来实现。具体做法可能包括在应用程序中增加缓冲逻辑，或者使用代理层来控制对从节点的读请求延迟。</p><p><strong>b.对于写操作</strong>:<br>使用 WAIT 命令，WAIT 命令是 Redis 提供的一种机制，允许在写操作后等待直到指定数量的从节点确认接收到了这次更新。这样可以在写入数据后立即强制数据同步，减少数据不一致的风险。具体实现就是在执行关键写操作后，通过调用 WAIT 命令并指定要等待的从节点数量和超时时间，可以确保这些更新在继续执行后续操作前被足够多的从节点接收，从而提高整体数据一致性。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WAIT 命令格式：WAIT &lt;numslaves&gt; &lt;timeout&gt;</span><br><span class="line">&lt;numslaves&gt;：等待确认写操作的从节点数量。</span><br><span class="line">&lt;timeout&gt;：等待的最长时间（毫秒）。如果超时，命令会返回实际确认的从节点数量，即使这个数量小于&lt;numslaves&gt;。</span><br></pre></td></tr></table></figure><p><strong>3. 写入能力受限</strong></p><ul><li><strong>局限性</strong>：所有的写操作都必须由主节点处理，限制了系统的整体写入吞吐量。</li><li><strong>解决策略</strong>：通过搭建Redis集群，分散写入操作到多个主节点，实现写入能力的水平扩展。</li></ul><h2 id="Redis-哨兵"><a href="#Redis-哨兵" class="headerlink" title="Redis 哨兵"></a>Redis 哨兵</h2><p>通过 Redis 的主从复制机制，我们可以实现数据的冗余备份，负载均衡。但在实际的生产环境中仅仅有主从复制是不够的。当主节点出现故障时，系统如何自动、快速地将一个从节点提升为新的主节点以保证服务的连续性呢？这就引出了我们接下来要讨论的话题—Redis 哨兵 <strong>Sentinel</strong>。</p><p><img src="/images/RedisCluster/05.png"></p><h3 id="哨兵基本概念"><a href="#哨兵基本概念" class="headerlink" title="哨兵基本概念"></a>哨兵基本概念</h3><h4 id="什么是哨兵？"><a href="#什么是哨兵？" class="headerlink" title="什么是哨兵？"></a>什么是哨兵？</h4><p>Redis 哨兵是一种监控工具，确保你的 Redis 始终可用。想象一下，你的主Redis 节点突然停机了，怎么办？这时，<strong>哨兵</strong>进入舞台中央！它自动检测问题，并迅速选择一个备用 Redis（从节点）来接管，确保数据服务不中断。</p><h3 id="哨兵的配置和部署"><a href="#哨兵的配置和部署" class="headerlink" title="哨兵的配置和部署"></a>哨兵的配置和部署</h3><h4 id="哨兵的配置"><a href="#哨兵的配置" class="headerlink" title="哨兵的配置"></a>哨兵的配置</h4><p>Redis 哨兵使用的配置文件是 <strong>sentinel.conf</strong></p><p>这里，我只讲解几个重要的配置项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 哨兵的监听端口</span><br><span class="line">port 26379</span><br><span class="line"># yes 代表哨兵以后台的方式启动</span><br><span class="line">daemonize yes</span><br><span class="line"># 设置哨兵的日志文件路径</span><br><span class="line">logfile &quot;/var/log/redis/sentinel.log&quot;</span><br><span class="line"></span><br><span class="line"># 为哨兵指定要监控的主节点。</span><br><span class="line"># mymaster，127.0.0.1，6379 分别是主节点的名字，主节点的ip地址，端口</span><br><span class="line"># 数字2 代表的是故障转移的阈值（这意味着，当2个哨兵都同意主节点不可用时，故障转移过程才会开始。）</span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6379 2  </span><br><span class="line"></span><br><span class="line">#设置哨兵等待主节点响应的时间，超过30s 代表主节点主观下线。</span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line">#当哨兵完成主从切换之后，这个配置决定有多少个从节点可以同时与新的主节点进行数据同步。</span><br><span class="line">sentinel parallel-syncs mymaster 1                 </span><br></pre></td></tr></table></figure><h4 id="哨兵的部署"><a href="#哨兵的部署" class="headerlink" title="哨兵的部署"></a>哨兵的部署</h4><p>为了确保更高的可靠性和稳定性，建议在至少三台机器上分别部署哨兵实例以形成一个集群。</p><p><strong>分别在三台机器上执行以下命令启动哨兵</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel /path/to/sentinel.conf</span><br><span class="line"></span><br><span class="line"># /path/to/sentinel.conf   哨兵配置文件的实际路径</span><br></pre></td></tr></table></figure><h4 id="哨兵集群交互图"><a href="#哨兵集群交互图" class="headerlink" title="哨兵集群交互图"></a>哨兵集群交互图</h4><p><img src="/images/RedisCluster/06.png"></p><p>哨兵集群中，关于哨兵与哨兵、哨兵与节点之间的通信，有以下三个核心问题需要我们弄清楚：</p><ol><li>哨兵与主节点之间的连接是如何建立的？</li><li>各个哨兵实例是如何建立连接的？</li><li>哨兵又是如何与从节点进行连接的？</li></ol><p><strong>第一个问题：</strong></p><p><strong>sentinel.conf</strong>  中提供了以下配置项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor 主节点名字 主节点ip 主节点端口  quorum</span><br></pre></td></tr></table></figure><p>该配置项提供了主节点的 ip 和 端口, 哨兵通过该地址就可以与主节点建立连接，从而监控它。</p><p><strong>第二个问题：</strong></p><p>哨兵之间的互相发现和连接主要基于 Redis 的发布与订阅机制：</p><p>当哨兵启动并监控主节点时，它会订阅主节点的 <code>__sentinel__:hello</code> 频道，并且也会在 <code>__sentinel__:hello</code> 频道上定期发布自己的信息（如IP和端口）。这样各个哨兵就可以实时获取到对方的 IP 地址和 端口信息。</p><p>通过观察上面的交互图，我们可以看到哨兵 B 会先订阅主节点频道 <code>__sentinel__:hello</code>，哨兵 A 、C 会定期在该频道上发布自己的 IP 地址和端口信息，因此，哨兵 B 就会实时获取到 A、C 的地址端口信息，从而与它们建立连接并通信。</p><p><strong>第三个问题：</strong><br>哨兵是通过定时发送 <code>INFO Replication</code> 命令给主节点，来获取所有从节点的 IP 地址和端口信息的。这样，哨兵就可以分别和各个从节点建立连接并进行通信。</p><p><strong>INFO Replication</strong> 的响应：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; INFO Replication</span><br><span class="line"># Replication</span><br><span class="line">role:master</span><br><span class="line">connected_slaves:2</span><br><span class="line">slave0:ip=192.168.1.1,port=6381,state=online,offset=1249761,lag=0</span><br><span class="line">slave1:ip=192.168.1.2,port=6380,state=online,offset=1249761,lag=1</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"># slave0、slave1、slaveXX 等代表的是各个从节点的信息。</span><br></pre></td></tr></table></figure><h3 id="哨兵的工作原理"><a href="#哨兵的工作原理" class="headerlink" title="哨兵的工作原理"></a>哨兵的工作原理</h3><p>我们都体验过这样的时刻：正当电视剧来到精彩的高潮，突然电视信号断开。如果此时，系统自动帮你切换到一个备用频道，继续播放剧情，你的体验会不会好很多？这正是 <strong>Redis 哨兵</strong>所提供的功能。</p><p>在数据世界中，当 Redis 主节点遇到问题，哨兵就如同这个智能切换系统，自动选择一个备用节点，确保服务的持续。</p><p><strong>这一切都归功于哨兵的三大核心职责：哨兵监控、哨兵 Leader 选举、故障转移与恢复。</strong></p><p>接下来，让我们探索这三大功能如何确保 Redis 服务的稳定运行。</p><h4 id="哨兵监控"><a href="#哨兵监控" class="headerlink" title="哨兵监控"></a>哨兵监控</h4><p><strong>Redis 哨兵监控图示:</strong> </p><p><img src="/images/RedisCluster/07.png"></p><p>通过上图我们可以看到，哨兵集群是通过定期发送 PING 命令到主节点和从节点，等待它们的 PONG 响应来监控它们的健康状态。如果在设定的时间间隔内（比如 10s，配置项为：down-after-milliseconds）未收到回应，哨兵则认为相应的节点可能出现故障，并将其标记为<strong>「主观下线」</strong>状态。</p><p>上面在理解了<strong>「主观下线」</strong> 后，你可能会想，一个哨兵的主观判断足够可靠吗？实际上，为了避免单点判断误差，哨兵系统一般以集群的方式部署，并且采取一种更集体、更“客观”的判断方式来判定主节点处于下线状态。</p><p><strong>更“客观”的判断方式</strong> ：</p><p>当一个哨兵认为某节点<strong>「主观下线」</strong> 后，它会询问其他哨兵是否也觉得该节点不可用。只有当超过半数的哨兵都认为该节点下线时，节点状态才会被标记为<strong>「客观下线」</strong> 。这种方式确保了系统对主节点状态的判断更为准确和可靠。一旦主节点被哨兵系统判定为<strong>「客观下线」</strong> 状态后，哨兵系统才会进行后续步骤（<strong>哨兵 Leader 选举、故障转移</strong>）。</p><p><strong>主节点客观下线图解：</strong></p><p><img src="/images/RedisCluster/08.png"></p><p><strong>主节点客观下线图解步骤说明</strong>：</p><p><strong>1. 哨兵健康检查</strong>：</p><p>哨兵 A 尝试 PING 主节点，等待 PONG 响应。</p><p><strong>2. 主观下线判断</strong>：</p><p>如果哨兵 A 未收到响应，它将主节点标为 “主观下线”。</p><p><strong>3. 询问其他哨兵</strong>：</p><p>哨兵 A 向其他哨兵（如哨兵B、C）广播主节点主观下线的消息，消息格式为：<code>+sdown master 主节点ip 主节点port</code>。</p><p>哨兵B &amp; 哨兵C 根据自己的观察，回复是否同意主节点主观下线。</p><p>如果同意，则会向哨兵 A 回复消息 <code>+sdown master 主节点ip 主节点port</code> 。</p><p>如果不同意，则会选择不回复，哨兵 A 如果长时间收不到哨兵 B、C 的回复，则会判定哨兵 B、C 是不同意主节点主观下线。</p><p><strong>4. 主节点客观下线确认</strong></p><p>如果大多数哨兵都同意主节点是 “主观下线”，那么主节点就被确定为 “客观下线”。随后，哨兵开始选举 <strong>Leader</strong> ，启动故障转移。</p><h4 id="哨兵-Leader-选举"><a href="#哨兵-Leader-选举" class="headerlink" title="哨兵 Leader 选举"></a>哨兵 Leader 选举</h4><p>在 Redis 的哨兵模式中，<strong>Leader</strong> 选举过程是至关重要的。当主节点出现问题时，为确保系统的稳定和高可用，哨兵们需要通过投票机制决定一个<strong>哨兵「Leader」</strong>来处理这次的故障切换。</p><p>但我们得知道，哨兵不是单独工作的，它们通常是以集群形式部署的。在这个集群中，哨兵可以分为两类：<strong>普通哨兵和候选哨兵</strong>。</p><p><strong>普通哨兵</strong>：它们的主要任务是持续监测Redis主从节点的健康状态。当它们观察到主节点无法正常响应时，它们会标记这个主节点为“主观下线”。</p><p><strong>候选哨兵</strong>：第一个发现主节点“客观下线”的哨兵就有资格成为候选哨兵，它会尝试启动选举过程，成为领导来处理主节点的故障。</p><p><strong>注意： 只要候选哨兵才能够参与选举 Leader</strong>。</p><p><strong>Leader 选举时序图</strong>：</p><p><img src="/images/RedisCluster/09.png"></p><p><strong>Leader 选举步骤详解</strong>：</p><p><strong>1. 请求投票</strong></p><ul><li><p>广播请求：<br>候选哨兵会广播一个特定的消息给所有其他哨兵，这个消息可以被理解为：“我认为主节点下线了（客观下线），我可以恢复请投票支持我。</p><p><strong>消息请求格式</strong>：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># ip ，port 是主节点的 IP 地址和端口。current-epoch 是请求哨兵的当前纪元，candidate-name 是请求成为领导者的哨兵的名称。</span><br><span class="line">SENTINEL is-master-down-by-addr &lt;ip&gt;  &lt;port&gt;  &lt;current-epoch&gt;  &lt;candidate-name&gt;</span><br><span class="line"></span><br><span class="line"># “纪元”（epoch）指的是一个递增的整数，用于标识故障转移尝试的次数和同步哨兵之间的状态。</span><br></pre></td></tr></table></figure><ul><li>响应与投票：</li></ul><p>如果其他哨兵觉得主节点还在线，它们拒绝投票。</p><p>如果其他哨兵同样觉得主节点下线并且还未投票，它们支持当前候选哨兵。</p><p><strong>响应消息格式</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># &lt;down-state&gt;     : 是一个整数，1 表示响应者认为主节点下线，0 表示认为主节点在线</span><br><span class="line"># &lt;leader-epoch&gt;   : 是 响应者 知道的最大的领导者纪元</span><br><span class="line"># &lt;candidate-name&gt; : 是响应者认为的当前选举的候选领导者的名字。</span><br><span class="line">&lt;down-state&gt; &lt;leader-epoch&gt; &lt;candidate-name&gt;</span><br></pre></td></tr></table></figure><ul><li>多个候选哨兵的处理</li></ul><p>如果在一个较短的时间窗口内，有多个哨兵都检测到主节点的客观下线并广播成为 Leader 的请求，其他哨兵需要做出选择。在同一纪元中，每个哨兵只能投票一次，通常倾向于支持最早发起请求的候选哨兵。</p><p><strong>2. 统计投票结果</strong></p><p>当候选哨兵收到的投票数达到哨兵总数的大多数时（超过半数），该候选哨兵就已经赢得了这次选举，成为哨兵 Leader，从而进行下一步操作 : <strong>故障转移</strong>。</p><p>上面的”半数“由配置项 <code>sentinel monitor mymaster 127.0.0.1 6379 2</code> 中的 quorum 参数（最后一个参数）决定。</p><h4 id="哨兵-Leader-进行故障转移与恢复"><a href="#哨兵-Leader-进行故障转移与恢复" class="headerlink" title="哨兵 Leader 进行故障转移与恢复"></a>哨兵 Leader 进行故障转移与恢复</h4><p>Redis 哨兵 Leader 的核心目标是自动选择一个新的主节点来替代失效的主节点。那么，具体是如何进行的呢？</p><p><strong>第一步：选出新主节点</strong></p><p>在所有的从节点中，哨兵 Leader 会找出一个最适合的节点来替代失效的主节点。选择的准则包括：</p><ul><li><p><strong>主从节点断开时间</strong></p><p>哨兵 Leader 会检查从节点与主节点断开的时间。如果这段时间太长，超出<strong>预设值</strong>，则这个从节点可能数据不新鲜或不稳定，不适合成为新主节点。</p><p><strong>预设值</strong>：$(down—after-milliseconds * 10) + $milliseconds_since_master_is_in_SDOWN_state$ $</p><p><strong>公式解释</strong>：主从服务器超时时间的十倍加上从哨兵 Leader 看主服务器不可用的时间。</p><p><strong>down—after-milliseconds</strong> : 主从服务器超时时间。<br><strong>milliseconds_since_master_is_in_SDOWN_state</strong> : 指的是哨兵 Leader 认为主节点进入主观下线状态后经过的时间。</p></li><li><p><strong>从节点优先级</strong></p><p>哨兵 Leader 根据主从节点断开时间就可以剔除不合适的从节点，接着将根据从节点的优先级进行过滤。</p><p>每个 Redis 从节点都有一个 replica-priority 配置值，表示节点的优先级。数值越小，优先级越高，其被选作新主节点的机会就越大。Redis 哨兵 Leader 首先会选择优先级比较高的从节点作为新的主节点。</p></li><li><p><strong>已处理的复制偏移量</strong></p><p>接着哨兵 Leader 会考虑从节点数据的新鲜度。在优先级相同的情况下，数据更新得越频繁的从节点更可能被选为新主节点。</p></li><li><p><strong>运行 ID</strong></p><p>运行 ID 是每个 Redis 实例启动时生成的唯一标识。当上述条件都相同时，哨兵 Leader 会选择字母顺序中运行 ID 最小的从节点，保证了选择的一致性。</p></li></ul><p><strong>选定新主节点后，哨兵 Leader 会发送 SLAVEOF no one 命令，将该从节点转化为主节点状态。</strong></p><p><strong>第二步：从节点连接新主节点</strong></p><p>哨兵 Leader 向每个从节点发出 <code>SLAVEOF [新主节点的IP] [新主节点的端口]</code> 指令。从节点执行该指令后，会首先与原主节点断开连接，然后与新主节点建立连接，并开始同步数据。</p><p><strong>第三步：将旧的主节点变成从节点</strong></p><p>旧的主节点恢复后，它不再是主节点，因为我们已经有了新的主节点。为了避免数据冲突和保证数据一致性，哨兵需要做以下调整：</p><p><strong>检测旧主节点</strong>：</p><p>哨兵会持续地监控所有的 Redis 节点，包括旧的主节点。当检测到旧的主节点重新上线并变得可达时，哨兵会进行下一步操作。</p><p><strong>自动降级和数据同步</strong>：</p><p>接着，哨兵 Leader 会自动发送 <code>SLAVEOF [新主节点的IP] [新主节点的端口] </code>命令给旧的主节点。这会指示旧的主节点开始从新的主节点复制数据，并且降级为从节点。</p><p><strong>持续监控</strong>：</p><p>哨兵集群会继续监控这个旧的主节点，以及其他所有节点，确保整个系统的稳定运行。</p><p><strong>第四步：通知应用程序和客户端</strong></p><p>新主节点准备就绪后，为保证数据的正常存取，我们必须让外部应用和客户端知晓这一变化。此时，哨兵通过 Redis 的<strong>发布&#x2F;订阅（Pub&#x2F;Sub）</strong> 机制来发送通知。</p><p><strong>了解一下 Redis 的发布&#x2F;订阅：</strong></p><p><strong>发布者</strong> ：负责发送消息到特定的频道。</p><p><strong>订阅者</strong> ：负责接收某个频道上的消息。</p><p><strong>频道</strong>   ：频道是消息传递的媒介。</p><p><strong>事件</strong>   ：当在一个特定的频道上发布了一个消息时，这就是一个事件。事件表示了某种特定的状态改变或通知。</p><p>发布者（如哨兵）可以将消息发送到特定的频道，而所有订阅了该频道的订阅者都会收到这个消息。</p><p><strong>哨兵如何使用发布&#x2F;订阅？</strong></p><p>首先，当哨兵 Leader 完成故障转移的主从切换之后，它就会记录下新主节点的 IP 和端口信息，并通知整个哨兵集群。</p><p><strong>消息发布</strong>：</p><p>接收到新主节点信息的所有哨兵（无论是 Leader 还是其他哨兵）都会利用 Redis 的发布&#x2F;订阅功能，在各自的 <strong>+switch-master</strong> 频道上发布这一新信息。</p><p><strong>客户端订阅与接收</strong>：客户端和应用程序只需向哨兵节点订阅该频道，即可实时获取新主节点的IP 地址和端口信息。</p><p><strong>例如</strong>：想要监听主从节点切换的通知，客户端只需向哨兵节点订阅<br><code>SUBSCRIBE +switch-master</code> 频道 ，这样，一旦有主从节点切换，通过这个订阅，客户端会立即被通知新的主节点 IP 和端口信息。</p><h3 id="哨兵的优点"><a href="#哨兵的优点" class="headerlink" title="哨兵的优点"></a>哨兵的优点</h3><ul><li><strong>高可用性</strong>：</li></ul><p>当 Redis 主节点（master）出现故障时，哨兵能够自动将某个从节点（slave）晋升为新的主节点，确保 Redis 服务的持续可用性。</p><ul><li><strong>服务发现</strong>:</li></ul><p>客户端和应用程序可通过 Redis 的发布&#x2F;订阅功能实时查询哨兵，以获取当前主节点的最新地址信息。</p><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p>回想一下，前面我们聊到了 Redis 的主从复制和哨兵，让我们进行一个小回顾：</p><p><strong>Redis的主从复制</strong>：简单来说，就是一个主节点有多个从节点复制其数据，这样做的好处是可以分摊读取的压力。</p><p><strong>哨兵机制</strong>：当主节点出现问题时，哨兵会帮我们自动选出一个新的主节点，确保系统不会因为一个节点的故障而中断。</p><p>听起来很完美对吧？但随着我们数据的增长，有一个问题逐渐浮现：如果我们的数据量超出了一个服务器的处理能力怎么办？毕竟单台服务器的资源是有限的。或者说，我想更快地读写数据，单纯的复制够用吗？</p><p>为了解决这样的问题，Redis 推出了一个叫做“集群”的模式。简单来说，它就是把数据分散到多个服务器上，让每个服务器只处理一部分数据，从而达到“集体努力”的效果。</p><p>听起来很酷吧？但是它是如何工作的？在我们接下来的探讨中，我们会一步步揭开 Redis 集群的神秘面纱，让大家对它有一个更加清晰的认识！</p><p><img src="/images/RedisCluster/10.png"></p><h3 id="Redis-集群基本概念"><a href="#Redis-集群基本概念" class="headerlink" title="Redis 集群基本概念"></a>Redis 集群基本概念</h3><h4 id="什么是-Redis-集群？"><a href="#什么是-Redis-集群？" class="headerlink" title="什么是 Redis 集群？"></a>什么是 Redis 集群？</h4><p>Redis 集群是一种允许多个 Redis 节点协同工作的技术，它提供了数据分片和故障恢复能力。在 Redis 集群中，数据会被划分为多个分片，每个分片存储在不同的节点上。这不仅使 Redis 能够存储更多的数据，而且，当某个节点出现故障时，其他节点可以迅速地接管它的任务，确保整体服务的连续性。</p><h4 id="为什么需要集群？"><a href="#为什么需要集群？" class="headerlink" title="为什么需要集群？"></a>为什么需要集群？</h4><p><strong>数据增长</strong>：随着应用程序和业务的发展，数据量持续增长，可能超出单个 <strong>Redis</strong> 实例的处理能力。</p><p><strong>业务持续性</strong>：为了确保业务的持续运行，即使在硬件故障或其他问题的情况下，我们需要一种更稳健的解决方案。</p><p><strong>性能要求</strong>：随着用户基数的增长和服务的扩展，性能要求也随之提高，集群可以提供更好的读写能力。</p><h3 id="Redis-集群的工作原理"><a href="#Redis-集群的工作原理" class="headerlink" title="Redis 集群的工作原理"></a>Redis 集群的工作原理</h3><h4 id="数据分片"><a href="#数据分片" class="headerlink" title="数据分片"></a>数据分片</h4><p><strong>什么是数据分片？</strong></p><p>在 <strong>Redis</strong> 集群中，数据分片是将所有的键分布到多个节点上的方法，从而每个节点只需要持有整个数据集的一部分。</p><p><strong>数据分片的好处</strong></p><ul><li><p>横向扩展：随着数据或请求负载的增长，可以简单地添加更多的节点来分担负载。</p></li><li><p>增加总吞吐量：因为数据和请求被分散到多个节点，每个节点只处理一部分的数据和请求，因此整体吞吐量得到提升。</p></li></ul><p> <strong>数据如何在集群中分片？</strong></p><p>在 Redis 集群中，数据的分布取决于一个非常核心的概念，那就是<strong>哈希槽</strong>。那么，这一切是如何工作的呢？</p><p><strong>1. 哈希槽：集群的基石</strong></p><p>Redis 集群总共定义了 16384 个哈希槽。</p><p>这些哈希槽的职责就是确定一个特定的键应该被存储在哪个节点上。</p><p><strong>2. 如何映射键到哈希槽？</strong></p><p>当你尝试在集群中保存一个键值对时，Redis 并不是随机选择一个哈希槽。</p><p>它使用键的名字，对其进行计算，确定应该归属于哪个哈希槽。</p><p><strong>计算公式</strong>：</p><p>$slot &#x3D; CRC16(key) \mod 16384$</p><p>CRC16 :计算键的哈希值的函数，slot 是该键所对应的槽号。</p><p>这意味着每个键名都会被映射到 0 到 16383 之间的某个哈希槽。</p><p><strong>3. 哈希槽与节点：亲密的伙伴</strong></p><p>当集群设置完毕后，这些哈希槽会被均匀地分配到所有的主节点上。当然也可以通过手动的方式进行分配。</p><p>比如，如果你有三个主节点，如果是均匀分配的话，可能第一个节点负责前 5461 个哈希槽，第二个节点负责接下来的 5461 个，第三个节点负责剩余的。</p><p> <strong>4. 客户端请求：如何找到正确的节点？</strong></p><ul><li>当客户端想要读取或写入一个键时，它会先计算出这个键应该属于哪个哈希槽。</li><li>知道了哈希槽，它就能找到对应的节点，并向该节点发送请求。</li></ul><p><strong>为了便于理解，我画一张示意图来解释一下，数据、哈希槽、主节点这三者的映射关系：</strong></p><p><img src="/images/RedisCluster/11.png"></p><h4 id="节点的角色：主节点与从节点"><a href="#节点的角色：主节点与从节点" class="headerlink" title="节点的角色：主节点与从节点"></a>节点的角色：主节点与从节点</h4><p>在 <strong>Redis</strong> 集群中，数据分片使得数据分布在多个节点上，而这些节点分为<strong>主节点</strong>和<strong>从节点</strong>。它们各自承担不同的职责，共同确保 <strong>Redis</strong> 集群的高可用性和高性能。</p><p><strong>Redis 集群节点交互图：</strong></p><p><img src="/images/RedisCluster/12.png"></p><p><strong>主节点 （Master Node）</strong></p><p><strong>主节点是 Redis 集群的核心，它们的职责如下：</strong></p><ul><li><p><strong>数据存储</strong>：每个主节点都负责存储整个数据集的一个子集，这取决于它所管理的哈希槽。</p></li><li><p><strong>处理写请求</strong>：所有写入数据的请求（例如：SET, HSET 等）都直接发送到相应的主节点。</p></li><li><p><strong>管理从节点</strong>：主节点负责向其从节点同步数据，确保数据的一致性。</p></li></ul><p><strong>从节点 （Slave Node）</strong></p><p>从节点为 <strong>Redis</strong> 集群提供额外的数据冗余和读取能力，每个主节点都会有一个或多个从节点，它们的职责如下：</p><ul><li><p><strong>数据备份</strong>：从节点复制并存储其对应主节点上的数据，为系统提供一个数据的备份。</p></li><li><p><strong>处理读请求</strong>：为了分担主节点的读负载，客户端可以从从节点读取数据。</p></li><li><p><strong>故障转移</strong>：如果主节点故障，从节点可以被晋升为新的主节点，继续为客户端提供服务。</p></li></ul><p><strong>如何在节点之间进行数据的读写？</strong></p><ul><li><p><strong>写操作</strong>：客户端首先计算键的哈希槽，确定应该由哪个主节点处理，然后直接向该主节点发送写请求。</p></li><li><p><strong>读操作</strong>：客户端可以选择从主节点或其任何从节点读取数据。当从节点用于读操作时，它可以帮助提高整体的读取性能，特别是在读操作比写操作多的场景下。</p></li></ul><h4 id="Redis-集群与-Gossip-协议"><a href="#Redis-集群与-Gossip-协议" class="headerlink" title="Redis 集群与 Gossip 协议"></a>Redis 集群与 Gossip 协议</h4><p>在深入了解 Redis 集群中的各个节点的角色之后，你可能会产生这样的疑问：这些节点如何找到彼此，并高效地共享信息和状态呢？当某个节点遇到问题时，其他节点如何迅速得知并做出相应调整？</p><p><strong>答案在于 Redis 集群采用的一个特殊的通信机制—“Gossip” 协议。</strong></p><p><strong>什么是 Gossip 协议？</strong></p><p>让我们用一个简单的例子来理解。想象一下，你在一个聚会上分享了一个趣事给几位朋友，这些朋友又告诉了其他人。很快，整个聚会上的人都知道了这个趣事。这种信息的传播方式，就是 Gossip 协议的核心思想：<strong>节点间通过“聊天”来共享和扩散信息。</strong></p><p>更专业地说，<strong>Gossip 协议</strong>是一种在分布式系统中进行信息同步和故障检测的轻量级通信机制。节点随机选择其他节点交换信息和状态。</p><p><strong>Redis 集群如何应用 Gossip 协议？</strong></p><p>Redis 集群的 Gossip 协议是基于传统 Gossip 协议之上进行的优化，以满足其特定的需求和特性。</p><ul><li><p><strong>节点发现</strong>：</p><p>新加入的节点使用 <strong>Gossip 协议</strong>来识别和握手与集群中的现有节点。进而将自己加入到集群中。</p></li><li><p><strong>状态交换</strong>：</p><p>节点定期使用 <strong>Gossip</strong> 协议与其他节点交换自身及已知的其他节点状态，节点状态包括：节点角色、节点的健康状态，是正常、故障、还是疑似故障。</p></li><li><p><strong>故障检测与通知</strong>：</p><p>如果某节点发现另一节点长时间无响应，它会利用 Gossip 协议迅速传播这一信息，确保整个集群得到通知并采取行动。</p></li><li><p><strong>数据路由</strong>：</p><p>在 Redis 集群中，数据的存储与检索是基于哈希槽的。节点之间需要交换它们各自负责的哈希槽信息，确保客户端请求能准确路由到对应的节点。</p></li></ul><p><strong>总结</strong>：</p><p><strong>Redis</strong> 集群利用 <strong>Gossip</strong> 协议实现节点间的有效通信，确保节点发现、状态同步、故障检测与通知以及数据路由，从而保障集群的高可用性和数据一致性。</p><h4 id="Redis-集群的故障转移与恢复"><a href="#Redis-集群的故障转移与恢复" class="headerlink" title="Redis 集群的故障转移与恢复"></a>Redis 集群的故障转移与恢复</h4><p>当我们谈论 Redis 集群的鲁棒性时，故障转移与恢复是不可或缺的部分。这确保即使面临节点故障，集群仍然可以正常运行。</p><p><strong>什么是故障转移？</strong></p><p>当主节点遇到问题并无法正常工作时，从节点准备接管并成为新的主节点。这个过程被称为故障转移。</p><p>你或许还记得，在哨兵模式中也有故障转移的流程。但 <strong>Redis</strong> 集群采用了其独有的故障转移策略，完全无需哨兵的介入。尽管两者在故障转移上有诸多相似之处，但关键的不同在于：<strong>Redis</strong> 集群不依赖于外部的监视器（哨兵），而是依赖集群内部的节点来共同参与和决策来实现故障转移。</p><p><strong>接下来，让我们来看下 Redis 集群故障转移与恢复的具体步骤：</strong></p><p><strong>故障转移第一步：故障检测</strong></p><p><strong>主观下线</strong>:</p><p>每个节点通过发送 <strong>PING</strong> 指令来周期性地对其他节点进行健康检查。若某节点在一个预定的 <strong>cluster-node-timeout</strong> 间隔内未接收到特定节点的 <strong>PONG</strong> 回复，它将标记该节点为主观下线状态。此状态仅代表单一节点的观察结果，并非集群共识。</p><p><strong>客观下线</strong></p><p>单一节点的主观观察并不触发集群级别的行动。只有当超过集群半数的节点都标记某节点为主观下线时，该节点才被认定为<strong>客观下线</strong>。这确保了故障转移的决策基于<strong>多数节点</strong>的共识，从而增加决策的准确性。</p><p><strong>首先，让我们来看下 Redis 集群中节点客观下线的判断过程。实际过程可能会更复杂，我这里只是简单举例说明</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># 假设 Redis 集群目前存在 A、B、C、D、E 五个节点</span><br><span class="line"></span><br><span class="line">步骤1: </span><br><span class="line">A ------&gt; B (节点 A 向 节点 B 发送 PING 请求，X 代表未收到回复消息)</span><br><span class="line">       X</span><br><span class="line">       </span><br><span class="line">步骤2:</span><br><span class="line">A -------&gt; 其他节点 (广播：“我认为B有问题！”)</span><br><span class="line"></span><br><span class="line"># 广播消息格式：&lt;当前节点ID&gt; FAIL &lt;被认为故障的节点ID&gt; &lt;当前节点的当前时间戳&gt;</span><br><span class="line"></span><br><span class="line">步骤3:</span><br><span class="line">其他节点分别发送 PING 请求 检查与 B 的通信情况：</span><br><span class="line"></span><br><span class="line">C -------&gt; B</span><br><span class="line">       X</span><br><span class="line">D -------&gt; B</span><br><span class="line">       X</span><br><span class="line">E -------&gt; B</span><br><span class="line">       ✓</span><br><span class="line"></span><br><span class="line">步骤4:</span><br><span class="line">收集所有关于B的故障报告：</span><br><span class="line"></span><br><span class="line">A: B故障</span><br><span class="line">C: B故障</span><br><span class="line">D: B故障</span><br><span class="line">E: B响应正常</span><br><span class="line"></span><br><span class="line">步骤5:</span><br><span class="line">如果超过半数的节点报告 B 故障，B 被标记为客观下线。接下来就是故障转移第二步。</span><br></pre></td></tr></table></figure><p> <strong>故障转移第二步：从节点晋升</strong></p><p>当一个主节点被确定为客观下线，需要从其关联的从节点中选举一个进行晋升，来替代失效的主节点。</p><p>主节点一般都会有多个从节点，这就带来了一个问题：<strong>在多个从节点中，哪一个是最合适的候选者来晋升为新的主节点？</strong></p><p>为了确定最佳的从节点，Redis 集群使用以下的选举策略来挑选从节点。</p><ul><li><p><strong>数据同步进度</strong>：</p><p>每个从节点都会定期与其主节点进行数据同步。但因为网络或其他原因，有些从节点的数据可能更新。在故障转移时，拥有最新数据的从节点将被优先考虑，以减少数据丢失。</p></li><li><p><strong>配置优先级</strong>：</p><p>在数据同步进度相同的情况下，优先级较高（值较小）的从节点会被选为新的主节点。</p></li><li><p><strong>网络连接质量</strong>：</p><p>如果上面的两个条件都一样，Redis 则会考虑网络连接稳定、响应时间短的从节点成为新的主节点，因为它更有可能快速且准确地响应客户端的请求。</p></li></ul><p>当从节点被选择并晋升为新的主节点后，整个集群需要进行<strong>自动重新配置</strong>来适应这种变化：</p><p><strong>自动重新配置</strong>：</p><ul><li><strong>哈希槽分配</strong>：新晋升的主节点会自动接管失效主节点的哈希槽，确保集群数据的连续访问性。</li><li><strong>集群元数据更新</strong>：为了适应拓扑变化，集群中的其他节点会更新其内部的元数据和配置(比如：新主节点的 ip 地址和 port 信息)，以识别并与新的主节点通信。</li></ul><p> <strong>故障转移第三步：故障恢复</strong></p><p><strong>1. 数据同步</strong>：</p><p>为了确保数据的一致性和完整性，新晋升的主节点需要分别和其他从节点之间建立连接并进行数据同步：</p><ul><li><p>那些继续作为从节点的节点会开始与新的主节点同步数据，这是为了确保从节点的数据是最新的。</p></li><li><p>同步过程可以是全量复制，也可以是部分复制，具体取决于自上次成功同步以来的数据变化量。</p></li></ul><p><strong>2. 客户端重新连接</strong>: </p><p>故障期间，客户端可能遭受了中断。为了恢复正常的数据库操作，它们需要重新定位并连接到新晋升的主节点。</p><p><strong>3. 旧主节点的恢复</strong>：</p><p>如果原先的失效主节点后来恢复了，并重新加入了集群，它将不再作为主节点，而是会被降级为从节点。</p><p>并且还需要与新的主节点同步数据，确保它自己的数据与新主节点的其他从节点数据一致。</p><p><strong>这里顺便提个问题：在上述故障恢复的第二步：客户端重新连接中，客户端如何知道新主节点的 IP 地址和端口信息的？</strong></p><p>我直接说答案吧，一般有以下两种做法：</p><p><strong>1. 客户端的 Redis Cluster 支持</strong>：这是最常见的方法。许多现代的 Redis 客户端，如 Redis-py （Python）、Jedis （Java）、Redigo （Go） 等，都内置了对 Redis Cluster 的支持。这些客户端会自动处理 “MOVED” 错误，重新路由请求到正确的节点，并更新其内部的节点映射缓存。使用这种方法可以大大简化应用程序的开发和维护，因为客户端库会自动处理集群的变动。</p><p><strong>2. 集群发现</strong>：对于那些需要更细粒度控制的应用或者使用没有内置 Redis Cluster 支持的客户端的场景，集群发现是一个有用的方法。通过定期发送 CLUSTER NODES 或 CLUSTER SLOTS 命令，应用程序可以自己管理和更新哈希槽到节点的映射。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#返回集群中所有节点的信息。返回的信息包括每个节点的 ID、地址、角色（主/从）、与其他节点的关系、哈希槽范围等</span><br><span class="line">CLUSTER NODES：</span><br><span class="line"></span><br><span class="line"># 返回集群中哈希槽和其相应节点的映射信息。这对于理解哪个节点负责哪些哈希槽非常有用。</span><br><span class="line">CLUSTER SLOTS</span><br></pre></td></tr></table></figure><h4 id="重新分片"><a href="#重新分片" class="headerlink" title="重新分片"></a>重新分片</h4><p>在我们了解 <strong>Redis</strong> 集群的节点角色和故障转移后，有一个非常重要的概念需要讲解：<strong>重新分片</strong>。随着数据量的增长或节点的变化，我们可能需要调整数据在集群中的分布。这就涉及到重新分片的过程。</p><p><strong>什么是重新分片？</strong></p><p>重新分片是一个过程，允许你在集群的不同节点之间移动哈希槽，这样可以确保数据在集群中均匀分布。</p><p><strong>为什么要进行重新分片？</strong></p><p><strong>集群扩展</strong>：随着业务的增长，我们可能需要添加更多的节点到集群中。此时，需要将一部分数据迁移到新的节点。</p><p><strong>数据均衡</strong>：为了防止某个节点数据过多导致性能瓶颈，我们可能需要将数据在各个节点之间重新分布。</p><p><strong>接下来，让我们来看下 Redis 集群是如何进行重新分片的？</strong></p><p>Redis 集群进行重新分片主要是通过以下 5 个步骤来进行的。</p><p><strong>步骤 1: 检查集群信息</strong></p><p>首先，通过 <code>redis-cli -c -p 7000 cluster nodes </code>命令，你获得了一个集群状态的信息，包括每个节点的ID、状态、IP 地址和端口，以及它们负责的哈希槽范围。这为我们提供了一个集群的总体布局和节点间的哈希槽分配情况。</p><p><strong>步骤 2: 识别负载不平衡的节点以及确定源节点和目标节点</strong></p><p><strong>观察节点负载</strong>：这一步需要额外信息，比如使用 INFO 命令或其他监控工具来查看节点的内存使用、CPU 负载、网络带宽等指标。这些数据有助于我们识别出源节点和目标节点 。</p><p><strong>源节点选择</strong>：源节点通常是那些负载较高的节点，你可能会选择那些内存使用率高、处理大量请求的节点作为哈希槽迁移的起点。</p><p><strong>目标节点选择</strong>：目标节点则是负载相对较低，有能力接收更多哈希槽的节点。如果你最近向集群中添加了新节点，这些新节点也是很好的目标节点候选。</p><p><strong>步骤 3: 确定迁移的哈希槽</strong></p><p>现在，我们已经确定了要迁移哈希槽的源节点以及目标节点。接下来就要确定要迁移的源节点的哈希槽。</p><p>并没有直接的 Redis 命令可以告诉你每个哈希槽的详细数据量，因为 Redis 集群的设计是将数据分布在不同的哈希槽中，但你可以通过键的分布来间接获取每个哈希槽的数据量。这可能需要你编写脚本或使用现有的管理工具来帮助分析。</p><p><strong>比如：编写脚本统计每个哈希槽的键数量</strong> </p><p>可以遍历节点上的所有键，使用 <code>CLUSTER KEYSLOT</code> 命令确定每个键属于哪个哈希槽，然后对每个哈希槽的键数量进行计数。这需要通过 Redis 的命令行接口或客户端库来实现。</p><p><strong>这个脚本的基本逻辑是</strong>：</p><ul><li>连接到源节点。</li><li>使用 SCAN 命令遍历所有键（以避免大量键时的性能问题）。</li><li>对于 SCAN 返回的每个键，使用 CLUSTER KEYSLOT 命令确定其哈希槽。</li><li>维护一个计数器，对每个哈希槽内的键数量进行统计。</li></ul><p>通过脚本收集到每个哈希槽内键的数量后，你可以分析这些数据来确定哪些哈希槽的数据量较大。通常，数据量大的哈希槽可能会导致源节点负载较高。基于这个分析，你可以选择数据量大（可能负载也较高）的哈希槽进行迁移。至此，我们便可以知道源节点要迁移的哈希槽。</p><p><strong>步骤 4: 执行重新分片</strong></p><p>经过上面的步骤，我们已经可以确定源节点、源节点要迁移的哈希槽以及将哈希槽要迁移的目标节点。</p><p><strong>接下来，就要执行重新分片：</strong></p><p>这个过程可以手动完成，也可以使用 Redis 的自动重新分片工具。手动重新分片提供了更好的控制，但自动重新分片更方便。</p><p><strong>手动重新分片</strong>：</p><p>使用 <strong>redis-cli –cluster reshard</strong> 命令开始重新分片过程。该命令可以在集群的任意节点上执行。</p><p><code>redis-cli --cluster reshard &lt;任意节点的IP&gt;:&lt;任意节点的端口&gt;</code><br>该命令会启动一个交互式会话，询问你需要从哪个节点移动哈希槽，迁移哈希槽的范围，移动多少个哈希槽，以及目标节点。</p><p><strong>自动重新分片</strong>:<br>如果你希望自动重新分片，可以使用 <strong>–cluster-rebalance</strong> 选项。这会尝试自动平衡集群的哈希槽分配。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster rebalance &lt;any-node-ip&gt;:&lt;any-node-port&gt; --cluster-use-empty-masters</span><br><span class="line">这里，&lt;any-node-ip&gt;:&lt;any-node-port&gt; 是集群中任一节点的 IP 地址和端口号。</span><br><span class="line">--cluster-use-empty-masters 选项允许命令使用没有分配任何哈希槽的节点。</span><br></pre></td></tr></table></figure><p><strong>–cluster-use-empty-masters</strong> ：这个选项指示rebalance命令，在重平衡操作中包括那些当前未持有任何哈希槽的主节点。默认情况下，重平衡操作可能不会向这些空闲的主节点分配哈希槽，因为目标是在已有槽的节点之间进行平衡。启用这个选项后，重平衡逻辑会将这些空闲的主节点考虑在内，尝试向它们分配一些哈希槽，从而使得这些节点参与到集群的工作负载中。</p><p><strong>步骤五:分片完成后的检查</strong></p><p><strong>验证集群状态</strong></p><p>首先使用 <code>redis-cli --cluster check</code> 命令：</p><p>这个命令提供了一种快速检查 Redis 集群状态的方法。它会检测诸如配置不一致、连接问题及槽分配不均等的问题。</p><p>执行命令：<code>redis-cli --cluster check &lt;any-node-ip&gt;:&lt;any-node-port&gt;</code>。这里，<any-node-ip>:<any-node-port> 代表集群中任意节点的IP地址和端口号。</p><p>命令输出将报告集群健康状况，包括所有节点是否在线、槽是否被正确分配和覆盖全范围、以及是否有任何节点之间的配置不匹配。</p><p><strong>确保节点可达性和同步状态</strong>：</p><p>检查命令输出中的每个节点状态，确认它们都是可达的并且处于联机状态。<br>确认所有的节点都正确同步了其他节点的状态信息，尤其是槽的分配信息。这一点对于集群的稳定运行和高可用性至关重要。</p><p><strong>监控重平衡效果</strong></p><p><strong>观察性能指标</strong>：</p><ul><li><strong>延迟</strong>：检查命令响应时间是否符合预期。任何异常的延迟增加都可能指示背后有问题，如网络问题或节点过载。</li><li><strong>吞吐量</strong>：监测集群处理请求的能力是否有所提升或至少保持在重平衡前的水平。</li><li><strong>负载分布</strong>：观察重平衡后节点的负载是否更均衡。使用INFO命令或Redis监控工具来查看各节点的负载情况。</li></ul><p><strong>使用 INFO 命令和监控工具</strong>：</p><ul><li>执行 <code>redis-cli -h &lt;node-ip&gt; -p &lt;node-port&gt; INFO</code> 命令，可以获取到Redis节点的详细运行时信息和统计数据。这对于评估节点健康状况和性能非常有帮助。</li><li>考虑使用Redis 监控工具，如 Prometheus 配合Redis Exporter，或其他第三方监控解决方案。这些工具可以提供实时的性能图表，帮助你更直观地理解集群状态和性能变化。</li></ul><p><strong>重新分片与客户端的挑战</strong></p><p>当我们讨论 <strong>Redis</strong> 集群的重新分片时，除了涉及哈希槽的迁移和节点之间的数据传输，还需要考虑一个重要的客户端层面的问题：<strong>如何确保在迁移过程中数据的连续访问性</strong>？</p><p>想象一下，当一个客户端正在访问一个特定的键值时，而这个键值恰好位于正在被迁移的哈希槽中，客户端会遇到什么情况呢？</p><p><strong>答案是</strong>：客户端会收到一个 <strong>ASK 重定向错误</strong>。</p><p><strong>深入理解 ASK 重定向</strong></p><p>当客户端试图在源节点访问正处于迁移过程的哈希槽中的数据时，源节点并不直接拒绝，而是返回一个 <strong>ASK</strong> 重定向错误。这一错误实际上是 <strong>Redis</strong> 集群为保证数据访问连续性而设计的机制，它引导客户端去目标节点重新请求数据，从而避免服务中断。</p><p><strong>如何处理 ASK 重定向？</strong></p><p><strong>流程图</strong>：</p><p><img src="/images/RedisCluster/13.png"></p><p><strong>重要步骤说明</strong>：</p><p>1.当客户端收到 <strong>ASK</strong> 重定向错误后，首先从错误信息中提取目标节点的 <strong>IP</strong> 地址和端口。</p><p>2.在向目标节点发送命令请求之前，客户端需要先发送一个特殊命令 <strong>ASKING</strong>。</p><p>3.发送 <strong>ASKING</strong> 命令后，客户端可以正常地重新向目标节点发送原命令请求。</p><p>4.客户端收到数据后，继续其后续的操作。</p><p><strong>这里提个问题</strong> ：上述的第二步中，在向目标节点发送命令请求之前，客户端需要先发送一个特殊命令 <strong>ASKING</strong>，该命令有何作用？</p><p>答：<strong>ASKING</strong> 命令是 <strong>Redis</strong> 集群在数据迁移时的特殊协议。当客户端收到一个 <strong>ASK</strong> 重定向提示时，它必须首先向目标节点发送 <strong>ASKING</strong> 命令。这是为了告诉目标节点：尽管该数据在常态下并不由你处理，但由于数据正在迁移，我需要暂时地从你这获取它。</p><p>值得注意的是，<strong>ASKING</strong> 命令的影响仅适用于紧随其后的那个请求。如果客户端后续还有其他请求收到ASK重定向，那么它必须为每一个这样的请求都重新发送 ASKING 命令。</p><h4 id="客户端与集群的交互"><a href="#客户端与集群的交互" class="headerlink" title="客户端与集群的交互"></a>客户端与集群的交互</h4><p>在我们讨论到 <strong>Redis</strong> 集群时，我们常常聚焦于后端的节点如何互相协作，而忽略了一个同样重要的角色：客户端。其实，客户端与集群的交互在 <strong>Redis</strong> 集群的日常运作中起到了举足轻重的作用。</p><p><strong>先来看下它们是怎样交互的？</strong></p><p><strong>交互流程图：</strong></p><p><img src="/images/RedisCluster/14.png"></p><p><strong>重要步骤说明：</strong></p><p><strong>1. 判断节点是否可用</strong></p><p>  客户端首先向已知节点发送命令，如果某个节点暂时不可用或发生了故障转移，客户端可能会收到 CLUSTERDOWN 或 TRYAGAIN 错误。在这种情况下，客户端应该稍等片刻，并重新尝试操作，因为集群很可能在短时间内自我恢复。</p><p><strong>而如果当前节点时可用的，就执行第二步。</strong></p><p><strong>2. 计算槽号</strong></p><p><strong>计算方式</strong>:  $slot &#x3D; CRC16(key) \mod 16384$</p><p><strong>3.判断槽号是否为当前节点所负责</strong></p><p>如果该槽号是当前节点负责的，则直接在当前节点执行命令并返回结果给客户端。<strong>如果不是当前节点所负责的，就执行下一步。</strong></p><p><strong>4. 客户端重定向</strong></p><p>如果槽号不是由当前节点负责的，节点会返回一个 <strong>MOVED</strong> 错误，告诉客户端正确的节点地址和端口。客户端则需要重新连接新节点，并再次发送命令，等待返回结果。</p><blockquote><p><strong>注意</strong>：在 Redis 集群中，客户端可能遇到 MOVED 或 ASK 错误，表示要查询的数据在另一个节点上。客户端必须能自动重定向请求到正确节点。因此，使用集群时，需要选择支持这种重定向功能的客户端库。</p></blockquote><h3 id="集群的优点和缺点"><a href="#集群的优点和缺点" class="headerlink" title="集群的优点和缺点"></a>集群的优点和缺点</h3><p>那相比主从复制和哨兵机制，Redis 集群都有哪些优缺点呢？</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p><strong>数据容量</strong>：单个 Redis 节点可能受限于物理内存，而集群通过分片技术，将数据分散在多个节点上，允许我们存储超出单机物理内存限制的大量数据。</p><p><strong>性能提升</strong>：由于数据和请求都被分散到多个节点上，集群可以更有效地处理高并发的读写请求，为应用提供更高的吞吐量。</p><p><strong>高可用性</strong>：当单一节点出现问题时，集群中的其他节点可以接管其工作，确保服务不中断。这种自动的故障转移能力提高了系统的可靠性和稳定性。而主从复制的高可用需要哨兵的参与。</p><p><strong>扩展性</strong>：随着业务的增长，可以简单地向集群添加更多节点，以满足存储和性能需求，而不需要停机或进行复杂的迁移。</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p><strong>配置复杂性</strong>：设置 Redis 集群意味着要协调多个节点，包括主节点和从节点。与简单的主从复制相比，集群的槽分配和管理更为复杂。而且，当需要增加或减少节点时，调整集群配置可能需要手动干预。</p><p><strong>数据迁移</strong>：在进行节点的增加或减少时，需要进行数据的重新分片，这可能会对性能产生短暂的影响。</p><p><strong>网络开销</strong>：Redis 集群中多个节点需要频繁通信以同步数据。在大的集群里，这可能导致网络变慢和更高的带宽消耗。</p><p><strong>命令限制</strong>：由于数据分片的原因，一些涉及多键操作的命令在集群模式下可能受到限制，比如 <strong>HMSET</strong>、<strong>HMGET等</strong>。</p><h3 id="Redis-集群的配置详解"><a href="#Redis-集群的配置详解" class="headerlink" title="Redis 集群的配置详解"></a>Redis 集群的配置详解</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># yes 代表启用集群模式</span><br><span class="line">cluster-enabled yes     </span><br><span class="line"># Redis 用于保存集群状态信息的文件，状态信息包括：所有节点的信息（IP和Port）、它们的状态（故障，在线）、哈希槽信息等</span><br><span class="line">cluster-config-file nodes-6379.conf     </span><br><span class="line"># 如果一个节点在15000毫秒（15秒）内没有收到来自另一个节点的PONG响应（即对PING请求的回应），那么它会认为那个节点是不可达或失效的（处于主观下线状态）。</span><br><span class="line">cluster-node-timeout 15000</span><br><span class="line"># 这个配置项决定了一个从节点断开与主节点连接多久后，会被认为不能进行故障转移和晋升为主节点。默认是10s</span><br><span class="line">cluster-replica-validity-factor 10  </span><br><span class="line"># 当一个主节点失效，为了晋升其下的从节点成为新的主节点，至少需要有多少个从节点在线，否则不会进行晋升过程。</span><br><span class="line">cluster-migration-barrier 1    </span><br><span class="line"># 是否允许从节点在集群的不同主节点之间迁移。这有助于在负载不均的情况下平衡从节点。</span><br><span class="line">cluster-allow-replica-migration yes  </span><br><span class="line">#  如果设置为 &quot;yes&quot;，则集群要保证所有的哈希槽都必须有一个主节点来管理它，否则整个集群将停止服务。</span><br><span class="line">cluster-require-full-coverage yes</span><br><span class="line">#   这个配置选项决定了当主节点失效时，从节点是否可以自动升级为主节点。置为 &quot;no&quot; 允许从节点尝试变为新的主节点。设置为 &quot;yes&quot; 则不允许这种晋升。</span><br><span class="line">cluster-replica-no-failover no   </span><br><span class="line">#  该配置项决定了在集群出现问题时，是否允许在从节点上进行读操作。设置为 &quot;no&quot; 时，从节点不允许读取。如果设置为 &quot;yes&quot;，即使集群有问题，从节点还是可以读取。</span><br><span class="line">cluster-allow-reads-when-down no        </span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在本文中，我们深入探讨了 <strong>Redis</strong> 的核心架构组件和它们如何相互作用以确保数据的可靠性和高性能。通过主从复制，Redis 实现了数据的冗余备份，为读操作提供了负载分担。而哨兵系统则为我们提供了自动故障转移，确保了系统的高可用性。最后，通过 Redis 集群，我们可以实现数据的水平分片，提供了更大规模的数据存储和处理能力。</p><p>为了让大家对 Redis 架构有更加深入的了解，我又对其进行了总结：</p><p><strong>主从复制</strong></p><ul><li><strong>目的</strong>：通过复制数据到多个副本，主从复制增强了数据的可用性和读取性能。</li><li><strong>工作原理</strong>：一个主节点负责写操作，同时将数据变更同步到一个或多个从节点，从节点主要处理读请求。</li><li><strong>局限性</strong>：主节点故障时，需人工干预进行故障恢复，可能导致数据丢失或服务不可用。</li><li><strong>应用场景</strong>：适用于读写分离，提高读取性能的场景。</li></ul><p><strong>哨兵</strong></p><ul><li><strong>目的</strong>：自动化处理故障转移，提高系统的可用性和稳定性。</li><li><strong>工作原理</strong>：通过监控主从节点状态，自动进行主节点故障的检测、选举和故障转移。</li><li><strong>优点</strong>：自动化故障恢复，减少了人工干预的需要，提高了系统的鲁棒性。</li><li><strong>应用场景</strong>：适用于需要高可用性解决方案的场景。</li></ul><p><strong>集群</strong></p><ul><li><strong>目的</strong>：通过数据分片和自动故障转移，实现数据的水平扩展和高可用性。</li><li><strong>工作原理</strong>：将数据分布在多个节点上，每个节点存储一部分数据，通过哈希槽来定位数据的位置。</li><li><strong>优缺点</strong>：提供了高性能的数据读写能力和良好的伸缩性，但配置和管理相对复杂。</li><li><strong>应用场景</strong>：适用于大规模数据存储和高并发访问的场景。</li></ul><p><strong>理论掌握了，接下来就是实战</strong>。下篇文章，我将带领大家实际搭建 Redis 的主从复制、哨兵与集群。想知道如何实际操作？那可以先关注我的公众号「<strong>跟着小康学编程</strong>」，这里不仅有持续更新的计算机原理相关的文章，还有如何系统学习 C、C++，Linux 系统编程以及网络编程的文章等。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>另外，小康最近创建了一个技术交流群，专门用来探讨技术相关或者解答读者的问题。大家在阅读这篇文章的时候，如果觉得有问题的或者有不理解的知识点，欢迎大家加群或者评论区询问。我能够解决的，尽量给大家回复。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> NoSQL数据库 </category>
          
          <category> 数据库技术 </category>
          
          <category> Redis教程 </category>
          
          <category> 高可用架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis架构 </tag>
            
            <tag> Redis主从复制 </tag>
            
            <tag> Redis哨兵 </tag>
            
            <tag> Redis集群 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>全面解析 Redis 持久化：RDB、AOF与混合持久化</title>
      <link href="/RedisPersistence/"/>
      <url>/RedisPersistence/</url>
      
        <content type="html"><![CDATA[<p>大家好，我是小康，今天给大家聊下 Redis 的几种持久化机制。</p><h1 id="Redis-持久化"><a href="#Redis-持久化" class="headerlink" title="Redis 持久化"></a>Redis 持久化</h1><p><strong>前言：</strong></p><p>在数字时代，数据的价值越来越被人们所重视。但数据只有在经过妥善保管和管理时，才能真正发挥其潜在价值。对于使用 Redis 这一热门的内存数据库的开发者和企业来说，数据的持久化无疑是一个必须面对的重要议题。</p><p>我们都知道，Redis 以其卓越的性能和灵活的数据结构而著称，但如何确保内存中的数据不因突发事件而丢失？如何在确保性能的前提下，为数据提供一个更加稳固的避风港？</p><p>本文将为你揭开 Redis 持久化的神秘面纱，探讨其背后的机制，并帮助你为你的应用选择合适的持久化策略。</p><h2 id="Redis与内存数据库的特性"><a href="#Redis与内存数据库的特性" class="headerlink" title="Redis与内存数据库的特性"></a>Redis与内存数据库的特性</h2><h3 id="为什么Redis是内存数据库？"><a href="#为什么Redis是内存数据库？" class="headerlink" title="为什么Redis是内存数据库？"></a>为什么Redis是内存数据库？</h3><p>Redis是一种键值存储系统，其数据主要存储在<strong>内存</strong>中，因此被称为<strong>内存数据库</strong>。与传统的磁盘存储数据库不同，Redis的设计初衷是为了提供高速、低延迟的数据访问。由于数据直接存储在内存中，可以避免磁盘I&#x2F;O的开销，从而实现极高的读写速度。</p><p>🔍例子: 想象一下你在家里找一本书。如果这本书就放在你的桌子上（相当于内存），你可以立刻拿到它。但如果它放在地下室的一个盒子里（相当于磁盘），那你可能需要花费更多时间去找。Redis的工作方式就像那本放在桌子上的书。</p><h3 id="内存数据库的优点和缺点"><a href="#内存数据库的优点和缺点" class="headerlink" title="内存数据库的优点和缺点"></a>内存数据库的优点和缺点</h3><p><strong>优点：</strong></p><ul><li><strong>速度：</strong>内存数据库如Redis能够提供快速的读写能力，因为内存的访问速度远超过磁盘。</li><li><strong>低延迟：</strong>数据存取的响应时间短，适合需要快速响应的应用。</li><li><strong>灵活性：</strong>由于数据结构存储在内存中，Redis等内存数据库支持丰富的数据类型和操作。</li><li><strong>简化的数据模型：</strong>键值存储方式简化了数据模型，便于开发和维护。</li></ul><p><strong>缺点：</strong></p><ul><li><strong>成本：</strong>内存通常比磁盘更昂贵，大量的数据存储需要大量的内存，可能导致高成本。</li><li><strong>数据持久性风险：</strong>如果没有合适的持久化策略，突然的系统崩溃可能导致数据丢失。</li><li><strong>数据容量限制：</strong>由于依赖内存，数据的容量受到物理内存大小的限制。</li></ul><h2 id="什么是持久化"><a href="#什么是持久化" class="headerlink" title="什么是持久化"></a>什么是持久化</h2><p><strong>持久化的定义：</strong></p><p><strong>持久化</strong>，顾名思义，指的是将短暂的、易失的数据转化为长时间保存，且不易丢失的格式。在数据库的语境中，持久化常常指的是将内存中的数据保存到硬盘或其他长期存储介质中，从而确保即使在系统崩溃、断电或其他突发事件中，数据也不会丢失。</p><p><strong>持久化的必要性：</strong></p><p><strong>数据安全性</strong>：技术世界并非总是完美的。系统可能会遭受故障、崩溃或遭受攻击。在没有持久化的情况下，所有存储在内存中的数据在这些情况下都可能丢失。持久化提供了一种机制，确保这些数据在发生故障后可以被恢复。</p><p>🔍例子: 想象一下你在电脑上工作了好几个小时，突然停电了。如果你没有定期保存你的工作，那么你可能会失去所有的努力。数据库持久化就像定期保存你的文件，确保即使发生意外，你的数据也不会丢失。</p><h2 id="Redis-持久化的方式"><a href="#Redis-持久化的方式" class="headerlink" title="Redis 持久化的方式"></a>Redis 持久化的方式</h2><p>Redis 提供三种持久化的方式: 分别是 <strong>RDB</strong>（Redis Database Snapshot） 和 <strong>AOF</strong>（Append Only File）以及 <strong>混合持久化</strong>。</p><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><h4 id="RDB是什么？"><a href="#RDB是什么？" class="headerlink" title="RDB是什么？"></a>RDB是什么？</h4><p>RDB 持久化方式是 Redis 将当前内存中的数据快照（snapshot）保存到硬盘的过程。换句话说，Redis 会创建一个代表某一时刻的数据集的磁盘文件。</p><p><strong>例子</strong>: 想象一下相机的快门点击。每当你点击快门，你都会捕捉到那个特定时刻的场景。RDB的工作方式很相似，只不过它捕捉的是数据的状态。</p><p>理解 RDB 的本质后，你可能会问，我们如何生成这个快照呢？使用 <strong>SAVE</strong> 和 <strong>BGSAVE</strong> 命令即可。</p><h4 id="RDB-生成图解"><a href="#RDB-生成图解" class="headerlink" title="RDB 生成图解"></a>RDB 生成图解</h4><p><img src="/images/RedisPersistence/1.png"></p><h4 id="RDB-工作原理"><a href="#RDB-工作原理" class="headerlink" title="RDB 工作原理"></a>RDB 工作原理</h4><h5 id="RDB-生成的流程图"><a href="#RDB-生成的流程图" class="headerlink" title="RDB 生成的流程图"></a>RDB 生成的流程图</h5><p><img src="/images/RedisPersistence/2.png"></p><p><strong>步骤说明</strong>：</p><p><strong>1.触发RDB生成</strong>:</p><p>触发 RDB 文件的生成有以下两种方式:</p><p><strong>手动触发</strong>：通过执行 SAVE 或 BGSAVE 命令。</p><p><strong>自动触发</strong>：基于 Redis 配置文件中的 save 指令设置的条件。（默认是通过 BGSAVE 命令来触发的）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis 配置文件 save 指令设置： </span><br><span class="line">save 3600 1        # 3600秒内如果超过1个key被修改则生成 RDB</span><br><span class="line">save 300 100       # 300秒内如果超过100个key被修改则生成 RDB</span><br><span class="line">save 60 10000      # 60秒内如果超过10000个key被修改则生成 RDB</span><br></pre></td></tr></table></figure><p><strong>2.创建子进程</strong>:</p><p>当执行 BGSAVE 命令时，Redis 主进程（父进程）会执行 fork 操作来创建一个子进程。这是一个昂贵的操作，尤其当数据集很大时。但好处是，一旦 fork 完成，父进程可以立即返回处理其他客户端请求，而不需要等待 RDB 的生成过程。</p><p>这里涉及到操作系统级别的知识。当 fork 操作执行后，子进程会获得父进程内存中的数据副本。但由于操作系统使用<strong>写时复制</strong>（Copy-On-Write, COW）技术，任何在父进程（Redis主进程）上发生的写操作不会影响子进程中的数据。这确保了子进程中的数据是隔离的，不受父进程中数据更改的影响。</p><p><strong>3.子进程生成RDB文件</strong>:</p><p>子进程将开始遍历整个数据集，将所有的数据写入一个新的临时RDB文件。这是一个纯I&#x2F;O操作，并且是线性的，所以非常快。子进程不需要处理任何客户端请求，只专注于写 RDB 文件，所以效率很高。</p><p><strong>注意 ：线性指的是数据在磁盘上是连续写入的。</strong></p><p><strong>4.RDB文件替换</strong>：</p><p>一旦子进程完成了新的 RDB 文件的写入，它会替换掉旧的 RDB 文件，并发送一个信号通知父进程任务完成。然后子进程退出。</p><h5 id="RDB-的载入"><a href="#RDB-的载入" class="headerlink" title="RDB 的载入"></a>RDB 的载入</h5><p>当 Redis 重新启动时，如果配置为使用 RDB 持久化，它会查找 RDB 文件，并加载它。由于 RDB 文件是一个紧凑的二进制表示形式，数据加载非常快。</p><h4 id="RDB-配置详解"><a href="#RDB-配置详解" class="headerlink" title="RDB 配置详解"></a>RDB 配置详解</h4><p>Redis 默认是不会开启持久化选项的，只要重启 redis，redis 之前保存的数据都会丢失的。因此在实际的生产环境中，我们都会配置 Redis 的 RDB 配置。</p><p>redis.conf 中关于 RDB 的所有配置:</p><pre><code>save &lt;seconds&gt; &lt;changes&gt;stop-writes-on-bgsave-errorrdbcompressionrdbchecksumsanitize-dump-payloaddbfilenamerdb-del-sync-filesdir</code></pre><p><strong>核心配置的常见问题解答：</strong></p><p><strong>Q: save seconds changes 是什么意思？</strong></p><p>A: 这个配置控制 Redis 如何定期保存数据到磁盘。当指定的时间（秒）内，数据发生的变化次数超过或等于<changes>时，Redis 将触发数据的保存操作。如果想禁用 RDB 持久化，可以在配置文件中注释掉所有的 save 指令，并且重启 Redis 服务即可。</p><p><strong>Q: 我看到了 stop-writes-on-bgsave-error，它的作用是什么？</strong></p><p>A: 当此选项被设置为 yes 时，如果后台保存数据出现错误，Redis 将停止所有写入操作。这是一种保护机制，确保在可能的磁盘问题或其他故障时，不再接受可能导致数据丢失的写操作。<br>当该选项被设置为 no 时，即使后台保存数据出现错误，Redis 仍然会继续接受写入操作。</p><p><strong>Q: rdbcompression 能给我带来什么好处？</strong></p><p>A: rdbcompression 设置为 yes 时，表示启用 rdbcompression， 启用 rdbcompression 会使Redis在保存数据前先对其进行压缩，这样可以减少存储空间的使用。但这也意味着在数据加载时可能需要额外的 CPU 时间来解压。</p><p><strong>Q: 我在配置中看到了 rdbchecksum，这是什么意思</strong>？</p><p>A: rdbchecksum 决定是否在 RDB 文件末尾添加一个 CRC64 校验和。这个校验和帮助检测 RDB 文件是否在传输或存储过程中受到损坏。如果你设置为yes，那么每次 Redis 保存或加载 RDB 文件时，它都会计算并检查这个校验和，确保数据的完整性。</p><p><strong>Q: 什么是sanitize-dump-payload？我应该如何配置它？</strong></p><p>A: 当你有一个Redis数据备份（RDB文件）或者使用 RESTORE 命令来导入数据时，你会希望这些数据是安全的，没有任何问题。但是，有些时候数据可能存在问题，这可能会导致 Redis 在后续的操作中崩溃或者出现错误。</p><p>sanitize-dump-payload 这个配置项就是帮助你在加载数据时检查这些数据的安全性。</p><p>如果你设置为no，那么Redis不会检查数据，这样会更快，但是风险也更大。</p><p>如果设置为yes，Redis会检查所有的数据，确保它们是安全的，不会导致问题。这样更安全，但可能会稍微慢一些。</p><p>如果设置为clients，只有从客户端（比如你的应用程序）发来的数据会被检查，而从其它 Redis 实例同步来的数据或RDB文件不会被检查。</p><p><strong>Q: rdb-del-sync-files 配置是做什么的？</strong></p><p>A: 这个配置项决定是否在某些场景下删除与复制（replication）相关的RDB文件。</p><p>在 Redis 的主从复制过程中，主节点需要生成 RDB 文件并将其发送给从节点，帮助从节点进行数据同步。在某些特定的安全环境中，一旦复制完毕，可能会要求尽快删除这些RDB文件。</p><p>rdb-del-sync-files 这个选项，当设置为 yes 时，并且主节点没有启用 RDB 和 AOF持久化，redis 会自动删除这些与复制相关的 RDB 文件。</p><p>默认为no，这意味着与复制相关的RDB文件在同步后不会被自动删除。</p><p><strong>Q8: dbfilename 和 dir 分别指的是什么？</strong></p><p>A: dbfilename 是 RDB 文件名（默认是 dump.rdb）；dir 则是 RDB 文件存放的目录，默认值 .&#x2F;（当前目录：Redis服务器启动时的工作目录），但推荐指定一个固定的目录，例如：&#x2F;var&#x2F;redis&#x2F;data&#x2F;</p><p><strong>注意：</strong></p><ul><li><p>上述的save 、dbfilename、以及 dir 指令配置是我们重点关注的，其他了解即可。</p></li><li><p>在更改 redis.conf 配置之后，我们需要重启 redis 服务，才能生效。</p></li></ul><h4 id="RDB-持久化的优缺点"><a href="#RDB-持久化的优缺点" class="headerlink" title="RDB 持久化的优缺点"></a>RDB 持久化的优缺点</h4><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><p><strong>快速备份</strong>：RDB可以迅速为你创建一个数据的“快照”，这是一个备份文件，方便你存储或者迁移数据。</p><p><strong>启动快</strong>：当Redis重新启动时，RDB能帮助它更快速地加载数据，因为它直接读取一个完整的数据文件。</p><p><strong>节省空间</strong>：与其他持久化方式相比，RDB的文件大小通常较小，因为它是经过压缩的。</p><h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><p><strong>可能丢数据</strong>：因为RDB只是不时地保存一次数据快照，如果在两次保存之间Redis出了问题，那中间的数据就可能会丢失。</p><p><strong>有时会卡</strong>：在数据很多的情况下，创建 RDB 文件时可能会使服务器短暂地感觉有些卡顿。</p><p><strong>卡顿的原因</strong>：尽管 Redis 使用写时复制（Copy-On-Write, COW）技术来减少内存的复制，fork( ) 在大数据集上的调用仍然可能相当耗时。这是因为操作系统需要为子进程准备一个与父进程相同的虚拟内存空间。在这个准备过程中，即使不立即复制物理内存，操作系统也需要复制和设置父进程的页表，这在数据集很大时会占用相当一部分时间。fork( ) 的执行时间与服务器上的数据量大小成正比。因此在数据集较大时，fork 可能会有比较久的延迟才能返回，所以才造成的卡顿。</p><h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><h4 id="AOF是什么？"><a href="#AOF是什么？" class="headerlink" title="AOF是什么？"></a>AOF是什么？</h4><p>想象你正在写日记，每次有新的事件，你就写下来。AOF 就像是 Redis 的日记，记录了所有的写操作命令。</p><h4 id="简单图解："><a href="#简单图解：" class="headerlink" title="简单图解："></a>简单图解：</h4><p><img src="/images/RedisPersistence/3.png"></p><h4 id="AOF-的工作原理"><a href="#AOF-的工作原理" class="headerlink" title="AOF 的工作原理"></a>AOF 的工作原理</h4><h5 id="基本机制和流程"><a href="#基本机制和流程" class="headerlink" title="基本机制和流程"></a>基本机制和流程</h5><p>Redis 中的 AOF 持久化方式旨在持续地保存服务器上的所有修改操作。每当执行一个会改变数据的命令时，Redis 都会将该命令写入 AOF 文件中。这样，当 Redis 需要恢复数据时，只需执行 AOF 文件中的命令就可以恢复到原来的状态。</p><h5 id="AOF-文件的生成"><a href="#AOF-文件的生成" class="headerlink" title="AOF 文件的生成"></a>AOF 文件的生成</h5><h5 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h5><p><img src="/images/RedisPersistence/4.png"></p><p><strong>步骤说明：</strong></p><p>AOF 持久化的实现主要是以上三步：<strong>命令追加、文件写入、文件同步</strong></p><ul><li><strong>命令追加</strong>: 将 redis 写操作命令追加到 aof_buf 缓冲区</li><li><strong>文件写入</strong>: 周期性地将 aof_buf 缓冲区的命令写入 AOF 文件的内核缓冲区。</li><li><strong>文件同步</strong>:根据配置同步策略，将 AOF 文件缓冲区的内容同步到磁盘。</li></ul><p>其中文件同步策略 redis 提供了三种，分别是以下三种：</p><p><strong>always</strong>：每次有命令写入时都立即同步。这提供了最高的数据安全性，但效率最低。</p><p><strong>everysec</strong>：每秒同步一次。这是一个权衡安全性和效率的策略。最多只丢失 1 秒 的数据</p><p><strong>no</strong>：让操作系统决定最佳的同步时间。这可能导致数据丢失，但提供了最高的效率。</p><h5 id="AOF-文件的载入"><a href="#AOF-文件的载入" class="headerlink" title="AOF 文件的载入"></a>AOF 文件的载入</h5><p>当 Redis 服务器启动时，如果配置为使用 AOF 持久化，它会检查 AOF 文件的存在。如果找到 AOF 文件，Redis 会加载并执行其中的命令来恢复数据的。</p><p><strong>这里顺带提个问题</strong>：假如 Redis 的 RDB 和 AOF 持久化都启用，redis 在载入数据的时候，是载入 AOF 文件？还是 RDB 文件？</p><p>我直接说答案：Redis 会优先载入 AOF 文件来恢复数据，而不是 RDB 文件。这是因为 AOF 文件通常包含了更完整的操作记录，从而能够恢复更完整的数据状态。而 RDB 文件是定时生成的数据快照，所以它可能没有记录到最后一次快照之后发生的所有更改。因此，使用 AOF 文件恢复数据可以提供更高的数据完整性。</p><h4 id="AOF-重写"><a href="#AOF-重写" class="headerlink" title="AOF 重写"></a>AOF 重写</h4><p>在了解了 AOF 的工作原理之后，我们知道它是通过追加写操作命令到文件的方式来恢复数据的。但这会带来一个新的问题: 随着追加命令的不断增加，这个 AOF 文件可能会变得很大和冗长。面对这样的问题，Redis 提供了一个非常有效的优化手段，那就是 <strong>AOF 重写</strong>。</p><p><strong>AOF重写是什么？</strong></p><p>AOF 重写，可以看作是对 AOF文件 进行的一次“精简”操作。它的目的是减少AOF文件的大小，并去除那些冗余的、不再必要的命令，使得该文件只包含恢复当前数据集所需的最小命令集。</p><p><strong>为什么需要AOF重写？</strong></p><p><strong>节省磁盘空间</strong>：随着操作的积累，原始AOF文件可能会变得非常大。通过重写，我们可以减少文件的大小。</p><p><strong>加速恢复速度</strong>：一个更小、更简洁的AOF文件意味着在Redis重启时，数据的恢复过程会更快。</p><p><strong>AOF 重写流程图</strong>：</p><p><img src="/images/RedisPersistence/5.png"></p><p><strong>步骤说明</strong>： </p><p><strong>AOF 重写主要有以下四步：</strong></p><ul><li>redis 主进程 fork 子进程来进行 AOF 的重写，生成 AOF 文件。</li><li>在子进程进行 AOF 重写的同时，redis 主进程将新的写操作命令写入 AOF重写缓冲区</li><li>主进程将 AOF 重写缓冲区的内容写入到新的 AOF 文件中</li><li>使用新的 AOF 文件替换旧的 AOF 文件</li></ul><p><strong>这里思考一下</strong>：子进程 进行 AOF 重写，具体怎么重写，是根据现有的 AOF 文件进行重写还是其他方式？</p><p>子进程是通过读取 Redis 当前的内存数据来进行重写的。假如:  redis 数据库存在列表键 List &#x3D; [a,b,c,d,e,f,g,h] ，在旧的 AOF 文件中，可能有多个命令添加和删除这些元素。但在 AOF 重写时，子进程只需要看 List键 的当前状态，然后生成一个简短的命令，如 RPUSH List a b c d e f g h，直接设置正确的值，避免了任何冗余操作。</p><h4 id="AOF-配置详解"><a href="#AOF-配置详解" class="headerlink" title="AOF 配置详解"></a>AOF 配置详解</h4><p>我们只需要在 Redis 配置文件 redis.conf 中搜索 APPEND ONLY MODE 即可搜到 AOF 配置项。</p><p><strong>Q: 我想启用 AOF 模式，我应该怎么做？</strong></p><p>A: 将 appendonly 设置为 yes。默认是 no。</p><p><strong>Q: 我想改变 AOF 文件的名称，该怎么做？</strong></p><p>A: 使用 appendfilename 选项。默认名称是 appendonly.aof。</p><p><strong>Q: 有哪些方式可以控制 AOF 数据同步到磁盘的频率？</strong></p><p>A: 使用 appendfsync 选项。你有三个选择：</p><p><strong>always</strong>: 每次写操作后都同步。</p><p><strong>everysec</strong>: 每秒同步一次。</p><p><strong>no</strong>: 由操作系统决定何时同步。</p><p>默认设置是 <strong>everysec</strong>。</p><p><strong>Q: 当 Redis 进行 AOF 重写或快照保存时，我怎样避免主进程 fsync 的延迟？</strong></p><p>A: 设置 no-appendfsync-on-rewrite 为 yes。默认是 no。</p><p><strong>Q: 我怎样自动触发 AOF 文件重写？</strong></p><p>A: 使用以下两个配置：</p><p><strong>auto-aof-rewrite-percentage</strong>: AOF 文件增长的百分比，达到此值则触发 AOF 重写。例如，如果设置为100%，那么当 AOF 文件的大小是上次重写后的两倍时，Redis 会考虑触发自动重写。</p><p><strong>auto-aof-rewrite-min-size</strong>: AOF 文件大小门槛，超过此值即使增长的百分比小也会触发 AOF 重写。</p><p><strong>Q: 如果 AOF 文件在末尾被截断，Redis怎么办？</strong></p><p>A: 使用 aof-load-truncated 选项。如果设置为 yes，Redis 尝试加载并启动，同时发出日志警告；如果为 no，Redis 会中止并拒绝启动。默认是 yes。</p><h4 id="AOF-持久化的优缺点"><a href="#AOF-持久化的优缺点" class="headerlink" title="AOF 持久化的优缺点"></a>AOF 持久化的优缺点</h4><p><strong>优点</strong>：</p><p><strong>不轻易丢数据</strong>：AOF 记录了所有的写操作，所以即使服务器突然断电，数据丢失的机会也很小。</p><p><strong>易于理解</strong>：AOF是一个文本文件，里面就是一系列的命令，你可以打开查看。</p><p><strong>出问题也能救</strong>：如果 AOF 文件最后有点损坏，Redis 也能够修复它，避免大量数据丢失。</p><p><strong>缺点</strong>：</p><p><strong>可能会慢一些</strong>：因为要不断写入操作，所以比 RDB 要慢一点。</p><p><strong>文件可能很大</strong>：AOF 会记录所有操作，所以文件可能迅速增大，占用更多空间。</p><p><strong>恢复时间长</strong>：如果需要从 AOF 文件中恢复数据，由于文件可能很大，所以这个过程可能会比较慢。</p><h3 id="混合持久化"><a href="#混合持久化" class="headerlink" title="混合持久化"></a>混合持久化</h3><p>  回顾一下，我们已经探讨了 Redis 的 RDB 和 AOF 持久化。RDB 提供快速的数据恢复，但可能有数据丢失风险；AOF 保证了数据完整性，但文件可能过大，恢复速度较慢。那么，是否有一种既快速又可靠的方法？接下来，我们将介绍 Redis 的<strong>混合持久化策略</strong>。</p><h4 id="混合持久化是什么？"><a href="#混合持久化是什么？" class="headerlink" title="混合持久化是什么？"></a>混合持久化是什么？</h4><p>混合持久化是 Redis 4.0 新引入的持久化策略，结合了 RDB 的快速恢复和 AOF 的数据完整性的优点，它首先以 RDB 格式保存当前数据状态，然后继续以 AOF 格式记录新的写操作，确保数据完整性并优化恢复速度。</p><h4 id="简单图解"><a href="#简单图解" class="headerlink" title="简单图解"></a>简单图解</h4><p><img src="/images/RedisPersistence/6.png"></p><h4 id="混合持久化的工作原理"><a href="#混合持久化的工作原理" class="headerlink" title="混合持久化的工作原理"></a>混合持久化的工作原理</h4><p>在 AOF 重写之前，RDB 和 AOF 都是按照它们各自的持久化策略工作的。当 AOF 重写被触发时，混合持久化才开始发挥作用：将当前的数据集会首先以RDB 格式写入新 AOF 文件的顶部，然后再追加新的命令到文件的末尾。</p><h5 id="混合持久化的工作流程图"><a href="#混合持久化的工作流程图" class="headerlink" title="混合持久化的工作流程图"></a>混合持久化的工作流程图</h5><p><img src="/images/RedisPersistence/7.png"></p><p><strong>步骤说明</strong>：</p><p>混合持久化的实现主要是靠主进程和子进程共同来完成的。</p><p><strong>子进程</strong>: </p><p>   子进程进行 AOF 重写：</p><ul><li>首先创建新的 AOF 文件 appendonly.rdb</li><li>将 Redis 当前的数据生成 RDB 快照写入 appendonly.rdb 文件的开始部分</li></ul><p><strong>主进程</strong></p><ul><li>主进程先将新的写操作命令写入 AOF 重写缓冲区<br>   -主进程将 AOF 重写缓冲区的内容追加到 appendonly.rdb<br>文件的 RDB 数据的末尾</li><li>使用 appendonly.rdb 文件替换旧的 AOF 文件</li></ul><h4 id="混合持久化的配置"><a href="#混合持久化的配置" class="headerlink" title="混合持久化的配置"></a>混合持久化的配置</h4><p><strong>Q: Redis 的混合持久化如何开启？</strong></p><p>A: 将 aof-use-rdb-preamble 选项设置为 yes，并且要同时启用 RDB 和 AOF 两种持久化。</p><p><strong>混合持久化的 AOF 重写与普通的 AOF 重写的区别</strong>：</p><p>在不使用混合持久化的情况下，普通的 AOF 重写是通过读取当前的内存数据并记录达到这一状态所需的最少命令来减少 AOF 文件的大小的。</p><p>而混合持久化在 AOF 重写时，会首先将当前数据集以 RDB 格式快照的形式写入新 AOF 文件的开始位置，然后再追加新的写命令到文件末尾。</p><h4 id="混合持久化的优缺点"><a href="#混合持久化的优缺点" class="headerlink" title="混合持久化的优缺点"></a>混合持久化的优缺点</h4><p><strong>优点</strong>：</p><p><strong>更快的启动速度</strong>：混合持久化结合了RDB的速度优势，所以Redis可以更快地重新启动，不用等待很久。</p><p><strong>数据安全</strong>：利用AOF的方式，即使服务器突然断电，也只会丢失极短的时间内的数据。</p><p><strong>文件更小巧</strong>：因为混合持久化结合了 RDB 和 AOF 的优势，所以文件大小和冗余度都可以得到控制。</p><p><strong>两全其美</strong>：简单说，它就是RDB和AOF的结合体，带来了两者的好处。</p><p><strong>缺点</strong>：</p><p><strong>稍微复杂</strong>：因为它结合了两种技术，所以处理起来比单一的 RDB 或 AOF 要复杂一点。</p><p><strong>可能占更多空间</strong>：在某些情况下，保存数据的文件可能会比只使用 RDB 或AOF 的文件要大一些。</p><p><strong>写入速度</strong>：可能会稍慢一些，特别是当数据需要经常被保存到硬盘时（比如当 appendfsync 配置为“always”时）</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在本系列文章中，我们深入探讨了 Redis 的持久化机制。通过详细介绍 RDB、AOF 以及混合持久化这三种主流的持久化方法，我们不仅学习了它们各自的工作机制和配置策略，还探讨了它们的优缺点，以帮助读者根据自己的实际需求选出合适的持久化方式。</p><ul><li>RDB 持久化以其高效的数据恢复速度和较小的性能开销脱颖而出，适合数据备份和灾难恢复场景。</li><li>AOF 持久化通过记录每个写操作确保了更高级别的数据安全性，尽管它可能导致文件体积增大和写入性能的轻微下降。</li><li>混合持久化模式结合了 RDB 的快速数据恢复能力和 AOF 的数据安全性，提供了一种既快速又可靠的数据恢复解决方案。</li></ul><p>所以大家在选择持久化策略时，需要考虑到数据安全性、恢复速度、以及系统性能三者之间的平衡。RDB 适合需要定期备份的场景，AOF 适合对数据丢失有严格要求的应用，而混合持久化模式则是一种比较折中的方案，它结合了 RDB 的快速数据恢复能力和 AOF 的数据安全性。</p><p><strong>这里我又将 Redis 的三种持久化方式的优缺点以及使用场景做了详细的对比</strong>:</p><table><thead><tr><th align="left">持久化方式</th><th align="center">优点</th><th align="right">缺点</th><th align="right">使用场景</th></tr></thead><tbody><tr><td align="left">RDB</td><td align="center">1. 生成文件速度快。2. 恢复数据速度快。3. 磁盘空间占用少。</td><td align="right">1. 数据丢失风险。2. 快照操作可能的性能下降。</td><td align="right">1. 数据备份。2. 数据迁移。3. 灾难恢复时的快速数据恢复。</td></tr><tr><td align="left">AOF</td><td align="center">1. 提供更高的数据安全性。2. 记录实际操作命令（可读性好）。3. 可以自定义保存频率。</td><td align="right">1. 文件可能较大。2. 数据恢复速度较慢。</td><td align="right">数据安全性要求高的场合</td></tr><tr><td align="left">混合持久化</td><td align="center">提供了数据安全和更快的数据恢复速度。</td><td align="right">维护两种文件格式，增加磁盘占用空间。</td><td align="right">快速的数据恢复和高数据安全性的场景。</td></tr></tbody></table><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>如果你对 Linux C&#x2F;C++ 编程，Redis 等后端技术感兴趣或者想学习计算机原理相关的知识，不妨关注我的公众号<strong>「跟着小康学编程」</strong>。这里不仅有持续更新的计算机基础相关的文章，还有如何系统学习 C、C++，Linux 系统编程以及网络编程的文章等。后续也会持续新增关于 Go微服务 、docker、k8s等云原生领域的内容。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>另外，小康最近创建了一个技术交流群，专门用来探讨技术相关或者解答读者的问题。大家在阅读这篇文章的时候，如果觉得有问题的或者有不理解的知识点，欢迎大家加群询问。我能够解决的，尽量给大家回复。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> NoSQL数据库 </category>
          
          <category> 数据库技术 </category>
          
          <category> Redis教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis持久化 </tag>
            
            <tag> RDB </tag>
            
            <tag> AOF </tag>
            
            <tag> 混合持久化 </tag>
            
            <tag> Redis教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis入门指南：掌握常见数据类型</title>
      <link href="/RedisObject/"/>
      <url>/RedisObject/</url>
      
        <content type="html"><![CDATA[<p><strong>前言:</strong></p><p>每次你在游戏中看到玩家排行榜，或者在音乐应用中浏览热门歌单，有没有想过这个排行榜是如何做到实时更新的？当然，依靠 Redis 即可做到。</p><p>在技术领域，我们经常听到<strong>「键值存储」</strong> 这个词。但在 Redis 的世界里，这只是冰山一角。Redis 的对象，不仅仅是简单的数据，它们是为各种任务量身定制的超能工具。</p><p>接下来，让我们走进 Redis 的对象世界，Redis 5.0版本就已经支持了下面的 9 种类型，分别是 ：<strong>字符串对象、列表对象、哈希对象、集合对象、有序集合对象、Bitmaps 对象、HyperLogLog 对象、Geospatial 对象、Stream对象。</strong></p><p><img src="/images/RedisObject/1.png"></p><h1 id="Redis-对象："><a href="#Redis-对象：" class="headerlink" title="Redis 对象："></a><strong>Redis 对象：</strong></h1><p>首先，我们要知道，<strong>Redis</strong> 中保存的数据是以<strong>键值对</strong>的形式存在的。</p><h2 id="对象的类型与编码"><a href="#对象的类型与编码" class="headerlink" title="对象的类型与编码"></a><strong>对象的类型与编码</strong></h2><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a><strong>类型</strong></h3><p>在 <strong>Redis</strong> 的大家庭中，每个键值对都有两个重要的“<strong>身份证</strong>”。那就是<strong>键的类型</strong>和<strong>值的类型</strong>。就好像我们的名字和职业，其中名字（键）总是一个字符串，而职业（值）则可以是各种各样：可以是字符串、列表、哈希、集合，甚至是有序集合。这就是我们所说的对象类型，五彩斑斓，各有特色。</p><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a><strong>编码</strong></h3><p>我们都知道超级英雄有着不同的超能力，蜘蛛侠(Spider-Man) 有蜘蛛感应，钢铁侠(Iron Man)有高科技装备。同样，Redis 中的每个对象都有一种称为“编码”的隐藏能力。这是什么呢？</p><p>简单说，编码是对象的“内部魔法”。它决定了对象在 Redis 内部的存储方式。就好像手机里的照片可以是 JPEG 或 PNG 格式，Redis 对象也可以有不同的编码格式。</p><p>但为什么这很重要呢？因为不同的编码方式意味着不同的存储效率和性能。Redis 非常聪明，它会选择最佳的编码方式，为我们节省空间和提高性能。</p><p>我们先来看下 <strong>Redis 对象结构体</strong>声明</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct redisObject &#123;</span><br><span class="line">    unsigned type:4;       # 数据类型，使用了4位来表示</span><br><span class="line">    unsigned encoding:4;   # 编码方式 </span><br><span class="line">    void *ptr;             # 指向底层数据结构的指针</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><p><strong>Redis</strong> 中的每个对象都是由 <strong>redisObject</strong> 结构表示，其中的 <strong>encoding</strong> 成员记录了对象所使用的编码，<strong>encoding</strong> 的取值不同，对象内部使用的数据结构也会有所不同。关于 redis 对象的各个数据结构的讲解，本篇不涉及，后续会补上。</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a><strong>分类</strong></h2><h3 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a><strong>字符串对象</strong></h3><h4 id="基本概念："><a href="#基本概念：" class="headerlink" title="基本概念："></a><strong>基本概念：</strong></h4><p>字符串对象是最简单的类型，也是二进制安全的，意味着可以存储任何形式的数据，例如 JPEG 图片、序列化的对象或者纯文本。</p><h4 id="简单图解"><a href="#简单图解" class="headerlink" title="简单图解:"></a><strong>简单图解:</strong></h4><p><img src="/images/RedisObject/2.png"></p><p><strong>value 可以存储任何类型的数据：包括普通字符串，数值类型(int,float) 等</strong></p><h4 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a><strong>内部实现</strong></h4><p>Redis 的 String 对象使用一种称为 简单动态字符串<strong>SDS（Simple Dynamic String）</strong> 的结构来存储数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">对象结构体声明:</span><br><span class="line">typedef struct redisObject &#123;</span><br><span class="line">    unsigned type:4;      # 数据类型，使用了4位来表示 </span><br><span class="line">    unsigned encoding:4;  # 编码方式</span><br><span class="line">    void *ptr;            # 指向底层数据结构的指针 </span><br><span class="line">&#125; robj;</span><br><span class="line"></span><br><span class="line">SDS 结构体声明:</span><br><span class="line">struct sdshdr &#123;</span><br><span class="line">    size_t len;           # 记录buf数组中已使用字节的数量。</span><br><span class="line">    size_t alloc;         # 记录buf数组的总容量。</span><br><span class="line">    char buf[];           # 字节数组，用于保存字符串。</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="String-对象的编码"><a href="#String-对象的编码" class="headerlink" title="String 对象的编码"></a><strong>String 对象的编码</strong></h4><p>String 对象的编码有三种: <strong>int、embstr、raw</strong> 。</p><ul><li>int 编码 ：对象 robj 的 ptr 成员指向的是 long 类型的整数</li><li>embstr 和 raw 编码 : 对象 robj 的 ptr 成员指向的是 sdshdr 结构体，值存储在 buf 中。</li></ul><p><strong>使用限制:</strong> 单个 <strong>String</strong> 对象的值可以存储的数据大小上限为 <strong>512MB</strong></p><h4 id="常见命令："><a href="#常见命令：" class="headerlink" title="常见命令："></a><strong>常见命令：</strong></h4><p><strong>基本操作</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SET key value : 设置键的值</span><br><span class="line">GET key       : 获取键的值</span><br><span class="line">DEL key       : 删除键</span><br><span class="line"></span><br><span class="line">&gt; SET username &quot;xiaokang&quot;</span><br><span class="line">OK</span><br><span class="line">&gt; GET username</span><br><span class="line">&quot;xiaokang&quot;</span><br><span class="line">&gt; DEL username</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p><strong>字符串操作</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">APPEND key value           : 向字符串尾部追加</span><br><span class="line">STRLEN key                 : 获取字符串的长度</span><br><span class="line">SETRANGE key offset value  : 覆盖部分内容</span><br><span class="line">GETRANGE key start end     : 获取子字符串</span><br><span class="line"># 上面命令的参数 offset、start、end 都指的是下标(从0开始)</span><br><span class="line"></span><br><span class="line"># 初始键值对 : SET username &quot;xiaokang&quot;</span><br><span class="line">&gt; APPEND username 1998</span><br><span class="line">(integer) 12</span><br><span class="line">&gt; GET username</span><br><span class="line">&quot;xiaokang1998&quot;</span><br><span class="line">&gt; STRLEN username</span><br><span class="line">(integer) 12</span><br><span class="line">&gt; SETRANGE username 0 kang</span><br><span class="line">(integer) 12</span><br><span class="line">&gt; GET username</span><br><span class="line">&quot;kangkang1998&quot;</span><br><span class="line">&gt; GETRANGE username 8 -1  # -1代表的是值的结尾</span><br><span class="line">&quot;1998&quot;</span><br></pre></td></tr></table></figure><p><strong>数值操作</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">INCR/DECY key                 : 自增1或自减1</span><br><span class="line">INCRBY/DECRBY key increment   : 自增或自减整数，步长为 increment 必须为整数，可正可负</span><br><span class="line">INCRBYFLOAT key increment     : 自增、自减浮点数，increment 推荐使用浮点数，代表你是在操作浮点数，可正可负</span><br><span class="line"># redis 中没有提供 DECRBYFLOAT，所以要想递减浮点数，increment 为负即可</span><br><span class="line"></span><br><span class="line">&gt; set count 2</span><br><span class="line">OK</span><br><span class="line">&gt; INCR count</span><br><span class="line">(integer) 3</span><br><span class="line">&gt; DECR count</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; INCRBY count 3</span><br><span class="line">(integer) 5</span><br><span class="line">127.0.0.1:6379&gt; DECRBY count 3</span><br><span class="line">(integer) 2</span><br><span class="line">&gt; SET float_count 5.5</span><br><span class="line">OK</span><br><span class="line">&gt; INCRBYFLOAT float_count 2.5</span><br><span class="line">&quot;8&quot;</span><br><span class="line">&gt; INCRBYFLOAT float_count -3.5</span><br><span class="line">&quot;4.5&quot;</span><br></pre></td></tr></table></figure><p><strong>批量操作</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MSET key1 value1 key2 value2 : 批量设置键值</span><br><span class="line">MGET key1 key2               : 批量获取键值</span><br><span class="line"></span><br><span class="line">&gt; MSET username xiaokang age 25</span><br><span class="line">OK</span><br><span class="line">&gt; GET username</span><br><span class="line">&quot;xiaokang&quot;</span><br><span class="line">&gt; MGET username age</span><br><span class="line">1) &quot;xiaokang&quot;</span><br><span class="line">2) &quot;25&quot;</span><br></pre></td></tr></table></figure><p><strong>条件设置</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SETNX key value                   : 仅当键不存在时设置值,键存在则不会执行任何操作</span><br><span class="line">MSETNX key value [key value ...]  : 批量设置</span><br><span class="line"></span><br><span class="line">&gt; SETNX career programmer</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; MSETNX sex man hobby swim</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p><strong>带有过期时间的设置</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SETEX key seconds value : 为键值设置过期时间</span><br><span class="line"></span><br><span class="line"># 10s 后 redis 会自动删除这个 key</span><br><span class="line">&gt; SETEX username 10 xiaokang</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><h4 id="应用案例"><a href="#应用案例" class="headerlink" title="应用案例"></a><strong>应用案例</strong></h4><p><strong>计数器</strong></p><p><strong>描述</strong>: 利用 Redis 追踪某些事物的数量。</p><p><strong>具体应用 :</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">1. 文章访问计数：文章的阅读次数</span><br><span class="line">#当某篇文章被访问时，递增该文章的阅读计数器。</span><br><span class="line">INCR article:12345:views</span><br><span class="line">#获取某篇文章的阅读次数。</span><br><span class="line">GET article:12345:views</span><br><span class="line"></span><br><span class="line">2. 社交媒体互动计数 ：点赞数</span><br><span class="line">#当某个帖子被点赞时，递增该帖子的点赞计数器。</span><br><span class="line">INCR post:67890:likes</span><br><span class="line">#检查某个帖子的点赞数。</span><br><span class="line">GET post:67890:likes</span><br><span class="line"></span><br><span class="line">3. 实时统计 ：例如，一个电商网站可以使用 Redis 来跟踪网站上当前的在线用户数量</span><br><span class="line">#当用户在线时，递增在线用户计数器。</span><br><span class="line">INCR website:online_users</span><br><span class="line">#检查当前在线的用户数量。</span><br><span class="line">GET website:online_users</span><br><span class="line"></span><br><span class="line">4. 限流: 例如，你可能想限制一个 API 在一定时间内的调用次数。</span><br><span class="line"># 设置一个 API 的调用次数限制。这里以 60 秒内最多调用 10 次为例。</span><br><span class="line">SETEX api:call_limit:client_ip 60 10</span><br><span class="line"># 当 API 被调用时，递减调用计数器。如果值小于或等于 0，则表示已达到限流。</span><br><span class="line">DECRBY api:call_limit:client_ip 1</span><br><span class="line"># 检查某个 API 的剩余调用次数。</span><br><span class="line">GET api:call_limit:client_ip</span><br></pre></td></tr></table></figure><p><strong>分布式锁 : 超越传统的锁机制</strong></p><p>想象一下，一个电商网站正在进行一次秒杀活动，该活动只有100个商品库存。当活动开始时，数万用户同时尝试购买这些商品。</p><p>如果秒杀系统只部署在一个服务器上，那么我们可以使用<strong>普通锁</strong>来保证库存不会被超卖。但是，现在的大型电商平台的抢购系统都是部署在多个服务器上的，所以单个服务器上的普通锁并不能保证整个系统的<strong>数据一致性</strong>。</p><p>这时候，我们需要一个更强大的锁：<strong>分布式锁</strong>， 那什么是分布式锁呢？分布式锁，顾名思义，是能在多个系统或多台机器之间都起到限制访问的“锁”。</p><p>在秒杀活动这个场景中，分布式锁确保了即便是数万用户在多个服务器上同时尝试购买，系统也能正确、有序地处理每一个购买请求，确保不会出现超卖的情况。</p><p><strong>基本概念：</strong></p><p>分布式锁是一种能够在多个计算机、服务器或节点之间确保任何时候只有一个进程在执行的机制。它是在复杂的分布式环境中维持顺序和一致性的关键工具。</p><p><strong>实现方式：</strong></p><p>使用 Redis 实现分布式锁一般步骤：</p><ol><li>加锁：SET lock_key unique_id EX expire_time NX</li></ol><ul><li>lock_key    ：分布式锁名</li><li>unique_id   ：唯一标识符</li><li>EX     ：设置过期时间</li><li>NX     ：当 lock_key 不存在时命令才会成功</li></ul><ol><li>操作共享资源</li><li>释放锁：通过 Lua 脚本来释放锁，先 GET 判断锁是否归属自己，再 DEL 释放锁</li></ol><p><strong>Lua 脚本 : 用来保证释放锁操作的原子性</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">判断锁是自己的，才释放</span><br><span class="line">if redis.call(&quot;GET&quot;,KEYS[1]) == ARGV[1]</span><br><span class="line">then</span><br><span class="line">    return redis.call(&quot;DEL&quot;,KEYS[1])</span><br><span class="line">else</span><br><span class="line">    return 0</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p><strong>上面实现方式存在一个问题：分布式锁的过期时间如何确定？</strong></p><p>如果客户端预期的操作时间超过锁的过期时间，这该怎么办？锁的超时时间设置过长过短都不好。一个合理的方案就是采用自动续期。</p><p><strong>续期具体做法：</strong></p><p>加锁时，我们设定一个到期时间，启动一个<strong>「守护线程」</strong> 定时查看锁的状态。如果锁即将到期且任务未完成，我们自动「<strong>续期」</strong> 这个锁，重新设置其到期时间。如果续期失败，为避免并发问题，客户端应立刻停止操作。</p><p>然而幸运的是，一些编程语言已经实现了专门的客户端库，如 Java 的 Redisson和 Go 的 redsync，它们提供了简化的分布式锁实现。这些库已内置了自动续期等关键功能，避免开发者手动构建这些逻辑。</p><p><strong>注意：</strong></p><p>以上只是实现了一个单机版的分布式锁，而 Redis 在实际生产环境中都会采用主从集群 + 哨兵的模式部署，这样当主库异常宕机时，哨兵可以实现「故障自动切换」，把从库提升为主库，继续提供服务，以此保证可用性。</p><p><strong>我们来考虑一个问题：当「主从发生切换」时，这个分布锁会依旧安全吗？</strong></p><p>关于这个问题我这里不做深入探讨，感兴趣的可以参考这篇文章：<strong>「链接地址在文章末尾」</strong></p><p><strong>缓存</strong></p><p><strong>描述</strong>：利用 Redis 缓存 MYSQL 等关系型数据库查询结果，从而减少关系型数据库的压力。</p><p><strong>具体实现:</strong></p><p>当用户请求某个数据时，首先检查 Redis 是否有这个数据。如果有，直接从 Redis 返回，这样可以避免查询数据库。如果 Redis 中没有，那么查询关系型数据库，获取数据后，存入 Redis，并设置一个适当的过期时间。</p><p><strong>简单示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func getUserInfo(rdb *redis.Client, userID string) string &#123;</span><br><span class="line"> // 尝试从 Redis 中获取用户信息</span><br><span class="line"> val, err := rdb.Get(ctx, userID).Result()</span><br><span class="line"> if err == redis.nil&#123;</span><br><span class="line">     userData := queryDatabase(userID) #在这里模拟一个数据库查询</span><br><span class="line">     rdb.Set(ctx, userID, userData, time.Hour)  # 缓存结果1小时 </span><br><span class="line">     return userData</span><br><span class="line"> &#125;</span><br><span class="line"> return val</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func queryDatabase(userID string) string &#123;</span><br><span class="line">    //查询数据库</span><br><span class="line">    // ...</span><br><span class="line">   return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Session 存储</strong></p><p><strong>Session 是什么：</strong></p><p>每次你在网上购物时，在浏览、选择商品、加入购物车，网站都能“记得”你的选择，这是因为它使用了”Session”。简单来说，Session 是服务器给你的一个小“记忆空间”。</p><p>在日常的网页浏览中，每当一个用户的请求到达服务器，例如页面访问、API调用，为了维持用户状态或提供个性化的服务，系统通常需要读取该用户的 session 数据。</p><p><strong>具体实现：</strong></p><p>当用户登录到一个系统时，后端通常会为该用户生成一个唯一的 session ID 。这个 ID 会被传回给客户端，通常存储在 cookie 中。随后，每次客户端发出请求时，都会携带这个 session ID，允许服务器识别出该用户。</p><p>为了应对这种频繁的数据读取需求，我们可以将这个 session ID 和 session 数据分别作为键值存储到 redis 中。session 数据包括 : 用户 ID、用户名等。使用 Redis 来存储 session 数据不仅提供了高速的读取效率，还让用户体验更为流畅。</p><p><strong>使用示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 在设置 session 存储时，一般会设置过期时间的。</span><br><span class="line">SET session:userId expired_time &quot;user_data_in_json_or_serialized_format&quot;</span><br><span class="line">GET session:userId</span><br></pre></td></tr></table></figure><h3 id="列表对象"><a href="#列表对象" class="headerlink" title="列表对象"></a>列表对象</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>Redis 的列表对象是一个有序的字符串集合，这里的有序指的是<strong>添加元素有先后顺序</strong>的，可以被看作是一个双向链表。在 Redis 中，每个列表可以包含超过 4 亿个元素。</p><h4 id="简单图解-1"><a href="#简单图解-1" class="headerlink" title="简单图解"></a>简单图解</h4><p><img src="/images/RedisObject/3.png"></p><h4 id="内部实现-1"><a href="#内部实现-1" class="headerlink" title="内部实现"></a>内部实现</h4><ul><li><strong>压缩列表</strong> <strong>(Ziplist)</strong>: 当列表对象保存的所有字符串元素的长度都小于 64 字节并且列表对象保存的元素数量小于 512 个，列表对象会使用压缩列表(ziplist)作为其底层实现。</li><li><strong>双向链表(Linkedlist)</strong>:不满足上述两个条件之一的, 列表对象会使用双向链表(Linkedlist) 作为其底层实现。</li></ul><h4 id="常见命令：-1"><a href="#常见命令：-1" class="headerlink" title="常见命令："></a><strong>常见命令：</strong></h4><p><strong>查找元素</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">LRANGE key start stop  : 获取列表指定范围内的元素</span><br><span class="line">LINDEX key index       : 通过索引获取列表中的元素</span><br><span class="line">LLEN key               : 返回列表的长度</span><br><span class="line"></span><br><span class="line"># 查看列表对象的所有元素，-1 代表列表对象的最后一个元素</span><br><span class="line">&gt; LRANGE myList 0 -1</span><br><span class="line">1) &quot;grape&quot;</span><br><span class="line">2) &quot;banana&quot;</span><br><span class="line">3) &quot;apple&quot;</span><br><span class="line">4) &quot;orange&quot;</span><br><span class="line">&gt; LINDEX myList 1</span><br><span class="line">&quot;banana&quot;</span><br><span class="line">&gt; LLEN myList</span><br><span class="line">(integer) 4</span><br></pre></td></tr></table></figure><p><strong>插入元素 :</strong></p><ul><li>普通插入</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">LPUSH key element [element ...]   : 将一个或多个值插入到列表头部</span><br><span class="line">RPUSH key element [element ...]   : 将一个或多个值插入到列表尾部</span><br><span class="line"></span><br><span class="line">&gt; LPUSH myList &quot;apple&quot; &quot;banana&quot;</span><br><span class="line">(integer) 2</span><br><span class="line">&gt; LRANGE myList 0 -1</span><br><span class="line">1) &quot;banana&quot;</span><br><span class="line">2) &quot;apple&quot;</span><br><span class="line">&gt; RPUSH myList &quot;orange&quot; &quot;pear&quot;</span><br><span class="line">(integer) 4</span><br><span class="line">&gt; LRANGE myList 0 -1</span><br><span class="line">1) &quot;banana&quot;</span><br><span class="line">2) &quot;apple&quot;</span><br><span class="line">3) &quot;orange&quot;</span><br><span class="line">4) &quot;pear&quot;</span><br></pre></td></tr></table></figure><ul><li>条件插入</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">LPUSHX key element  [element ...] : 只有当列表存在时，将值插入到列表的头部，如果列表不存在，则什么也不做</span><br><span class="line">RPUSHX key element  [element ...] : 只有当列表存在时，将值插入到列表的尾部，如果列表不存在，则什么也不做</span><br><span class="line"></span><br><span class="line">&gt; LPUSHX myList &quot;grape&quot;</span><br><span class="line">(integer) 5</span><br><span class="line">&gt; LRANGE myList 0 -1</span><br><span class="line">1) &quot;grape&quot;</span><br><span class="line">2) &quot;banana&quot;</span><br><span class="line">3) &quot;apple&quot;</span><br><span class="line">4) &quot;orange&quot;</span><br><span class="line">5) &quot;pear&quot;</span><br><span class="line">&gt; LPUSHX noExistList &quot;peach&quot;</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure><p><strong>删除元素:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">LPOP key [count]      : 移除并返回列表的前 count 个元素</span><br><span class="line">RPOP key [count]      : 移除并返回列表的最后 count 个元素</span><br><span class="line">LREM key count value  : 移除列表中与参数 value 相等的 count 个元素</span><br><span class="line"></span><br><span class="line"># 先查看列表中的元素</span><br><span class="line">&gt; LRANGE myList 0 -1</span><br><span class="line">1) &quot;grape&quot;</span><br><span class="line">2) &quot;banana&quot;</span><br><span class="line">3) &quot;apple&quot;</span><br><span class="line">4) &quot;orange&quot;</span><br><span class="line">5) &quot;pear&quot;</span><br><span class="line">&gt; LPOP myList</span><br><span class="line">&quot;grape&quot;</span><br><span class="line">&gt; LRANGE myList 0 -1</span><br><span class="line">1) &quot;banana&quot;</span><br><span class="line">2) &quot;apple&quot;</span><br><span class="line">3) &quot;orange&quot;</span><br><span class="line">4) &quot;pear&quot;</span><br><span class="line">&gt; RPOP myList</span><br><span class="line">&quot;pear&quot;</span><br><span class="line">&gt; LRANGE myList 0 -1</span><br><span class="line">1) &quot;banana&quot;</span><br><span class="line">2) &quot;apple&quot;</span><br><span class="line">3) &quot;orange&quot;</span><br></pre></td></tr></table></figure><p><strong>修改元素：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">LSET key index value : 通过索引来设置元素的值</span><br><span class="line">LTRIM key start stop ：裁剪列表</span><br><span class="line"># 先查看列表中的元素</span><br><span class="line">&gt; LRANGE myList 0 -1</span><br><span class="line">1) &quot;grape&quot;</span><br><span class="line">2) &quot;banana&quot;</span><br><span class="line">3) &quot;apple&quot;</span><br><span class="line">4) &quot;orange&quot;</span><br><span class="line">&gt; LSET myList 0 &quot;peach&quot;</span><br><span class="line">OK</span><br><span class="line">&gt; LRANGE myList 0 -1</span><br><span class="line">1) &quot;peach&quot;</span><br><span class="line">2) &quot;banana&quot;</span><br><span class="line">3) &quot;apple&quot;</span><br><span class="line">4) &quot;orange&quot;</span><br><span class="line">&gt; LTRIM myList 0 2</span><br><span class="line">OK</span><br><span class="line">&gt; LRANGE myList 0 -1</span><br><span class="line">1) &quot;peach&quot;</span><br><span class="line">2) &quot;banana&quot;</span><br><span class="line">3) &quot;apple&quot;</span><br></pre></td></tr></table></figure><p><strong>元素转移:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RPOPLPUSH source destination: 将 source 列表的最后一个元素弹出，并将该元素添加到 destination 列表的头部，同时返回该元素，如果 destination 列表不存在，redis 会自动创建 destination 列表</span><br><span class="line"></span><br><span class="line">&gt; LRANGE myList 0 -1</span><br><span class="line">1) &quot;banana&quot;</span><br><span class="line">2) &quot;apple&quot;</span><br><span class="line">&gt; RPOPLPUSH myList destList</span><br><span class="line">&quot;apple&quot;</span><br><span class="line">&gt; LRANGE destList 0 -1</span><br><span class="line">1) &quot;apple&quot;</span><br></pre></td></tr></table></figure><p>要注意的是列表对象并不存在 LPOPRPUSH 命令，可以通过组合 LPOP 和 RPUSH 命令来实现类似效果。</p><p><strong>阻塞操作:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">BLPOP key [key ...] timeout            : 移除并获取列表的第一个元素，或阻塞直到有一个可用</span><br><span class="line">BRPOP key [key ...] timeout            : 移除并获取列表的最后一个元素，或阻塞直到有一个可用</span><br><span class="line">BRPOPLPUSH source destination timeout  : 将 source 列表的最后一个元素弹出，并将该元素添加到 destination 列表的头部，同时返回该元素</span><br><span class="line"></span><br><span class="line"># 先查看列表中的元素</span><br><span class="line">&gt; LRANGE myList 0 -1</span><br><span class="line">1) &quot;peach&quot;</span><br><span class="line">2) &quot;banana&quot;</span><br><span class="line">3) &quot;apple&quot;</span><br><span class="line">4) &quot;orange&quot;</span><br><span class="line">&gt;  LRANGE noExistList 0 -1</span><br><span class="line">(empty array)</span><br><span class="line">&gt; BLPOP myList noExistList 10</span><br><span class="line">1) &quot;myList&quot;</span><br><span class="line">2) &quot;peach&quot;</span><br><span class="line">&gt; LRANGE myList 0 -1</span><br><span class="line">1) &quot;banana&quot;</span><br><span class="line">2) &quot;apple&quot;</span><br><span class="line">3) &quot;orange&quot;</span><br><span class="line">&gt; BRPOP myList noExistList 10</span><br><span class="line">1) &quot;myList&quot;</span><br><span class="line">2) &quot;orange&quot;</span><br><span class="line"># 先查看列表的初识元素</span><br><span class="line">&gt; LRANGE myList 0 -1</span><br><span class="line">1) &quot;banana&quot;</span><br><span class="line">&gt; LRANGE destList 0 -1</span><br><span class="line">1) &quot;apple&quot;</span><br><span class="line">&gt; BRPOPLPUSH myList destList 10</span><br><span class="line">&quot;banana&quot;</span><br><span class="line">&gt; LRANGE myList 0 -1</span><br><span class="line">(empty array)</span><br><span class="line">&gt; LRANGE destList 0 -1</span><br><span class="line">1) &quot;banana&quot;</span><br><span class="line">2) &quot;apple&quot;</span><br></pre></td></tr></table></figure><h4 id="应用案例："><a href="#应用案例：" class="headerlink" title="应用案例："></a><strong>应用案例：</strong></h4><p>1.<strong>消息队列</strong> ：</p><p>当用户在网上购物下订单后，为了不让他们等待各种后续处理（如检查库存、处理付款、发货），我们直接把订单放入一个消息队列，然后由后台进程从队列中获取并处理订单。</p><p><strong>实现步骤：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 生产者（下订单的用户）        </span><br><span class="line">LPUSH orders_queue order_id</span><br><span class="line">2. 消费者服务获取订单（ 消费者：后台处理订单的服务）   </span><br><span class="line">BRPOP orders_queue 5</span><br><span class="line">3. 处理订单 :                   </span><br><span class="line">一旦消费者从队列中获取了一个新订单，它可以开始进行必要的处理，</span><br><span class="line">例如检查库存、处理付款等。</span><br></pre></td></tr></table></figure><p>2.<strong>栈和队列</strong> ：</p><p><strong>栈：</strong> 想象一个浏览器的返回功能。用户访问了几个页面，你希望能够提供一个[返回] 按钮让用户回到他们之前浏览的页面。</p><p><strong>实现步骤：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 添加元素</span><br><span class="line">LPUSH browser_history &quot;page1&quot;</span><br><span class="line">LPUSH browser_history &quot;page2&quot;</span><br><span class="line">LPUSH browser_history &quot;page3&quot;</span><br><span class="line"></span><br><span class="line">2.当用户点击返回按钮时:</span><br><span class="line">LPOP browser_history  # Fetches &quot;page3&quot;, the most recently visited</span><br></pre></td></tr></table></figure><p><strong>队列：</strong></p><p>当我们在电商网站上浏览商品、点击广告或执行其他操作时，这些行为都可以被捕获为一个”事件”。每个事件通常都包含一些基本信息，如用户ID、商品ID、点击时间、页面URL等。</p><p><strong>实现步骤：</strong></p><ul><li>用户点击事件捕获</li></ul><p>假设一个用户点击了一个商品。此时，我们可以创建一个 JSON 对象来存储这次点击的详细信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$json = &#123;</span><br><span class="line">    &quot;user_id&quot;: &quot;12345&quot;,</span><br><span class="line">    &quot;product_id&quot;: &quot;98765&quot;,</span><br><span class="line">    &quot;timestamp&quot;: &quot;2023-09-01T12:00:00Z&quot;,</span><br><span class="line">    &quot;page_url&quot;: &quot;/products/98765&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>发送事件到队列</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LPUSH click_events $json</span><br></pre></td></tr></table></figure><ul><li>消费者进程获取事件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RPOP click_events</span><br></pre></td></tr></table></figure><p>当消费者进程从队列中获取事件后，可以进一步解析这个JSON对象，并进行所需的处理，例如更新商品的点击率等，以便将该商品推荐给更多的用户。</p><p>3.<strong>历史追踪</strong>：</p><p>可以使用 Redis 列表来跟踪最近的历史记录，例如最近访问的网页或其他活动。</p><p><strong>以最近访问的网页举例说明:</strong> 在一个网站上，你可能希望追踪用户最近访问了哪些页面。每当用户访问一个新页面时，你可以使用 LPUSH 将这个页面 URL 添加到一个列表中，并使用 LTRIM 确保列表只保存最近 N 次访问。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LPUSH user_recent_pages &quot;/home&quot;</span><br><span class="line">LPUSH user_recent_pages &quot;/product/1&quot;</span><br><span class="line">LTRIM user_recent_pages 0 9  # 保留最近10个访问的页面</span><br></pre></td></tr></table></figure><p>使用 Redis 列表来跟踪最近的历史记录能够高效地保存和查询用户的近期活动，从而为用户提供个性化的推荐。</p><h3 id="哈希对象"><a href="#哈希对象" class="headerlink" title="哈希对象"></a><strong>哈希对象</strong></h3><h4 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a><strong>基本概念</strong></h4><p>Redis 哈希对象也是一种用于存储键值对集合的数据结构，它允许你将多个键值对存储在一个 Redis 键中。</p><p>我们一般会使用 Redis 的 Hash 对象来存储对象信息，比如用户信息，用户的名字、年龄、爱好、电子邮箱、密码等。与使用普通的 key-value 存储方式相比 , 哈希对象的存储方式更为高效和节省空间，特别是当我们要存储大量小对象时。</p><h4 id="简单图解："><a href="#简单图解：" class="headerlink" title="简单图解："></a>简单图解：</h4><p><img src="/images/RedisObject/4.png"></p><p><strong>简单说明：</strong></p><p>假设你有一把大钥匙，这把钥匙可以打开一个特定的箱子。这箱子里面有很多物品，每个物品都有标签来描述它。</p><ul><li>大钥匙 就是我们的 key</li><li>箱子 就代表一个 哈希对象</li><li>箱子里的物品与其标签 就是 field-value 键值对</li></ul><h4 id="内部实现-2"><a href="#内部实现-2" class="headerlink" title="内部实现"></a><strong>内部实现</strong></h4><ul><li><strong>压缩列表(ziplist)</strong> ：当哈希对象保存的所有键值对的键和值的字符串长度都小于64字节并且哈希对象保存的键值对的数量小于 512 个，哈希对象会采用压缩列表作为其底层实现。</li><li><strong>字典(基于哈希表实现)</strong> ：当不能满足上述条件之一时，哈希对象则会采用字典作为其底层实现。</li></ul><h4 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a><strong>常见命令</strong></h4><p><strong>设置值</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HSET key field value [field value ...] : 设置哈希的 Field-Value 对,可以设置多个</span><br><span class="line">HSETNX key field value                 : 只有在字段 field 不存在时，才设置对应的 value 值，否则什么也不做。</span><br><span class="line"></span><br><span class="line">&gt; HSET userInfo username xiaokang age 25 hobby swim</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure><p><strong>获取值</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">HGET key field              : 获取哈希指定字段的值</span><br><span class="line">HMGET key field [field ...] : 获取哈希多个字段的值 # 批量获取</span><br><span class="line">HGETALL key                 : 获取哈希表中的所有字段和值</span><br><span class="line">HKEYS key                   : 获取哈希中所有的字段名(field)</span><br><span class="line">HVALS key                   : 获取哈希中所有的字段值(value)</span><br><span class="line"></span><br><span class="line">&gt; HGET userInfo username</span><br><span class="line">&quot;xiaokang&quot;</span><br><span class="line">&gt; HMGET userInfo &quot;username&quot; &quot;age&quot;</span><br><span class="line">1) &quot;xiaokang&quot;</span><br><span class="line">2) &quot;25&quot;</span><br><span class="line">&gt; HGETALL userInfo</span><br><span class="line">1) &quot;username&quot;</span><br><span class="line">2) &quot;xiaokang&quot;</span><br><span class="line">3) &quot;age&quot;</span><br><span class="line">4) &quot;25&quot;</span><br><span class="line">5) &quot;hobby&quot;</span><br><span class="line">6) &quot;swim&quot;</span><br><span class="line">&gt; HKEYS userInfo</span><br><span class="line">1) &quot;username&quot;</span><br><span class="line">2) &quot;age&quot;</span><br><span class="line">3) &quot;hobby&quot;</span><br><span class="line">&gt; HVALS userInfo</span><br><span class="line">1) &quot;xiaokang&quot;</span><br><span class="line">2) &quot;25&quot;</span><br><span class="line">3) &quot;swim&quot;</span><br></pre></td></tr></table></figure><p><strong>自增操作</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">HINCRBY key field increment       : 为哈希字段的整数值加上增量 # increment 可正可负</span><br><span class="line">HINCRBYFLOAT key field increment  : 为哈希字段的浮点数值加上增量 # increment 可正可负</span><br><span class="line"></span><br><span class="line">&gt; HGET userInfo age</span><br><span class="line">&quot;25&quot;</span><br><span class="line">&gt; HINCRBY userInfo age 1</span><br><span class="line">(integer) 26</span><br><span class="line">&gt; HGET userInfo age</span><br><span class="line">&quot;26&quot;</span><br><span class="line"></span><br><span class="line"># HINCRBYFLOAT 命令类似，increment 既可以是整数也可以是浮点数，可正可负</span><br></pre></td></tr></table></figure><p><strong>删除操作</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">HDEL key field [field ...] : 删除一个或多个哈希表字段</span><br><span class="line"></span><br><span class="line"># 先查看 hash 字段的所有字段和值</span><br><span class="line">&gt; HGETALL userInfo</span><br><span class="line">1) &quot;username&quot;</span><br><span class="line">2) &quot;xiaokang&quot;</span><br><span class="line">3) &quot;age&quot;</span><br><span class="line">4) &quot;25&quot;</span><br><span class="line">5) &quot;hobby&quot;</span><br><span class="line">6) &quot;swim&quot;</span><br><span class="line">&gt; HDEL userInfo &quot;hobby&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; HGETALL userInfo</span><br><span class="line">1) &quot;username&quot;</span><br><span class="line">2) &quot;xiaokang&quot;</span><br><span class="line">3) &quot;age&quot;</span><br><span class="line">4) &quot;25&quot;</span><br></pre></td></tr></table></figure><p><strong>其他操作</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">HEXISTS key field     : 检查哈希对象中是否存在给定的字段</span><br><span class="line">HLEN key              : 获取哈希中字段的数量</span><br><span class="line">HSTRLEN key field     : 获取哈希字段的字符串长度</span><br><span class="line"></span><br><span class="line"># 先查看哈希的所有字段和值</span><br><span class="line">&gt; HGETALL userInfo</span><br><span class="line">1) &quot;username&quot;</span><br><span class="line">2) &quot;xiaokang&quot;</span><br><span class="line">3) &quot;age&quot;</span><br><span class="line">4) &quot;25&quot;</span><br><span class="line">&gt; HLEN userInfo</span><br><span class="line">(integer) 2</span><br><span class="line">&gt; HSTRLEN userInfo &quot;username&quot;</span><br><span class="line">(integer) 8</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong></p><ul><li><strong>小哈希优化：</strong> Redis 对于哈希对象的内存布局进行了优化。小哈希（即哈希对象字段数量很少且字段值大小较小）的内存使用会更加高效。</li><li><strong>避免大量删除：</strong> 使用 HDEL 一次删除大量字段可能会影响性能，建议分批进行。</li><li><strong>使用哈希而非多个键：</strong> 当需要存储有关特定对象的多个相关字段时，使用单个哈希键比使用多个独立的 Redis 键更为高效。</li></ul><h4 id="应用案例-1"><a href="#应用案例-1" class="headerlink" title="应用案例"></a><strong>应用案例</strong></h4><ul><li><strong>对象存储 :</strong></li></ul><p>主要是指将某种实体或数据（如用户信息）持久性地保存在 Redis 中，如 ：用户的用户名、邮箱、密码等信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">保存用户信息：</span><br><span class="line">HSET user:1234 name &quot;John Doe&quot; email &quot;john.doe@example.com&quot; age 30</span><br><span class="line">获取用户的邮箱：</span><br><span class="line">HGET user:1234 email</span><br></pre></td></tr></table></figure><ul><li><strong>对象缓存：</strong></li></ul><p>这是指当数据原本存储在其他存储系统（如关系型数据库）中，但由于频繁访问或读取，我们决定在 Redis 中缓存该数据的一份副本，以减少对原始数据源的访问压力并提高读取速度。</p><p><strong>场景描述：</strong></p><p>假设你有一个博客网站，用户可以阅读和评论各种博客文章。每当用户点击一个博客标题，系统都会从关系型数据库中获取该文章的详细内容进行显示。但是，由于某些热门文章被大量用户频繁访问，直接从数据库中获取文章可能会对数据库造成很大的压力，从而影响网站的性能。</p><p><strong>具体实现：</strong></p><p><strong>伪代码展示 :</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">    &quot;github.com/go-redis/redis/v8&quot;</span><br><span class="line">    &quot;context&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var ctx = context.Background()</span><br><span class="line">options := &amp;redis.Options&#123;</span><br><span class="line">    Addr: &quot;localhost:6379&quot;,  // Redis服务器地址</span><br><span class="line">&#125;</span><br><span class="line">// 初始化Redis客户端：</span><br><span class="line">rdb := redis.NewClient(options)</span><br><span class="line"></span><br><span class="line">// 检查缓存：当用户请求一篇文章时，首先检查Redis缓存中是否存在该文章的数据。</span><br><span class="line">exists, err := rdb.HExists(ctx, &quot;article:ID&quot;, &quot;title&quot;).Result()</span><br><span class="line">if err != nil &#123;</span><br><span class="line">    // Handle error</span><br><span class="line">&#125;</span><br><span class="line">//从缓存中获取数据：如果文章存在于Redis中，则直接从Redis的哈希对象中获取所有相关字段，并显示给用户。</span><br><span class="line">if exists &#123;</span><br><span class="line">    articleData, err := rdb.HGetAll(ctx, &quot;article:ID&quot;).Result()</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        // Handle error</span><br><span class="line">    &#125;</span><br><span class="line">    display(articleData)</span><br><span class="line">&#125;</span><br><span class="line">//从数据库中获取数据：如果文章不在Redis缓存中，则从关系型数据库中获取数据保存到 Redis 缓存中，并且设置超时。</span><br><span class="line">if !exists &#123;</span><br><span class="line">    articleData := Database.fetchArticleByID(&quot;article:ID&quot;)</span><br><span class="line">    _, err := rdb.HMSet(ctx, &quot;article:ID&quot;, map[string]interface&#123;&#125;&#123;</span><br><span class="line">        &quot;title&quot;:   articleData.Title,</span><br><span class="line">        &quot;author&quot;:  articleData.Author,</span><br><span class="line">        &quot;content&quot;: articleData.Content,</span><br><span class="line">    &#125;).Result()</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        // Handle error</span><br><span class="line">    &#125;</span><br><span class="line">    rdb.Expire(ctx, &quot;article:ID&quot;, time.Hour) // 设置1小时的过期时间</span><br><span class="line">    // 显示给用户</span><br><span class="line">    display(articleData)</span><br><span class="line">&#125;</span><br><span class="line">//显示给用户的函数</span><br><span class="line">func display(articleData map[string]string) &#123;</span><br><span class="line">    // ... 你的显示逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>实时统计 ：</strong></li></ul><p>为了跟踪网站的实时活动，我们可以使用哈希来保存当前在线用户、页面浏览量和API 请求次数等。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">增加在线用户数：</span><br><span class="line">HINCRBY website:stats online_users 1</span><br><span class="line">减少在线用户数：</span><br><span class="line">HINCRBY website:stats online_users -1</span><br><span class="line">记录每个页面的访问次数：</span><br><span class="line">HINCRBY pageviews:20230901 &quot;/home&quot; 1</span><br></pre></td></tr></table></figure><h3 id="集合对象"><a href="#集合对象" class="headerlink" title="集合对象"></a>集合对象</h3><h4 id="基本概念：-1"><a href="#基本概念：-1" class="headerlink" title="基本概念："></a>基本概念：</h4><p>集合对象（Set）是一种存储多个唯一元素的无序集合数据结构，它提供了丰富的操作使得集合对象成为非常强大和灵活的工具。集合对象特别适用于存储不允许重复的数据项，例如标签、社交网络中的好友列表或者任何需要快速判断某个元素是否存在的场景。</p><h4 id="简单图解-2"><a href="#简单图解-2" class="headerlink" title="简单图解"></a>简单图解</h4><p><img src="/images/RedisObject/5.png"></p><h4 id="内部实现-3"><a href="#内部实现-3" class="headerlink" title="内部实现"></a>内部实现</h4><ul><li><strong>整数集合（intset） :</strong> 当集合对象保存的所有元素都是整数或者集合对象保存的整数个数不超过512个时，集合对象采用 intset 作为其底层实现。</li><li><strong>字典（基于哈希表实现）：</strong> 不满足上面的两个条件之一，则采用字典作为其底层实现。</li></ul><h4 id="常见命令-1"><a href="#常见命令-1" class="headerlink" title="常见命令"></a>常见命令</h4><p><strong>基本操作:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">SADD key member [member ...] ：向集合添加一个或多个成员</span><br><span class="line">SMEMBERS key                 ：获取集合中的所有成员</span><br><span class="line">SCARD key                    ：获取集合的成员数量</span><br><span class="line">SISMEMBER key member         ：判断 member 元素是否是集合 key 的成员</span><br><span class="line">SREM key member [member ...] ：移除集合中的一个或多个成员</span><br><span class="line"></span><br><span class="line">&gt; SADD mySet &quot;apple&quot; &quot;banana&quot; &quot;peach&quot;</span><br><span class="line">(integer) 3</span><br><span class="line">&gt; SMEMBERS mySet</span><br><span class="line">1) &quot;peach&quot;</span><br><span class="line">2) &quot;banana&quot;</span><br><span class="line">3) &quot;apple&quot;</span><br><span class="line">&gt; SCARD mySet</span><br><span class="line">(integer) 3</span><br><span class="line">&gt; SISMEMBER mySet &quot;peach&quot;   # 成员存在返回 1</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; SISMEMBER mySet &quot;pear&quot;    # 成员不存在返回 0</span><br><span class="line">(integer) 0</span><br><span class="line">&gt; SREM mySet &quot;peach&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; SMEMBERS mySet</span><br><span class="line">1) &quot;banana&quot;</span><br><span class="line">2) &quot;apple&quot;</span><br></pre></td></tr></table></figure><p><strong>集合运算:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">SINTER key [key ...]                  ：返回所有给定集合的交集</span><br><span class="line">SINTERSTORE destination key [key ...] ：交集存储在 destination 集合中</span><br><span class="line">SUNION key [key ...]                  ：返回所有给定集合的并集</span><br><span class="line">SUNIONSTORE destination key [key ...] ：并集存储在 destination 集合中</span><br><span class="line">SDIFF key [key ...]                   ：返回第一个集合与其他集合之间的差集</span><br><span class="line">SDIFFSTORE destination key [key ...]  ：差集存储在 destination 集合中</span><br><span class="line"></span><br><span class="line">&gt; SMEMBERS mySet</span><br><span class="line">1) &quot;pear&quot;</span><br><span class="line">2) &quot;banana&quot;</span><br><span class="line">3) &quot;apple&quot;</span><br><span class="line">&gt; SMEMBERS yourSet</span><br><span class="line">1) &quot;peach&quot;</span><br><span class="line">2) &quot;banana&quot;</span><br><span class="line">3) &quot;apple&quot;</span><br><span class="line">&gt; SINTER mySet yourSet</span><br><span class="line">1) &quot;banana&quot;</span><br><span class="line">2) &quot;apple&quot;</span><br><span class="line">&gt; SINTERSTORE resultSet mySet yourSet</span><br><span class="line">(integer) 2</span><br><span class="line">&gt; SMEMBERS resultSet</span><br><span class="line">1) &quot;banana&quot;</span><br><span class="line">2) &quot;apple&quot;</span><br><span class="line"># 并集我这里不提了，和交集操作类似</span><br><span class="line">&gt; SDIFF mySet yourSet</span><br><span class="line">1) &quot;pear&quot;</span><br><span class="line">&gt; SDIFFSTORE result mySet yourSet</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; SMEMBERS result</span><br><span class="line">1) &quot;pear&quot;</span><br></pre></td></tr></table></figure><p><strong>随机操作：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">SRANDMEMBER key [count]               ：随机返回集合中的一个或多个成员</span><br><span class="line">SPOP key [count]                      ：随机移除并返回集合中的一个或多个成员</span><br><span class="line"></span><br><span class="line">&gt; SMEMBERS mySet</span><br><span class="line">1) &quot;pear&quot;</span><br><span class="line">2) &quot;banana&quot;</span><br><span class="line">3) &quot;apple&quot;</span><br><span class="line"># 可以看到每次返回的成员都不一样</span><br><span class="line">&gt; SRANDMEMBER mySet</span><br><span class="line">&quot;pear&quot;</span><br><span class="line">&gt; SRANDMEMBER mySet</span><br><span class="line">&quot;apple&quot;</span><br><span class="line">&gt; SPOP mySet</span><br><span class="line">&quot;pear&quot;</span><br><span class="line">&gt; SMEMBERS mySet</span><br><span class="line">1) &quot;banana&quot;</span><br><span class="line">2) &quot;apple&quot;</span><br></pre></td></tr></table></figure><p><strong>其他操作:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">SMOVE source destination member       : 将 member 成员从 source 集合移动到 destination 集合</span><br><span class="line"></span><br><span class="line">&gt; SMEMBERS mySet</span><br><span class="line">1) &quot;pear&quot;</span><br><span class="line">2) &quot;banana&quot;</span><br><span class="line">3) &quot;apple&quot;</span><br><span class="line">&gt; SMEMBERS yourSet</span><br><span class="line">1) &quot;peach&quot;</span><br><span class="line">2) &quot;banana&quot;</span><br><span class="line">3) &quot;apple&quot;</span><br><span class="line">&gt; SMOVE mySet yourSet &quot;pear&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; SMEMBERS mySet</span><br><span class="line">1) &quot;banana&quot;</span><br><span class="line">2) &quot;apple&quot;</span><br><span class="line">&gt; SMEMBERS yourSet</span><br><span class="line">1) &quot;peach&quot;</span><br><span class="line">2) &quot;pear&quot;</span><br><span class="line">3) &quot;banana&quot;</span><br><span class="line">4) &quot;apple&quot;</span><br></pre></td></tr></table></figure><h4 id="应用案例-2"><a href="#应用案例-2" class="headerlink" title="应用案例"></a><strong>应用案例</strong></h4><ul><li><strong>社交网站的好友与关注系统</strong></li></ul><p>利用集合来存储每个用户的朋友或关注者列表。例如，我们可以为每个用户维护一个集合，其中包含他们的所有朋友或关注者。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SADD &quot;alice:friends&quot; &quot;bob&quot;     # Alice 关注了 Bob</span><br><span class="line">SADD &quot;bob:friends&quot; &quot;charlie&quot;   # Bob 关注了 Charlie</span><br><span class="line">SISMEMBER &quot;alice:friends&quot;, &quot;bob&quot; # 判断 Bob 是否是 Alice 的朋友</span><br></pre></td></tr></table></figure><ul><li><strong>标签系统</strong></li></ul><p>可以为内容（如文章、图片等）添加标签，并利用集合存储这些标签。</p><p><strong>场景描述：</strong>假设你正在运行一个博客平台，你希望为每篇文章添加一组标签，使用户可以更容易地根据主题或兴趣查找相关文章。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1.为文章添加标签：</span><br><span class="line"># 当你发布文章&quot;Redis入门指南&quot;，其ID为1001，你为它添加了标签&quot;technology&quot;, &quot;tutorial&quot;,和&quot;redis&quot;。</span><br><span class="line">SADD tag:technology 1001</span><br><span class="line">SADD tag:tutorial 1001</span><br><span class="line">SADD tag:redis 1001</span><br><span class="line"></span><br><span class="line">2.查找具有特定标签的文章</span><br><span class="line"># 如果用户想要查看所有与&quot;redis&quot;相关的文章：</span><br><span class="line">SMEMBERS tag:redis   # 输出 1001 ：这表示文章ID为1001的文章带有&quot;redis&quot;标签。</span><br><span class="line"></span><br><span class="line">3.获取文章的所有标签</span><br><span class="line"># 每当你需要查看某篇文章的标签，你可以为其创建一个集合。以文章ID为1001为例：</span><br><span class="line">SADD article:1001:tags &quot;technology&quot;</span><br><span class="line">SADD article:1001:tags &quot;tutorial&quot;</span><br><span class="line">SADD article:1001:tags &quot;redis&quot;</span><br><span class="line"></span><br><span class="line"># 要查看文章1001的所有标签：</span><br><span class="line">SMEMBERS article:1001:tags</span><br><span class="line"># 输出：</span><br><span class="line">1) &quot;technology&quot;</span><br><span class="line">2) &quot;tutorial&quot;</span><br><span class="line">3) &quot;redis&quot;</span><br></pre></td></tr></table></figure><ul><li><strong>唯一计数</strong></li></ul><p>例如，记录网站的独立访客数。集合可以帮助我们做到这一点，因为它们只存储唯一的元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.存储当天登录的所有用户ID：</span><br><span class="line">SADD visitors:2023-09-20 user12345</span><br><span class="line">SADD visitors:2023-09-20 user67890</span><br><span class="line">2.获得当天登录的独立用户数</span><br><span class="line">SCARD visitors:2023-09-20</span><br></pre></td></tr></table></figure><h3 id="有序集合对象"><a href="#有序集合对象" class="headerlink" title="有序集合对象"></a>有序集合对象</h3><h4 id="基本概念：-2"><a href="#基本概念：-2" class="headerlink" title="基本概念："></a>基本概念：</h4><p>Redis 有序集合（Sorted Set）对象是一种存储非重复元素集合的数据结构，每个元素都关联一个双精度浮点数分数（score），用于维护元素之间的排序顺序。有序集合支持高效的元素插入和删除操作，同时保持元素按分数排序，使其非常适合于需要按照排序顺序访问元素的场景，如排行榜、带权重的任务队列等。</p><h4 id="简单图解-3"><a href="#简单图解-3" class="headerlink" title="简单图解:"></a>简单图解:</h4><p><img src="/images/RedisObject/6.png"></p><h4 id="内部实现-4"><a href="#内部实现-4" class="headerlink" title="内部实现"></a>内部实现</h4><ul><li>压缩列表（ziplist）:  当有序集合保存的元素数量小于 128 个 并且有序集合保存的所有元素成员的长度小于 64 字节，有序集合对象会采用 ziplist 作为其底层实现。</li><li>跳表(skiplist )：不满足以上2个条件之一的采用 skiplist 作为其底层实现。</li></ul><h4 id="常见命令-2"><a href="#常见命令-2" class="headerlink" title="常见命令"></a>常见命令</h4><p><strong>添加与更新成员</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ZADD key score member [score member ...] : 添加一个或多个成员到有序集合，或者更新已存在成员的分数</span><br><span class="line">ZINCRBY key increment member             : 增加有序集合中指定成员的分数</span><br><span class="line"></span><br><span class="line">&gt; ZADD myZSet 10 member1 20 member2</span><br><span class="line">(integer) 2</span><br><span class="line"># 获取有序集合中的所有成员及其分数</span><br><span class="line">&gt; ZRANGE myZSet 0 -1 WITHSCORES</span><br><span class="line">1) &quot;member1&quot;</span><br><span class="line">2) &quot;10&quot;</span><br><span class="line">3) &quot;member2&quot;</span><br><span class="line">4) &quot;20&quot;</span><br><span class="line">&gt; ZINCRBY myZSet 5 &quot;member1&quot;</span><br><span class="line">&quot;15&quot;</span><br><span class="line">&gt; ZRANGE myZSet 0 -1 WITHSCORES</span><br><span class="line">1) &quot;member1&quot;</span><br><span class="line">2) &quot;15&quot;</span><br><span class="line">3) &quot;member2&quot;</span><br><span class="line">4) &quot;20&quot;</span><br></pre></td></tr></table></figure><p><strong>查询操作</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">ZCARD key            : 获取有序集合的成员数量</span><br><span class="line">ZSCORE key member    : 获取指定成员的分数值</span><br><span class="line">ZRANK key member     : 返回有序集合中指定成员的排名，排名依次是 0，1，2 ...</span><br><span class="line">ZREVRANK key member  : 返回有序集合中指定成员的排名，成员按分数值递减排列</span><br><span class="line">&gt; ZCARD myZSet</span><br><span class="line">(integer) 2</span><br><span class="line">&gt; ZSCORE myZSet &quot;member2&quot;</span><br><span class="line">&quot;20&quot;</span><br><span class="line">&gt; ZRANK myZSet &quot;member1&quot;</span><br><span class="line">(integer) 0</span><br><span class="line">&gt; ZRANK myZSet &quot;member2&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; ZREVRANK myZSet &quot;member2&quot;</span><br><span class="line">(integer) 0</span><br><span class="line">&gt; ZREVRANK myZSet &quot;member1&quot;</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">ZRANGE key min max [WITHSCORES]        : 返回有序集中指定区间内的成员  # min 和 max 是要获取的排名范围（排名可以理解为索引，从0开始，其中0是分数最低的成员），可选的 [WITHSCORES] 参数表示除了返回成员名外，还要返回它们的分数</span><br><span class="line">ZREVRANGE key start stop [WITHSCORES]  : 返回有序集中指定区间内的成员，成员按分数递减排列</span><br><span class="line"></span><br><span class="line">&gt; ZRANGE myZSet 0 1</span><br><span class="line">1) &quot;member1&quot;</span><br><span class="line">2) &quot;member2&quot;</span><br><span class="line">&gt; ZRANGE myZSet 0 1 WITHSCORES</span><br><span class="line">1) &quot;member1&quot;</span><br><span class="line">2) &quot;15&quot;</span><br><span class="line">3) &quot;member2&quot;</span><br><span class="line">4) &quot;20&quot;</span><br><span class="line">&gt; ZREVRANGE myZSet 0 1</span><br><span class="line">1) &quot;member2&quot;</span><br><span class="line">2) &quot;member1&quot;</span><br><span class="line">&gt; ZREVRANGE myZSet 0 1 WITHSCORES</span><br><span class="line">1) &quot;member2&quot;</span><br><span class="line">2) &quot;20&quot;</span><br><span class="line">3) &quot;member1&quot;</span><br><span class="line">4) &quot;15&quot;</span><br><span class="line"></span><br><span class="line">ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]                                        : 获取分数在指定区间的所有成员，建议：max &gt;= min</span><br><span class="line">ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]: 获取分数在指定区间的所有成员，成员按分数递减排列; 建议：max &gt;= min</span><br><span class="line">#[LIMIT offset count]  这是一个限制返回的成员数量的可选项。其中，offset 是开始返回的起始位置（基于0的索引），count 是返回的成员总数。例如，LIMIT 1 3 会返回从下标为1开始的3个成员</span><br><span class="line"></span><br><span class="line">&gt; ZRANGEBYSCORE myZSet 16 22</span><br><span class="line">1) &quot;member2&quot;</span><br><span class="line">&gt; ZRANGEBYSCORE myZSet 16 22 WITHSCORES</span><br><span class="line">1) &quot;member2&quot;</span><br><span class="line">2) &quot;20&quot;</span><br><span class="line">&gt; ZRANGEBYSCORE myZSet 15 22 WITHSCORES LIMIT 0 2</span><br><span class="line">1) &quot;member1&quot;</span><br><span class="line">2) &quot;15&quot;</span><br><span class="line">3) &quot;member2&quot;</span><br><span class="line">4) &quot;20&quot;</span><br><span class="line">&gt; ZREVRANGEBYSCORE myZSet 22 15 WITHSCORES</span><br><span class="line">1) &quot;member2&quot;</span><br><span class="line">2) &quot;20&quot;</span><br><span class="line">3) &quot;member1&quot;</span><br><span class="line">4) &quot;15&quot;</span><br><span class="line"></span><br><span class="line">ZCOUNT key min max: 计算在有序集合中指定区间分数的成员数</span><br><span class="line">ZLEXCOUNT key min max: 用于计算基于成员名称的字典序位于指定区间内的成员数量 # 对于 min和 max，要使用方括号 [ 或 ( 来指示范围的边界是否包含在计数中。方括号 [ 表示该值是包含的，而小括号 ( 表示该值是不包含的。</span><br><span class="line"></span><br><span class="line">&gt; ZCOUNT myZSet 15 20</span><br><span class="line">(integer) 2</span><br><span class="line">&gt; ZLEXCOUNT myZSet [a [z</span><br><span class="line">(integer) 2</span><br><span class="line">&gt; ZLEXCOUNT myZSet [a [b</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line">ZSCAN key cursor [MATCH pattern] [COUNT count]: 迭代Redis的有序集合（ZSET）的元素，包括它的成员和分数。是一种渐进地遍历有序集的方法，而不是一次返回所有结果，这对于大型数据集尤为有用，因为它不会因为要返回大量的结果而阻塞服务器。</span><br><span class="line"># cursor: 用于迭代的游标。初次调用时，通常设置为&quot;0&quot;，之后的调用将使用上次返回的游标值。</span><br><span class="line">MATCH pattern (可选): 一个可选的匹配模式，用于筛选具有特定模式的元素。</span><br><span class="line">COUNT count (可选): 提示服务器每次迭代应返回多少元素。实际数目可能会稍多或稍少。</span><br><span class="line"></span><br><span class="line">&gt; ZSCAN myZSet  0</span><br><span class="line">1) &quot;0&quot;</span><br><span class="line">2) 1) &quot;member1&quot;</span><br><span class="line">   2) &quot;15&quot;</span><br><span class="line">   3) &quot;member2&quot;</span><br><span class="line">   4) &quot;20&quot;</span><br><span class="line">&gt; ZSCAN myZSet  0 MATCH  mem*</span><br><span class="line">1) &quot;0&quot;</span><br><span class="line">2) 1) &quot;member1&quot;</span><br><span class="line">   2) &quot;15&quot;</span><br><span class="line">   3) &quot;member2&quot;</span><br><span class="line">   4) &quot;20&quot;</span><br><span class="line">&gt; ZSCAN myZSet  0 COUNT 1</span><br><span class="line">1) &quot;0&quot;</span><br><span class="line">2) 1) &quot;member1&quot;</span><br><span class="line">   2) &quot;15&quot;</span><br><span class="line">   3) &quot;member2&quot;</span><br><span class="line">   4) &quot;20&quot;</span><br></pre></td></tr></table></figure><p><strong>删除操作</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">ZREM key member [member ...]    : 移除有序集合中的一个或多个成员</span><br><span class="line"># 先查看有序集合中的成员及分数</span><br><span class="line">&gt; ZRANGE myZSet 0 -1 WITHSCORES</span><br><span class="line">1) &quot;member1&quot;</span><br><span class="line">2) &quot;15&quot;</span><br><span class="line">3) &quot;member2&quot;</span><br><span class="line">4) &quot;20&quot;</span><br><span class="line">&gt; ZREM myZSet &quot;member1&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; ZRANGE myZSet 0 -1 WITHSCORES</span><br><span class="line">1) &quot;member2&quot;</span><br><span class="line">2) &quot;20&quot;</span><br><span class="line"></span><br><span class="line">ZPOPMAX key [count]             : 移除并返回有序集合中的最大的一些成员</span><br><span class="line">&gt; ZADD myZSet 15 &quot;member1&quot; 30 &quot;member3&quot; 55 &quot;member5&quot; 40 &quot;member4&quot;</span><br><span class="line">(integer) 4</span><br><span class="line">&gt; ZRANGE myZSet 0 -1 WITHSCORES</span><br><span class="line"> 1) &quot;member1&quot;</span><br><span class="line"> 2) &quot;15&quot;</span><br><span class="line"> 3) &quot;member2&quot;</span><br><span class="line"> 4) &quot;20&quot;</span><br><span class="line"> 5) &quot;member3&quot;</span><br><span class="line"> 6) &quot;30&quot;</span><br><span class="line"> 7) &quot;member4&quot;</span><br><span class="line"> 8) &quot;40&quot;</span><br><span class="line"> 9) &quot;member5&quot;</span><br><span class="line">10) &quot;55&quot;</span><br><span class="line">&gt; ZPOPMAX myZSet 2</span><br><span class="line">1) &quot;member5&quot;</span><br><span class="line">2) &quot;55&quot;</span><br><span class="line">3) &quot;member4&quot;</span><br><span class="line">4) &quot;40&quot;</span><br><span class="line">&gt; ZRANGE myZSet 0 -1 WITHSCORES</span><br><span class="line">1) &quot;member1&quot;</span><br><span class="line">2) &quot;15&quot;</span><br><span class="line">3) &quot;member2&quot;</span><br><span class="line">4) &quot;20&quot;</span><br><span class="line">5) &quot;member3&quot;</span><br><span class="line">6) &quot;30&quot;</span><br><span class="line"></span><br><span class="line">ZPOPMIN key [count]             : 移除并返回有序集合中的最小的一些成员</span><br><span class="line"># ZPOPMIN 我这里就不举例了，和 ZPOPMAX 类似</span><br><span class="line"></span><br><span class="line">ZREMRANGEBYRANK key start stop  : 移除有序集合中给定的排名区间的所有成员</span><br><span class="line">ZREMRANGEBYSCORE key min max    : 移除有序集合中给定的分数区间的所有成员</span><br><span class="line">ZREMRANGEBYLEX key min max      : 移除有序集合中给定的成员名字典区间的所有成员</span><br><span class="line"></span><br><span class="line">&gt; ZREMRANGEBYSCORE myZSet 20 30</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; ZRANGE myZSet 0 -1 WITHSCORES</span><br><span class="line">(empty array)</span><br><span class="line">&gt;  ZADD myZSet 15 &quot;member1&quot; 30 &quot;member3&quot; 55 &quot;member5&quot; 40 &quot;member4&quot;</span><br><span class="line">(integer) 4</span><br><span class="line">&gt; ZRANGE myZSet 0 -1 WITHSCORES</span><br><span class="line">1) &quot;member1&quot;</span><br><span class="line">2) &quot;15&quot;</span><br><span class="line">3) &quot;member3&quot;</span><br><span class="line">4) &quot;30&quot;</span><br><span class="line">5) &quot;member4&quot;</span><br><span class="line">6) &quot;40&quot;</span><br><span class="line">7) &quot;member5&quot;</span><br><span class="line">8) &quot;55&quot;</span><br><span class="line">&gt; ZREMRANGEBYLEX myZSet [&quot;member1&quot; [&quot;member4&quot;</span><br><span class="line">(integer) 3</span><br><span class="line">&gt; ZRANGE myZSet 0 -1 WITHSCORES</span><br><span class="line">1) &quot;member5&quot;</span><br><span class="line">2) &quot;55&quot;</span><br></pre></td></tr></table></figure><p><strong>集合操作</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">ZUNIONSTORE destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]    : 计算给定的一个或多个有序集的并集，并存储在新的 destination 中</span><br><span class="line">ZINTERSTORE destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]    : 计算给定的一个或多个有序集的交集，并存储在新的 destination 中</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line">destination   - 新的有序集合的名字，用于存放结果。</span><br><span class="line">numkeys       - 指定将要合并的有序集合的数量。</span><br><span class="line">key [key ...] - 需要合并的有序集合的名字。</span><br><span class="line">WEIGHTS       - 可选参数，用于为每一个输入的有序集分配一个乘法因子。例如，如果某个集合的 WEIGHT 是2，那么在计算并集时，该集合中的每个元素的分数都会乘以2。</span><br><span class="line">AGGREGATE     - 可选参数，它决定了当多个有序集合中存在相同元素时，如何处理这些元素的分数。有三个选项：SUM（默认）、MIN和MAX。SUM将相同元素的分数加起来，MIN 使用最小分数，而 MAX 使用最大分数。</span><br><span class="line"></span><br><span class="line">&gt; ZADD set1 1 &quot;one&quot; 2 &quot;two&quot;</span><br><span class="line">(integer) 2</span><br><span class="line">&gt; ZADD set2 1 &quot;one&quot; 3 &quot;three&quot;</span><br><span class="line">(integer) 2</span><br><span class="line">&gt; ZRANGE set1 0 -1 WITHSCORES</span><br><span class="line">1) &quot;one&quot;</span><br><span class="line">2) &quot;1&quot;</span><br><span class="line">3) &quot;two&quot;</span><br><span class="line">4) &quot;2&quot;</span><br><span class="line">&gt; ZRANGE set2 0 -1 WITHSCORES</span><br><span class="line">1) &quot;one&quot;</span><br><span class="line">2) &quot;1&quot;</span><br><span class="line">3) &quot;three&quot;</span><br><span class="line">4) &quot;3&quot;</span><br><span class="line">&gt; ZUNIONSTORE result 2 set1 set2</span><br><span class="line">(integer) 3</span><br><span class="line">&gt; ZRANGE result 0 -1 WITHSCORES</span><br><span class="line">1) &quot;one&quot;</span><br><span class="line">2) &quot;2&quot;</span><br><span class="line">3) &quot;two&quot;</span><br><span class="line">4) &quot;2&quot;</span><br><span class="line">5) &quot;three&quot;</span><br><span class="line">6) &quot;3&quot;</span><br><span class="line"># 当然，你可以使用 WEIGHTS 和 AGGREGATE 参数来调整结果的计算方式。例如，如果你想要为 set1 的每个成员加倍其分数，然后和 set2 求并集，并取每个成员的最大值作为结果：</span><br><span class="line"></span><br><span class="line"># set1 set2 两个集合的初始值没变，还是上面的数据</span><br><span class="line">&gt; ZUNIONSTORE result 2 set1 set2  WEIGHTS 2 1 AGGREGATE MAX</span><br><span class="line">(integer) 3</span><br><span class="line">&gt; ZRANGE result 0 -1 WITHSCORES</span><br><span class="line">1) &quot;one&quot;</span><br><span class="line">2) &quot;2&quot;</span><br><span class="line">3) &quot;three&quot;</span><br><span class="line">4) &quot;3&quot;</span><br><span class="line">5) &quot;two&quot;</span><br><span class="line">6) &quot;4&quot;</span><br></pre></td></tr></table></figure><h4 id="应用案例-3"><a href="#应用案例-3" class="headerlink" title="应用案例"></a>应用案例</h4><p><strong>实时排行榜</strong></p><ul><li><strong>游戏排行榜</strong></li></ul><p>在线游戏的实时排行榜，玩家或用户的得分可以即时更新，并按分数进行排序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 添加或更新分数</span><br><span class="line">ZADD leaderboard 1500 &quot;player1&quot;</span><br><span class="line">ZADD leaderboard 2200 &quot;player2&quot;</span><br><span class="line">ZADD leaderboard 1800 &quot;player3&quot;</span><br><span class="line">#查询前3名玩家</span><br><span class="line">ZREVRANGE leaderboard 0 2 WITHSCORES</span><br><span class="line"># 获取某个玩家的排名</span><br><span class="line">ZREVRANK leaderboard &quot;player1&quot;</span><br></pre></td></tr></table></figure><ul><li>网站文章或视频的热门排行</li></ul><p>网站可能希望展示其上点击量最高的文章或视频。每次有用户点击时，相关内容的计数就会增加，然后可以使用有序集合实时显示热门内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 文章被点击：</span><br><span class="line">ZINCRBY article_views 1 &quot;article123&quot;</span><br><span class="line">#获取最热门的 3 篇文章</span><br><span class="line">ZREVRANGE article_views 0 2 WITHSCORES</span><br></pre></td></tr></table></figure><ul><li>电商平台的热门产品排行</li></ul><p>电商平台可能希望展示最受欢迎的产品。每当产品被购买，其热度都会增加。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#产品被购买：</span><br><span class="line">ZINCRBY product_sales 1 &quot;product123&quot;</span><br><span class="line">#获取最受欢迎的10个产品</span><br><span class="line">ZREVRANGE product_sales 0 9 WITHSCORES</span><br></pre></td></tr></table></figure><p><strong>时间线事件记录</strong></p><p><strong>场景描述：</strong>假设我们正在为一个社交网络网站设计功能，用户每次登录、发帖或评论都会在其时间线上生成一个事件。我们希望可以跟踪这些事件并能够检索特定时间范围内的事件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#用户在某个时间点登录了网站</span><br><span class="line">ZADD user123:timeline 1631498200 &quot;Logged in&quot;</span><br><span class="line">#该用户稍后发表了一篇文章</span><br><span class="line">ZADD user123:timeline 1631498300 &quot;Posted an article about Redis&quot;</span><br><span class="line">#查询该用户在指定的时间范围内的所有事件</span><br><span class="line">ZRANGEBYSCORE user123:timeline 1631498200 1631498400</span><br></pre></td></tr></table></figure><p><strong>延迟任务队列</strong></p><p><strong>场景描述：</strong>用户订阅了一个在线服务，比如说一个<strong>音乐服务</strong>，它提供了<strong>一个月</strong>的免费试用。为了提醒用户及时续费或者保存他们的歌单数据，服务提供商可以在试用期结束前的几天，发送一个“您的试用即将结束，请及时续费”的提醒。这个提醒任务就可以放入延迟队列。</p><p><strong>具体实现步骤：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 用户注册: 当用户开始他们的免费试用时，你会将这个用户和他们试用结束时间的时间戳（减去3天，这样在结束前3天提醒他们）加入到一个有序集合中。</span><br><span class="line">ZADD trial_end_reminders (start_timestamp + trial_period - few_days) user_id  # 一般时间戳是以秒为单位的，对于这个例子，trial_period = 24*86400，few_days = 3 * 86400。</span><br><span class="line">#后台任务：后台任务每天定期检查这个有序集合，查看哪些用户需要在今天被提醒。</span><br><span class="line">ZRANGEBYSCORE trial_end_reminders (current_timestamp) (current_timestamp + 86400)</span><br><span class="line"></span><br><span class="line">#发送提醒：对于上面命令返回的每一个用户，你的系统会发送一个提醒邮件或者应用内通知，告诉他们试用即将结束，并提供一个续订链接。</span><br><span class="line"></span><br><span class="line">#清理：在发送提醒后，你需要从有序集合中移除这些用户，确保他们不会被再次提醒。</span><br><span class="line">ZREM trial_end_reminders user_id_1 user_id_2 ...</span><br></pre></td></tr></table></figure><h3 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps"></a><strong>Bitmaps</strong></h3><h4 id="基本概念：-3"><a href="#基本概念：-3" class="headerlink" title="基本概念："></a><strong>基本概念：</strong></h4><p>Redis 的 Bitmaps（位图）是一种特殊的数据结构，用于高效地处理大量的布尔值（true&#x2F;false或者1&#x2F;0）。在 Redis 中，Bitmaps 实际上并不是一种独立的数据类型，而是字符串（String）类型的一种特殊操作方式。通过 <strong>位操作</strong> 命令，Redis 允许用户在一个很大的字节数组中设置和获取位（bit）的值。</p><h4 id="简单图解-4"><a href="#简单图解-4" class="headerlink" title="简单图解:"></a><strong>简单图解:</strong></h4><p><img src="/images/RedisObject/7.png"></p><h4 id="内部实现-5"><a href="#内部实现-5" class="headerlink" title="内部实现"></a>内部实现</h4><p><strong>Bitmaps</strong> 实际上就是一个 String，底层采用字节数组来存储数据。</p><p>Bitmaps 提供了一系列的命令来操作和查询二进制位。</p><h4 id="基本命令："><a href="#基本命令：" class="headerlink" title="基本命令："></a>基本命令：</h4><p><strong>设置和获取位值：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SETBIT key offset value    : 设置或清除操作只需将对应位 置 0 即可指定的位 # 清除操作只需将对应位 置 0 即可， offset只能是非负整数。</span><br><span class="line">GETBIT key offset          : 获取指定位的值</span><br><span class="line"></span><br><span class="line">#  将位于索引7的位设置为1</span><br><span class="line">&gt; SETBIT mymap 7 1</span><br><span class="line">(integer) 0</span><br><span class="line">#  获取位于索引7的位的值</span><br><span class="line">&gt; GETBIT mymap 7</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p><strong>统计和查找：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">BITCOUNT key                 ：计算整个字符串中设置为1的位数</span><br><span class="line">BITCOUNT key [start end]     ：计算在指定范围内设置为1的位数</span><br><span class="line">BITPOS key bit [start] [end] : 找到第一个设置为1或0的位</span><br><span class="line"></span><br><span class="line">其中，start和end是字符串的字节索引（不是bit索引）</span><br><span class="line"></span><br><span class="line">&gt; BITCOUNT mymap  </span><br><span class="line">(integer) 1</span><br><span class="line">&gt; BITCOUNT mymap 0 1  # 计算从字节0到字节1之间设置为1的位数</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; BITPOS mymap 1</span><br><span class="line">(integer) 7</span><br><span class="line">&gt; BITPOS mymap 0</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure><p><strong>其他运算</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BITOP operation destkey key [key ...]   ： 对一个或多个bitmaps进行位运算</span><br><span class="line">operation 可能是 AND, OR, XOR, NOT 其中一种</span><br><span class="line">AND:逻辑与 、OR:逻辑或、XOR:逻辑异或、NOT：逻辑非</span><br><span class="line"></span><br><span class="line">&gt; SETBIT yourmap 5 1</span><br><span class="line">(integer) 0</span><br><span class="line">&gt; BITOP AND destMap mymap yourmap</span><br><span class="line">(integer) 1         # 返回 1，表示 destMap 的长度是 1 字节         </span><br></pre></td></tr></table></figure><h4 id="应用案列："><a href="#应用案列：" class="headerlink" title="应用案列："></a><strong>应用案列：</strong></h4><p><strong>员工打卡签到：</strong></p><p>大家都知道，员工打卡签到系统几乎是每家公司的标配功能。每天上班，员工都需要打卡来记录他们的出勤情况。今天我们来探讨一下，如何利用 Redis 中的 Bitmaps 来高效地实现这个功能。</p><p><strong>为什么选择 Bitmaps?</strong></p><p>员工打卡签到无非就是两种结果：签到和未签到。这种二元状态正好与Bitmaps的存储方式相契合，每位员工的每天签到状态只需用一个位（0或1）来表示。</p><p>每天使用一个特定日期格式的 key（如 user:12345:attendance:2023-09-01）存储Bitmaps。员工的 ID 直接作为位索引，如 ID 为 42 的员工签到，则将sign_2023-09-01的第 42 位设为 1。</p><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#员工打卡签到</span><br><span class="line">SETBIT user:42:attendance:2023-09-01 42 1    # 员工 ID 42 在2023-09-01签到</span><br><span class="line">SETBIT user:42:attendance:2023-09-01 1024 1  # 员工 ID 1024 在2023-09-01签到</span><br><span class="line"></span><br><span class="line">#检查特定用户是否在某天签到</span><br><span class="line">GETBIT user:42:attendance:2023-09-01 42  # 查看员工 ID 42 在2023-09-01是否签到</span><br><span class="line">GETBIT user:42:attendance:2023-09-01 500  # 查看员工 ID 500 在2023-09-01是否签到</span><br><span class="line"></span><br><span class="line">#计算某一天的签到用户数</span><br><span class="line">BITCOUNT user:42:attendance:2023-09-01  # 查看2023-09-01的签到用户数</span><br></pre></td></tr></table></figure><p><strong>日活跟踪:</strong></p><p>记录特定日期所有活跃用户的信息。例如，我们可以使用一个特定日期的 bitmaps 来跟踪该日期的所有活跃用户。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 用户 ID 为 12345 和 67890 在 2023-09-01 都活跃了</span><br><span class="line">SETBIT active_users:2023-09-01 12345 1</span><br><span class="line">SETBIT active_users:2023-09-01 67890 1</span><br><span class="line"></span><br><span class="line"># 检查用户 ID 为 12345 在 2023-09-01 是否活跃</span><br><span class="line">GETBIT active_users:2023-09-01 12345</span><br><span class="line"></span><br><span class="line">#检查某一天所有的活跃用户数</span><br><span class="line">BITCOUNT user:42:attendance:2023-09-01</span><br></pre></td></tr></table></figure><p><strong>用户登录：</strong></p><p>可以使用 bitmaps 来跟踪用户的登录状态，例如，确定用户是否已登录。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 用户 ID 为 12345 登录了</span><br><span class="line">SETBIT user:12345:login_status 1</span><br><span class="line"></span><br><span class="line"># 检查用户 ID 为 12345 是否登录</span><br><span class="line">GETBIT user:12345:login_status</span><br></pre></td></tr></table></figure><p><strong>这三个应用的关注点区别：</strong></p><p><strong>打卡签到：</strong> 主要关注个体用户的连续行为，例如连续签到多少天。</p><p><strong>日活跟踪：</strong> 关注整体的用户行为，例如在某一天有多少用户活跃了。</p><p><strong>用户登录：</strong> 主要跟踪用户的即时状态，例如某用户当前是否在线或已登录。</p><h3 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h3><p>在大数据应用中，我们经常需要计算或估算某个集合中不重复元素的数量（<strong>基数</strong>），例如统计网站的独立访客(UV)。但当数据规模非常大时，传统的统计方法会消耗大量的存储和计算资源。这时，Redis 的 HyperLogLog（简称HLL）提供了一个很好的解决方案。</p><h4 id="基本概念：-4"><a href="#基本概念：-4" class="headerlink" title="基本概念："></a>基本概念：</h4><p>从广义上说，HyperLogLog 是一个概率性的数据结构，用于估算集合的<strong>基数</strong>（即<strong>不重复元素的数量</strong>）。它不会提供完美准确的计数，但它使用的存储空间非常小（最多使用12KB的内存）。</p><p>在 <strong>Redis</strong> 的语境中，我们可以将 HyperLogLog 视为一种特定的数据类型。</p><h4 id="简单图解：-1"><a href="#简单图解：-1" class="headerlink" title="简单图解："></a>简单图解：</h4><p><img src="/images/RedisObject/8.png"></p><p><strong>步骤说明：</strong></p><ul><li>输入值通过哈希函数生成固定长度的二进制哈希值。</li><li>哈希值的前几位决定了它应该进入数组的位置。</li><li>存储值，将给定值的前导零的个数存储在数组的对应位置</li><li>数组中的值可能会根据新的哈希值进行更新（新的哈希值的前导零个数大于数组值才会更新）</li><li>根据数组元素进行基数估计</li></ul><h4 id="内部实现-6"><a href="#内部实现-6" class="headerlink" title="内部实现"></a>内部实现</h4><p>Redis 的 HyperLogLog 是一种特殊的数据类型，用来估计一个集合中有多少不同的元素。它不会给出完全准确的答案，但它的估计接近真实值，并且使用的存储空间非常小。它是基于一种名为 ‘HyperLogLog’ 的聪明算法来工作的，这种算法使用概率学的魔法来做估计，而不是真正地数每一个元素。</p><h4 id="基本命令：-1"><a href="#基本命令：-1" class="headerlink" title="基本命令："></a><strong>基本命令：</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">PFADD key element [element ...]           :  添加元素</span><br><span class="line">PFCOUNT key [key ...]                     :  查询基数估计值</span><br><span class="line">PFMERGE destkey sourcekey [sourcekey ...] :  合并多个 HyperLogLog 数据集</span><br><span class="line"></span><br><span class="line">&gt; PFADD myhll a b c d e f g</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; PFCOUNT myhll</span><br><span class="line">(integer) 7</span><br><span class="line">&gt; PFADD yourhll a b c d h i j k</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; PFMERGE desthll myhll yourhll</span><br><span class="line">OK</span><br><span class="line">&gt; PFCOUNT desthll</span><br><span class="line">(integer) 11</span><br></pre></td></tr></table></figure><h4 id="应用案例：-1"><a href="#应用案例：-1" class="headerlink" title="应用案例："></a><strong>应用案例：</strong></h4><p><strong>网站的 UV（独立访客）统计</strong></p><p>当你要统计一个网站的UV（独立访客）时，你的目标是确定有多少独立的用户访问了你的网站，而不是访问的总次数。传统的方法（比如，基于关系型数据库的计数）可能会很耗资源，特别是当访客量非常大时。</p><p>而 Redis 的 HyperLogLog 提供了一个空间效率非常高的方式来进行这样的估算。每当有用户访问网站时，你可以记录其 IP 地址或者某个与用户相关的唯一标识符（sessionID），然后使用 PFADD 命令将其加入到 HyperLogLog 中。</p><p><strong>具体实现：</strong></p><p><strong>为每个独立的访客生成唯一标识：</strong></p><p>现在大部分网站都会采用 cookie 技术。每当用户访问网站时，服务器都会为这位新访客生成一个唯一的 ID 并将其存储在 cookie 中。这个唯一的 ID 用于在后续的访问中识别该用户，从而跟踪其在网站上的行为和偏好。</p><p>我们使用 <strong>user_cookie_12345</strong> ，<strong>user_cookie_12346</strong> 等来标识不同的cookie</p><p><strong>添加 Cookie 到 HyperLogLog:</strong></p><p>为了跟踪一天的 UV，可以为每天创建一个 HyperLogLog。当用户访问你的网站时，使用PFADD命令将他们的唯一标识添加到 HyperLogLog 中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; PFADD uv_2023_09_01 user_cookie_12345 </span><br><span class="line">&gt; PFADD uv_2023_09_01 user_cookie_12346 </span><br><span class="line">&gt; PFADD uv_2023_09_01 user_cookie_12347 </span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><strong>估算该日的UV：</strong></p><p>使用 PFCOUNT 命令来获取估算的UV值。</p><p>该命令会返回一个估算的独立访客数量。请注意，这是一个估算值，但其精度在大多数情况下是足够的。</p><p><strong>存储历史数据：</strong></p><p>如果你想跟踪UV的历史数据，可以为每天保留一个 HyperLogLog。例如：uv_2023_09_01、uv_2023_09_02等。</p><p><strong>合并多日数据：</strong></p><p>如果你想要一个时间范围内的估算 UV（例如一个月），你可以使用 PFMERGE 命令合并多个 HyperLogLog。</p><p>以上就是使用 Redis 的 HyperLogLog 进行网站UV统计的基本方法。使用这种方法，你可以用非常少的空间（每个 HyperLogLog 只需要12KB）来跟踪大量的独立访客。</p><h3 id="Geospatial"><a href="#Geospatial" class="headerlink" title="Geospatial"></a>Geospatial</h3><p><strong>简介：</strong></p><p>Redis支持一个称为 Geospatial 的地理空间索引功能。这一功能在许多需要地理定位数据的应用中都有着广泛应用，如找到某个位置附近的餐厅或商店等。</p><h4 id="基本概念：-5"><a href="#基本概念：-5" class="headerlink" title="基本概念："></a>基本概念：</h4><p>“Geo” 来源于希腊语，意为“地球”，而 “spatial” 则表示“与空间有关”。结合起来，Geospatial 主要关注地球上的空间位置或地域。在 Redis 中，这意味着我们可以使用坐标系统（如经纬度）来存储和查询地理位置的数据。</p><h4 id="简单图解-5"><a href="#简单图解-5" class="headerlink" title="简单图解:"></a>简单图解:</h4><p><img src="/images/RedisObject/9.png"></p><h4 id="内部实现-7"><a href="#内部实现-7" class="headerlink" title="内部实现:"></a>内部实现:</h4><p><strong>地图到数字：</strong></p><p>想象一下，我们的地球是一个巨大的地图。如果我们要在这张地图上标记一个位置，通常会使用经纬度来描述它。但计算机更擅长处理数字而不是这样的坐标。因此，Redis 使用了一种叫做 Geohash 的技巧，它可以把这些坐标（比如经纬度）转换成一个数字。</p><p><strong>把位置存进列表：</strong></p><p>Redis 有一种特殊的列表叫做 zset（有序集合）。在 Geospatial 中，位置的名字（比如”北京”）作为元素，而转换得到的数字（Geohash）作为这个元素的“分数”。</p><p><strong>查找附近的地方：</strong></p><p>当我们想知道某个位置附近的其他地方时，Redis 会先找出这个位置的数字（Geohash），然后在 zset 中查找分数接近的其他元素。这样就可以快速地找出附近的位置。</p><p><strong>注意：</strong></p><p>使用 Geohash 的方法可能不是百分之百精确的，因为它是一种近似的方法。但在实际应用中，这种小小的误差通常不会导致太大的问题，而它让存储和查找变得非常迅速。</p><h4 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a><strong>基本命令</strong></h4><p><strong>添加操作：</strong></p><p>向指定的键中添加地理空间位置（经度、纬度、名称）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GEOADD key longitude latitude member [longitude latitude member ...]                    : 向指定的键中添加地理空间位置（经度、纬度、名称）</span><br><span class="line"></span><br><span class="line">&gt; GEOADD china:city 114.085947 22.547 shenzhen 113.280637 23.125178 guangzhou</span><br><span class="line">(integer) 2</span><br><span class="line">&gt; GEOADD china:city 121.472644 31.231706 shanghai 116.405285 39.904989 beijing</span><br><span class="line">(integer) 2</span><br><span class="line">&gt; GEOADD china:city 108.948024 34.263161 xian 106.504962 29.533155 chongqing</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure><p><strong>获取操作：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">GEOPOS key member [member ...]                      : 获取一个或多个位置元素的经纬度</span><br><span class="line">GEODIST key member1 member2 [m|km|ft|mi]            : 获取两个地点之间的距离    # [m|km|ft|mi]:  分别是：米，千米，英尺，英里</span><br><span class="line">GEORADIUS key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [ASC|DESC] [COUNT count]  : 根据给定的经纬度坐标，返回位于给定距离内的位置。</span><br><span class="line"></span><br><span class="line">#参数详解</span><br><span class="line">WITHCOORD    ： 返回查询结果中地理位置的经纬度坐标</span><br><span class="line">WITHDIST     ： 返回每个查询结果地点到给定坐标的距离</span><br><span class="line">WITHHASH     ： 返回位置的 52 位整数表示的 geohash</span><br><span class="line">ASC|DESC     ： 决定了查询结果的排序方式，按距离升序排列、按距离降序排列 </span><br><span class="line">COUNT count  :  限制查询结果的数量。</span><br><span class="line"></span><br><span class="line">&gt; GEOADD china:city 108.948024 34.263161 xian 106.504962 29.533155 chongqing</span><br><span class="line">(integer) 2</span><br><span class="line">&gt; GEOPOS china:city xian chongqing</span><br><span class="line">1) 1) &quot;108.94802302122116089&quot;</span><br><span class="line">   2) &quot;34.2631604414749944&quot;</span><br><span class="line">2) 1) &quot;106.50495976209640503&quot;</span><br><span class="line">   2) &quot;29.53315530684997015&quot;</span><br><span class="line">&gt; GEODIST china:city shenzhen xian km</span><br><span class="line">&quot;1396.1268&quot;</span><br><span class="line">&gt; GEORADIUS china:city 118.767413 32.041544 500 km</span><br><span class="line">1) &quot;shanghai&quot;</span><br><span class="line">&gt; GEORADIUS china:city 118.767413 32.041544 500 km WITHCOORD</span><br><span class="line">1) 1) &quot;shanghai&quot;</span><br><span class="line">   2) 1) &quot;121.47264629602432251&quot;</span><br><span class="line">      2) &quot;31.23170490709807012&quot;</span><br><span class="line">&gt; GEORADIUS china:city 118.767413 32.041544 500 km WITHDIST</span><br><span class="line">1) 1) &quot;shanghai&quot;</span><br><span class="line">   2) &quot;271.5419&quot;</span><br></pre></td></tr></table></figure><p><strong>我们来看一个混合使用参数的例子：</strong></p><p>查询距离某个位置 1000 公里内的所有地方，并返回其名称、距离、坐标，然后按距离升序排序，只显示前 3 个结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt; GEORADIUS china:city 118.767413 32.041544 1000 km WITHDIST WITHCOORD ASC COUNT 3</span><br><span class="line">1) 1) &quot;shanghai&quot;</span><br><span class="line">   2) &quot;271.5419&quot;</span><br><span class="line">   3) 1) &quot;121.47264629602432251&quot;</span><br><span class="line">      2) &quot;31.23170490709807012&quot;</span><br><span class="line">2) 1) &quot;beijing&quot;</span><br><span class="line">   2) &quot;899.9931&quot;</span><br><span class="line">   3) 1) &quot;116.40528291463851929&quot;</span><br><span class="line">      2) &quot;39.9049884229125027&quot;</span><br><span class="line">3) 1) &quot;xian&quot;</span><br><span class="line">   2) &quot;946.7395&quot;</span><br><span class="line">   3) 1) &quot;108.94802302122116089&quot;</span><br><span class="line">      2) &quot;34.2631604414749944&quot;</span><br></pre></td></tr></table></figure><h4 id="应用案例-4"><a href="#应用案例-4" class="headerlink" title="应用案例"></a><strong>应用案例</strong></h4><p><strong>位置数据存储与查询</strong>：</p><ul><li><strong>社交应用</strong>：用户可以查找附近的朋友或兴趣点。例如，一个社交网络应用可以允许用户查看附近的其他用户或活动。</li><li><strong>出行与导航</strong>：用于存储和查询地理位置数据，如共享单车或共享汽车的当前位置，以及用户附近的可用车辆。</li></ul><h3 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a><strong>Stream</strong></h3><h4 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a><strong>基本概念</strong></h4><p>Redis Stream 是 Redis 5.0 中引入的新数据类型，设计用来存储和查询日志数据结构。Stream 是 Redis 对“日志”数据结构的实现，这种结构在各种场景中都很有用，如<strong>消息队列</strong>和<strong>事件日志</strong>。</p><p>与简单的 List 不同，Stream 能够更好地支持多用户并发操作，同时还提供了复杂的消息确认和消费机制。</p><h4 id="Stream-基本组件介绍"><a href="#Stream-基本组件介绍" class="headerlink" title="Stream 基本组件介绍"></a>Stream 基本组件介绍</h4><p><strong>Stream：</strong>一个Stream是一个按时间顺序排列的消息列表。每个消息都有一个唯一的ID和键值对组成的数据。</p><p><strong>Consumer：</strong>这是一个从 Stream 读取消息的客户端。每个 Consumer 都有一个唯一的名字。</p><p><strong>Consumer Group：</strong>一个 Consumer Group 包含一组 Consumer，它们共同读取一个 Stream。这样做是为了并行处理消息。</p><h4 id="简单图解-6"><a href="#简单图解-6" class="headerlink" title="简单图解"></a>简单图解</h4><p><img src="/images/RedisObject/10.png"></p><h4 id="内部实现-8"><a href="#内部实现-8" class="headerlink" title="内部实现:"></a>内部实现:</h4><p><strong>ListPack :</strong> Redis 中的 Stream 的底层用的是一种名为 ListPack 的数据结构，它非常紧凑并且效率高。</p><p><strong>唯一ID :</strong> 每个消息都有一个由时间戳和序列号组成的唯一ID，确保消息的全局唯一性。</p><h4 id="基本命令-1"><a href="#基本命令-1" class="headerlink" title="基本命令:"></a><strong>基本命令:</strong></h4><p><strong>基础操作</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">添加操作：</span><br><span class="line">XADD key  *|ID field value [field value ...]  :   </span><br><span class="line"># *|ID: 消息的 ID。使用 * 会自动生成一个ID，或者你可以指定一个</span><br><span class="line"></span><br><span class="line">&gt; XADD mystream * name xiaokang age 25</span><br><span class="line">&quot;1695020949856-0&quot;</span><br><span class="line">&gt; XADD mystream * hobby swim job programmer</span><br><span class="line">&quot;1695029970290-0&quot;</span><br><span class="line"></span><br><span class="line">查询操作:</span><br><span class="line">XRANGE key start end [COUNT count]      ：  查询指定ID范围内的消息</span><br><span class="line">XREVRANGE key end start [COUNT count]   :   反向查询指定ID范围内的消息</span><br><span class="line"></span><br><span class="line">#  参数说明：</span><br><span class="line">key            : 表示你要检索的 Stream 的名字</span><br><span class="line">[COUNT count]  : 可选参数，用于限制返回的消息数量</span><br><span class="line">对于 XRANGE 命令，参数 start 和 end 的含义：</span><br><span class="line">start          : 检索的起始消息 ID</span><br><span class="line">end            : 检索的结束消息 ID</span><br><span class="line"></span><br><span class="line">对于 XRANGE 命令，参数 start 和 end 的含义： </span><br><span class="line">start          : 反向检索的起始消息 ID</span><br><span class="line">end            : 反向检索的结束消息 ID</span><br><span class="line"></span><br><span class="line">特殊符号解释:</span><br><span class="line">参数 start 取 &#x27;-&#x27; ， 表示最早的消息，取 + 表示最新的消息</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 检索所有消息</span><br><span class="line">&gt; XRANGE mystream - +</span><br><span class="line">1) 1) &quot;1695020949856-0&quot;</span><br><span class="line">   2) 1) &quot;name&quot;</span><br><span class="line">      2) &quot;xiaokang&quot;</span><br><span class="line">      3) &quot;age&quot;</span><br><span class="line">      4) &quot;25&quot;</span><br><span class="line">2) 1) &quot;1695029970290-0&quot;</span><br><span class="line">   2) 1) &quot;hobby&quot;</span><br><span class="line">      2) &quot;swim&quot;</span><br><span class="line">      3) &quot;job&quot;</span><br><span class="line">      4) &quot;programmer&quot;</span><br><span class="line">#  反向检索所有消息</span><br><span class="line">&gt; XREVRANGE  mystream +  -</span><br><span class="line">1) 1) &quot;1695029970290-0&quot;</span><br><span class="line">   2) 1) &quot;hobby&quot;</span><br><span class="line">      2) &quot;swim&quot;</span><br><span class="line">      3) &quot;job&quot;</span><br><span class="line">      4) &quot;programmer&quot;</span><br><span class="line">2) 1) &quot;1695020949856-0&quot;</span><br><span class="line">   2) 1) &quot;name&quot;</span><br><span class="line">      2) &quot;xiaokang&quot;</span><br><span class="line">      3) &quot;age&quot;</span><br><span class="line">      4) &quot;25&quot;</span><br><span class="line"></span><br><span class="line">获取长度：</span><br><span class="line">XLEN key                   ：获取Stream中的消息数量</span><br><span class="line"></span><br><span class="line">&gt; XLEN mystream</span><br><span class="line">(integer) 2</span><br><span class="line"></span><br><span class="line">裁剪操作：</span><br><span class="line">XTRIM key MAXLEN|MINID [=|~] threshold [LIMIT count]  ：裁减Stream 的长度，控制其大小</span><br><span class="line"># 参数说明</span><br><span class="line">MAXLEN|MINID  : 裁减策略选择。</span><br><span class="line">MAXLEN        ：使 Stream 最多保持指定数量的消息。</span><br><span class="line">MINID         ：删除所有小于指定ID的消息。</span><br><span class="line"></span><br><span class="line">[=|~]: 这是一个可选的修饰符，与上面的 MAXLEN 或 MINID 一起使用。</span><br><span class="line"></span><br><span class="line">=：这意味着长度或ID应该精确匹配。对于 MAXLEN，它确保Stream的长度恰好等于指定的长度（删除任何额外的消息）；对于 MINID，它确保删除的所有消息的ID值都小于等于给定值。</span><br><span class="line">~：这意味着长度或ID是一个近似值。这可能会导致更快的裁减操作，但Stream的实际长度可会略微超过或低于指定的值。</span><br><span class="line">[LIMIT count]  : 这是一个可选的参数，它限制了在一个操作中可以删除的消息数</span><br><span class="line"></span><br><span class="line">&gt; XTRIM mystream MAXLEN = 1</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; XRANGE mystream - +</span><br><span class="line">1) 1) &quot;1695029970290-0&quot;</span><br><span class="line">   2) 1) &quot;hobby&quot;</span><br><span class="line">      2) &quot;swim&quot;</span><br><span class="line">      3) &quot;job&quot;</span><br><span class="line">      4) &quot;programmer&quot;</span><br><span class="line">      </span><br><span class="line">删除操作：</span><br><span class="line">XDEL key ID [ID ...]       ： 从Stream中删除指定的消息</span><br><span class="line"></span><br><span class="line">&gt; XDEL mystream &quot;1695029970290-0&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">&gt; XRANGE mystream - +</span><br><span class="line"></span><br><span class="line">读取消息操作:</span><br><span class="line"></span><br><span class="line">XREAD [COUNT count] [BLOCK milliseconds] STREAMS key [key ...] ID [ID ...]                    : 用于从一个或多个流中读取消息</span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line">COUNT count                  :可选参数，指定要从每个流中读取的最大消息数。</span><br><span class="line">BLOCK milliseconds           :可选参数，阻塞操作的时间（以毫秒为单位）。该命令会等待指定的时间，直到有新的消息可用。 在给定的时间内没有新消息，则命令会返回一个空响应</span><br><span class="line">STREAMS                      :指示后面要列出要从中读取的流的名称。这是一个固定的关键字。</span><br><span class="line">key [key ...]                :要从中读取的流的名称列表</span><br><span class="line">ID [ID ...]                  :为每个指定的流提供一个消息 ID，从该 ID 之后（不包括该 ID）开始读取消息。</span><br><span class="line">特殊 ID $                     :表示只读取新的消息，也就是那些在发出此 XREAD 命令之后添加到流中的消息。</span><br></pre></td></tr></table></figure><p><strong>消费者和消费者组操作</strong></p><p>XGROUP：用于创建、修改或删除消费者组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 参数说明:</span><br><span class="line">CREATE : 创建一个新的消费者组。</span><br><span class="line">XGROUP CREATE key groupname ID|$ [MKSTREAM]</span><br><span class="line"></span><br><span class="line">key        : Stream 的名称。</span><br><span class="line">groupname  : 消费者组的名称。</span><br><span class="line">ID         : 从哪个消息 ID 开始消费。如果选择 $，则只会消费新添加到 Stream 的消息。</span><br><span class="line">MKSTREAM   : 可选参数。如果 Stream 不存在，它会创建一个新的空 Stream。</span><br><span class="line"></span><br><span class="line">SETID  :  设置消费者组的开始消费消息的 ID。</span><br><span class="line">XGROUP SETID key groupname ID|$</span><br><span class="line">key        : Stream 的名称。</span><br><span class="line">groupname  : 消费者组的名称。</span><br><span class="line">ID         : 从哪个消息 ID 开始消费。如果选择 $，则只会消费新添加到 Stream 的消息。</span><br><span class="line"></span><br><span class="line">DESTROY  :  删除一个消费者组。</span><br><span class="line">XGROUP DESTROY key groupname</span><br><span class="line">key        : Stream 的名称。</span><br><span class="line">groupname  : 消费者组的名称。</span><br><span class="line"></span><br><span class="line">CREATECONSUMER  :  在给定的消费者组中显式地创建一个消费者。</span><br><span class="line">XGROUP CREATECONSUMER key groupname consumername</span><br><span class="line">key          : Stream 的名称。</span><br><span class="line">groupname    : 消费者组的名称。</span><br><span class="line">consumername : 新创建的消费者的名称。</span><br></pre></td></tr></table></figure><p>XREADGROUP：使用消费者组从Stream中读取消息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [key ...] ID [ID ...] </span><br><span class="line"># 参数说明：</span><br><span class="line">group               : 指的是你想读取消息的消费者组的名称。</span><br><span class="line">consumer            : 是该消费者组内的消费者名称。每次使用 XREADGROUP，都需要指定消费者名称。</span><br><span class="line">COUNT count         : 可选参数，指定从每个流中读取的最大消息数量。</span><br><span class="line">NOACK               : 消息在被读取时不会被标记为“未确认”。因此，不需要（也不能）对它们进行确认。默认情况下，当消费者读取消息后，是需要对消息进行确认的。</span><br><span class="line">ID [ID ...]         : 为每个指定的流提供一个消息 ID，从该 ID 之后（不包括该 ID）开始读取消息。</span><br><span class="line">特殊 ID &gt;            : 表示从上次读取的位置继续读取（只在使用 XREADGROUP 时有效）。</span><br></pre></td></tr></table></figure><p>XACK   : 用来确认消费者已成功处理的特定消息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">XACK key group ID [ID ...] </span><br><span class="line"></span><br><span class="line"># 参数解释 </span><br><span class="line">key            : 这是你要确认消息的 Stream 的名字。</span><br><span class="line">group          : 这是消息所属的消费者组的名称。</span><br><span class="line">ID [ID ...]    : 一个或多个你想确认的消息的 ID。</span><br></pre></td></tr></table></figure><p>XPENDING  ：用于查询消费者组中待处理（已发送但未确认）的消息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">XPENDING key group [[IDLE min-idle-time] start end count [consumer]]</span><br><span class="line">key                           : 你要查询的 Stream 的名称。</span><br><span class="line">group: 你要查询的消费者组的名称。</span><br><span class="line">IDLE min-idle-time            : 这是一个可选的参数，它允许你只查询那些已经空闲或未确认超过指定毫秒数的消息。</span><br><span class="line">start                         : 起始消息 ID。</span><br><span class="line">end                           : 结束消息 ID。</span><br><span class="line">count                         : 你要返回的消息的最大数量。</span><br><span class="line">consumer                      : 这是一个可选的参数，它允许你只查询特定消费者的待处理消息。</span><br></pre></td></tr></table></figure><p>XCLAIM ：允许一个消费者重新认领消费者组中的挂起消息，通常用于处理由失效消费者未完成的消息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">XCLAIM key group consumer min-idle-time ID [ID ...] [IDLE ms] [TIME ms-unix-time] [RETRYCOUNT count] [force] [justid] </span><br><span class="line"></span><br><span class="line">key                        : 指定的 Stream 名称。</span><br><span class="line">group                      : 你想要操作的消费者组名称。</span><br><span class="line">consumer                   : 这是尝试认领消息的消费者的名字。</span><br><span class="line">min-idle-time              : 以毫秒为单位的时间，仅当消息的闲置时间超过此值时，消费者才能认领该消息。</span><br><span class="line">ID [ID ...]                : 你想要认领的消息的 ID 列表。</span><br><span class="line">IDLE ms                    : 设置消息的新的闲置时间（自从最后一次被消费以来的时间）。</span><br><span class="line">TIME ms-unix-time          : 修改消息的最后一次被读取的时间为给定的 Unix 时间</span><br><span class="line">RETRYCOUNT count           : 设置消息的投递计数（即这条消息已经被送达的次数）。</span><br><span class="line">force                      : 这个选项允许你不考虑 min-idle-time 条件，直接强制认领消息。</span><br><span class="line">justid                     : 如果设置这个选项，命令只返回消息 ID，不返回消息的内容。</span><br></pre></td></tr></table></figure><p>接下来，我通过一个示例来演示如何使用Redis Stream中的命令进行消息的添加、消费和确认。</p><p><strong>场景：</strong></p><p>以一个在线订单系统为例，当一个用户下单时，订单详细信息被添加到一个名为“orders”的stream中。有一个消费者组叫做“order-processors”，里面有两个消费者：“processor1”和“processor2”。它们的任务是处理这些订单，例如更新库存、发送确认邮件等。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">1. 添加订单</span><br><span class="line">XADD orders * order_id 123 item_id A1 count 2  # 用户A下了一个订单，订单编号为123,买了 2件</span><br><span class="line">&quot;1695103666038-0&quot;</span><br><span class="line">2.创建消费者组</span><br><span class="line">XGROUP CREATE orders order-processors $ MKSTREAM            # 创建一个名为“order-processors”的消费者组，从                    stream 的开始处监听新的订单。</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">3.读取和处理订单</span><br><span class="line"># processor1读取了订单123并开始处理它</span><br><span class="line">XREADGROUP GROUP order-processors processor1 COUNT 1 STREAMS orders &gt;</span><br><span class="line"># 同时，另一个用户B下了一个订单，编号为124</span><br><span class="line">XADD orders * order_id 124 item_id A2 quantity 1</span><br><span class="line"># 然后，processor2 开始读取订单：</span><br><span class="line">XREADGROUP GROUP order-processors processor2 COUNT 1 STREAMS orders &gt;</span><br><span class="line"></span><br><span class="line">4.确认订单已处理</span><br><span class="line"># 当processor1成功处理订单123时，它会确认处理完成：</span><br><span class="line">XACK orders order-processors messageID1</span><br><span class="line"># 注意：messageID1是processor1从Stream读取到的订单123的ID。</span><br><span class="line"></span><br><span class="line">5.查看未处理的订单</span><br><span class="line">XPENDING orders order-processors</span><br><span class="line"># 假设processor2由于某种原因暂时不能处理订单124，这时我们会看到订单124尚未被处理。</span><br><span class="line"></span><br><span class="line">6.重新处理失败的订单</span><br><span class="line"># 如果processor2出现故障，processor1可以认领并处理订单124：</span><br><span class="line">XCLAIM orders order-processors processor1 3600000 messageID2</span><br></pre></td></tr></table></figure><p>这个简单的在线订购系统例子展示了如何使用Redis Streams进行实时订单处理。这种模式可以确保即使某个消费者失败，订单也能被其他消费者接手并顺利处理。</p><h4 id="应用案例-5"><a href="#应用案例-5" class="headerlink" title="应用案例:"></a><strong>应用案例:</strong></h4><p><strong>消息队列</strong></p><p>消息队列是一种应用程序之间传递数据的方式。它允许应用程序异步地发送和接收消息，这意味着发送消息的应用程序和接收消息的应用程序无需同时运行。</p><p><strong>以在线购物系统的订单处理为例进行说明：</strong></p><p>考虑一个在线购物系统。当用户下单时，系统不应该让用户等待直到所有的后端处理（例如库存检查、付款处理、通知仓库等）都完成。相反，一旦订单提交，系统应该立即给用户一个响应，而后端的处理可以稍后进行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#1. 添加订单到队列：</span><br><span class="line">#用户下单后，我们将订单数据添加到名为orders的Redis Stream中。</span><br><span class="line">XADD orders * order_id 101 product_id P01 quantity 3</span><br><span class="line"></span><br><span class="line">#2.处理订单：</span><br><span class="line"># 后台有多个workers（进程），它们不断地监听新的订单，并进行处理。这些worke 可以是分布在多台机器上的多个进程。</span><br><span class="line"></span><br><span class="line">首先，我们创建一个消费者组：</span><br><span class="line">XGROUP CREATE orders order-processors $ MKSTREAM</span><br><span class="line"></span><br><span class="line">接着，一个worker可以开始读取并处理订单：</span><br><span class="line">XREADGROUP GROUP order-processors worker1 COUNT 1 STREAMS orders &gt;</span><br><span class="line"># 这里，worker1是处理订单的消费者名称。&gt;意味着从最新的消息开始读取。</span><br><span class="line"></span><br><span class="line">确认订单处理完成：</span><br><span class="line">一旦worker1处理完订单，它需要确认该订单已被处理：</span><br><span class="line">XACK orders order-processors &lt;messageID&gt;    # 其中，&lt;messageID&gt;是在步骤1中Redis生成的订单ID。 </span><br></pre></td></tr></table></figure><p>通过此例子，我们展示了如何使用 Redis Stream 作为消息队列，来异步处理在线购物系统中的订单。这种结构确保了用户下单后能够迅速得到响应，同时订单处理也能在后台高效地进行。</p><p><strong>事件日志</strong></p><p>事件日志就是记录系统或应用中发生的各种事件，如用户操作、系统异常等。</p><p><strong>事件日志的常见应用是在电商平台中记录用户的购物行为。</strong></p><p>假设你运营一个电商平台，每当用户浏览、搜索、点击、购买或者评论商品时，都会产生一个事件。你可以使用Redis Streams来记录这些事件。<strong>基于这些事件，可以做一些实时分析，比如：分析用户的购物模式和偏好，为他们提供更相关的商品推荐。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1.浏览商品:</span><br><span class="line">事件：商品浏览</span><br><span class="line">数据：用户ID，商品ID，浏览时间，来源页面等。</span><br><span class="line">XADD user-activity * event &quot;商品浏览&quot; userID &quot;12345&quot; productID &quot;abcd&quot; timestamp &quot;1632067200&quot; source &quot;主页&quot;</span><br><span class="line">2.搜索商品:</span><br><span class="line">事件：商品搜索</span><br><span class="line">数据：用户ID，搜索关键词，搜索时间，搜索结果数等。</span><br><span class="line">XADD user-activity * event &quot;商品搜索&quot; userID &quot;12345&quot; keyword &quot;运动鞋&quot; timestamp &quot;1632067250&quot; results &quot;50&quot;</span><br><span class="line">3.点击商品:</span><br><span class="line">事件：商品点击</span><br><span class="line">数据：用户ID，商品ID，点击时间。</span><br><span class="line">XADD user-activity * event &quot;商品点击&quot; userID &quot;12345&quot; productID &quot;abcd&quot; timestamp &quot;1632067300&quot;</span><br><span class="line">4.购买商品:</span><br><span class="line">事件：商品购买</span><br><span class="line">数据：用户ID，商品ID，购买数量，总价，购买时间。</span><br><span class="line">XADD user-activity * event &quot;商品购买&quot; userID &quot;12345&quot; productID &quot;abcd&quot; quantity &quot;2&quot; total &quot;200&quot; timestamp &quot;1632067400&quot;</span><br><span class="line">5.商品评价:</span><br><span class="line">事件：商品评价</span><br><span class="line">数据：用户ID，商品ID，评分，评论内容，评价时间。</span><br><span class="line">XADD user-activity * event &quot;商品评价&quot; userID &quot;12345&quot; productID &quot;abcd&quot; rating &quot;5&quot; review &quot;非常满意&quot; timestamp &quot;1632067500&quot;</span><br></pre></td></tr></table></figure><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a><strong>总结：</strong></h2><p>在上文，我们深入探讨了 Redis 的九种对象类型，包括字符串(String)、列表(List)、哈希(Hash)、集合(Set)、有序集合(Sorted Set)、Bitmaps、HyperLogLog、Geospatial 和 Stream。</p><p><strong>这里简单总结下各种数据结构的使用场景：</strong></p><ul><li><strong>字符串对象</strong>是最简单的数据类型，适用于缓存、临时存储等场景。</li><li><strong>列表对象</strong>提供了队列的实现，非常适合消息队列和栈的应用。</li><li><strong>哈希对象</strong>是存储对象属性的理想选择，适用于存储和访问对象。</li><li><strong>集合对象和有序集合对象</strong>适用于存储不重复元素，其中有序集合还可以进行排名和范围查询。</li><li><strong>Bitmaps和 HyperLogLog</strong> 提供了高效的计数和统计功能。</li><li><strong>Geospatial</strong> 允许进行地理位置的存储和查询。</li><li><strong>Stream</strong> 为构建复杂的消息传递提供了基础。</li></ul><p>Redis 作为一个高性能的键值数据库，已经成为现代应用开发不可或缺的组成部分。通过深入了解 Redis 的各种对象及其编码方式，我们不仅可以更加高效地利用其提供的功能，还能针对不同的应用场景选择最适合的对象类型，从而优化我们的应用性能和资源使用。</p><p>本篇文章旨在为大家提供一个关于 Redis 各个对象的全面指南，从基本概念到内部实现，再到实际应用案例。不管您是刚开始接触 Redis 还是已经有很多经验，希望本文都能为您带来新的启示。</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a><strong>最后</strong></h3><p>如果你对 Linux C&#x2F;C++ 编程，Redis 等后端技术感兴趣或者想学习计算机原理相关的知识，不妨关注我的公众号「跟着小康学编程」**。这里不仅有丰富的学习资源，还有持续更新的简单易懂的技术文章。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>另外，小康最近创建了一个技术交流群，专门用来探讨技术相关或者解答读者的问题。大家在阅读这篇文章的时候，如果觉得有问题的或者有不理解的知识点，欢迎大家加群或者评论区询问。我能够解决的，尽量给大家回复。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h3><p>[1]Redis分布式锁到底安全吗？: <em><a href="http://kaito-kidd.com/2021/06/08/is-redis-distributed-lock-really-safe/">http://kaito-kidd.com/2021/06/08/is-redis-distributed-lock-really-safe/</a></em></p>]]></content>
      
      
      <categories>
          
          <category> NoSQL数据库 </category>
          
          <category> 数据库技术 </category>
          
          <category> Redis教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis基础 </tag>
            
            <tag> Redis数据类型 </tag>
            
            <tag> Redis案例 </tag>
            
            <tag> 键值存储 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 命令入门指南：快速掌握基础命令</title>
      <link href="/LinuxCmd/"/>
      <url>/LinuxCmd/</url>
      
        <content type="html"><![CDATA[<p>作为程序员，我们在日常的工作中或多或少都会接触 Linux ，掌握其基本命令也是必不可少的。网上很多人都会推荐去看《<strong>鸟哥的私房菜—基础篇》</strong>，作为 Linux 编程的爱好者的我，还是不建议初学者一上来就看这本书，感觉对初学者不太友好，当手册去查还是可以的。</p><p>为了让更多想学习 Linux 的朋友快速入门，我这里专门给大家提供一个<strong>系统性学习 Linux 命令的详细指南</strong>，该指南主要是介绍要掌握的 Linux 基本命令有哪些，以及提供一些基础的示例，更加详细的命令参数大家可以在这个网站上查询，很方便的。<a href="https://man.niaoge.com/">https://man.niaoge.com/</a></p><p><strong>先来大致浏览下我们本篇文章要讲解的命令</strong>：</p><p><img src="/images/LinuxCmd/1.png"></p><h2 id="文件和目录操作命令"><a href="#文件和目录操作命令" class="headerlink" title="文件和目录操作命令"></a>文件和目录操作命令</h2><p><strong>ls：列出目录内容</strong>，想看看当前目录下有什么？简单！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls</span><br></pre></td></tr></table></figure><p><strong>cd：更改当前目录</strong>，<br>想跳转到桌面目录？试试这个：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~/Desktop</span><br></pre></td></tr></table></figure><p><strong>touch: 创建新文件</strong>，<br>快速创建一个新文件 note.txt：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch note.txt</span><br></pre></td></tr></table></figure><p><strong>pwd：显示当前目录的完整路径</strong>，<br>确认你现在在哪个目录？只需一条命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwd</span><br></pre></td></tr></table></figure><p><strong>mkdir：创建新目录</strong>，<br>需要一个新的项目目录 project？轻松搞定：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir project</span><br></pre></td></tr></table></figure><p><strong>rm：删除文件或目录</strong>，<br>要小心使用！彻底删除一个目录 project：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># -f 或 --force 选项强制删除文件或目录</span><br><span class="line"># -r 或 -R 或 --recursive 选项告诉rm命令递归地删除目标目录以及目录内的所有内容（文件和子目录）</span><br><span class="line">rmdir -fr  project  </span><br></pre></td></tr></table></figure><p><strong>cp：复制文件或目录</strong>，<br>将文件 example.txt 复制到目录 backup 中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp example.txt backup/</span><br></pre></td></tr></table></figure><p><strong>mv：移动或重命名文件或目录</strong>，<br>更改文件名 old_name.txt 为 new_name.txt：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv old_name.txt new_name.txt</span><br></pre></td></tr></table></figure><p>将文件 report.txt 移动到另一个目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv report.txt ~/Documents/</span><br></pre></td></tr></table></figure><p><strong>tree : 树形结构显示目录，首先确保已安装 tree</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 安装 tree</span><br><span class="line">sudo apt-get install tree  # Debian/Ubuntu</span><br><span class="line"></span><br><span class="line">然后运行：</span><br><span class="line">tree</span><br></pre></td></tr></table></figure><p><strong>ln   : 创建链接文件</strong>，<br>创建 source.txt 的硬链接 hard_link.txt：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln source.txt hard_link.txt</span><br></pre></td></tr></table></figure><p>或者创建符号链接（软链接）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s source.txt soft_link.txt</span><br></pre></td></tr></table></figure><h2 id="权限管理命令"><a href="#权限管理命令" class="headerlink" title="权限管理命令"></a>权限管理命令</h2><p><strong>chown：更改文件或目录的所有者和群组</strong>，<br>文件归谁？chown说了算：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown newowner filename</span><br></pre></td></tr></table></figure><p><strong>chmod：更改文件或目录权限</strong>，<br>谁能看？谁能改？chmod让你决定：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 755 filename</span><br></pre></td></tr></table></figure><p><strong>chgrp：专门用于更改文件或目录的群组归属</strong>，<br>改变文件或文件夹的所属群组，轻松管理访问权限：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chgrp newgroup filename</span><br></pre></td></tr></table></figure><h2 id="软件包管理命令"><a href="#软件包管理命令" class="headerlink" title="软件包管理命令"></a>软件包管理命令</h2><p><strong>Debian&#x2F;Ubuntu系统</strong></p><p><strong>apt-get：一键管理软件</strong>。安装、更新或删除软件包</p><p>装软件、升级都不是问题，apt-get帮你忙：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install packagename</span><br></pre></td></tr></table></figure><p><strong>CentOS&#x2F;RHEL系统</strong></p><p><strong>yum：包管理器</strong>，包管理器让软件安装更简单，安装、更新或删除软件包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install packagename</span><br></pre></td></tr></table></figure><h2 id="压缩和解压命令"><a href="#压缩和解压命令" class="headerlink" title="压缩和解压命令"></a>压缩和解压命令</h2><p><strong>tar：文件打包工具</strong>，<br>把一堆文件或文件夹打包成一个文件，超方便的备份方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -cvf myfiles.tar /path/to/directory</span><br></pre></td></tr></table></figure><p><strong>gzip：压缩文件</strong>，<br>想让文件小一点，传输快一点？gzip来帮忙：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip filename</span><br></pre></td></tr></table></figure><p><strong>bzip2：另一压缩选择</strong>，<br>寻找比gzip还要压得更紧的？试试 bzip2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bzip2 filename</span><br></pre></td></tr></table></figure><h2 id="文本处理命令"><a href="#文本处理命令" class="headerlink" title="文本处理命令"></a>文本处理命令</h2><p><strong>cat：查看和合并文件</strong>，<br>想快速查看文件内容或把几个文件拼成一个？用 cat：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 查看文件内容</span><br><span class="line">cat file1.txt</span><br><span class="line"># 合并文件</span><br><span class="line">cat file1.txt file2.txt &gt; combined.txt</span><br></pre></td></tr></table></figure><p><strong>more&#x2F;less：分页浏览文本</strong>，<br>文件太长，一屏看不完？试试 more 和 less：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">more longfile.txt</span><br><span class="line">less longfile.txt</span><br></pre></td></tr></table></figure><p><strong>grep：文本中的搜寻高手</strong>，<br>在文本文件中查找某个字符串,如：找出文件中包含”error”的所有行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep &#x27;error&#x27; logfile.txt</span><br></pre></td></tr></table></figure><p><strong>sed：流编辑器</strong>，<br>把文本中的”old”全部替换成”new”：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;s/old/new/g&#x27; file.txt</span><br></pre></td></tr></table></figure><p><strong>awk：文本处理小能手</strong>，<br>打印文件的第一列：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;&#123;print $1&#125;&#x27; file.txt</span><br></pre></td></tr></table></figure><p><strong>sort：给你的文本排排队</strong>，<br>对文件的内容按行排序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort file.txt</span><br></pre></td></tr></table></figure><p><strong>uniq：重复行不见了</strong>，<br>过滤掉重复行，记得先sort：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sort file.txt | uniq</span><br><span class="line"># | 符号被称为管道符（pipe）。管道是一种将一个命令的输出作为另一个命令输入的机制，在这个例子中，管道的作用是将 sort file.txt 的输出直接传输给 uniq 命令。</span><br></pre></td></tr></table></figure><p><strong>cut：文本的</strong>“<strong>剪刀手</strong>“ ，<br>只看每行的前5个字符：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cut -c1-5 file.txt</span><br></pre></td></tr></table></figure><p><strong>wc：数数大师</strong>，<br>数一数文件里有多少行、词、字符：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wc file.txt</span><br></pre></td></tr></table></figure><p><strong>find：文件搜查官</strong>，<br>搜索某文件，在目录中搜索所有.txt文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /path/to/search -name &quot;*.txt&quot;</span><br></pre></td></tr></table></figure><p><strong>head&#x2F;tail：文件的头和尾</strong>，<br>看文件的开头10行或结尾10行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">head file.txt</span><br><span class="line">tail file.txt </span><br></pre></td></tr></table></figure><h2 id="系统管理命令"><a href="#系统管理命令" class="headerlink" title="系统管理命令"></a>系统管理命令</h2><p><strong>top：实时监控系统状态</strong>，<br>想知道你的电脑现在在忙什么？top就像电脑的健康监测器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top</span><br></pre></td></tr></table></figure><p><strong>ps：查看运行中的进程</strong>，<br>想找出所有正在运行的程序？ps 给你全视角：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ps aux </span><br><span class="line"></span><br><span class="line">#一般这样使用：</span><br><span class="line">ps -ef | grep processName</span><br></pre></td></tr></table></figure><p><strong>kill：结束进程</strong>，<br>有个进程不听话，要“礼貌地”让它停止？用 kill：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill PID</span><br></pre></td></tr></table></figure><p><strong>useradd&#x2F;userdel：用户账号管理</strong>，<br>新来了个同事，需要账号？或者有人离开了？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">useradd newuser</span><br><span class="line">userdel olduser</span><br></pre></td></tr></table></figure><p><strong>df：检查磁盘空间</strong>，<br>硬盘还有空间吗？df一目了然：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -h</span><br></pre></td></tr></table></figure><p><strong>du：分析文件夹大小</strong>，<br>这个文件夹占了多少空间？du告诉你答案：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du -sh /path/to/directory</span><br></pre></td></tr></table></figure><p><strong>hostname：查看或设置主机名</strong>，<br>这台机器叫什么？或者想给它起个新名字？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 查看主机名</span><br><span class="line">hostname</span><br><span class="line"># 设置主机名</span><br><span class="line">hostname newname</span><br></pre></td></tr></table></figure><p><strong>uname：获取系统信息</strong>，<br>这台机器上跑的是什么操作系统？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -a</span><br></pre></td></tr></table></figure><p><strong>man：手册页</strong>，<br>忘记了某个命令的参数？man命令是你的救星：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">man command</span><br><span class="line"></span><br><span class="line">比如：man ls</span><br></pre></td></tr></table></figure><p><strong>passwd：更改密码</strong>，<br>需要更改密码或重置别人的密码？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd username</span><br></pre></td></tr></table></figure><p><strong>su：切换用户</strong> ，<br>需要临时变身为另一个用户？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su  username</span><br></pre></td></tr></table></figure><p><strong>fdisk&#x2F;gdisk：分区大师</strong>，<br>用于管理磁盘分区的工具，硬盘需要新分区或调整？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fdisk /dev/sdx</span><br><span class="line">gdisk /dev/sdx</span><br></pre></td></tr></table></figure><p><strong>mount&#x2F;unmount：挂载与卸载文件系统</strong>，<br>把新的硬盘或USB挂载上去，或者安全地移除它：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mount /dev/sdx /mnt</span><br><span class="line">umount /mnt</span><br></pre></td></tr></table></figure><h2 id="网络操作命令"><a href="#网络操作命令" class="headerlink" title="网络操作命令"></a>网络操作命令</h2><p><strong>ping：检查网络连接</strong>，<br>想确认你的电脑能不能访问互联网上的某个地址？ping是你的朋友：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping google.com</span><br></pre></td></tr></table></figure><p><strong>ifconfig：配置和显示网络接口</strong>，<br>查看或设置网络接口的 IP 地址等信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure><p><strong>ssh：安全地远程登录</strong>，<br>远程登录到另一台电脑上，安全又方便：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh username@remotehost</span><br></pre></td></tr></table></figure><p><strong>scp：安全地远程复制文件</strong>，<br>从一台电脑安全地传输文件到另一台电脑：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp localfile.txt username@remotehost:/remote/directory</span><br></pre></td></tr></table></figure><p><strong>wget：从网上下载文件</strong>，<br>需要下载网上的文件？wget就搞定：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://example.com/file.zip</span><br></pre></td></tr></table></figure><p><strong>curl：与网站交互</strong>，<br>发送请求到网站，可以用来下载文件或测试API：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://example.com</span><br></pre></td></tr></table></figure><p><strong>netstat&#x2F;ss：查看网络连接</strong>，<br>查看你的机器上的网络连接信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">netstat</span><br><span class="line"></span><br><span class="line">一般这样使用：</span><br><span class="line">netstat -anpt | grep &quot;80&quot; # 输出涉及端口号为80的连接</span><br><span class="line"></span><br><span class="line">-a:显示所有的套接字（sockets）</span><br><span class="line">-n :以数字形式显示地址和端口号</span><br><span class="line">-p :显示每个连接所对应的进程标识符（PID）和进程名</span><br><span class="line">-t :只显示TCP连接</span><br></pre></td></tr></table></figure><p>或者使用ss，一个更现代的替代：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ss</span><br><span class="line">ss -anpt | grep &quot;80&quot; # 输出涉及端口号为80的连接</span><br></pre></td></tr></table></figure><p><strong>traceroute：追踪数据包的路径</strong>，<br>查看数据包从你的电脑到目标地址经过了哪些路由器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">traceroute example.com</span><br></pre></td></tr></table></figure><p><strong>dig：DNS查询</strong>，<br>查找域名的IP地址等DNS信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dig example.com</span><br></pre></td></tr></table></figure><p><strong>tcpdump：网络抓包工具</strong>，<br>监听并打印想要的数据包：例如，如果你想要捕获从特定IP地址和端口443的数据包，可以使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth0 src host 192.168.1.1 and port 443 -w https_traffic_from_192.168.1.1.pcap</span><br></pre></td></tr></table></figure><p><strong>telnet：远程访问工具</strong>，<br>测试远程服务的连接性，虽然现在多用ssh替代：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet remotehost port</span><br></pre></td></tr></table></figure><p><strong>lsof：查看打开的文件和套接字</strong>，<br>列出哪些进程正在使用网络套接字：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -i</span><br></pre></td></tr></table></figure><p><strong>nc：网络连接小工具</strong>，<br>建立TCP&#x2F;UDP连接，进行数据监听和传输：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -l 1234 # 监听端口1234</span><br></pre></td></tr></table></figure><h2 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a>其他常用命令</h2><p><strong>echo：输出文字到终端，也能写入文件</strong>，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;This is a test.&quot; &gt; test.txt</span><br></pre></td></tr></table></figure><p><strong>history：显示历史命令</strong>，<br>看看你都敲过什么：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">history</span><br></pre></td></tr></table></figure><p><strong>crontab：定时运行命令，自动化管理</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># crontab -e 命令用于编辑当前用户的cron作业列表。</span><br><span class="line">crontab -e</span><br></pre></td></tr></table></figure><p>cron 是 Linux 和 Unix 系统中用来定时执行任务的工具。<br>通过crontab -e命令，你可以为当前用户添加、编辑或删除计划任务。</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>至此，你已经系统地学习了 Linux 常见的基本命令，覆盖了文件和目录的操作、权限管理、软件包处理、压缩与解压、文本处理、系统管理以及网络操作等多个方面。这些命令是Linux 开发必须掌握的。</p><p>通过本篇文章的指南，希望初学者能够对 Linux 命令有了清晰的认识和实际操作的能力。记住，掌握这些命令只是开始，真正的精通还需要你在实践中不断探索和应用。遇到问题时，不要忘记利用 man 命令或在线资源寻求帮助，持续地学习和实践，你才能更加自如地驾驭 Linux 系统。</p><h3 id="最后："><a href="#最后：" class="headerlink" title="最后："></a>最后：</h3><p>掌握了基本的 Linux 命令，接下来就是如何在 Linux 环境下进行编程，想要深入学习 Linux 编程的朋友们可以先关注我的公众号「<strong>跟着小康学编程</strong>」，这里不仅有持续更新的计算机基础相关的文章，还有如何系统学习 C、C++，Linux 系统编程以及网络编程的文章等。后续也会持续新增关于 Go微服务 、docker、k8s等云原生领域的内容。</p><p>感兴趣的朋友可以关注我的公众号，扫描下方二维码即可关注。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>另外，小康最近创建了一个技术交流群，专门用来探讨技术相关或者解答读者的问题。大家在阅读这篇文章的时候，如果觉得有问题的或者有不理解的知识点，欢迎大家加群或者评论区询问。我能够解决的，尽量给大家回复。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> Linux 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux 命令 </tag>
            
            <tag> Linux 入门 </tag>
            
            <tag> Linux 基础教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>必读：2024年度最佳计算机编程书籍推荐</title>
      <link href="/techbooks/"/>
      <url>/techbooks/</url>
      
        <content type="html"><![CDATA[<p>读大学期间，自己买了很多技术书，加上图书馆借的，自己读了不少。</p><p>技术书有很多，大家怎么选呢？</p><p>作为过来人，小康自己读过许多好书，也遇到过一些效果不佳的。为了帮助大家节省时间，避免走弯路，我在这里精心挑选了一些极具价值的书籍进行推荐。<br>这些书籍不仅数量精简，而且都是经典之作，值得深入研读。因为小康自己从事的是后台开发的，所以这里推荐的书籍也是偏向后台的。但有一些通用计算机原理相关的书籍，对于以后想从事编程相关工作的朋友，也都是可以看的。</p><p><strong>下面是我大学以及工作之后买的一些书籍</strong>：</p><p><img src="/images/techbooks/1.png"></p><p>微信搜索「<strong>跟着小康学编程</strong>」关注公众号后，在后台回复「<strong>书单</strong>」即可获取本文书单链接。</p><p>回复「<strong>pdf</strong>」即可获取本文提到的书籍电子版 pdf</p><p><img src="/images/techbooks/2.png"></p><h3 id="一、语言类"><a href="#一、语言类" class="headerlink" title="一、语言类"></a>一、语言类</h3><p>C 语言</p><ul><li><p>《C程序设计语言》(第2版，新版) - 作者 : K&amp;R</p></li><li><p>《C Primer Plus》(第6版) - 作者 : Stephen Prata</p></li><li><p>《C和指针》  作者: Kenneth A. Reek</p></li></ul><p>C++ 语言</p><ul><li>《C++ Primer》(第5版) （作者: Stanley B. Lippman, Josée Lajoie, 和 Barbara E. Moo ）</li><li>《Accelerated C++》   作者: Andrew Koenig 和 Barbara E. Moo</li><li>《Effective C++》       作者: Scott Meyers</li><li>《深度探索C++对象模型》     作者：Stanley B. Lippman</li><li>《C++ STL标准程序库开发指南》   作者：闫常友、王敏</li><li>《C++ STL源码剖析》        作者：侯捷</li><li>《深入理解 C++11：C++11 新特性解析与应用》 作者：Michael Wong IB</li></ul><p>Java 语言</p><ul><li>《Java核心技术 卷I》（原书第11版） 作者: Cay S. Horstmann</li><li>《Effective java》（第3版）      作者: Joshua Bloch</li><li>《深入理解 Java 虚拟机》（第3版）  作者: 周志明</li><li>《Java 并发编程实战》            作者: Brian Goetz 和 Tim Peierls</li></ul><p>Go 语言</p><ul><li>《Go程序设计语言》             作者: Alan A. A. Donovan 和 Brian W. Kernighan</li><li>《Go语言实战》                作者: William Kennedy 等</li><li>《Go语言高级编程》             作者: 柴树杉、曹春晖</li><li>《Go Web编程》               作者: 郑兆雄</li><li>《Go 语言学习笔记》            作者: 雨痕</li><li>《Go 语言底层原理剖析》         作者: 郑建勋</li></ul><p>微信搜索「<strong>跟着小康学编程</strong>」关注公众号后，在后台回复「<strong>书单</strong>」即可获取本文书单链接。</p><p>回复「<strong>pdf</strong>」即可获取本文提到的书籍电子版 pdf</p><p><img src="/images/techbooks/2.png"></p><h3 id="二、计算机基础"><a href="#二、计算机基础" class="headerlink" title="二、计算机基础"></a>二、计算机基础</h3><h4 id="计算机组成原理："><a href="#计算机组成原理：" class="headerlink" title="计算机组成原理："></a>计算机组成原理：</h4><ul><li>《计算机组成与设计：硬件&#x2F;软件接口》（第5版）  作者: David A. Patterson 和 John L. Hennessy</li></ul><h4 id="操作系统："><a href="#操作系统：" class="headerlink" title="操作系统："></a>操作系统：</h4><ul><li>《现代操作系统》（第4版）作者: Andrew S. Tanenbaum 和 Herbert Bos</li><li>《现代操作系统 原理与实现》 作者: 陈海波 、 夏虞斌</li></ul><h4 id="数据结构与算法："><a href="#数据结构与算法：" class="headerlink" title="数据结构与算法："></a>数据结构与算法：</h4><ul><li>《大话数据结构》 作者:程杰</li><li>《算法图解》     作者: Aditya Bhargava</li></ul><h4 id="计算机网络："><a href="#计算机网络：" class="headerlink" title="计算机网络："></a>计算机网络：</h4><ul><li><p>《计算机网络》            作者: 谢希仁</p></li><li><p>《计算机网络：自顶向下方法》 作者: James F. Kurose 和 Keith W. Ross</p></li><li><p>《TCP&#x2F;IP详解 卷1：协议》  作者: W. Richard Stevens</p></li></ul><h3 id="三、系统编程、网络编程"><a href="#三、系统编程、网络编程" class="headerlink" title="三、系统编程、网络编程"></a>三、系统编程、网络编程</h3><ul><li><p>《程序员自我修养—链接、装载与库》(主要讲编译链接的)      作者:  俞甲子、石凡以及潘爱民</p></li><li><p>《Linux系统编程》                  作者: Robert Love</p></li><li><p>《UNIX网络编程 卷1：套接字联网API》  作者: W. Richard Stevens, 与 Bill Fenner 和 Andrew M. Rudoff</p></li><li><p>《UNIX网络编程 卷2：进程间通信》  作者: W. Richard Stevens</p></li><li><p>《UNIX环境高级编程》            作者: W. Richard Stevens</p></li><li><p>《Linux高性能服务器编程》       作者: 游双</p></li><li><p>《Linux&#x2F;UNIX系统编程手册》（上下册）作者：Michael Kerrisk</p></li><li><p>《深入理解计算机系统》            作者：Randal E. Bryant和David O’Hallaron。</p></li></ul><h3 id="四、Linux-内核"><a href="#四、Linux-内核" class="headerlink" title="四、Linux 内核"></a>四、Linux 内核</h3><ul><li>《深入理解Linux内核》          作者: Daniel P. Bovet 和 Marco Cesati</li><li>《Linux内核设计与实现》        作者: Robert Love</li></ul><h3 id="五、数据库"><a href="#五、数据库" class="headerlink" title="五、数据库"></a>五、数据库</h3><h4 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h4><ul><li><p>《MySQL必知必会》         作者: Ben Forta</p></li><li><p>《MySQL技术内幕：InnoDB存储引擎》    作者: 姜承尧</p></li><li><p>《高性能MySQL》    作者Peter Zaitsev</p></li></ul><h4 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h4><ul><li>《Redis入门指南》(第二版)    作者: 李子骅</li><li>《Redis设计与实现》         作者: 黄健宏</li><li>《Redis实战》              作者: Josiah L. Carlson</li></ul><h4 id="。。。。未完待续，后续会补充的更加完善，更加成体系。"><a href="#。。。。未完待续，后续会补充的更加完善，更加成体系。" class="headerlink" title="。。。。未完待续，后续会补充的更加完善，更加成体系。"></a>。。。。未完待续，后续会补充的更加完善，更加成体系。</h4><p>微信搜索「<strong>跟着小康学编程</strong>」关注公众号后，在后台回复「<strong>书单</strong>」即可获取本文书单链接。</p><p>回复「<strong>pdf</strong>」即可获取本文提到的书籍电子版 pdf</p><p><img src="/images/techbooks/2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 书籍推荐 </category>
          
          <category> 编程资源 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程入门 </tag>
            
            <tag> 软件开发 </tag>
            
            <tag> 计算机科学 </tag>
            
            <tag> 编程最佳实践 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手把手教你搭建 Linux C/C++ 编程环境</title>
      <link href="/SetupLinuxEnv/"/>
      <url>/SetupLinuxEnv/</url>
      
        <content type="html"><![CDATA[<p>废话不多说，手把手教你如何搭建 <strong>Linux 编程环境</strong>。</p><h2 id="搭建环境具体步骤"><a href="#搭建环境具体步骤" class="headerlink" title="搭建环境具体步骤"></a>搭建环境具体步骤</h2><h3 id="选择一个-Linux-发行版："><a href="#选择一个-Linux-发行版：" class="headerlink" title="选择一个 Linux 发行版："></a>选择一个 Linux 发行版：</h3><p>如果你是 Linux 初学者，我建议你选择 Ubuntu。该系统对新手友好，安装过程简单，而且有大量的在线资源和社区支持。</p><h3 id="考虑使用虚拟机-："><a href="#考虑使用虚拟机-：" class="headerlink" title="考虑使用虚拟机 ："></a>考虑使用虚拟机 ：</h3><p>不想直接安装 Linux 系统 ?  没问题！使用虚拟机可以在你的主操作系统上模拟运行 Linux。</p><p>有以下两种虚拟机软件可供选择：</p><ul><li><strong>VirtualBox</strong> - 一个开源的、免费的虚拟化软件，非常适合初学者。</li><li><strong>VMware Workstation</strong> - 一个功能强大的虚拟化工具。</li></ul><p>这里我推荐直接使用 VMware，一旦你选择了虚拟机软件，就可以下载 Ubuntu 的 ISO 镜像并在虚拟机中安装它。</p><p><strong>1.下载 VMware 虚拟机并安装</strong></p><p> <a href="https://www.vmware.com/content/vmware/vmware-published-sites/us/products/workstation-player/workstation-player-evaluation.html.html">VMware虚拟机下载地址</a> </p><p><strong>2.下载 ISO 镜像并安装</strong></p><p><a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu-releases/">Ubuntu 的 ISO 镜像下载地址</a></p><p>以下载 20.04.6 ISO 镜像版本举例：</p><p><img src="/images/Linux%E7%BC%96%E7%A8%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/1.png"></p><p>我们可以看到两个版本：desktop 版本（图形桌面版）和 server 版本（无图形界面的服务器版）。</p><p>建议初学者直接下载 desktop 版本，这是一个桌面版的镜像，对初学者来说更友好，因为它提供了图形用户界面。</p><h3 id="vmware-安装-ubuntu-iso-镜像具体步骤"><a href="#vmware-安装-ubuntu-iso-镜像具体步骤" class="headerlink" title="vmware 安装 ubuntu iso 镜像具体步骤"></a>vmware 安装 ubuntu iso 镜像具体步骤</h3><h4 id="第一步：新建虚拟机，对于初学者，选择「典型」即可。"><a href="#第一步：新建虚拟机，对于初学者，选择「典型」即可。" class="headerlink" title="第一步：新建虚拟机，对于初学者，选择「典型」即可。"></a>第一步：新建虚拟机，对于初学者，选择「典型」即可。</h4><p><img src="/images/Linux%E7%BC%96%E7%A8%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/2.png"></p><h4 id="第二步：选择浏览，选择已经下载的-iso-镜像文件，直接点击下一步"><a href="#第二步：选择浏览，选择已经下载的-iso-镜像文件，直接点击下一步" class="headerlink" title="第二步：选择浏览，选择已经下载的 iso 镜像文件，直接点击下一步"></a>第二步：选择浏览，选择已经下载的 iso 镜像文件，直接点击下一步</h4><p><img src="/images/Linux%E7%BC%96%E7%A8%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/3.png"></p><h4 id="第三步：设置用户名密码，点击下一步"><a href="#第三步：设置用户名密码，点击下一步" class="headerlink" title="第三步：设置用户名密码，点击下一步"></a>第三步：设置用户名密码，点击下一步</h4><p><img src="/images/Linux%E7%BC%96%E7%A8%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/4.png"></p><h4 id="第四步：设置安装位置，点击下一步"><a href="#第四步：设置安装位置，点击下一步" class="headerlink" title="第四步：设置安装位置，点击下一步"></a>第四步：设置安装位置，点击下一步</h4><p><img src="/images/Linux%E7%BC%96%E7%A8%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/5.png"></p><h4 id="第五步：设置最大磁盘大小，其他默认即可，点击下一步"><a href="#第五步：设置最大磁盘大小，其他默认即可，点击下一步" class="headerlink" title="第五步：设置最大磁盘大小，其他默认即可，点击下一步"></a>第五步：设置最大磁盘大小，其他默认即可，点击下一步</h4><p><img src="/images/Linux%E7%BC%96%E7%A8%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/6.png"></p><h4 id="第六步：自定义硬件"><a href="#第六步：自定义硬件" class="headerlink" title="第六步：自定义硬件"></a>第六步：自定义硬件</h4><p>可以设置内存大小、CPU 核数以及网络适配器模式（推荐使用桥接模式）等，设置完毕，点击完成。完成之后<strong>点击开启虚拟机</strong>即可。</p><p><img src="/images/Linux%E7%BC%96%E7%A8%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/7.png"></p><h3 id="设置开发环境："><a href="#设置开发环境：" class="headerlink" title="设置开发环境："></a>设置开发环境：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 1.更新包列表: 更新包管理器的包列表，确保你能从最新的仓库中获取软件。</span><br><span class="line">sudo apt update</span><br><span class="line"></span><br><span class="line"># 2.安装 GCC 编译器 : GCC 是 GNU Compiler Collection 的简称，是最常用的C 和 C++ 编译器。</span><br><span class="line">sudo apt install gcc</span><br><span class="line"></span><br><span class="line"># 3.安装构建工具: build-essential 包提供了很多开发标准C和C++程序所需的工具。</span><br><span class="line"># 包括 g++（GNU C++ 编译器）、make（用于自动化编译的工具）和一些其他必要的库和开发文件。</span><br><span class="line">sudo apt install build-essential</span><br><span class="line"></span><br><span class="line"># 3.安装调试工具</span><br><span class="line">sudo apt install gdb</span><br><span class="line"> </span><br><span class="line"># 3.安装检测内存泄漏工具 valgrind</span><br><span class="line">sudo apt install valgrind</span><br><span class="line"># Valgrind 主要用于内存泄露检测、内存调试以及性能分析的工具。</span><br><span class="line"></span><br><span class="line"># 安装其他</span><br><span class="line">sudo apt install openssh-server     # 安装 OpenSSH 服务器，以支持 ssh 连接</span><br></pre></td></tr></table></figure><h3 id="安装调试工具"><a href="#安装调试工具" class="headerlink" title="安装调试工具"></a>安装调试工具</h3><p>调试是开发过程中不可或缺的一部分。gdb 是一个广泛使用的 GNU C&#x2F;C++ 调试器，能帮助你分析程序运行时的问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install gdb</span><br></pre></td></tr></table></figure><p>另外，这里给大家推荐一个终端神器 MobaXterm，它可以远程操作服务器。<br>它集成了多种网络工具和服务器，提供了包括 SSH、Telnet、RDP、VNC 和 FTP 等在内的远程网络连接功能。这款软件特别适合那些需要远程开发的人群。</p><p>笔者用过很多终端工具，Putty、Xshell，MobaXterm 等，综合使用下来还是使用 MobaXterm 最方便，MobaXterm 提供了用户友好的图形界面，带有多标签和多会话支持，使得管理多个连接变得轻而易举。</p><p><a href="https://mobaxterm.mobatek.net/download.html">mobaxterm 下载链接</a></p><p>具体如何使用可以看这篇文章，讲的还不错。<a href="https://zhuanlan.zhihu.com/p/56341917">全能终端神器 MobaXterm 使用指南</a></p><h3 id="安装-IDE-或代码编辑器"><a href="#安装-IDE-或代码编辑器" class="headerlink" title="安装 IDE 或代码编辑器"></a>安装 IDE 或代码编辑器</h3><p><strong>注意</strong>：下面除了 vim 需要在 Linux 环境（ubuntu）安装，vscode、Visual Studio 以及 cLion 在 windows 和 Linux 下都可以安装，但是我推荐在 Windows 上安装，写代码比较方便。最后只需要将代码上传至 Linux 服务器即可。关于如何上传，大家可以设置一下 IDE 的远程开发。不管是 Visual Studio 还是 cLion 都可以配置远程开发，比如下面这篇文章：</p><p><a href="https://blog.csdn.net/weixin_42264234/article/details/120937676">cLion 配置远程开发教程</a></p><p>根据你的偏好，你可以选择一个适合自己的集成开发环境（IDE）或代码编辑器。以下是我比较推荐的工具：</p><h4 id="vi、vim"><a href="#vi、vim" class="headerlink" title="vi、vim"></a>vi、vim</h4><p>所有的 Unix Like 系统，包括 Linux 系统都会内建 vi 文书编辑器，其他的文书编辑器则不一定会存在。但是目前我们使用比较多的是 vim 编辑器。</p><p>vim 是从 vi 发展出来的一个文本编辑器。代码补全、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。因此，我们一般会使用vim，而不是vi。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 安装 vim</span><br><span class="line">sudo apt install vim</span><br></pre></td></tr></table></figure><p>vim 安装完成之后，我们一般会做一些简单的配置，方便我们开发使用。</p><p>以下是一些 vim 配置的相关教程：</p><p><a href="https://www.ruanyifeng.com/blog/2018/09/vimrc.html">vim 配置教程1</a></p><p><a href="https://blog.csdn.net/m0_49499097/article/details/125951478">vim 配置教程2</a></p><p>还不知道如何在 Linux 使用 Vim 的朋友可以看这篇文章：</p><p><a href="https://www.runoob.com/linux/linux-vim.html">Vim 操作使用教程</a></p><h4 id="vscode"><a href="#vscode" class="headerlink" title="vscode"></a>vscode</h4><p>Visual Studio Code（VS Code）是微软开发的一个免费、开源的轻量级代码编辑器，支持多种编程语言（C&#x2F;C++ 比较常用），提供语法高亮、智能代码补全、代码调试等功能，并通过扩展支持更多工具和语言，适用于各种软件开发项目。</p><p><a href="https://code.visualstudio.com/Download">vscode 下载链接</a></p><h4 id="Visual-Studio"><a href="#Visual-Studio" class="headerlink" title="Visual Studio"></a>Visual Studio</h4><p>Visual Studio 是微软开发的一款强大的集成开发环境（IDE），专为 .NET 和 C&#x2F;C++ 等多种编程语言提供全面的软件开发工具，支持从代码编写到调试和运行的整个开发过程。</p><p><a href="https://code.visualstudio.com/Download">Visual Studio 下载链接</a></p><p>关于如何安装 Visual Studio， 大家可以参考下面这篇文章：</p><p><a href="https://zhuanlan.zhihu.com/p/475267922">Visual Studio 安装教程</a></p><h4 id="cLion"><a href="#cLion" class="headerlink" title="cLion"></a>cLion</h4><p>CLion 是 JetBrains 公司旗下发布的一款跨平台 C&#x2F;C++IDE 开发工具。相对于 visual studio 动辄五六个G的安装包，clion安装包不到300M。其功能非常强大，不输于vs，并且同样支持丰富的插件。</p><p><a href="https://www.jetbrains.com/clion/download/other.html">CLion 下载链接</a></p><p>需要注意的是 CLion 正版需要收费，但是网上提供破解版的教程：</p><p><a href="https://studygolang.com/articles/36388">Clion 2023.1.3破解激活教程，附激活码！</a> （<strong>亲测有效</strong>）</p><p>下载安装完成之后，还需要安装 C&#x2F;C++ 编译环境，<br>尽管 CLion 是一个强大的IDE，但它本身不包含编译器。这意味着你需要安装一个外部编译器来编译和运行你的C&#x2F;C++代码。</p><p>对于 Windows 用户来说，MinGW 和 Cygwin 是两个流行的选择，它们都能为 CLion 提供所需的编译器和工具链。</p><p><strong>两者如何选择？</strong>：</p><ul><li>对于需要开发原生 Windows 应用程序，同时希望保持代码在其他平台上也能编译和运行的跨平台项目，<strong>MinGW</strong> 是更好的选择。</li><li>如果你的目标是在 Windows 上模拟 Unix&#x2F;Linux 环境，或者移植原本只能在 Unix&#x2F;Linux 上运行的程序到 Windows，<strong>Cygwin</strong> 提供了必要的环境和工具。</li></ul><p><strong>下面是我帮大家整理的 MinGW 和 Cygwin 的下载安装教程，方便大家安装</strong>：</p><p><a href="https://sourceforge.net/projects/mingw-w64/files/">MinGW 下载链接</a></p><p><a href="https://www.w3cschool.cn/c/c-dh5j3owj.html">MinGW 安装教程</a></p><p><a href="https://www.cygwin.com/">Cygwin 下载链接</a></p><p><a href="https://juejin.cn/post/7047049435452276750#heading-2">Cygwin 安装教程</a></p><h3 id="安装版本控制系统"><a href="#安装版本控制系统" class="headerlink" title="安装版本控制系统"></a>安装版本控制系统</h3><p>对于任何规模的软件项目来说，版本控制都是不可或缺的。Git 是目前最流行的版本控制系统，可以通过以下命令安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install git</span><br></pre></td></tr></table></figure><p><strong>安装完成后，配置您的Git用户信息</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;YourName&quot;</span><br><span class="line">git config --global user.email &quot;youremail@example.com&quot;</span><br></pre></td></tr></table></figure><p>安装和配置好 Git 之后，你已经迈出了使用版本控制的第一步。接下来，大家还必须学会使用 Git 来远程操作 GitHub 等仓库，因为无论是在将来的工作中，还是在个人项目中，你都会频繁地使用 Git 来与 GitHub 这样的公共托管平台，或 GitLab 等私有仓库平台进行代码的推送、拉取和合作。</p><p>GitHub，作为一个基于 Git 的在线托管平台，使得共享代码、协作开发变得轻而易举。还没有注册过 GitHub 账户的朋友可以先去注册，<a href="https://github.com/">GitHub 账户注册</a></p><p>接下来，我来介绍下本地 Git 如何连接 GitHub：</p><p><strong>1.首先我们要知道</strong>：GitHub 支持通过 HTTPS 和 SSH 两种方式与远程仓库进行通信，这两种方法各有特点：</p><ul><li><p><strong>使用 HTTPS 连接 GitHub 时</strong>，你只需在克隆仓库或推送更改时输入<strong>用户名和密码</strong>。这种方式简单，但可能需要频繁输入认证信息。</p></li><li><p><strong>而通过 SSH 连接 GitHub</strong>，你需要先生成 SSH 密钥对，并将公钥添加到 GitHub 账户。完成设置后，每次操作时 Git 会自动使用你的私钥进行认证，无需手动输入认证信息，提供了更便利的使用体验。</p><p> <strong>在终端执行以下命令生成新的 SSH 密钥</strong>:</p><p><code>ssh-keygen -t ed25519 -C &quot;youremail@example.com</code></p><p>这个命令会在~&#x2F;.ssh 目录下创建一个新的密钥文件（默认是id_rsa）和一个公钥文件（id_rsa.pub）。</p><p><strong>然后将 <strong>SSH</strong> 公钥添加到 GitHub</strong>：</p><ul><li>复制 ~&#x2F;.ssh&#x2F;id_rsa.pub 公钥文件的内容。</li><li>登录到你的 GitHub 账户，进入“Settings &gt; SSH and GPG keys”。</li><li>点击“New SSH key”，在“Title”中输入一个描述性的标题，将复制的公钥粘贴到“Key”字段中，然后点击“Add SSH key”。</li></ul></li></ul><p><strong>2.测试SSH连接</strong>：在终端中执行以下命令测试 SSH 连接是否成功：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>如果一切配置正确，你应该会看到一条消息确认你已经成功认证。</p><p>至此，本地 Git 连接 GitHub 就成功了。接下来，你就可以愉快的使用 Git 来上传项目至 Github 了。如果你还不会 Git 的基本操作，可以看 B 站的这几个视频，帮你快速入门：</p><p><a href="https://www.bilibili.com/video/BV1gs411j7Rd?p=3&vd_source=404f52a7ebbf2477ea859f9609a15c65">git视频教程（入门篇）</a></p><p><a href="https://www.bilibili.com/video/BV1y4411a7Nn/?spm_id_from=333.788.recommend_more_video.1&vd_source=404f52a7ebbf2477ea859f9609a15c65">git视频教程（进阶篇）</a></p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>在这篇指南中，我们提供了详细的步骤来搭建一个高效的 Linux C&#x2F;C++ 编程环境。我们从选择适合新手的 Ubuntu 系统入手，然后引导你使用 VMware 或 VirtualBox 这样的虚拟机软件来安装和运行 Linux，这样即便是在 Windows 系统上也能轻松体验 Linux 编程的魅力。</p><p>安装系统后，我们详细介绍了如何在 Ubuntu 上安装编译器、构建工具和其他必要的开发软件，确保了你的开发环境是完整和功能齐全的。无论是通过命令行工具还是现代IDE，这些工具的安装都是为了让你的开发工作流更加顺畅。</p><p>最后，我们还强调了版本控制系统 Git 的重要性，并提供了如何配置 Git 和 GitHub 的步骤，这对于现代软件开发来说是不可或缺的。</p><p>通过阅读这篇文章，你应该能够独立地搭建自己的 Linux 编程环境，并且准备好开始你的编程旅程。希望本篇指南对你有所帮助，如果你有任何问题，欢迎在评论区留言。</p><p>也欢迎你来关注我的微信公众号「<strong>跟着小康学编程</strong>」，微信搜索<strong>跟着小康学编程</strong>或者扫描下方二维码关注 。 这里不仅有持续更新的计算机基础相关的文章，还有如何系统学习 C、C++，Linux 系统编程以及网络编程的文章等。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p>]]></content>
      
      
      <categories>
          
          <category> Linux 开发 </category>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux 编程 </tag>
            
            <tag> C/C++ 开发 </tag>
            
            <tag> 环境配置 </tag>
            
            <tag> 开发工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何快速掌握 C++：从新手到高手的学习指南</title>
      <link href="/how-to-learn-C++/"/>
      <url>/how-to-learn-C++/</url>
      
        <content type="html"><![CDATA[<p>大家好，我是小康，今天我们来聊下如何快速学习 C++ 语言。</p><p>本篇文章适合于有 C 语言编程基础的小伙伴们，如果还没有学习过 C，请看这篇文章先入个门：<a href="https://mp.weixin.qq.com/s?__biz=MzkyNjQyMTMyOA==&mid=2247487373&idx=1&sn=6304025e2c0a846e97999e765667d866&chksm=c236d7b2f5415ea4b12b87fddf981abcd325d7458885aeade0957db5344da97f1b82d7e65cce&token=733890015&lang=zh_CN#rd">C语言快速入门</a></p><h3 id="引言："><a href="#引言：" class="headerlink" title="引言："></a>引言：</h3><p>C++，作为一门集面向过程和面向对象编程于一体的强大语言，既保留了 C 语言的高效性，又引入了类、继承、多态、模板等现代编程概念，是学习计算机编程不可或缺的一环。本文旨在为初学者提供一个<strong>清晰的 C++ 学习路径</strong>，帮助你快速入门并掌握这门语言。</p><p>大家可以先浏览下本篇文章要讲解的 C++ 知识图谱：</p><p><img src="/images/C++%E8%AF%AD%E8%A8%80/1.png"></p><p>C++的基础语法我就不讲解了，包括<code>变量和常量的定义</code>、<code>标识符和关键字</code>、<code>语句</code>等，这些和 C 的一样，如果你还没有学习过 C 语言，可以看我之前的文章：「如何快速学习 C 语言 ？」</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>C++的基本数据类型包括  <code>字符型</code>、<code>整型</code>、<code>浮点型和布尔型</code>。</p><p><strong>字符型</strong> (char)：用于存储单个字符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> letter = <span class="string">&#x27;A&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>整型</strong> (int, short, long, long long)：用于存储整数, 以及它们的 unsigned 变体(unsigned int, unsigned short,unsigned long,unsigned long long)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> age = <span class="number">30</span>;</span><br><span class="line"><span class="type">long</span> var = <span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> bigInt = <span class="number">1000000</span>;</span><br></pre></td></tr></table></figure><p><strong>浮点型</strong> (float, double)：用于存储小数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> temperature = <span class="number">36.6</span>;</span><br><span class="line"><span class="type">double</span> distance = <span class="number">384400.0</span>; <span class="comment">// 从地球到月亮的距离，单位千米</span></span><br></pre></td></tr></table></figure><p><strong>布尔型</strong> (bool)：用于存储真（true）或假（false）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> isRainy = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><h3 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h3><p>枚举类型允许定义一个变量，它可以在几个预定义的值之间进行选择。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span> &#123;</span> RED, GREEN, BLUE &#125;;</span><br><span class="line">Color my_color = RED;</span><br></pre></td></tr></table></figure><h3 id="复合数据类型"><a href="#复合数据类型" class="headerlink" title="复合数据类型"></a>复合数据类型</h3><p>复合数据类型（也称为复杂数据类型）允许你将多个不同类型的数据项组合成一个单一的实体。这种类型的典型代表是<code>结构体</code>（struct）、<code>共用体</code>（union）和<code>类</code>（class）。</p><h4 id="结构体-struct"><a href="#结构体-struct" class="headerlink" title="结构体 (struct)"></a>结构体 (struct)</h4><p>结构体允许将多个不同类型的数据项组合成一个单一的复合类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义结构体类型</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义结构体类型变量并初始化</span></span><br><span class="line">Person person = &#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>&#125;;</span><br></pre></td></tr></table></figure><h4 id="联合体（union）"><a href="#联合体（union）" class="headerlink" title="联合体（union）"></a>联合体（union）</h4><p>联合体是一个用于优化内存使用的特殊数据类型，允许在同一内存位置存储不同的数据类型，但任一时刻只能使用其中一个成员。联合体变量使用关键字 <strong>union</strong> 来定义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Data</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">float</span> f;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Data</span> <span class="title">data</span>;</span></span><br></pre></td></tr></table></figure><h4 id="类-class"><a href="#类-class" class="headerlink" title="类 (class)"></a>类 (class)</h4><p>类是C++的核心，是支持面向对象编程的基础。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义 Book 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> title;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> author;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">read</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Reading &quot;</span> &lt;&lt; title &lt;&lt; <span class="string">&quot; by &quot;</span> &lt;&lt; author &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 定义 book 对象</span></span><br><span class="line">Book book = &#123;<span class="string">&quot;The C++ Programming Language&quot;</span>, <span class="string">&quot;Bjarne Stroustrup&quot;</span>&#125;;</span><br><span class="line"><span class="comment">// 调用 book 对象的 read 方法</span></span><br><span class="line">book.read();</span><br></pre></td></tr></table></figure><p>看不懂代码没关系，这里只需要了解 <code>类</code> 是 C++ 的一种特有数据类型。关于类的讲解下文会提及。</p><h3 id="派生数据类型"><a href="#派生数据类型" class="headerlink" title="派生数据类型"></a>派生数据类型</h3><p>派生数据类型是通过对已有的数据类型（基本类型、复合类型）进行某种形式的“扩展”或“派生”而得到的。典型的派生数据类型包括数组和指针。</p><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>数组用来存储固定大小的相同类型元素序列。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> numbers[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure><h4 id="指针："><a href="#指针：" class="headerlink" title="指针："></a>指针：</h4><p>指针用来存储变量的内存地址。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> var = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* ptr = &amp;var;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Value of var: &quot;</span> &lt;&lt; *ptr &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>这里我只简单提下。在上一篇文章<a href="https://mp.weixin.qq.com/s?__biz=MzkyNjQyMTMyOA==&mid=2247487373&idx=1&sn=6304025e2c0a846e97999e765667d866&chksm=c236d7b2f5415ea4b12b87fddf981abcd325d7458885aeade0957db5344da97f1b82d7e65cce&token=733890015&lang=zh_CN#rd">C语言快速入门</a><br>中关于数组和指针有过详细的讲解，不太了解的可以去看那片文章。C++ 的数组和指针和C的用法一样。只不过 C++ 多了一种比较特殊的类型-引用。</p><h4 id="引用："><a href="#引用：" class="headerlink" title="引用："></a>引用：</h4><p>C++中的引用是一种给已存在的变量起一个新名字（或别名）的机制。一旦一个引用被初始化为指向一个变量，它就一直指向那个变量：你对引用所做的任何操作都会影响到原始变量。</p><h5 id="引用的基本用法："><a href="#引用的基本用法：" class="headerlink" title="引用的基本用法："></a>引用的基本用法：</h5><p>引用在定义时必须被初始化，并且一旦被绑定到一个变量上，就不能再绑定到另一个变量上。引用的语法是在变量类型后面加上 <strong>&amp;</strong> 符号。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp; refA = a; <span class="comment">// refA是变量a的引用</span></span><br></pre></td></tr></table></figure><h5 id="引用的特性："><a href="#引用的特性：" class="headerlink" title="引用的特性："></a>引用的特性：</h5><ul><li>引用必须在定义时被初始化，并且一旦被初始化绑定到一个变量，就不能再指向其他变量。</li><li>引用不占用任何内存空间（引用只是变量的一个别名）。</li><li>不存在null引用。引用必须连接到一块合法的内存。</li></ul><h5 id="引用的用途："><a href="#引用的用途：" class="headerlink" title="引用的用途："></a>引用的用途：</h5><p>引用主要用于以下几个方面：</p><p><strong>1. 函数参数传递</strong>：通过传递引用给函数，可以让函数直接修改外部变量的值，而不是拷贝其值。这样做可以提高效率（尤其是对于大型对象）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过使用引用作为函数参数，可以使得函数能够修改调用者提供的参数。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">increment</span><span class="params">(<span class="type">int</span>&amp; value)</span> &#123;</span><br><span class="line">    value += <span class="number">1</span>; <span class="comment">// 直接修改传入的参数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line">    increment(x); <span class="comment">// x被修改为6</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;x after increment: &quot;</span> &lt;&lt; x &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 C++ 中，函数参数传递时，参数是类对象比较常见。</p><p><strong>2. 函数返回值</strong>：函数可以返回一个引用，从而允许对函数返回值直接赋值。这在操作重载运算符时尤其有用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="type">int</span> myNumber = <span class="number">10</span>; <span class="comment">// 全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回全局变量myNumber的引用</span></span><br><span class="line"><span class="type">int</span>&amp; <span class="title function_">getMyNumberRef</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> myNumber;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Original myNumber: &quot;</span> &lt;&lt; myNumber &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: 10</span></span><br><span class="line">    <span class="comment">// 通过函数返回的引用直接修改myNumber的值</span></span><br><span class="line">    getMyNumberRef() = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Modified myNumber: &quot;</span> &lt;&lt; myNumber &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: 20</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对于拷贝代价较大的对象（比如大型的类实例），通过引用传递或返回可以避免拷贝，提高程序效率。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>C++ 中的函数是一组一起执行一个任务的语句。函数允许你定义一次代码块并多次调用它，这有助于代码的重用和模块化。</p><h3 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h3><p>一个 C++ 函数定义包括以下几个主要部分：</p><ul><li><strong>返回类型</strong>：函数可以返回一个值。返回类型是函数返回值的数据类型。如果函数不返回值，则使用void类型。</li><li><strong>函数名称</strong>：标识函数的唯一名称。</li><li><strong>参数列表</strong>：括号内的参数，用于从函数调用者向函数传递信息。如果函数不接受任何参数，则括号为空。</li><li><strong>函数体</strong>：大括号内的一系列语句，定义了函数的执行任务。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数定义示例</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="函数声明（函数原型）"><a href="#函数声明（函数原型）" class="headerlink" title="函数声明（函数原型）"></a>函数声明（函数原型）</h3><p>为了在定义函数之前调用函数，你需要在调用点之前声明函数原型。函数声明（或称为函数原型）仅需要指定函数返回类型、函数名和参数类型，不需要函数体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>; <span class="comment">// 函数声明</span></span><br></pre></td></tr></table></figure><h3 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3><p>定义函数后，你可以通过提供函数名和所需的参数（如果有的话）来调用函数。</p><h4 id="函数调用方式"><a href="#函数调用方式" class="headerlink" title="函数调用方式"></a>函数调用方式</h4><p><strong>函数名(参数1，参数2，…)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> result = add(<span class="number">5</span>, <span class="number">3</span>); <span class="comment">// 函数调用</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出：Result: 8</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>C++支持几种参数传递方式：</p><ul><li><strong>按值传递</strong>：调用函数时，实参的值被拷贝给形参。在函数内对形参的修改不会影响实参。</li><li><strong>按引用传递</strong>：允许函数修改调用者的变量。这通过将形参定义为引用类型实现。</li><li><strong>按指针传递</strong>：意味着将变量地址作为参数传递给函数，函数通过这个指针直接访问和修改原始变量的值。</li></ul><h4 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// 按值传递</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">byValue</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">    value = <span class="number">10</span>; <span class="comment">// 只修改形参的值，对实参无影响</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 按引用传递</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">byReference</span><span class="params">(<span class="type">int</span>&amp; value)</span> &#123;</span><br><span class="line">    value = <span class="number">20</span>; <span class="comment">// 修改了实参的值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 按指针传递</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">byPointer</span><span class="params">(<span class="type">int</span>* value)</span> &#123;</span><br><span class="line">    *value = <span class="number">30</span>; <span class="comment">// 通过解引用修改了实参的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">1</span>, c = <span class="number">1</span>;</span><br><span class="line">    byValue(a);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After byValue: &quot;</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 1</span></span><br><span class="line">    byReference(b);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After byReference: &quot;</span> &lt;&lt; b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 20 </span></span><br><span class="line">    byPointer(&amp;c);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After byPointer: &quot;</span> &lt;&lt; c &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 30</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>C++中的函数重载（Function Overloading）是指允许在同一作用域内声明多个具有相同名称的函数，只要它们的参数列表（参数的类型、数量或顺序）不同即可。编译器根据函数调用时提供的参数类型和数量来决定具体调用哪个函数。</p><h4 id="代码示例：-1"><a href="#代码示例：-1" class="headerlink" title="代码示例："></a>代码示例：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下两个 print 函数构成重载</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Printing int: &quot;</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">double</span> f)</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Printing float: &quot;</span> &lt;&lt; f &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  print(<span class="number">10</span>);</span><br><span class="line">  print(<span class="number">10.5</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="特殊函数"><a href="#特殊函数" class="headerlink" title="特殊函数"></a>特殊函数</h3><h4 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h4><p>在 C++ 的类中定义的函数称为成员函数（Member Functions）。成员函数可以访问类的私有（private）、保护（protected）和公有（public）成员。</p><p>代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">myFunction</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 成员函数实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="常量成员函数"><a href="#常量成员函数" class="headerlink" title="常量成员函数"></a>常量成员函数</h4><p>常量成员函数是 C++ 中的一种特殊的成员函数，它保证在函数执行过程中<strong>不会修改对象的任何成员变量</strong>。这种函数通过在成员函数声明的末尾添加 <strong>const</strong> 关键字来定义。常量成员函数可以被任何类型的对象调用，包括常量对象。</p><p>在类的实现中，常量成员函数对类内部的状态（成员变量）只能进行只读操作，不能进行修改。这为类的使用提供了额外的安全保证，确保了不会意外改变对象状态的函数逻辑。</p><p>代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义 MyClass 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">private:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">public:</span><br><span class="line">    MyClass(<span class="type">int</span> v) : value(v) &#123;&#125; <span class="comment">// 构造函数，初始化value</span></span><br><span class="line">    <span class="comment">// 常量成员函数声明，使用const关键字</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span> <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value; <span class="comment">// 这里只是返回成员变量的值，不会修改它</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 尝试在常量成员函数中修改成员变量将导致编译错误</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">tryToModify</span><span class="params">()</span> <span class="type">const</span> &#123;</span><br><span class="line">        <span class="comment">// value = 100; // 错误：不能在常量成员函数中修改成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    MyClass <span class="title function_">obj</span><span class="params">(<span class="number">42</span>)</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The value is: &quot;</span> &lt;&lt; obj.getValue() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出：The value is: 42</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> MyClass <span class="title function_">constObj</span><span class="params">(<span class="number">55</span>)</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The value is: &quot;</span> &lt;&lt; constObj.getValue() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出：The value is: 55</span></span><br><span class="line">    <span class="comment">// constObj.tryToModify(); // 错误：不能在常量对象上调用非常量成员函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码看不懂不要紧，这里只要了解常量成员函数的基本概念，以及如何声明即可。看完下文类和对象的讲解，再回过头来看代码就可以理解。</p><h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><p>C++的面向对象编程（OOP）是一种编程范式，它使用“对象”来设计软件。对象可以包含数据（称为属性或成员变量）和代码（称为方法或成员函数）。C++的 OOP 建立在几个核心概念之上：类、封装、继承、多态。让我们一一详细讲解这些知识点。</p><h3 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h3><h4 id="类的定义："><a href="#类的定义：" class="headerlink" title="类的定义："></a>类的定义：</h4><p>类是创建对象的蓝图。它定义了对象的属性（成员变量）和行为（成员函数或方法），在C++中，使用关键字<code>class</code> 来定义类。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义 MyClass 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="成员的访问权限："><a href="#成员的访问权限：" class="headerlink" title="成员的访问权限："></a>成员的访问权限：</h4><p>在C++中，类的成员（包括变量和函数）可以具有三种不同的访问权限：<code>public</code>、<code>private</code>和<code>protected</code>。这些访问权限控制了类外部的代码对类成员的访问级别，从而实现了封装和数据隐藏。</p><ul><li><p><strong>public</strong>（公有成员）：可以被任何其他代码访问，无论是类的内部还是外部。如果类的成员声明为public，那么在类的实例化对象外部也可以直接访问这些成员。</p></li><li><p><strong>private</strong>（私有成员）：只能被该类的成员函数、友元函数和该类的其他实例访问。如果类的成员声明为private，那么这些成员只能在类的内部被访问。这是默认的访问级别，如果没有指定访问权限，则成员默认为private。</p></li><li><p><strong>protected</strong>（受保护成员）：可以被该类的成员函数、友元函数、该类的派生类中的成员访问。如果类的成员声明为protected，那么这些成员既可以在类的内部被访问，也可以在派生类中被访问，但不能直接通过类的实例在类的外部被访问。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> publicVar;  <span class="comment">// 公有成员变量，任何地方都可访问</span></span><br><span class="line">protected:</span><br><span class="line">    <span class="type">int</span> protectedVar;  <span class="comment">// 受保护成员变量，类内部和派生类可访问</span></span><br><span class="line">private:</span><br><span class="line">    <span class="type">int</span> privateVar;  <span class="comment">// 私有成员变量，仅类内部可访问</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">void</span> <span class="title function_">privateMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 私有成员函数，仅类内部可访问</span></span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">publicMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 公有成员函数，任何地方都可访问</span></span><br><span class="line">        privateVar = <span class="number">0</span>; <span class="comment">// 可以访问私有成员</span></span><br><span class="line">        privateMethod(); <span class="comment">// 可以调用私有成员函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="成员访问权限有什么用？"><a href="#成员访问权限有什么用？" class="headerlink" title="成员访问权限有什么用？"></a>成员访问权限有什么用？</h4><ul><li><strong>封装</strong>：通过将成员设为私有或受保护，类可以隐藏其实现细节，仅通过公有接口与外界交互。这样做可以在不影响外部代码的情况下自由修改类的内部实现。</li><li><strong>维护性</strong>：限制对成员的访问可以减少因错误使用类成员而产生的bug，使得代码更加可维护。</li><li><strong>扩展性</strong>：合理使用访问权限可以在不破坏原有类的基础上进行扩展，增加新的功能。</li></ul><h4 id="成员变量和成员函数"><a href="#成员变量和成员函数" class="headerlink" title="成员变量和成员函数"></a>成员变量和成员函数</h4><p>类中定义的变量称为成员变量，类中定义的函数称为成员函数。它们定义了类的属性和行为。</p><p>成员变量初始化有以下两种方式：</p><p><strong>1. 构造函数初始化列表</strong>：使用构造函数的初始化列表直接初始化成员变量，这是最常用且推荐的初始化成员变量的方式，特别是对于常量成员和引用成员。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> &#123;</span></span><br><span class="line">private:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">public:</span><br><span class="line">    Example(<span class="type">int</span> d) : data(d) &#123;&#125; <span class="comment">// 构造函数初始化列表</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>2. 在构造函数体内赋值</strong>：在函数体内对成员进行初始化。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> &#123;</span></span><br><span class="line">private:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">public:</span><br><span class="line">    Example(<span class="type">int</span> d) &#123;</span><br><span class="line">        data = d; <span class="comment">// 在构造函数体内赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h4><p><strong>构造函数</strong>：构造函数的名称与类名相同，可以有参数，也可以重载（即定义多个构造函数，每个构造函数有不同的参数列表）。如果你不提供任何构造函数，C++编译器会自动生成一个默认的无参构造函数。</p><p>构造函数在创建对象时自动调用，用于初始化对象。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    Car() &#123; <span class="comment">// 默认构造函数</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Car object created.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Car(<span class="built_in">string</span> brand) &#123; <span class="comment">// 带有参数的构造函数</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; brand &lt;&lt; <span class="string">&quot; car object created.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>析构函数</strong>：析构函数的名称是类名前加上波浪符号<code>~</code>，它不能带参数，因此一个类只能有一个析构函数。析构函数用于执行对象销毁前的清理工作，比如释放分配的资源等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    ~Car() &#123; <span class="comment">// 析构函数</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Car object destroyed.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过合理定义和使用构造函数和析构函数，我们可以确保对象在创建和销毁时维持合理的状态，以及有效地管理资源。</p><p>一个简单的 Car 类定义示例：</p><p>该 Car 类包含构造函数和析构函数，成员变量和成员函数等基本成员。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义 Car 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">string</span> brand;  <span class="comment">// 汽车的品牌</span></span><br><span class="line">    <span class="comment">// 构造函数，使用初始化列表来初始化成员变量。</span></span><br><span class="line">    Car(<span class="built_in">string</span> b) : brand(b) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; brand &lt;&lt; <span class="string">&quot; car is created.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~Car() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; brand &lt;&lt; <span class="string">&quot; car is destroyed.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 成员函数</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">drive</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Driving &quot;</span> &lt;&lt; brand &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Car <span class="title function_">myCar</span><span class="params">(<span class="string">&quot;Ford&quot;</span>)</span>;  <span class="comment">// 创建一个Car对象，品牌为&quot;Ford&quot;</span></span><br><span class="line">    myCar.drive();      <span class="comment">// 调用drive成员函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="对象的创建："><a href="#对象的创建：" class="headerlink" title="对象的创建："></a>对象的创建：</h4><p>对象是类的实例。通过类，我们可以创建对象，并使用其属性和方法。对象可以通过成员访问运算符<code>.</code>访问其成员变量和成员函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Car <span class="title function_">myCar</span><span class="params">(<span class="string">&quot;Ford&quot;</span>)</span>; <span class="comment">// 福特汽车</span></span><br><span class="line">myCar.drive();     <span class="comment">// 访问 myCar 对象的成员方法</span></span><br></pre></td></tr></table></figure><h4 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h4><p>在C++中，this指针是一个特殊的指针，它指向当前对象。每个非静态成员函数（包括构造函数、析构函数以及其他成员函数）都有一个this指针作为其隐式参数，这使得成员函数能够访问调用它的对象的成员。this指针在成员函数内部使用，特别是在需要引用调用函数的当前对象时。</p><p>当我们在类的成员函数中需要引用对象本身时，就会用到this指针。这在以下几种情况中尤其有用：</p><ul><li>当参数名称与成员变量名称相同时，用以区分成员变量和参数。</li><li>在实现链式调用时返回对象的引用。</li><li>当需要返回对象本身的指针时。</li></ul><p>示例代码：</p><p><strong>1. 区分成员变量和参数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> width;</span><br><span class="line">    Box(<span class="type">int</span> width) &#123;</span><br><span class="line">        <span class="comment">// 使用this指针区分成员变量和构造函数参数</span></span><br><span class="line">        this-&gt;width = width;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">displayWidth</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Width: &quot;</span> &lt;&lt; width &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 直接访问width，实际上是this-&gt;width</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个例子中，构造函数的参数width与类的成员变量width同名。通过使用this-&gt;width，我们明确指出了左边的width是对象的成员变量，而不是参数。</p><p><strong>2. 实现链式调用</strong></p><p>链式调用是一种编程风格，通过在成员函数末尾返回对象本身，可以连续调用多个成员函数。</p><p>示例代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span> &#123;</span></span><br><span class="line">private:</span><br><span class="line">    <span class="type">int</span> width;</span><br><span class="line">public:</span><br><span class="line">    Box&amp; <span class="title function_">setWidth</span><span class="params">(<span class="type">int</span> width)</span> &#123;</span><br><span class="line">        this-&gt;width = width;</span><br><span class="line">        <span class="keyword">return</span> *this;  <span class="comment">// 返回当前对象的引用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">displayWidth</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Width: &quot;</span> &lt;&lt; width &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Box box;</span><br><span class="line">    box.setWidth(<span class="number">10</span>).displayWidth();  <span class="comment">// 链式调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在setWidth函数中，返回*this允许链式调用，即连续调用对象的成员函数。</p><p><strong>3. 返回对象本身的指针</strong></p><p>有时候，我们可能需要在成员函数中返回指向当前对象的指针。</p><p>示例代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    Box* <span class="title function_">getPointer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> this;  <span class="comment">// 返回指向当前对象的指针</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在getPointer函数中，通过返回this，我们得到了一个指向当前对象的指针。</p><p>this指针是 C++ 中一个强大的工具，它提供了一个自引用的机制。通过 this 指针，类的成员函数可以访问调用它们的对象的其他成员。理解 this 指针对于深入学习C++面向对象编程非常重要。</p><p><strong>而理解 this 指针，关键是要了解它的底层原理</strong>：</p><p>在C++中，this指针的底层实现其实非常直观。当一个非静态成员函数被调用时，编译器隐式地将当前对象的地址作为一个参数传递给函数。这个隐式参数就是this指针。因此，每个非静态成员函数在内部都有一个名为this的额外参数，指向调用该函数的对象。</p><h5 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h5><ul><li><p>对于一个类<code>ClassType</code>中的非静态成员函数<code>memberFunction</code>，调用形式<code>object.memberFunction(args...)</code>,实际上在底层被编译器处理为<code>ClassType::memberFunction(&amp;object, args...)</code>，其中<code>&amp;object</code>就是<code>this指针</code>。</p></li><li><p>因此，即使你在成员函数定义中没有显式地看到<code>this</code>参数，编译器仍然按照每个非静态成员函数都有一个类型为<code>ClassType*</code>的<code>this指针</code>作为其第一个参数的方式来处理。</p></li></ul><p>考虑以下类定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">myFunction</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Value of a: &quot;</span> &lt;&lt; this-&gt;a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当你创建一个MyClass对象并调用其成员函数myFunction时：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyClass obj;</span><br><span class="line">obj.a = <span class="number">10</span>;</span><br><span class="line">obj.myFunction();</span><br></pre></td></tr></table></figure><p>在调用 obj.myFunction() 时，实际上编译器在底层将其转换为类似以下形式的调用（这是一种简化的表达，实际转换会依赖于具体的编译器）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyClass::myFunction(&amp;obj);</span><br></pre></td></tr></table></figure><p>这里，&amp;obj 是对象 obj 的地址，它被隐式地作为 this 指针传递给 myFunction。所以，在 myFunction 内部，当你访问 this-&gt;a 时，实际上就是通过 obj 的地址来访问它的成员变量 a。</p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>封装在 C++ 面向对象编程中是一种将数据（属性）和行为（方法）捆绑在一起的机制，同时对外隐藏内部实现的细节，仅通过定义好的接口与外界交互。</p><p><strong>简单来说</strong>:封装实质上是关于数据隐藏和接口暴露的。在定义一个类时，你会将某些数据成员标记为 private，这意味着它们只能被类的内部成员函数访问，对类的使用者来说，这些细节被隐藏了。然而，你也会提供public的成员函数作为操作这些数据的接口，这样类的使用者可以在不知道内部实现细节的情况下，通过这些接口来操作对象。</p><h4 id="封装的实现"><a href="#封装的实现" class="headerlink" title="封装的实现"></a>封装的实现</h4><p>在C++中，封装通过<strong>类</strong>实现，类中可以定义三种类型的成员：public（公有成员）、private（私有成员）和protected（受保护成员）。这些访问修饰符定义了成员的访问范围：</p><ul><li><strong>private</strong> 成员只能由同一类的成员函数访问。</li><li><strong>public</strong> 成员可以由任何可以访问类对象的代码访问。</li><li><strong>protected</strong> 成员可以被基类和派生类中的成员函数访问。</li></ul><p>通过精心设计公有接口，类的设计者可以控制外部代码对内部数据的访问方式，保护对象的状态不被非法操作破坏。</p><h4 id="封装的优势"><a href="#封装的优势" class="headerlink" title="封装的优势"></a>封装的优势</h4><ul><li><strong>数据安全</strong>：通过隐藏内部实现细节，减少了外部对内部数据的直接访问，降低了数据被误用或误修改的风险。</li><li><strong>接口清晰</strong>：用户只需关注类提供的公有接口，不必深究类的内部实现，使得类更加易于使用和理解。</li><li><strong>易于维护和扩展</strong>：类的内部实现可以自由修改，只要公有接口保持不变，就不会影响到使用该类的代码，提高了代码的可维护性和扩展性。</li></ul><p><strong>一个体现 C++ 封装的类的实现</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">private:</span><br><span class="line">    <span class="built_in">string</span> name;  <span class="comment">// 私有成员变量，存储人的姓名</span></span><br><span class="line">    <span class="type">int</span> age;      <span class="comment">// 私有成员变量，存储人的年龄</span></span><br><span class="line">public:</span><br><span class="line">    <span class="comment">// 构造函数，初始化姓名和年龄，使用初始化列表来初始化成员变量。</span></span><br><span class="line">    Person(<span class="built_in">string</span> n, <span class="type">int</span> a) : name(n), age(a) &#123;&#125;</span><br><span class="line">    <span class="comment">// 公有成员函数，设置姓名</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">setName</span><span class="params">(<span class="built_in">string</span> n)</span> &#123;</span><br><span class="line">        name = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 公有成员函数，获取姓名</span></span><br><span class="line">    <span class="built_in">string</span> <span class="title function_">getName</span><span class="params">()</span> <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 公有成员函数，设置年龄</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(a &gt;= <span class="number">0</span>) &#123; <span class="comment">// 确保年龄是非负数</span></span><br><span class="line">            age = a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 公有成员函数，获取年龄</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 成员函数，打印Person信息</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">printInfo</span><span class="params">()</span> <span class="type">const</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;, Age: &quot;</span> &lt;&lt; age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Person <span class="title function_">person</span><span class="params">(<span class="string">&quot;John Doe&quot;</span>, <span class="number">30</span>)</span>; <span class="comment">// 创建Person对象</span></span><br><span class="line">    person.printInfo(); <span class="comment">// 打印信息</span></span><br><span class="line">    <span class="comment">// 尝试修改Person的姓名和年龄</span></span><br><span class="line">    person.setName(<span class="string">&quot;Jane Doe&quot;</span>);</span><br><span class="line">    person.setAge(<span class="number">25</span>);</span><br><span class="line">    <span class="comment">// 再次打印修改后的信息</span></span><br><span class="line">    person.printInfo(); <span class="comment">// 打印信息</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h4 id="继承的定义"><a href="#继承的定义" class="headerlink" title="继承的定义"></a>继承的定义</h4><p>继承允许新的类（派生类）继承现有类（基类）的属性和方法。它支持代码重用，并建立了类之间的层次关系。</p><h4 id="继承的分类"><a href="#继承的分类" class="headerlink" title="继承的分类"></a>继承的分类</h4><h5 id="单一继承"><a href="#单一继承" class="headerlink" title="单一继承"></a>单一继承</h5><p>在单一继承中，一个派生类只继承自一个基类。这意味着派生类包含了基类的所有属性和方法，同时还可以添加自己的属性和方法，或者重写基类的方法。</p><p><strong>定义方式</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseClass</span> &#123;</span></span><br><span class="line">    <span class="comment">// 基类的成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedClass</span> :</span> public BaseClass &#123;</span><br><span class="line">    <span class="comment">// 派生类的成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里，DerivedClass 是通过单一继承从 BaseClass派生而来的。</p><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Eating.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span> public Animal &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">bark</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Barking.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Dog myDog;</span><br><span class="line">    myDog.eat(); <span class="comment">// 调用基类的方法</span></span><br><span class="line">    myDog.bark(); <span class="comment">// 调用派生类的方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h5><p>多重继承允许一个派生类同时从多个基类继承属性和方法。这种方式增加了灵活性，但也可能引入复杂性，例如需要处理潜在的命名冲突，以及著名的“菱形问题”。</p><p><strong>定义方式</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseClass1</span> &#123;</span></span><br><span class="line">    <span class="comment">// 基类1的成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseClass2</span> &#123;</span></span><br><span class="line">    <span class="comment">// 基类2的成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedClass</span> :</span> public BaseClass1, public BaseClass2 &#123;</span><br><span class="line">    <span class="comment">// 派生类的成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个例子中，DerivedClass 同时从 BaseClass1 和BaseClass2 继承，成为它们的派生类。</p><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Eating.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 第二个基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Flying.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类(麻雀)，继承自Animal和Bird</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sparrow</span> :</span> public Animal, public Bird &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="comment">//发出声音，模拟麻雀叫声</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">chirp</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Chirping.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Sparrow mySparrow;</span><br><span class="line">    mySparrow.eat(); <span class="comment">// 调用Animal基类的方法</span></span><br><span class="line">    mySparrow.fly(); <span class="comment">// 调用Bird基类的方法</span></span><br><span class="line">    mySparrow.chirp(); <span class="comment">// 调用派生类的方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多重继承允许一个派生类同时继承自多个基类。这是C++提供的一种强大功能，它可以让派生类继承并实现多个基类定义的接口和属性。然而，在使用多重继承时，我们可能会遇到一种特殊情况：菱形继承（也称为钻石继承）问题。</p><p><strong>菱形继承</strong></p><p>假设有这样一个场景：我们有一个基类A，然后有两个类B和C分别继承自A，最后有一个类D同时继承自B和C。这样构成的继承结构形状像一个菱形，因此称为菱形继承。如下图：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">     A</span><br><span class="line">    / \</span><br><span class="line">   B   C</span><br><span class="line">    \ /</span><br><span class="line">     D</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对应的代码示例：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> public A &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> public A &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> public B, public C &#123;</span><br><span class="line">    <span class="comment">// D通过B和C继承了A，可能会导致A的成员在D中存在多份拷贝</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>菱形继承引入的问题是D通过B和C继承了两份A的成员，这导致了数据冗余和不一致性的风险。特别是当试图访问从A继承来的成员时，编译器会因为不知道应该通过B还是C的路径去访问而产生歧义。</p><p><strong>解决菱形继承问题</strong></p><p>C++中通过引入虚继承来解决菱形继承问题。在菱形继承的结构中，将B和C对A的继承声明为虚继承（使用<code>virtual</code>关键字），可以确保D中只有一份A的成员副本。</p><p>这样，无论是通过B还是C，访问到的都是同一份来自A的成员，解决了成员访问歧义的问题，并且保证了数据的一致性。</p><p><strong>虚继承的声明方式</strong>：</p><p>通过在派生类中使用 <strong>virtual</strong> 关键字进行继承。</p><p>使用虚继承来解决菱形继承问题示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// B和C虚继承A</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> virtual public A &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> virtual public A &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// D继承自B和C</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> public B, public C &#123;&#125;;</span><br></pre></td></tr></table></figure><p>在这个例子中，通过将 B 和 C 对 A 的继承声明为虚继承，我们确保了在 D 中只有一份来自 A 的成员 value，无论是通过 B 还是 C 的路径访问 value，访问到的都是相同的成员。</p><h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><p>在C++中，友元（Friend）是一个允许某些外部函数或类访问另一个类的私有（private）和保护（protected）成员的特性。友元关系不受类之间的公有（public）、私有（private）和保护（protected）访问控制的约束，这使得某些特定的函数或类可以直接访问类的内部成员。</p><p>友元机制可以增强程序的灵活性，但同时也可能破坏对象的封装性。</p><p>友元可以是：</p><ul><li>友元函数</li><li>友元类</li><li>友元成员函数</li></ul><h4 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h4><p>友元函数在C++中是一种特殊的函数，它虽然不是类的成员函数，但能够访问类的私有（private）和保护（protected）成员。这允许全局函数访问类的私有成员。</p><p>友元函数的定义包含两个主要步骤：</p><ul><li><p><strong>在类内声明友元函数</strong>：你需要在类定义内部使用 <code>friend</code> 关键字声明该函数为友元，这告诉编译器这个特定的函数可以访问类的私有和保护成员。</p></li><li><p><strong>定义友元函数</strong>：友元函数的定义与普通函数相同，但需要注意的是，友元函数本身不是类的成员函数，因此它不能通过对象或指针来调用，而是像普通函数那样直接调用。</p></li></ul><p>代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">private:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">public:</span><br><span class="line">    MyClass(<span class="type">int</span> val) : value(val) &#123;&#125; <span class="comment">// 构造函数初始化value</span></span><br><span class="line">    <span class="comment">// 声明友元函数</span></span><br><span class="line">    friend <span class="type">void</span> <span class="title function_">friendFunction</span><span class="params">(MyClass&amp; obj)</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 定义友元函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">friendFunction</span><span class="params">(MyClass&amp; obj)</span> &#123;</span><br><span class="line">    <span class="comment">// 友元函数可以访问MyClass的私有成员value</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Accessing private member value: &quot;</span> &lt;&lt; obj.value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    MyClass <span class="title function_">myObj</span><span class="params">(<span class="number">100</span>)</span>;</span><br><span class="line">    <span class="comment">// 调用友元函数，并访问MyClass对象的私有数据</span></span><br><span class="line">    friendFunction(myObj); <span class="comment">// 输出: Accessing private member value: 100</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h4><p>当一个类被声明为另一个类的友元时，这个友元类的所有成员函数都可以访问另一个类的私有和保护成员。</p><p>示例代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span> &#123;</span></span><br><span class="line">    <span class="type">double</span> width;</span><br><span class="line">public:</span><br><span class="line">    Box(<span class="type">double</span> wid) : width(wid) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    friend <span class="class"><span class="keyword">class</span> <span class="title">Printer</span>;</span> <span class="comment">// 声明Printer为友元类</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Printer</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">printWidth</span><span class="params">(Box box)</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Width of box : &quot;</span> &lt;&lt; box.width &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Box <span class="title function_">box</span><span class="params">(<span class="number">10.0</span>)</span>;</span><br><span class="line">    Printer printer;</span><br><span class="line">    printer.printWidth(box);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子中，Printer 类是 Box 类的友元，因此 Printer 的成员函数 printWidth可以访问 Box 的私有成员 width。</p><h4 id="友元成员函数"><a href="#友元成员函数" class="headerlink" title="友元成员函数"></a>友元成员函数</h4><p>一个类的成员函数可以被声明为另一个类的友元。</p><p>示例代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span> &#123;</span></span><br><span class="line">    <span class="type">double</span> width;</span><br><span class="line">public:</span><br><span class="line">    Box(<span class="type">double</span> wid) : width(wid) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    friend <span class="type">void</span> <span class="title function_">Printer::printWidth</span><span class="params">(Box box)</span>; <span class="comment">// 前向声明</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Printer</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">printWidth</span><span class="params">(Box box)</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Width of box : &quot;</span> &lt;&lt; box.width &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Box <span class="title function_">box</span><span class="params">(<span class="number">10.0</span>)</span>;</span><br><span class="line">    Printer printer;</span><br><span class="line">    printer.printWidth(box); <span class="comment">// 使用Printer对象打印Box的宽度</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，Printer类的成员函数printWidth是Box类的友元，因此它可以访问Box的私有成员width。</p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>使用友元时应谨慎，因为它破坏了类的封装性。一个设计良好的类应该尽量隐藏其实现细节，只通过公共接口与外界交互。</li><li>友元关系不能被继承。</li><li>友元关系是单向的，即如果类A是类B的友元，类B不一定是类A的友元。</li></ul><h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><p>运算符重载是 C++ 中一个非常强大的特性，它允许开发者为自定义类型指定运算符操作的行为。这样，我们就可以对自定义类型使用标准的C++运算符，如+、-、&lt;&lt;等。这不仅可以提高代码的直观性，还可以使得自定义类型的操作更加自然。</p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>运算符重载允许开发者为自定义类型重新定义运算符的功能。它可以作为成员函数或非成员函数(友元函数)实现，但必须至少有一个操作数是用户定义的类型。</p><p><strong>使用运算符重载时，需要遵循一些规则</strong>：</p><ul><li>不能改变运算符的优先级。</li><li>不能创造新的运算符。</li><li>有些运算符不能被重载，如<code>.</code>、<code>::</code>、<code>?:</code>和<code>sizeof</code>。其他的内置运算符都是可以重载的，比如常见的算术运算符、比较运算符、逻辑运算符等。</li><li>大多数重载的运算符可以是成员函数，也可以是非成员函数，但有些必须是成员函数，如赋值运算符<code>=</code>。</li></ul><h4 id="运算符重载的分类"><a href="#运算符重载的分类" class="headerlink" title="运算符重载的分类"></a>运算符重载的分类</h4><p>根据运算符作用于的对象，运算符重载可以是成员函数或非成员函数。</p><h5 id="成员函数运算符重载"><a href="#成员函数运算符重载" class="headerlink" title="成员函数运算符重载"></a>成员函数运算符重载</h5><p>当运算符重载作为成员函数时，它的第一个操作数隐式地成为了调用它的对象，这意味着你不能改变操作数的顺序。这通常用于二元运算符，比如加法运算符+，或一元运算符，比如递增运算符++。</p><p>我们先来看个成员函数运算符重载的例子,以重载<code>+</code>运算符为例，定义一个 <code>Point</code> 类，并为它重载 <code>+</code> 运算符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    Point(<span class="type">int</span> x = <span class="number">0</span>, <span class="type">int</span> y = <span class="number">0</span>) : x(x), y(y) &#123;&#125;</span><br><span class="line">    <span class="comment">// 重载+运算符</span></span><br><span class="line">    Point operator+(<span class="type">const</span> Point&amp; rhs) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x + rhs.x, y + rhs.y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Point <span class="title function_">p1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span>, <span class="title function_">p2</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span>;</span><br><span class="line">    Point p3 = p1 + p2;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;p3 = (&quot;</span> &lt;&lt; p3.x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; p3.y &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们定义了 <code>Point</code> 类的对象可以通过<code>+</code>运算符相加，返回两点坐标的和。</p><h5 id="非成员函数运算符重载"><a href="#非成员函数运算符重载" class="headerlink" title="非成员函数运算符重载"></a>非成员函数运算符重载</h5><p>非成员函数运算符重载通常声明为类的友元，这样它们就可以访问类的私有成员。这种方式适用于操作符左侧的对象不是重载运算符所在类的实例的情况，比如<code>输出流运算符&lt;&lt;</code>。</p><p><strong>重载&lt;&lt;运算符</strong></p><p>接下来，我们看下非成员函数运算符重载的例子，重载<code>&lt;&lt;</code>运算符以便能够直接打印 <code>Point</code> 对象。</p><p>由于<code>&lt;&lt;</code>运算符需要操作<code>std::ostream</code>类型的左操作数（如<code>std::cout</code>），它不能作为成员函数重载，而应该是非成员函数(友元函数)。通常，我们会将这样的函数声明为友元，以便它可以访问类的私有成员。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    friend <span class="built_in">std</span>::ostream&amp; operator&lt;&lt;(<span class="built_in">std</span>::ostream&amp; os, <span class="type">const</span> Point&amp; p);</span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    Point(<span class="type">int</span> x = <span class="number">0</span>, <span class="type">int</span> y = <span class="number">0</span>) : x(x), y(y) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 重载&lt;&lt;运算符</span></span><br><span class="line"><span class="built_in">std</span>::ostream&amp; operator&lt;&lt;(<span class="built_in">std</span>::ostream&amp; os, <span class="type">const</span> Point&amp; p) &#123;</span><br><span class="line">    os &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; p.x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; p.y &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Point <span class="title function_">p1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; p1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 现在可以直接打印Point对象了</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这里留个问题</strong>：为什么<code>&lt;&lt;</code>运算符不能作为成员函数重载，而只能是非成员函数？</p><p>这个问题，在我开始学习运算符重载的时候就挺疑惑的，不过现在已经搞清楚了，接下来，我尽可能用易懂的文字及代码示例给大家讲解清楚：</p><p>在 C++ 中，当你使用如 <code>std::cout &lt;&lt; object</code>; 的形式进行输出时，期望的行为是把<code>object</code>的内容发送到输出流<code>std::cout</code>。为了实现这个行为，我们需要重载&lt;&lt;运算符。但这里的挑战在于，<code>std::cout</code>是一个<code>std::ostream</code>类型的对象，而<code>object</code>是另一个用户自定义类型的类对象。</p><p><strong>成员函数的限制</strong>：<br>如果<code>&lt;&lt;</code>运算符是作为用户自定义类型的一个成员函数来重载，它的使用方式将变为<code>object.operator&lt;&lt;(std::cout);</code>。这意味着，从语法上讲，你正在尝试向<code>object</code>发送<code>std::cout</code>，而不是反过来。这与我们通常使用输出流的直觉相违背，因为我们希望<code>std::cout</code>在左边，<code>object</code>在右边，即：<code>std::cout&lt;&lt;object</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    MyClass(<span class="type">int</span> v) : value(v) &#123;&#125;</span><br><span class="line">    <span class="comment">// 假设尝试将 &lt;&lt; 作为成员函数重载</span></span><br><span class="line">    <span class="type">void</span> operator&lt;&lt;(<span class="built_in">std</span>::ostream&amp; os) &#123;</span><br><span class="line">        os &lt;&lt; value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    MyClass <span class="title function_">obj</span><span class="params">(<span class="number">10</span>)</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; obj; <span class="comment">// 这是我们想要的使用方式</span></span><br><span class="line">    obj &lt;&lt; <span class="built_in">std</span>::<span class="built_in">cout</span>; <span class="comment">// 如果&lt;&lt;是成员函数，实际调用将会是这样，这显然不符合我们的预期</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>为什么用非成员函数?</strong></p><p>为了让<code>std::cout &lt;&lt; object;</code>按预期工作，我们需要把<code>&lt;&lt;</code>运算符重载为非成员函数，这样它就可以接受两个参数：左边的<code>std::ostream</code>对象和右边的用户自定义类型对象。这种方式符合我们直观的使用习惯。</p><p><strong>使用友元函数</strong></p><p>此外，由于重载的<code>&lt;&lt;</code>运算符通常需要访问用户自定义类型对象的内部数据（可能包括私有成员），我们一般会把这个重载函数声明为<strong>友元函数</strong>。这样，即使是非成员函数，它也能访问类的私有或受保护成员，从而可以输出对象的内部状态。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    MyClass(<span class="type">int</span> val) : value(val) &#123;&#125;</span><br><span class="line">    <span class="comment">// 注意，这里没有作为成员函数重载&lt;&lt;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载&lt;&lt;运算符作为全局函数，并声明为友元，以便可以访问MyClass的内部数据</span></span><br><span class="line"><span class="built_in">std</span>::ostream&amp; operator&lt;&lt;(<span class="built_in">std</span>::ostream&amp; os, <span class="type">const</span> MyClass&amp; obj) &#123;</span><br><span class="line">    os &lt;&lt; obj.value; <span class="comment">// 假设我们要输出MyClass对象的value成员</span></span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    MyClass <span class="title function_">myObject</span><span class="params">(<span class="number">10</span>)</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; myObject; <span class="comment">// 正确地把myObject的内容输出到std::cout</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>在讲解多态之前，我们先来回顾下继承，因为多态是建立在类的继承关系之上的。</p><p><strong>简单来说</strong>: 继承允许我们基于一个已有的类（称为基类）来创建新的类（称为派生类）。派生类继承了基类的属性和方法，并且可以添加自己的属性和方法，或者重写继承来的方法。这为代码复用提供了一个强大的机制。</p><p>多态，字面意思是“多种形态”。在C++中，它允许我们通过一个共同的接口来操作不同的数据类型。这听起来可能有点抽象，不过别担心，让我们通过一个例子来简化它。</p><p>想象一下，你在动物园里，看到了各种各样的动物。虽然每种动物都有自己独特的叫声，但是你可以通过一个统一的行为“发出声音”来描述它们的共性。在C++中，我们可以将这种“发出声音”的行为抽象成一个共同的接口，然后让每种动物类根据自己的特性来实现这个接口。</p><h4 id="多态的分类："><a href="#多态的分类：" class="headerlink" title="多态的分类："></a>多态的分类：</h4><p>在C++中，多态主要以两种形式出现：<strong>编译时多态和运行时多态。</strong></p><ul><li><p><strong>编译时多态</strong>，也称为静态多态，主要是通过函数重载和模板实现的。函数重载允许你在同一个作用域内创建多个同名函数，只要它们的参数列表不同即可。编译器根据调用函数时提供的参数类型和数量，来决定调用哪个函数。</p></li><li><p><strong>运行时多态</strong>，也称为动态多态，是通过虚函数和继承实现的。这允许你在基类中定义一个接口，并在派生类中以不同的方式实现该接口。运行时多态的关键在于，你在代码运行时才确定调用哪个函数。</p></li></ul><h4 id="运行时多态的实现："><a href="#运行时多态的实现：" class="headerlink" title="运行时多态的实现："></a>运行时多态的实现：</h4><p>要实现C++的运行时多态，你需要掌握两个核心概念：<strong>虚函数和指针或引用</strong>。</p><p><strong>虚函数</strong>：</p><p>虚函数是在基类中使用关键字 <code>virtual</code> 声明的函数，它可以在派生类中被重覆盖，覆盖指的是派生类被重写的函数和基类声明的虚函数具有相同的函数声明。这样当你通过基类的指针或引用调用虚函数时，C++会根据对象的实际类型来决定调用哪个版本的函数。</p><p><strong>简单示例</strong></p><p>让我们回到动物园的例子，如果“动物”是一个基类，“狗”和“猫”是派生类，那么即使我们有一个指向“动物”的指针，我们也可以用它来调用“狗”和“猫”特有的方法。</p><p>代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    virtual <span class="type">void</span> <span class="title function_">speak</span><span class="params">()</span> &#123; </span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Some sound&quot;</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span> public Animal &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">speak</span><span class="params">()</span>  &#123; </span><br><span class="line">          <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Woof&quot;</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span> public Animal &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">speak</span><span class="params">()</span>  &#123; </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Meow&quot;</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Animal* myAnimal = new Dog();</span><br><span class="line">    myAnimal-&gt;speak();  <span class="comment">// Outputs: Woof</span></span><br><span class="line"></span><br><span class="line">    myAnimal = new Cat();</span><br><span class="line">    myAnimal-&gt;speak();  <span class="comment">// Outputs: Meow</span></span><br><span class="line"></span><br><span class="line">    delete myAnimal; <span class="comment">// Assuming myAnimal now points to Cat, delete the Cat object</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们定义了一个基类 Animal 和两个派生类 Dog 和 Cat。每个类都有一个 speak 函数，但实现各不相同。通过基类指针调用 speak 时，C++运行时会根据对象的实际类型来决定调用 Dog 的 speak 还是 Cat 的 speak。</p><p><strong>这里问个问题</strong>：myAnimal是基类指针，为什么调用的是派生类(Cat类和Dog类)的方法？</p><p>其实就是通过多态和虚函数机制来实现的。简单来说：</p><ul><li><p><code>虚函数</code>：在基类中用virtual关键字声明的函数。派生类可以重写这些函数。</p></li><li><p><code>虚表指针</code>：每个包含虚函数的类对象都有一个指针（vptr），指向其类的虚表。</p></li><li><p><code>虚表</code>：每个包含虚函数的类都有一个虚函数表（简称vtable），里面存储了虚函数的地址。</p></li></ul><p><code>注意</code>：虚函数表（vtable）是在编译期间确定的，而虚表指针（vptr）是在每个对象被构造时创建并初始化的。(<strong>这个也是面试常考的点</strong>)</p><p>当通过基类指针调用虚函数时，程序会使用这个指针指向的对象的虚表来确定实际调用哪个函数(这个过程是在运行时做的)。这样，即便是通过基类指针，程序也能调用到派生类中重写的方法，实现了多态。 </p><p>在这个例子中，Animal 类中的 speak 函数被声明为 virtual，这使得 Dog 和 Cat类能够提供自己的speak函数实现。当通过类型为 Animal* 的指针 myAnimal 调用 speak 函数时，C++ 运行时会检查 myAnimal 实际指向的对象类型（Dog或Cat），并调用那个类型的 speak 函数。</p><h4 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h4><p>当我们希望定义一个通用接口，但又不想在基类中提供任何具体实现时，该怎么办。使用纯虚函数和抽象类即可实现。</p><h5 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h5><p>纯虚函数是一种特殊的虚函数，在基类中声明但不提供实现（不定义函数体），并且要求派生类必须提供具体的实现。这通过在函数声明的末尾加上<code>= 0</code>来实现。</p><p>纯虚函数的存在使得基类变成所谓的抽象类，这意味着它不能被直接实例化。这样，抽象类为派生类定义了一个或多个必须实现的接口，从而实现了一个完全抽象的概念层。</p><h5 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h5><p>抽象类是包含至少一个纯虚函数的类。它主要用作其他类的基类，定义了一组接口，派生类通过实现这些接口实现多态性。抽象类提供了一种强制派生类遵守特定设计契约的机制。</p><p>回到我们的动物园例子，假设我们想要强制每种动物都必须实现自己的“发出声音”的方法，但在“动物”这一概念层面，我们无法给出一个具体的实现。这就是纯虚函数和抽象类发挥作用的地方。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象基类Animal</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="comment">// 纯虚函数</span></span><br><span class="line">    virtual <span class="type">void</span> <span class="title function_">speak</span><span class="params">()</span> <span class="type">const</span> = <span class="number">0</span>;</span><br><span class="line">    virtual ~Animal() &#123;&#125; <span class="comment">// 虚析构函数，保证派生类的析构函数被调用</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dog类继承自Animal并实现speak方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span> public Animal &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">speak</span><span class="params">()</span> <span class="type">const</span>  &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Dog says: Woof!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Cat类继承自Animal并实现speak方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span> public Animal &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">speak</span><span class="params">()</span> <span class="type">const</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Cat says: Meow!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">letAnimalSpeak</span><span class="params">(<span class="type">const</span> Animal* animal)</span> &#123;</span><br><span class="line">    animal-&gt;speak(); <span class="comment">// 动态绑定speak方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Dog dog;</span><br><span class="line">    Cat cat;</span><br><span class="line">    letAnimalSpeak(&amp;dog);</span><br><span class="line">    letAnimalSpeak(&amp;cat);</span><br><span class="line">    <span class="comment">// Animal animal; // 错误：不能实例化抽象类</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这个示例中，Animal类成为了一个抽象基类，因为它包含了一个纯虚函数 speak。我们不能直接实例化 Animal 类，但我们可以通过它的派生类 Dog 和 Cat 来实例化对象，并且通过 Animal 类的引用或指针来调用它们各自的 speak 方法。</p><p>通过将 speak 方法定义为纯虚函数，我们确保了所有 Animal 的派生类都必须实现自己的 speak 方法，这样每种动物都有自己独特的发声方式。同时，这也展示了运行时多态的强大之处：即使是通过 Animal 类型的引用或指针，程序在运行时也能正确调用到派生类对象的 speak 方法。</p><p>引入纯虚函数和抽象类后，我们的代码设计变得更加清晰和严格。这种方式不仅强制派生类遵守一定的规则，也提供了一个明确的、可扩展的接口框架。</p><p><strong>使用多态的好处</strong>：<br>多态的使用提供了几个优点：</p><ul><li><strong>代码的可复用性</strong>：可以通过基类接口编写通用的代码，这些代码能够与任何派生类对象协同工作，从而减少代码重复。</li><li><strong>代码的可扩展性</strong>：新增派生类时，不需要修改现有的基类代码或其他派生类代码，只需覆盖基类的虚函数即可。</li><li><strong>接口的一致性</strong>：派生类可以有不同的实现，但是共享相同的基类接口，使得接口一致、清晰。</li></ul><p>在讲解虚函数的时候，我们提到了覆盖，然而在C++中也存在另外一个相似的概念叫隐藏，这两者也是比较容易混淆的，接下来我们来看下覆盖和隐藏是什么？以及它们之间的区别？</p><h3 id="覆盖和隐藏"><a href="#覆盖和隐藏" class="headerlink" title="覆盖和隐藏"></a>覆盖和隐藏</h3><p>在C++中，函数覆盖和函数隐藏是面向对象编程中的两个基本概念，它们都涉及到派生类（子类）与基类（父类）之间方法的关系。</p><h4 id="函数覆盖（Function-Overriding）"><a href="#函数覆盖（Function-Overriding）" class="headerlink" title="函数覆盖（Function Overriding）"></a>函数覆盖（Function Overriding）</h4><p>当派生类中的成员函数与基类中的一个虚函数具有相同的签名（即相同的函数名称、返回类型及参数列表）时，我们说派生类的函数覆盖了（overriding）基类的函数。函数覆盖是实现多态的关键机制之一。</p><ul><li>覆盖发生在派生类与基类之间的虚函数上。</li><li>覆盖的目的是在派生类中提供一个特定实现，替换掉基类中的默认实现。</li></ul><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    virtual <span class="type">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Display of Base&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> public Base &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">display</span><span class="params">()</span> override &#123; <span class="comment">// 覆盖基类的display函数</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Display of Derived&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Base* ptr = new Derived();</span><br><span class="line">    ptr-&gt;display(); <span class="comment">// 调用Derived类的display方法</span></span><br><span class="line">    delete ptr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，Derived 类的 display 函数覆盖了 Base 类的 display 函数。通过基类指针调用 display 时，实际上调用的是 Derived 类的实现。这其实就是所为的多态。</p><h4 id="函数隐藏（Function-Hiding）"><a href="#函数隐藏（Function-Hiding）" class="headerlink" title="函数隐藏（Function Hiding）"></a>函数隐藏（Function Hiding）</h4><p>当派生类中的函数与基类中的某个函数具有相同的名称，但是签名不同，则我们说派生类中的函数隐藏了（hiding）基类中的同名函数。</p><ul><li>隐藏与覆盖不同，它发生在所有同名函数上，无论它们是否为虚函数。</li><li>隐藏的发生仅仅因为函数的名称相同。</li></ul><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Display of Base&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> public Base &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">display</span><span class="params">(<span class="type">int</span>)</span> &#123; <span class="comment">// 隐藏了基类的display函数</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Display of Derived with parameter&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Derived obj;</span><br><span class="line">    obj.display(<span class="number">5</span>); <span class="comment">// 调用Derived类的display方法</span></span><br><span class="line">    <span class="comment">// obj.display(); // 错误：Base类的display方法被隐藏</span></span><br><span class="line">    obj.Base::display(); <span class="comment">// 明确调用Base类的display方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，Derived 类的 display 函数隐藏了 Base 类的 display 函数，因为它们的签名不同。尝试直接调用没有参数的 display() 会导致编译错误，除非我们明确指定要调用 Base 类的版本。</p><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>C++提供了四种类型转换运算符，用于在不同类型之间进行显式转换。这些转换方式比C语言中的传统转换提供了更好的类型安全性和可读性。</p><h4 id="1-静态类型转换（static-cast）"><a href="#1-静态类型转换（static-cast）" class="headerlink" title="1. 静态类型转换（static_cast）"></a>1. 静态类型转换（static_cast）</h4><p>static_cast是用于类型之间转换的最常见形式，它在编译时检查转换的合法性。如果转换不合法，编译时会报错。它主要用于以下场景：</p><ul><li><strong>基本数据类型的转换</strong>：如整型与浮点型之间的转换。</li><li><strong>类层次结构中的向上转换</strong>（从派生类到基类）：这是安全的。</li><li><strong>类层次结构中的向下转换</strong>（从基类到派生类）：可能不安全，因为基类指针可能并不真正指向一个派生类对象。</li><li><strong>void指针的转换</strong>：将void<em>转换为具体类型的指针，或将具体类型的指针转换为void</em>。</li></ul><p>基本数据类型的转换示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> d = <span class="number">10.5</span>;</span><br><span class="line"><span class="type">int</span> i = static_cast&lt;<span class="type">int</span>&gt;(d); <span class="comment">// double转int</span></span><br></pre></td></tr></table></figure><p>类层次结构中的向上转换、向下转换代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">baseMethod</span><span class="params">()</span> &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base method\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> public Base &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">derivedMethod</span><span class="params">()</span> &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Derived method\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向上转换</span></span><br><span class="line">Derived derivedObj;</span><br><span class="line">Base* basePtr = static_cast&lt;Base*&gt;(&amp;derivedObj); <span class="comment">// 安全的向上转换</span></span><br><span class="line">basePtr-&gt;baseMethod(); <span class="comment">// 正常：可以访问基类方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 向下转换</span></span><br><span class="line">Base baseObj;</span><br><span class="line">Derived* derivedPtr = static_cast&lt;Derived*&gt;(&amp;baseObj); <span class="comment">// 不安全的向下转换</span></span><br><span class="line"><span class="comment">// derivedPtr-&gt;derivedMethod(); // 不安全：baseObj不是Derived的实例</span></span><br></pre></td></tr></table></figure><h4 id="2-常量类型转换（const-cast）"><a href="#2-常量类型转换（const-cast）" class="headerlink" title="2. 常量类型转换（const_cast）"></a>2. 常量类型转换（const_cast）</h4><p><code>const_cast</code>主要用于修改类型的<code>const</code>属性，包括：去除<code>const</code>属性：允许修改原本被声明为<code>const</code>的变量。</p><p>代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp; b = const_cast&lt;<span class="type">int</span>&amp;&gt;(a); <span class="comment">// 去除const属性</span></span><br><span class="line">b = <span class="number">20</span>; <span class="comment">// 修改成功，但修改const变量是未定义行为</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; b&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">// 20</span></span><br></pre></td></tr></table></figure><h4 id="3-动态类型转换（dynamic-cast）"><a href="#3-动态类型转换（dynamic-cast）" class="headerlink" title="3. 动态类型转换（dynamic_cast）"></a>3. 动态类型转换（dynamic_cast）</h4><p><code>dynamic_cast</code>是C++中用于在类的继承体系内进行类型转换的操作符，特别适用于执行安全的向下转换。<strong>向下转换是指将基类的指针（或引用）转换为派生类的指针（或引用）</strong>。这种转换在运行时检查对象的实际类型，以确保转换的合法性和安全性.</p><p>dynamic_cast向下转换代码示例：</p><p>假设有一个基类 Base 和一个从 Base 派生的类 Derived：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    virtual <span class="type">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base class&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    virtual ~Base() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> public Base &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">print</span><span class="params">()</span> override &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Derived class&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">specificFunction</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Derived class specific function&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在，如果我们想安全地将基类 Base 的指针转换为派生类 Derived 的指针，并调用派生类的特定函数，我们可以使用dynamic_cast：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Base* basePtr = new Derived();</span><br><span class="line">    basePtr-&gt;print();  <span class="comment">// 输出: Derived class</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 安全的向下转换</span></span><br><span class="line">    Derived* derivedPtr = dynamic_cast&lt;Derived*&gt;(basePtr);</span><br><span class="line">    <span class="keyword">if</span> (derivedPtr != nullptr) &#123;</span><br><span class="line">        derivedPtr-&gt;specificFunction();  <span class="comment">// 输出: Derived class specific function</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Conversion failed.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    delete basePtr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，basePtr 实际上指向一个 Derived 类的对象，因此使用 dynamic_cast 将 basePtr 转换为 Derived* 类型是安全的，并且转换成功。这允许我们安全地调用 Derived 类的 specificFunction 方法。</p><p><code>dynamic_cast</code>类型转换如何使用讲完了，接下来我们来看下 dynamic_cast类型转换的具体过程是怎样的？</p><h5 id="dynamic-cast的工作原理"><a href="#dynamic-cast的工作原理" class="headerlink" title="dynamic_cast的工作原理"></a>dynamic_cast的工作原理</h5><p><code>dynamic_cast</code>利用 C++ 的<code>运行时类型信息（RTTI）</code>机制来检查转换的安全性。它在运行时检查对象的实际类型，以确保所执行的转换是合法的。这种检查使得dynamic_cast比其他类型转换操作符（如static_cast或reinterpret_cast）更安全，但也带来了一定的性能开销。</p><p><strong>RTTI 是什么？</strong></p><p>C++的RTTI（Runtime Type Information，运行时类型信息）是一种机制，它允许C++程序在运行时查询和操作对象的类型信息。这种能力使得dynamic_cast能够在执行类型转换前，检查转换是否安全，从而确保类型转换的正确性和安全性。</p><p>dynamic_cast类型转换的具体过程？</p><p><strong>1. 确定对象的实际类型</strong></p><p><strong>访问虚函数表（vtable）</strong>：在C++中，每个具有虚函数的类的对象都会有一个隐藏的指针（称为虚表指针vptr），指向一个静态的虚函数表（vtable）。vtable主要用于支持多态性，即在运行时决定调用哪个虚函数。</p><p><strong>类型信息（RTTI）在vtable中</strong>：除了虚函数的地址外，vtable还包含了指向特定的类型信息的指针，这里说的类型信息就是RTTI。RTTI的核心是type_info类的对象，它为每个类提供了唯一的类型标识。</p><p><strong>2. 利用RTTI确定实际类型</strong>：</p><ul><li>当使用dynamic_cast进行类型转换时，C++运行时会查找原对象的vtable，通过其中的RTTI信息（即指向type_info对象的指针）来获取对象的实际类型。</li><li>一旦获得了对象的实际类型信息，dynamic_cast接着检查这个类型与目标类型的关系。对于向下转换（基类指针转换为派生类指针），它验证目标派生类是否确实是源对象实际类型的派生类或相同类型。</li></ul><p>在多态的使用场景中，上面提到的原对象指的是一个指向基类的指针或引用指向的对象。<br>目标派生类指的是我们希望将原对象的基类指针或引用转换到的目标类。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Base* basePtr = new Derived();</span><br><span class="line">Derived* derivedPtr = dynamic_cast&lt;Derived*&gt;(basePtr);</span><br></pre></td></tr></table></figure><p>对于上面的代码示例：原对象指的就是 basePtr 基类指针指向的 Derived 对象。目标派生类指的是 Derived 类。</p><p><strong>3.验证转换的合法性并执行转换或失败处理</strong></p><ul><li>如果转换合法，dynamic_cast修改源指针或引用，使其指向正确的目标类型的对象。</li><li>如果转换不合法：对于指针类型，dynamic_cast返回nullptr，表示转换失败。<br>对于引用类型，dynamic_cast 抛出 std::bad_cast 异常，因为引用不能为 nullptr。</li></ul><h4 id="4-重新解释类型转换-reinterpret-cast"><a href="#4-重新解释类型转换-reinterpret-cast" class="headerlink" title="4.重新解释类型转换 reinterpret_cast"></a>4.重新解释类型转换 reinterpret_cast</h4><p>reinterpret_cast是C++中一种强大但需谨慎使用的类型转换操作符。它允许开发者在几乎任何指针类型之间进行转换，也支持指针与足够大的整数类型之间的转换。其基本作用是重新解释数据的位模式，但不改变数据本身。</p><p>由于 reinterpret_cast 不进行类型检查和转换安全性保证，使用时需要特别注意，以防止未定义行为的发生。</p><h5 id="指针类型转换"><a href="#指针类型转换" class="headerlink" title="指针类型转换"></a>指针类型转换</h5><p>reinterpret_cast 可以用来将一个指针类型转换为另一个指针类型，即便这两个类型之间并无直接的关联。这种转换基本上是在告诉编译器：<strong>将内存地址当作另一种类型来解释，但不改变位模式本身</strong>。这种转换不会进行任何类型安全检查，因此非常危险且易于产生错误。因此在解引用转换后的指针之前，你需要确保转换是有意义的。</p><p>指针类型转换示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">char</span>* cp = &amp;c;</span><br><span class="line"><span class="comment">// 将char*转换为int*，虽然不安全，但可以编译通过</span></span><br><span class="line"><span class="type">int</span>* ip = reinterpret_cast&lt;<span class="type">int</span>*&gt;(cp);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;*ip&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 输出随机值</span></span><br></pre></td></tr></table></figure><h5 id="指针与整数类型之间的转换"><a href="#指针与整数类型之间的转换" class="headerlink" title="指针与整数类型之间的转换"></a>指针与整数类型之间的转换</h5><p>reinterpret_cast也可以用于将指针转换为整数类型，或者相反。这在需要在整数和指针之间进行转换，例如，当与需要整数参数的底层系统调用交互时非常有用。为了安全地执行这种转换，整数类型必须足够大以存储指针值，通常使用 uintptr_t 或 intptr_t。</p><p>示例代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdint&gt;</span>  <span class="comment">// 包含uintptr_t定义</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">42</span>;</span><br><span class="line">    <span class="comment">// 将int指针转换为整数</span></span><br><span class="line">    <span class="type">uintptr_t</span> ptrAsInt = reinterpret_cast&lt;<span class="type">uintptr_t</span>&gt;(&amp;a);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The pointer as integer: &quot;</span> &lt;&lt; ptrAsInt &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将整数转换回int指针</span></span><br><span class="line">    <span class="type">int</span>* aPtrAgain = reinterpret_cast&lt;<span class="type">int</span>*&gt;(ptrAsInt);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The integer as pointer: &quot;</span> &lt;&lt; *aPtrAgain &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>指针与整数类型之间的转换的使用场景</strong>：</p><ul><li><p><strong>系统级调用或API</strong>:<br>一些底层的系统调用或API可能要求使用整数类型的“句柄”来代表资源或对象。在这些情况下，如果资源或对象由C++管理，并通过指针访问，我们可以临时将指针转换为整数类型的句柄，进行调用，然后再转换回指针进行操作。</p></li><li><p><strong>回调函数与用户数据</strong>:<br>在使用回调函数时，通常需要提供一个指向用户数据的指针。如果回调函数的接口仅允许传递整数类型的用户数据，我们可以将指针转换为整数进行传递，然后在回调函数中再转换回指针，以访问实际的用户数据。</p></li></ul><p>示例代码：使用回调函数</p><p>假设我们有一个C++库，该库提供了一个设置回调函数的API，但API要求回调函数的用户数据必须是uintptr_t类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdint&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyCallback</span><span class="params">(<span class="type">uintptr_t</span> userData)</span> &#123;</span><br><span class="line">    <span class="comment">// 在回调中将整数还原回指针</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span>* str = reinterpret_cast&lt;<span class="built_in">std</span>::<span class="built_in">string</span>*&gt;(userData);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *str &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">RegisterCallback</span><span class="params">(<span class="type">void</span>(*callback)(<span class="type">uintptr_t</span>), <span class="built_in">std</span>::<span class="built_in">string</span>* userData)</span> &#123;</span><br><span class="line">    <span class="comment">// 调用回调函数，将指针作为整数传递</span></span><br><span class="line">    callback(reinterpret_cast&lt;<span class="type">uintptr_t</span>&gt;(userData));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> myData = <span class="string">&quot;Hello, callback!&quot;</span>;</span><br><span class="line">    RegisterCallback(MyCallback, &amp;myData);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p>C++的模板是一种强大的编程特性，它允许程序员编写与类型无关的代码，也就是所谓的泛型编程。这使得我们可以编写一个通用的代码框架，它可以用于多种数据类型。使用模板可以大大提高代码的复用性和灵活性。</p><p>C++ 模板主要有两种形式：<strong>函数模板和类模板</strong></p><p>在讲解函数模板和类模板之前，我们先来了解下 <strong>模板参数</strong> ？</p><p>在 C++ 模板编程中，模板参数是定义模板时指定的一种占位符，它在模板实例化时被具体的类型或值所替代。模板参数使模板具有泛型，能够适应不同的数据类型或值。C++ 中的模板参数主要分为两类：<strong>类型参数和非类型参数</strong>。</p><h4 id="类型参数"><a href="#类型参数" class="headerlink" title="类型参数"></a>类型参数</h4><p>类型参数允许在模板定义时指定一些<strong>占位符</strong>类型，这些类型在模板实例化时被<strong>具体的类型</strong>所替代。这意味着你可以编写一个通用的模板，然后用不同的类型来实例化它，生成针对那些类型的特化版本。</p><p><strong>类型参数声明方式</strong>：使用关键字 typename 或 class 来声明。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">T <span class="title function_">max</span><span class="params">(T x, T y)</span> &#123;</span><br><span class="line">    <span class="comment">// 函数实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述示例中，<code>T</code>是一个类型参数，表示 max 函数的两个参数可以接受任何类型。</p><h4 id="非类型参数"><a href="#非类型参数" class="headerlink" title="非类型参数"></a>非类型参数</h4><p>非类型参数允许你将<strong>一个或多个常量值</strong>作为参数传递给模板。非类型参数必须是一个<strong>常量表达式</strong>，因为模板在编译时实例化。</p><p>下面来看类模板如何使用非类型参数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">template &lt;  T, <span class="type">size_t</span> N&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FixedArray</span> &#123;</span></span><br><span class="line">    T data[N]; <span class="comment">// N 是一个非类型参数</span></span><br><span class="line">public:</span><br><span class="line">    T&amp; operator[](<span class="type">size_t</span> index) &#123; <span class="keyword">return</span> data[index]; &#125;</span><br><span class="line">    <span class="type">const</span> T&amp; operator[](<span class="type">size_t</span> index) <span class="type">const</span> &#123; <span class="keyword">return</span> data[index]; &#125;</span><br><span class="line">    constexpr <span class="type">size_t</span> <span class="title function_">size</span><span class="params">()</span> <span class="type">const</span> &#123; <span class="keyword">return</span> N; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这个示例中，N是一个非类型参数，它指定了FixedArray的大小。</p><p>非类型参数大多数使用在类模板中，虽然非类型参数在函数模板中的使用不如在类模板中那么频繁，但在某些情况下，它们仍然非常有用，特别是当你需要根据编译时常量来调整函数行为时。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T, <span class="type">int</span> increment&gt;</span><br><span class="line">T <span class="title function_">addIncrement</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value + increment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>addIncrement</code> 函数模板通过非类型参数 <code>increment</code> 允许在编译时确定增加的量，这可以在不同的调用中提供不同的增量值。</p><h4 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h4><p>函数模板允许我们创建一个函数原型，它可以用不同的数据类型来实例化。这意味着我们可以用一个函数模板来创建一系列执行相似操作的函数，而无需为每种数据类型编写重复的代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">T <span class="title function_">max</span><span class="params">(T x, T y)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; y ? x : y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>调用函数模板</strong></p><p><strong>1. 自动类型推导:</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Max of &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; max(a, b) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line"></span><br><span class="line"><span class="type">double</span> c = <span class="number">3.5</span>, d = <span class="number">2.5</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Max of &quot;</span> &lt;&lt; c &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; d &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; max(c, d) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者这样调用：</span></span><br><span class="line">max(<span class="number">3</span>, <span class="number">5</span>)；</span><br></pre></td></tr></table></figure><p><strong>2. 显式指定模板参数类型</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Max of 2 and 3 is &quot;</span> &lt;&lt; max&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">3</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Max of 2.5 and 3.5 is &quot;</span> &lt;&lt; max&lt;<span class="type">double</span>&gt;(<span class="number">2.5</span>, <span class="number">3.5</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>上面整型的调用，函数模板实际上会被实例化为一个接受两个 int 类型参数的函数版本：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; y ? x : y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而对于double类型的调用，函数模板会被实例化为一个接受两个 double 类型参数的函数版本。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">max</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; y ? x : y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h4><p>类模板与函数模板类似，允许我们定义一个类蓝图，用于生成处理不同数据类型的类。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    Box(T value) : value(value) &#123;&#125;</span><br><span class="line">    T <span class="title function_">getValue</span><span class="params">()</span> <span class="type">const</span> &#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">private:</span><br><span class="line">    T value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建类模板实例</span></span><br><span class="line">Box&lt;<span class="type">int</span>&gt; <span class="title function_">intBox</span><span class="params">(<span class="number">123</span>)</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Value in intBox: &quot;</span> &lt;&lt; intBox.getValue() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">Box&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title function_">stringBox</span><span class="params">(<span class="string">&quot;Hello Templates&quot;</span>)</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Value in stringBox: &quot;</span> &lt;&lt; stringBox.getValue() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>通过以上例子，我们了解了模板的基本使用，以及它是如何提高代码的复用性的。</p><p>上面的<code>max</code>函数模板的通用性确保了它可以用于整数、浮点数，甚至是字符串等多种类型，展现了模板编程的灵活性。然而，这种通用性有时候也是一把双刃剑。以指针类型为例，如果我们使用上述<code>max</code>函数比较两个指针，它实际上会比较指针的地址，而不是指针所指向的值，这可能并不是我们期望的行为。</p><p>在这种情况下，C++提供了一种强大的机制来优化和定制模板行为——<strong>模板特化</strong>。模板特化允许我们为特定的类型或值集合提供专门的实现，以此来处理那些需要特殊考虑的特定情况。模板特化分为两大类：<strong>全特化（Explicit Specialization）和偏特化（Partial Specialization）</strong>。</p><h4 id="全特化"><a href="#全特化" class="headerlink" title="全特化"></a>全特化</h4><p>全特化（Explicit Specialization）是为一个已有的模板定义提供一个特定版本的过程，这个特定版本适用于特定的类型或值。全特化意味着为模板的所有参数指定具体的类型或值。全特化不再是模板，而是对模板的一个特定实例提供了一个完全定制的实现。</p><h5 id="类模板全特化："><a href="#类模板全特化：" class="headerlink" title="类模板全特化："></a>类模板全特化：</h5><p>当你想为一个特定类型提供一个完全不同的类模板实现时，可以使用全特化。</p><p><strong>语法</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt;&gt; <span class="comment">// 空尖括号代表全特化的声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span>&lt;</span>Type&gt; &#123;</span><br><span class="line">    <span class="comment">// 特化的实现</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span> <span class="comment">// 通用模板</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">function</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Generic MyClass\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>&lt;</span><span class="type">int</span>&gt; &#123; <span class="comment">// 全特化为int类型</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">function</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Specialized MyClass for int\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="函数模板全特化："><a href="#函数模板全特化：" class="headerlink" title="函数模板全特化："></a>函数模板全特化：</h5><p>与类模板相似，你也可以为特定类型提供特定的函数模板实现。</p><p><strong>语法</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt;&gt;</span><br><span class="line">ReturnType functionName&lt;SpecificType&gt;(parameters) &#123;</span><br><span class="line">    <span class="comment">// 特化的实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举一个函数模板全特化的例子，比如对于前面的<code>max</code>函数，我们想要对指针类型进行特化，使其比较指针所指向的值而不是指针地址：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">T <span class="title function_">max</span><span class="params">(T x, T y)</span> &#123; <span class="comment">// 通用模板</span></span><br><span class="line">    <span class="keyword">return</span> x &gt; y ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;&gt;   <span class="comment">//使用全特化</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* max&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(<span class="type">const</span> <span class="type">char</span>* a, <span class="type">const</span> <span class="type">char</span>* b) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(a, b) &gt; <span class="number">0</span> ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这个例子，展示如何为特定类型（在这里是const char*类型的字符串）提供特化实现。</p><h4 id="偏特化"><a href="#偏特化" class="headerlink" title="偏特化"></a>偏特化</h4><p>偏特化允许你为模板的<strong>一部分参数</strong>提供具体的类型或值，而其余参数仍然保持泛型。<strong>偏特化仅适用于类模板，不能用于函数模板</strong>。通过偏特化，你可以对模板的部分参数施加约束，从而为特定的类型组合提供特定的实现。</p><p><strong>语法示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T, typename U&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span>&#125;; <span class="comment">// 通用模板</span></span><br><span class="line"></span><br><span class="line">template &lt;typename U&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>&lt;</span><span class="type">int</span>, U&gt; &#123;&#125;; <span class="comment">// 对第一个参数为int的偏特化</span></span><br></pre></td></tr></table></figure><p>代码示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">template&lt;typename T, typename U&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span> <span class="comment">// 原始模板</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">function</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Generic MyClass&lt;T, U&gt;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename U&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>&lt;</span><span class="type">int</span>, U&gt; &#123; <span class="comment">// 偏特化其中一个参数为int</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">function</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Partially Specialized MyClass&lt;int, U&gt;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    MyClass&lt;<span class="type">double</span>, <span class="type">double</span>&gt; myClass1; <span class="comment">// 将使用原始模板</span></span><br><span class="line">    myClass1.function();</span><br><span class="line">    MyClass&lt;<span class="type">int</span>, <span class="type">double</span>&gt; myClass2; <span class="comment">// 将使用偏特化模板</span></span><br><span class="line">    myClass2.function();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p>在C++中，内存管理是一个非常重要的概念，它关系到程序的性能和稳定性。C++提供了多种内存管理方式，包括<strong>自动、静态、动态分配</strong>等。让我们一步一步来了解。</p><p>为了更好地理解这些内存管理方式及其应用场景，我们首先需要了解C&#x2F;C++程序在运行时的内存布局。这里我介绍 Linux C&#x2F;C++ 程序的内存布局，因为大多数 C&#x2F;C++ 程序都是运行在 Linux 操作系统上，因此有必要了解下。</p><h4 id="Linux-C-C-程序的内存布局图示"><a href="#Linux-C-C-程序的内存布局图示" class="headerlink" title="Linux C&#x2F;C++ 程序的内存布局图示"></a>Linux C&#x2F;C++ 程序的内存布局图示</h4><p><img src="https://files.mdnice.com/user/48364/48290d63-a0e4-4242-9393-edb280609e52.png"></p><p>上图中，从下往上，地址是增加的，<code>0-3G</code>属于用户空间，<code>3G-4G</code> 属于内核空间.</p><p>接下来，我们对上面图示的各个区（段）作个详细的说明： </p><h4 id="内核空间（Kernel-Space）"><a href="#内核空间（Kernel-Space）" class="headerlink" title="内核空间（Kernel Space）"></a>内核空间（Kernel Space）</h4><p>Kernel space（内核空间）指的是操作系统内核所占用的内存区域。这部分内存是保留给操作系统内核的，用于执行核心的系统任务和硬件操作。出于安全和稳定性的考虑，用户程序通常无法直接访问这部分内存。在多数操作系统中，内核空间位于内存地址的高区域。在32位Linux系统上，通常最高的1GB内存（如地址从0xC0000000到0xFFFFFFFF）被保留给内核空间，而剩下的下3GB内存用于用户空间。</p><h4 id="用户空间（User-Space）"><a href="#用户空间（User-Space）" class="headerlink" title="用户空间（User Space）"></a>用户空间（User Space）</h4><ul><li><p><strong>栈（Stack）</strong></p><p>栈用于存放函数的局部变量、函数参数和返回地址。栈有着LIFO（后进先出）的特性，每当进入一个新的函数调用时，就会在栈上为其分配空间，函数返回时则释放这些空间。栈的大小通常有限，并且由操作系统预先定义。</p></li><li><p><strong>内存映射段(Memory Mapping Segment)</strong></p><p>内存映射段是一块可以被用来映射文件内容到进程地址空间的内存区域。这不仅包括用于动态库（如libc.so等）的映射，还包括程序运行时可能使用的任何匿名映射或文件映射。</p></li><li><p><strong>堆（Heap）</strong></p><p>堆用于动态内存分配，由new和delete（或malloc和free）控制。不同于栈，堆上的内存分配和释放是不自动的，需要程序员手动管理。堆的大小相对更灵活，受限于系统的可用内存。</p></li><li><p><strong>BSS段（Block Started by Symbol）</strong></p><p>BSS段，全称为“Block Started by Symbol”，主要用于存储程序中未初始化的全局变量和静态变量。与数据段（存放已初始化的全局变量和静态变量）相对，BSS段的特点是在程序启动之前，操作系统会自动将其内容初始化为零。这意味着，如果你在程序中声明了一个未初始化的全局或静态变量，它会被放在BSS段。</p></li><li><p><strong>数据区</strong></p><p>这部分内存用于存放全局变量和静态变量。不同于栈和堆上的变量，全局&#x2F;静态变量的生命周期贯穿整个程序运行期间，从程序开始执行时分配，到程序结束时才被释放。</p></li><li><p><strong>代码区</strong></p><p>存放程序的二进制代码，即编译后的机器指令。这部分内存是只读的。</p></li></ul><p>接下来，我们详细来聊下C++的多种内存管理方式，包括<strong>自动、静态、动态分配</strong>。</p><h4 id="常见的内存管理方式"><a href="#常见的内存管理方式" class="headerlink" title="常见的内存管理方式"></a>常见的内存管理方式</h4><h5 id="自动存储（Stack-Allocation）"><a href="#自动存储（Stack-Allocation）" class="headerlink" title="自动存储（Stack Allocation）"></a>自动存储（Stack Allocation）</h5><p>最简单的内存管理方式是自动存储，也就是在函数内部声明的局部变量。这些变量在函数被调用时自动分配内存（在栈上分配），并在函数返回时自动释放。</p><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">function</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> localVar = <span class="number">5</span>; <span class="comment">// 自动存储，函数结束时自动销毁</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="静态存储（Static-Allocation）"><a href="#静态存储（Static-Allocation）" class="headerlink" title="静态存储（Static Allocation）"></a>静态存储（Static Allocation）</h5><p>静态存储用于全局变量和静态变量，其生命周期贯穿整个程序运行期间。静态变量只被初始化一次，在首次加载时分配内存。</p><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">function</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> staticVar = <span class="number">5</span>; <span class="comment">// 静态存储，整个程序运行期间持续存在</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="动态存储（Dynamic-Allocation）"><a href="#动态存储（Dynamic-Allocation）" class="headerlink" title="动态存储（Dynamic Allocation）"></a>动态存储（Dynamic Allocation）</h5><p>动态存储是C++内存管理的核心，允许在运行时分配任意大小的内存。它使用<code>new</code>和<code>delete</code>操作符来手动管理内存。</p><p><strong>使用new和delete</strong></p><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = new <span class="type">int</span>; <span class="comment">// 动态分配一个int</span></span><br><span class="line">*ptr = <span class="number">5</span>; <span class="comment">// 给分配的int赋值</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *ptr &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 使用分配的内存</span></span><br><span class="line">delete ptr; <span class="comment">// 释放内存</span></span><br></pre></td></tr></table></figure><p><strong>使用new[]和delete[]管理数组</strong></p><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="built_in">array</span> = new <span class="type">int</span>[<span class="number">5</span>]; <span class="comment">// 动态分配一个有5个整数的数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">    <span class="built_in">array</span>[i] = i * i;</span><br><span class="line">&#125;</span><br><span class="line">delete[] <span class="built_in">array</span>; <span class="comment">// 释放数组</span></span><br></pre></td></tr></table></figure><p>现在大家已经了解了C++中的内存管理基础，接下来，我们将探讨如何更安全、更有效地管理资源。C++提供了一个强大的编程范式，称为RAII（资源获取即初始化）。</p><h4 id="RAII"><a href="#RAII" class="headerlink" title="RAII"></a>RAII</h4><p>“Resource Acquisition Is Initialization” (RAII) 是一种在C++中管理资源（如内存、文件句柄等）的编程模式。在RAII模式下，<strong>资源的分配（获取）发生在构造函数中，资源的释放（归还）发生在析构函数中</strong>。这种方式利用了C++自动调用析构函数的特性，确保了资源总是被正确释放，即使在面对异常情况时也不例外。</p><h4 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h4><p>通过<code>RAII</code>的介绍，我们已经认识到构造函数和析构函数在资源管理中的重要性。然而，在现实的编程实践中，尤其是面对复杂的资源管理需求时，单靠构造函数和析构函数可能不足以保证资源的安全和高效管理。这时，智能指针的概念应运而生。</p><p><code>智能指针</code>，实质上是一种行为类似于指针的对象，但它们包裹了原始指针，自动管理指向的资源。智能指针的核心理念正是基于<code>RAII模式</code>——通过对象的生命周期来管理资源。当智能指针的实例被创建时，它获取一个资源（比如动态分配的内存）；当智能指针实例销毁时，它释放那个资源。</p><p>C++11 标准库中提供了几种智能指针，如std::unique_ptr、std::shared_ptr和std::weak_ptr，但是我这里不讲解C++11 标准库的智能指针，而是重点讲解<code>boost</code>库里的智能指针。这两者的实现原理类似。后续会出一篇专门讲解 <code>C++11</code>新特性的文章。</p><p>在C++11之前，C++社区已经有一套成熟的解决方案来处理资源管理问题，那就是boost库提供的智能指针。</p><p>boost库是C++标准的实验田，很多在boost中实现的功能后来都被纳入了C++标准库。例如，C++11标准中的智能指针（std::shared_ptr和std::unique_ptr）、基于范围的for循环、无序容器等，都是从Boost库中借鉴或直接采用的。因此，可以说Boost对C++标准的发展有着重要的贡献。</p><h5 id="boost库智能指针有哪些？"><a href="#boost库智能指针有哪些？" class="headerlink" title="boost库智能指针有哪些？"></a>boost库智能指针有哪些？</h5><p><strong>1. boost::scoped_ptr</strong></p><p><code>boost::scoped_ptr</code>是一种简单的智能指针，用于管理在作用域内分配的对象。它不能传递所有权，即不能从一个<code>scoped_ptr</code>拷贝或赋值给另一个<code>scoped_ptr</code>。当<code>scoped_ptr</code>离开作用域时，它所管理的对象会被自动销毁。</p><p>使用示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/scoped_ptr.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    MyClass() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;MyClass constructed\n&quot;</span>; &#125;</span><br><span class="line">    ~MyClass() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;MyClass destroyed\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    boost::scoped_ptr&lt;MyClass&gt; <span class="title function_">ptr</span><span class="params">(new MyClass)</span>;</span><br><span class="line">    <span class="comment">// ptr在这里可用</span></span><br><span class="line">&#125; <span class="comment">// ptr离开作用域，自动销毁MyClass实例</span></span><br></pre></td></tr></table></figure><p><strong>2. boost::shared_ptr</strong></p><p><code>boost::shared_ptr</code>是一种引用计数的智能指针，也称共享型智能指针，允许多个<code>shared_ptr</code>实例共享同一个对象的所有权。当最后一个引用（shared_ptr实例）被销毁或重新指向另一个对象时，所管理的对象会被自动释放。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/shared_ptr.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    MyClass() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;MyClass constructed\n&quot;</span>; &#125;</span><br><span class="line">    ~MyClass() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;MyClass destroyed\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    boost::<span class="built_in">shared_ptr</span>&lt;MyClass&gt; <span class="title function_">ptr1</span><span class="params">(new MyClass)</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        boost::<span class="built_in">shared_ptr</span>&lt;MyClass&gt; ptr2 = ptr1; <span class="comment">// ptr1和ptr2共享对象</span></span><br><span class="line">    &#125; <span class="comment">// ptr2离开作用域，对象不会被销毁，因为ptr1仍然存在，引用计数不为0</span></span><br><span class="line">&#125; <span class="comment">// ptr1离开作用域，对象被销毁（引用计数为0）</span></span><br></pre></td></tr></table></figure><p>对于上面提到的<code>引用计数</code>，大家可以简单理解为一个<code>非负整型数值</code>.</p><p><strong>3. boost::weak_ptr</strong></p><p><code>boost::weak_ptr</code>专门设计用于与<code>boost::shared_ptr</code>协同工作，解决潜在的循环引用问题。循环引用发生在两个或多个对象通过<code>shared_ptr</code>相互引用时，导致它们的引用计数永远不会归零，进而导致内存泄漏。<code>weak_ptr</code>提供了一种机制，允许对这些对象进行观察，而不增加引用计数。</p><p><strong>weak_ptr的几个特性</strong>：</p><ul><li><strong>观察者</strong>：boost::weak_ptr是对boost::shared_ptr所管理对象的非拥有性引用（观察者）。它允许你访问对象，但不会延长对象的生命周期。</li><li><strong>临时升级</strong>：虽然weak_ptr本身不能直接访问对象，但它可以被临时升级为一个shared_ptr（如果对象仍然存在），以安全地访问对象。</li><li><strong>解决循环引用</strong>：在使用shared_ptr管理相互引用的对象时，容易产生循环引用，导致对象无法被释放。weak_ptr不参与引用计数，因此可以打破这种循环，避免内存泄漏。</li></ul><p><strong>weak_ptr基本用法</strong>：</p><p><strong>1. 创建weak_ptr</strong></p><p>weak_ptr通常通过与一个shared_ptr关联来创建：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">boost::<span class="built_in">shared_ptr</span>&lt;<span class="type">int</span>&gt; <span class="title function_">sp</span><span class="params">(new <span class="type">int</span>(<span class="number">42</span>))</span>; <span class="comment">// 创建shared_ptr</span></span><br><span class="line">boost::weak_ptr&lt;<span class="type">int</span>&gt; <span class="title function_">wp</span><span class="params">(sp)</span>;            <span class="comment">// 通过shared_ptr创建weak_ptr</span></span><br></pre></td></tr></table></figure><p><strong>2. 使用weak_ptr</strong></p><p>要访问 weak_ptr 所观察的对象，需要将它临时升级为shared_ptr，这可以通过调用weak_ptr的lock方法实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">boost::<span class="built_in">shared_ptr</span>&lt;<span class="type">int</span>&gt; sp = wp.lock(); <span class="comment">// 尝试将weak_ptr升级为shared_ptr</span></span><br><span class="line"><span class="keyword">if</span> (sp) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *sp &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 安全使用</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;对象已被销毁&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 解决循环引用示例</strong></p><p>考虑两个类ClassA和ClassB，它们通过shared_ptr相互持有对方：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/shared_ptr.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassB</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassA</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    boost::<span class="built_in">shared_ptr</span>&lt;ClassB&gt; bPtr;</span><br><span class="line">    ~ClassA() &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ClassA destroyed\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassB</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    boost::<span class="built_in">shared_ptr</span>&lt;ClassA&gt; aPtr;</span><br><span class="line">    ~ClassB() &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ClassB destroyed\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    boost::<span class="built_in">shared_ptr</span>&lt;ClassA&gt; <span class="title function_">a</span><span class="params">(new ClassA())</span>;</span><br><span class="line">    boost::<span class="built_in">shared_ptr</span>&lt;ClassB&gt; <span class="title function_">b</span><span class="params">(new ClassB())</span>;</span><br><span class="line"></span><br><span class="line">    a-&gt;bPtr = b; <span class="comment">// a持有b的shared_ptr</span></span><br><span class="line">    b-&gt;aPtr = a; <span class="comment">// b持有a的shared_ptr，形成循环引用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，main 函数中创建了两个shared_ptr对象a和b，分别指向 ClassA 和ClassB 的新实例。然后，我们通过 a-&gt;bPtr &#x3D; b;和b-&gt;aPtr &#x3D; a;让这两个实例相互持有对方，从而创建了循环引用。</p><p>由于存在循环引用，当 main 函数执行完毕，尽管a和b的作用域结束，它们应该被销毁，但 ClassA 和 ClassB 的实例的引用计数并没有降到零（因为它们相互引用），导致析构函数没有被调用，从而引发内存泄漏。</p><p>如何解决？使用<code>weak_ptr</code>可以解决这个问题：</p><p>可以将其中一个类的shared_ptr成员改为weak_ptr。这样做可以打破循环引用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassB</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassA</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="comment">// 使用weak_ptr代替shared_ptr</span></span><br><span class="line">    boost::weak_ptr&lt;ClassB&gt; bPtr;</span><br><span class="line">    ~ClassA() &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ClassA destroyed\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassB</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    boost::<span class="built_in">shared_ptr</span>&lt;ClassA&gt; aPtr;</span><br><span class="line">    ~ClassB() &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ClassB destroyed\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    boost::<span class="built_in">shared_ptr</span>&lt;ClassA&gt; <span class="title function_">a</span><span class="params">(new ClassA())</span>;</span><br><span class="line">    boost::<span class="built_in">shared_ptr</span>&lt;ClassB&gt; <span class="title function_">b</span><span class="params">(new ClassB())</span>;</span><br><span class="line"></span><br><span class="line">    a-&gt;bPtr = b; <span class="comment">// ClassA中持有ClassB的弱引用</span></span><br><span class="line">    b-&gt;aPtr = a; <span class="comment">// ClassB中持有ClassA的强引用，形成非对称的引用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当main结束时，a和b的shared_ptr都会被销毁。</span></span><br><span class="line">    <span class="comment">// b的shared_ptr被销毁时，由于ClassA中持有的是ClassB的weak_ptr，不会阻止ClassB对象的销毁。</span></span><br><span class="line">    <span class="comment">// 因此，ClassB被销毁后，ClassA中的weak_ptr变为悬挂指针，但ClassA对象也会随之被安全销毁。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里大家只需要掌握这几种智能指针的简单使用即可，后面笔者有计划写一篇关于智能指针实现原理的文章，从源码实现的角度来讲解。帮助大家更好的理解智能指针。</p><h4 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h4><p>在C++中，内存泄漏是指程序分配的内存没有被正确释放，导致程序不再能够使用那部分内存。内存泄漏在长时间运行的程序中尤为危险，因为它们会逐渐消耗掉所有可用的内存资源，可能导致程序崩溃或系统变得缓慢。</p><h5 id="内存泄露的原因："><a href="#内存泄露的原因：" class="headerlink" title="内存泄露的原因："></a>内存泄露的原因：</h5><p>在C++中，内存泄露通常由以下几个原因引起：</p><ul><li><strong>动态分配内存未释放</strong>：使用new或malloc等分配内存后，未使用delete或free释放。</li><li><strong>资源未释放</strong>：除了内存外，文件句柄、数据库连接等资源未被关闭或释放也会造成资源泄露。</li><li><strong>循环引用</strong>：使用智能指针（如std::shared_ptr）时，不当的循环引用会导致对象无法被自动销毁。</li><li><strong>异常安全性问题</strong>：<br>当函数或方法在执行过程中抛出异常，而这个函数或方法之前进行了资源分配（如动态内存分配），如果没有正确地处理异常（例如通过异常安全的智能指针或try&#x2F;catch块来确保资源被释放），那么原本应该在函数结束时释放的资源可能会因为异常的抛出而遗漏。</li></ul><h5 id="内存泄露的检测："><a href="#内存泄露的检测：" class="headerlink" title="内存泄露的检测："></a>内存泄露的检测：</h5><p>检测内存泄露通常可以通过以下几种方式：</p><p><strong>1. 代码审查</strong>：通过审查代码逻辑，检查每次new的内存分配是否都有对应的delete释放。</p><p><strong>2. 运行时工具</strong>：</p><ul><li><p>Valgrind：Linux下一个强大的内存检测工具，能够检测出内存泄露、内存越界等问题。Valgrind的优点在于它不需要对程序进行重新编译，适用于几乎所有的二进制文件，但缺点是运行速度较慢，通常会让程序的执行速度降低10倍以上。</p></li><li><p>AddressSanitizer：一个快速的内存错误检测工具，能够检测出包括内存越界访问、使用后释放、堆栈缓冲区溢出等问题。与Valgrind相比，ASan的主要优点是执行速度快（一般只会让程序变慢2倍左右）和提供精确的错误信息，但它需要对程序进行重新编译并链接，并且增加了程序的内存需求。</p></li></ul><h5 id="如何避免内存泄漏？"><a href="#如何避免内存泄漏？" class="headerlink" title="如何避免内存泄漏？"></a>如何避免内存泄漏？</h5><p><strong>1. 限制动态内存的使用</strong></p><p>尽量减少动态内存分配的使用。许多情况下，可以通过使用栈分配的变量或标准容器来代替动态分配的内存。这不仅可以减少内存泄漏的风险，还可以提高程序的性能。</p><p><strong>2. 使用智能指针</strong>：尽量避免在代码中直接使用裸指针管理动态分配的内存。裸指针很容易导致内存泄漏，因为它们不会自动释放所指向的内存。如果确实需要使用指针，考虑使用<code>智能指针</code>来代替。</p><p><strong>3. 使用容器类</strong>：C++标准库提供了多种容器，如std::vector、std::list等，这些容器在内部管理内存，可以减少直接使用动态内存分配的需要。</p><p><strong>4. 使用对象池</strong>：<br>对于频繁创建和销毁的小对象，使用对象池可以是一个有效的解决方案。对象池预先分配一定数量的对象，并在需要时重用它们，从而避免了频繁的动态内存分配和释放。</p><p><strong>5. 定期检查和测试</strong>：使用内存检测工具定期检查程序，及早发现并修复内存泄漏问题。</p><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>C++中的异常处理是通过<code>try</code>、<code>catch</code>、<code>throw</code>关键字实现的，旨在处理程序运行时可能出现的错误和异常情况。使用异常处理可以使错误处理代码和正常业务逻辑分离，使程序结构更清晰，更易于维护。</p><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul><li><strong>throw</strong>：当检测到错误条件时，程序可以通过throw关键字抛出一个异常。抛出的异常可以是预定义的数据类型，也可以是自定义类型。</li><li><strong>try</strong>：try块包含可能抛出异常的代码。如果在try块中的代码抛出了异常，执行将跳转到相应的catch块。</li><li><strong>catch</strong>：catch块用于捕获和处理异常。可以定义多个catch块来捕获不同类型的异常。</li></ul><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><p>下面是一个简单的示例，演示了如何使用C++的异常处理机制：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">divide</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">        throw <span class="string">&quot;Division by zero error&quot;</span>; <span class="comment">// 抛出异常</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; divide(<span class="number">10</span>, <span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 正常情况</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; divide(<span class="number">10</span>, <span class="number">0</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 这里将抛出异常</span></span><br><span class="line">    &#125; catch (<span class="type">const</span> <span class="type">char</span>* msg) &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Error: &quot;</span> &lt;&lt; msg &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 捕获并处理异常</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中，divide函数在除数为零时抛出一个异常，main函数中的 try 块捕获并处理了这个异常。</p><h4 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h4><p>除了使用预定义类型作为异常外，C++还允许定义自定义异常类。通过继承标准的<code>exception</code>类来创建自定义异常更为方便：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义异常类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyException</span> :</span> public exception &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* <span class="title function_">what</span><span class="params">()</span> <span class="type">const</span> <span class="title function_">throw</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Custom error occurred&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        throw MyException();</span><br><span class="line">    &#125; catch (MyException&amp; e) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;MyException caught&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; e.what() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; catch (exception&amp; e) &#123;</span><br><span class="line">        <span class="comment">// 其他所有的异常</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，我们定义了一个名为MyException的自定义异常类，并在main函数中抛出和捕获了这个异常。自定义异常类通过覆写 what 方法提供了异常的描述信息。</p><p>通过合理使用C++的异常处理机制，可以有效地管理程序中的错误情况，提高程序的健壮性和可读性。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章旨在提供一个关于C++语言学习的指南，以帮助初学者系统地掌握C++编程的关键技能和概念。通过深入浅出的方式，我们逐步解析了C++开发的各个方面，从基础的数据类型、函数使用，到高级的面向对象编程技术，如类和对象的操作、封装、继承、以及多态等。</p><ul><li><p><strong>数据类型和函数</strong>：我们探讨了C++的基本数据类型、枚举、复合以及派生数据类型，这为理解C++提供了坚实的基础。同时，函数的定义、声明、调用以及参数传递等知识点，构建了函数编程的框架。</p></li><li><p><strong>面向对象编程</strong>：详细讨论了类和对象的定义、成员变量和函数、构造函数和析构函数等概念，强调了封装、继承和多态这三大面向对象编程的核心特性。特别地，通过this指针、友元、运算符重载的讲解，进一步拓展了面向对象的编程思维。</p></li><li><p><strong>高级特性</strong>：深入到模板编程，介绍了类型参数、非类型参数、函数模板、类模板以及模板的特化，这些内容展现了C++泛型编程的强大能力。同时，对C++中的内存管理、异常处理进行了探讨，了解了怎样编写高效且安全的C++代码。</p></li></ul><p>这篇文章主要是给大家提供一个如何快速学习 C++ 的指南，不知道怎样学习 C++ 的朋友可以 <strong>按照我列的知识点去看书，去实践，掌握 C++ 语言应该会很快的。记住：一定要多敲代码，多实践！！</strong></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>如果单纯去学习C、C++语言是干不了任何事情的，作为与硬件和操作系统打交道的计算机底层语言，要想掌握 C和C++，你还得学习这几门课程：计算机组成原理、操作系统、数据结构。甚至还得了解汇编语言。除此之外，还需要学习 Linux 系统编程以及网络编程相关知识。</p><p>如果你想学习 Linux 编程，包括系统编程和网络编程相关的内容，可以关注我的公众号「<strong>跟着小康学编程</strong>」，微信搜索<strong>跟着小康学编程</strong>或者扫描下方二维码关注 。这里会定时更新 计算机编程 相关的技术文章，感兴趣的读者可以关注一下。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png">   </p><p>另外：C&#x2F;C++、Java、Go语言，计算机组成原理、操作系统、数据结构与算法、计算机网络以及Linux 系统编程和网络编程、数据库等经典书籍的电子档 pdf 我已经为大家整理好了，想要获取的同学可以关注我的公众号「<strong>跟着小康学编程</strong>」，然后后台回复：<strong>pdf</strong>，即可获取。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言学习 </category>
          
          <category> C++ 编程教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++入门 </tag>
            
            <tag> C++教程 </tag>
            
            <tag> C++快速学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入 C++11：从 auto 到 Lambda，解锁现代 C++ 的强大功能</title>
      <link href="/C++11/"/>
      <url>/C++11/</url>
      
        <content type="html"><![CDATA[<p>在介绍 C++11 之前，我们先回顾一下 C++98和C++03。C++98 作为 C++ 的第一个国际标准，奠定了这门语言的基础结构和核心特性，比如<strong>类、继承、模板、异常处理</strong>等。这些特性使得 C++ 成为一门强大的、面向对象的编程语言，广泛应用于系统&#x2F;应用软件、游戏开发、实时系统等领域。C++03 则是对 C++98 进行了修订，主要解决标准的疑义和错误，没有引入新特性。</p><p>然而，随着软件开发的不断进化，C++98和C++03 在表达能力、编程便利性和性能方面显示出了局限性。比如：<strong>对并发编程的支持不够强大，模板编程有时显得过于复杂，资源管理（尤其是内存管理）易于出错等</strong>。这些局限性促使了 C++11 标准的诞生，它被视为 C++ 的一次重大更新，于 2011 年正式发布。这次更新标志着 C++ 进入现代化的重要一步，引入了许多新特性和改进，旨在使 C++ 更易于使用，更灵活，同时提高了代码的安全性和性能。</p><p>另外，学习 C++11 新特性需要你有简单的 C、C++编程基础，还不了解的朋友可以看这两篇文章：<a href="https://mp.weixin.qq.com/s?__biz=MzkyNjQyMTMyOA==&mid=2247487373&idx=1&sn=6304025e2c0a846e97999e765667d866&chksm=c236d7b2f5415ea4b12b87fddf981abcd325d7458885aeade0957db5344da97f1b82d7e65cce&token=733890015&lang=zh_CN#rd">如何学习 C 语言</a>  和 <a href="https://mp.weixin.qq.com/s?__biz=MzkyNjQyMTMyOA==&mid=2247487758&idx=1&sn=1baa05f2c966eaa7623c8e48f152503d&chksm=c236c931f541402711b3130adeb3afc906af6ce954206cfe076e0c477e001d77fd041e802b3b&token=733890015&lang=zh_CN#rd">如何快速学习 C++</a>   ，文章通俗易懂而且有丰富的代码示例帮助理解。非常值得一看！！</p><p><strong>C++11 新增了很多新特性值得我们学习，包含如下</strong>：</p><p><img src="/images/C++11/1.png"></p><h2 id="核心语言增强"><a href="#核心语言增强" class="headerlink" title="核心语言增强"></a>核心语言增强</h2><h3 id="自动类型推断-auto"><a href="#自动类型推断-auto" class="headerlink" title="自动类型推断 (auto)"></a>自动类型推断 (auto)</h3><p>auto 关键字让编译器能够自动推断变量的类型（通过变量初始化时的表达式来确定类型），简化了变量声明的语法。</p><h4 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> variable_name = expression;</span><br></pre></td></tr></table></figure><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = <span class="number">5</span>; <span class="comment">// x 是 int</span></span><br><span class="line"><span class="keyword">auto</span> y = <span class="number">3.14</span>; <span class="comment">// y 是 double</span></span><br></pre></td></tr></table></figure><h3 id="获取表达式的类型（decltype）"><a href="#获取表达式的类型（decltype）" class="headerlink" title="获取表达式的类型（decltype）"></a>获取表达式的类型（decltype）</h3><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">decltype(expression) variableName;</span><br></pre></td></tr></table></figure><p>这里，expression 是你要查询类型的表达式，而 variableName 是使用该表达式类型声明的变量名称。</p><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码:"></a>示例代码:</h4><p><strong>基础示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line">decltype(x) y = x; <span class="comment">// y 的类型是int</span></span><br></pre></td></tr></table></figure><p>在这个例子中，decltype(x)将y的类型推导为x的类型，即<code>int</code>。</p><p><strong>结合 auto 使用</strong>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto x = 1; // x 的类型是int</span><br><span class="line">decltype(x) y = x; // y 的类型也是int</span><br></pre></td></tr></table></figure><p><strong>用于复杂表达式</strong></p><p><code>decltype</code>  特别有用于表达式的类型不明显时：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">decltype(vec.begin()) it = vec.begin(); <span class="comment">// it 的类型是 std::vector&lt;int&gt;::iterator</span></span><br></pre></td></tr></table></figure><h3 id="基于范围的-for-循环"><a href="#基于范围的-for-循环" class="headerlink" title="基于范围的 for 循环"></a>基于范围的 for 循环</h3><p>C++11引入了基于范围的for循环（Range-based for loop），这是一个用于遍历序列（如数组、容器等）的语法糖。它简化了迭代序列中每个元素的代码书写方式，使代码更加简洁易读。</p><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法:"></a>基本语法:</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (declaration : range) &#123;</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>declaration</strong>：用于迭代序列中每个元素的变量声明。这个变量的类型可以是序列元素的类型，也可以是(auto)自动类型推导。</li><li><strong>range</strong>：要迭代的序列，可以是数组、容器（如std::vector、std::list等）或任何支持begin()和end()方法的对象。</li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h4><p><strong>遍历数组</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> element : <span class="built_in">array</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; element &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出: 1 2 3 4 5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>遍历容器（如std::vector）</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> element : vec) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; element &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出: 10 20 30 40 50</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用 auto 自动类型推导</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; words = &#123;<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span>, <span class="string">&quot;!&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> word : words) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; word &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出: Hello World !</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong>:</p><p>如果你需要在循环中修改序列中的元素，请使用引用<code>&amp;</code>来声明变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span>&amp; num : vec) &#123;</span><br><span class="line">    num *= <span class="number">2</span>; <span class="comment">// 修改元素值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不需要修改元素，并且元素类型较大时，考虑使用常量引用<code>const &amp;</code>来避免不必要的拷贝，提高效率。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; word : words) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; word &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>基于范围的for循环</strong>是 C++11 中引入的一项便利特性，通过简化集合的遍历操作，它让代码更加简洁，增强了代码的可读性和易用性。</p><h3 id="统一初始化"><a href="#统一初始化" class="headerlink" title="统一初始化"></a>统一初始化</h3><p>C++11 引入了统一初始化（Uniform Initialization），这是一种使用花括号 <code>&#123;&#125; </code>进行变量初始化的语法。它提供了一种一致的语法来初始化任何对象。</p><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法:"></a>语法:</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Type variable&#123;value1, value2, ...&#125;;</span><br></pre></td></tr></table></figure><p><strong>基本类型的初始化</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a&#123;<span class="number">10</span>&#125;;</span><br><span class="line"><span class="type">double</span> b&#123;<span class="number">3.14</span>&#125;;</span><br></pre></td></tr></table></figure><p><strong>聚合类型（如结构体和数组）的初始化</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line">Point p&#123;<span class="number">10</span>, <span class="number">20</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure><p><strong>容器的初始化</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure><p><strong>类对象的初始化</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    MyClass(<span class="type">int</span> x, <span class="type">double</span> y) : x_(x), y_(y) &#123;&#125;</span><br><span class="line">private:</span><br><span class="line">    <span class="type">int</span> x_;</span><br><span class="line">    <span class="type">double</span> y_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyClass obj&#123;<span class="number">5</span>, <span class="number">3.14</span>&#125;;</span><br></pre></td></tr></table></figure><h3 id="初始器列表（Initializer-Lists）"><a href="#初始器列表（Initializer-Lists）" class="headerlink" title="初始器列表（Initializer Lists）"></a>初始器列表（Initializer Lists）</h3><p>初始器列表是C++11引入的一项特性，它进一步扩展了统一初始化的能力，特别是对于容器和自定义类对象的初始化。它允许构造函数接收一个由花括号<code>&#123;&#125;</code>包围的元素列表，从而提供了一种简洁且强大的初始化方式。</p><h4 id="包含必要头文件"><a href="#包含必要头文件" class="headerlink" title="包含必要头文件"></a>包含必要头文件</h4><p>要使用初始器列表，你需要包含<code>&lt;initializer_list&gt;</code>头文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;initializer_list&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h4><p>初始器列表主要通过在类构造函数中使用<code>std::initializer_list&lt;T&gt;</code>类型的参数来实现，其中<code>T</code>是列表中元素的类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    ClassName(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;T&gt; <span class="built_in">list</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码:"></a>示例代码:</h4><p><strong>自定义类的初始器列表</strong></p><p>假设有一个代表简单整数集合的类，我们希望能够在创建对象时直接用一组整数来初始化这个集合：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntSet</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; elements;</span><br><span class="line">public:</span><br><span class="line">    IntSet(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="type">int</span>&gt; <span class="built_in">list</span>) : elements(<span class="built_in">list</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Initialized with elements: &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> elem : elements) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    IntSet mySet = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出: Initialized with elements: 1 2 3 4 5 </span></span><br></pre></td></tr></table></figure><p><strong>函数参数为初始器列表</strong>:</p><p>函数也可以接受<code>std::initializer_list&lt;T&gt;</code>类型的参数，这在需要传递一组值时非常有用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="type">int</span>&gt; vals)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> val : vals) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    print(&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出: 10 20 30 40 50 </span></span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><code>初始器列表（Initializer Lists）</code>为C++11提供了一种强大的初始化机制，特别是在初始化需要一组值的对象时。通过使用初始器列表，可以极大地简化代码，提高可读性和可维护性。这一特性在自定义类、函数参数传递时尤为有用。</p><h3 id="nullptr-关键字"><a href="#nullptr-关键字" class="headerlink" title="nullptr 关键字"></a>nullptr 关键字</h3><p>在 C++11 中，<code>nullptr</code> 是一个特殊的字面量，用于表示空指针。它是对之前 C++ 版本中使用整数 0 或宏 NULL 来表示空指针的改进。<code>nullptr</code> 的引入提供了一种类型安全的方式来表示没有指向任何对象的指针。</p><h4 id="定义及使用："><a href="#定义及使用：" class="headerlink" title="定义及使用："></a>定义及使用：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = nullptr;</span><br><span class="line"><span class="keyword">if</span> (ptr == nullptr) &#123;</span><br><span class="line">    <span class="comment">// 检查 ptr 是否为空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="为什么需要-nullptr？"><a href="#为什么需要-nullptr？" class="headerlink" title="为什么需要 nullptr？"></a>为什么需要 nullptr？</h4><ul><li><strong>类型安全</strong>：在 C++11 之前，NULL 通常被定义为 0，这意味着它实际上是一个整数。这可能导致类型混淆和错误，特别是在函数重载的情况下。<code>nullptr</code> 明确地表示一个空指针，不会与整数混淆。</li><li><strong>更好的语义</strong>：<code>nullptr</code> 直观地表示指针为空，改善了代码的可读性和意图表达。</li></ul><h4 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h4><p><strong>使用 nullptr 初始化指针</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = nullptr; <span class="comment">// ptr 是一个指向 int 的空指针</span></span><br></pre></td></tr></table></figure><p><strong>函数重载中 nullptr 的优势</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;func(int) called&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span>*)</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;func(int*) called&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    func(<span class="number">0</span>);        <span class="comment">// 调用 func(int)</span></span><br><span class="line">    func(nullptr);  <span class="comment">// 明确调用 func(int*)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，使用 <code>nullptr</code> 可以明确地调用接受指针参数的重载函数版本，避免了潜在的歧义。</p><p>通过引入<code>nullptr</code>，C++11 提高了代码的类型安全性和清晰度，明确区分了整数 0 和空指针的概念。</p><h3 id="长长整形（Long-Long-Int）"><a href="#长长整形（Long-Long-Int）" class="headerlink" title="长长整形（Long Long Int）"></a>长长整形（Long Long Int）</h3><p>在 C++11 之前，整型的最大大小受限于long int，其大小至少为32位。为了支持更大的整数，C++11引入了<code>long long int</code>和<code>unsigned long long int</code>类型，保证至少64位的大小。</p><h4 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="type">int</span> bigNumber = <span class="number">9223372036854775807LL</span>; <span class="comment">// LL 表示这是一个 long long 类型的字面量</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> bigUnsignedNumber = <span class="number">18446744073709551615ULL</span>; <span class="comment">// ULL 表示这是一个 unsigned long long 类型的字面量</span></span><br></pre></td></tr></table></figure><h3 id="无符号字面量"><a href="#无符号字面量" class="headerlink" title="无符号字面量"></a>无符号字面量</h3><p>无符号字面量就是用来表示无符号整数的字面量。在C++中，可以通过在整数后面添加<code>U</code>或<code>u</code>来创建无符号整型字面量。</p><p><strong>注意</strong>：字面量（Literal）是指在源代码中直接表示其值的固定值的表示法。字面量可以是数字、字符、字符串或其他固定值。</p><h4 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> x = <span class="number">123U</span>; <span class="comment">// U 表示无符号整数</span></span><br></pre></td></tr></table></figure><h3 id="用户自定义字面量"><a href="#用户自定义字面量" class="headerlink" title="用户自定义字面量"></a>用户自定义字面量</h3><p>C++11引入了用户自定义字面量（User-Defined Literals, UDL），允许开发者定义自己的字面量操作符，为字面量赋予新的含义。这通过定义一个以<code>_</code>开头的字面量操作符函数实现。</p><h4 id="语法：-1"><a href="#语法：-1" class="headerlink" title="语法："></a>语法：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return_type operator <span class="string">&quot;&quot;</span> _customSuffix(<span class="type">const</span> <span class="type">char</span>*);</span><br></pre></td></tr></table></figure><h4 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h4><p>定义一个将字符串转换为复数的自定义字面量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;complex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义自定义字面量 _i，用于创建复数</span></span><br><span class="line"><span class="built_in">std</span>::<span class="type">complex</span>&lt;<span class="type">double</span>&gt; operator<span class="string">&quot;&quot;</span> _i(<span class="type">long</span> <span class="type">double</span> d) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::<span class="type">complex</span>&lt;<span class="type">double</span>&gt;(<span class="number">0</span>, d); <span class="comment">// 第一个参数表示所构造复数的实部，第二个参数代表虚部。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">auto</span> c = <span class="number">3.14</span>_i; <span class="comment">// 使用自定义字面量创建一个复数，将会调用operator&quot;&quot; _i 函数</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Real part: &quot;</span> &lt;&lt; c.real() &lt;&lt; <span class="string">&quot;, Imaginary part: &quot;</span> &lt;&lt; c.imag() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>_i</code>是自定义的字面量操作符，它将跟随它的数字转换为一个复数。这使得代码更加直观和易于理解。</p><h3 id="强类型枚举-enum-class"><a href="#强类型枚举-enum-class" class="headerlink" title="强类型枚举 (enum class)"></a>强类型枚举 (enum class)</h3><p>C++11 引入了强类型枚举，也称为作用域枚举（scoped enums），使用 <code>enum class </code>关键字定义。与传统的枚举（unscoped enums）相比，强类型枚举具有更好的类型安全性，不会隐式地转换为整型，枚举值必须在作用域内访问，并且可以指定底层类型。</p><h4 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">EnumName</span> :</span> UnderlyingType &#123;</span><br><span class="line">    enumerator1,</span><br><span class="line">    enumerator2,</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>EnumName</strong> 是枚举类型的名称。</li><li><strong>UnderlyingType</strong> 是用来表示枚举值的底层类型，通常是某种整型（如int、unsigned int、short等）。如果没有该字段，则底层类型默认为 int</li></ul><h4 id="强类型枚举定义"><a href="#强类型枚举定义" class="headerlink" title="强类型枚举定义"></a>强类型枚举定义</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">Color</span> :</span> <span class="type">unsigned</span> <span class="type">int</span> &#123;</span><br><span class="line">    Red,</span><br><span class="line">    Green,</span><br><span class="line">    Blue</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">StatusCode</span> :</span> <span class="type">char</span> &#123;</span><br><span class="line">    Ok = <span class="string">&#x27;O&#x27;</span>,</span><br><span class="line">    Error = <span class="string">&#x27;E&#x27;</span>,</span><br><span class="line">    Unknown = <span class="string">&#x27;U&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="简单例子"><a href="#简单例子" class="headerlink" title="简单例子"></a>简单例子</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 传统枚举</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span> &#123;</span> Red, Green, Blue &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 强类型枚举  底层类型为 int</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">StrongColor</span> &#123;</span> Red, Green, Blue &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Color c = Red; <span class="comment">// 直接访问</span></span><br><span class="line">    <span class="comment">// StrongColor sc = Red; // 错误：Red 不在作用域内</span></span><br><span class="line">    StrongColor sc = StrongColor::Red; <span class="comment">// 正确：使用作用域访问</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// int colorInt = sc; // 错误：不能隐式转换为整型</span></span><br><span class="line">    <span class="type">int</span> colorInt = static_cast&lt;<span class="type">int</span>&gt;(sc); <span class="comment">// 正确：需要显式转换</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; colorInt &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出：0，假设 StrongColor::Red 底层对应的整数值为 0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，强类型枚举 StrongColor 的使用增加了类型安全性，避免了与整型之间的隐式转换，并且强制使用枚举类名作为作用域来访问枚举值。这些特性有助于避免命名冲突和提高代码清晰度。</p><h3 id="常量表达式-constexpr"><a href="#常量表达式-constexpr" class="headerlink" title="常量表达式 (constexpr)"></a>常量表达式 (constexpr)</h3><p>C++11 引入了 <code>constexpr</code> 关键字，用于定义常量表达式。这个关键字可以用于变量、函数和构造函数，允许在编译时进行计算，而不是运行时。这对于提高程序的性能非常有用，因为它允许在编译期间执行更多的计算，减少运行时的工作量。</p><h4 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h4><p><strong>定义常量表达式变量</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// type 变量类型</span></span><br><span class="line">constexpr type variable = value;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义常量</span></span><br><span class="line">constexpr <span class="type">int</span> max_size = <span class="number">100</span>; </span><br></pre></td></tr></table></figure><p><strong>定义常量表达式函数</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// type 函数的返回值类型</span></span><br><span class="line">constexpr type <span class="title function_">function_name</span><span class="params">(parameters)</span> &#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">定义常量表达式函数：</span><br><span class="line">constexpr <span class="type">int</span> <span class="title function_">square</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>常量表达式函数必须返回一个常量表达式，函数体中只能有一条返回语句，且不能包含任何形式的循环、分支（除了条件运算符）等。</p><p><strong>声明类构造函数</strong>：允许类类型在编译时被初始化。构造函数体必须为空，所有成员初始化都必须使用常量表达式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    constexpr <span class="title function_">Point</span><span class="params">(<span class="type">double</span> xVal = <span class="number">0</span>, <span class="type">double</span> yVal = <span class="number">0</span>)</span> : <span class="title function_">x</span><span class="params">(xVal)</span>, <span class="title function_">y</span><span class="params">(yVal)</span> &#123;&#125;</span><br><span class="line">    constexpr <span class="type">double</span> <span class="title function_">getX</span><span class="params">()</span> <span class="type">const</span> &#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">    constexpr <span class="type">double</span> <span class="title function_">getY</span><span class="params">()</span> <span class="type">const</span> &#123; <span class="keyword">return</span> y; &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    <span class="type">double</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  constexpr Point <span class="title function_">p</span><span class="params">(<span class="number">9.0</span>, <span class="number">27.0</span>)</span>;</span><br><span class="line">  constexpr <span class="type">double</span> x = p.getX(); <span class="comment">// 在编译时计算</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用-constexpr-的优点包括："><a href="#使用-constexpr-的优点包括：" class="headerlink" title="使用 constexpr 的优点包括："></a>使用 constexpr 的优点包括：</h4><ul><li><strong>性能提升</strong>：通过在编译时而不是运行时计算值，可以提高程序的运行效率。</li><li><strong>类型安全</strong>：与宏相比，<code>constexpr</code> 提供了更强的类型安全。</li><li><strong>更广泛的用途</strong>：<code>constexpr</code> 变量、函数和对象可以用在需要编译时常量的上下文中，如数组大小、模板参数等。</li></ul><h3 id="默认和删除函数"><a href="#默认和删除函数" class="headerlink" title="默认和删除函数"></a>默认和删除函数</h3><p>C++11引入了两个重要的特性：允许显式地声明默认构造函数和析构函数，以及允许删除函数。这些特性提供了对类行为更细致的控制，特别是在管理资源、实现单例模式或防止对象拷贝时非常有用。</p><h4 id="默认函数（-default）"><a href="#默认函数（-default）" class="headerlink" title="默认函数（&#x3D; default）"></a>默认函数（&#x3D; default）</h4><p>在C++11之前，如果你希望类有一个默认的构造函数、拷贝构造函数、拷贝赋值运算符或析构函数，你通常不需要做任何事情；编译器会为你自动生成这些。然而，一旦你定义了任何构造函数，编译器就不会自动生成默认构造函数了。C++11通过<code>= default</code>关键字允许你显式地要求编译器为你生成这些函数，即使你已经定义了其他构造函数。</p><p><strong>语法</strong>: </p><p><strong>使用关键字 <code>= default</code> 来声明</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    ClassName() = <span class="keyword">default</span>; <span class="comment">// 默认构造函数</span></span><br><span class="line">    ClassName(<span class="type">const</span> ClassName&amp;) = <span class="keyword">default</span>; <span class="comment">// 默认拷贝构造函数</span></span><br><span class="line">    ClassName&amp; operator=(<span class="type">const</span> ClassName&amp;) = <span class="keyword">default</span>; <span class="comment">// 默认拷贝赋值运算符</span></span><br><span class="line">    ~ClassName() = <span class="keyword">default</span>; <span class="comment">// 默认析构函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>代码示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    MyClass() = <span class="keyword">default</span>; <span class="comment">// 显式声明使用编译器生成的默认构造函数</span></span><br><span class="line">    MyClass(<span class="type">int</span> value) : data(value) &#123;&#125; <span class="comment">// 自定义构造函数</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">private:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="删除函数（-delete）"><a href="#删除函数（-delete）" class="headerlink" title="删除函数（&#x3D; delete）"></a>删除函数（&#x3D; delete）</h4><p>C++11允许你显式地禁用类的某些函数（比如拷贝构造函数或拷贝赋值运算符），只需将它们声明为<code>= delete</code>。这对于防止对象被无意拷贝或赋值非常有用，尤其在设计只能移动不能拷贝的资源管理类时。</p><p><strong>语法</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    ClassName(<span class="type">const</span> ClassName&amp;) = delete; <span class="comment">// 禁用拷贝构造函数</span></span><br><span class="line">    ClassName&amp; operator=(<span class="type">const</span> ClassName&amp;) = delete; <span class="comment">// 禁用拷贝赋值运算符</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>代码示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NonCopyable</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    NonCopyable() = <span class="keyword">default</span>;</span><br><span class="line">    NonCopyable(<span class="type">const</span> NonCopyable&amp;) = delete; <span class="comment">// 禁止拷贝</span></span><br><span class="line">    NonCopyable&amp; operator=(<span class="type">const</span> NonCopyable&amp;) = delete; <span class="comment">// 禁止赋值</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结:"></a>总结:</h4><p><code>= default</code>和<code>= delete</code>是C++11中引入的两个关键特性，它们提供了对类默认行为的显式控制。通过<code>= default</code>，你可以明确地告诉编译器为类生成默认的构造函数、析构函数或拷贝&#x2F;赋值运算符，即使定义了其他构造函数。通过<code>= delete</code>，你可以防止类的拷贝或赋值，这在设计不可拷贝的资源管理类或单例类时特别有用。这两个特性让类的设计意图更加清晰，同时也有助于避免潜在的错误。</p><h3 id="委托构造函数"><a href="#委托构造函数" class="headerlink" title="委托构造函数"></a>委托构造函数</h3><p>在 C++11 中，委托构造函数（Delegating Constructors）是一种允许一个构造函数在同一个类中调用另一个构造函数的功能，目的是为了减少代码重复，提高代码复用性。这允许构造函数之间的代码共享，从而避免在每个构造函数中重复相同的初始化代码。</p><h4 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h4><p>委托构造函数的语法相当直接，就是在构造函数的初始化列表中调用同一个类的另一个构造函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    ClassName(参数列表) : ClassName(其他参数列表) &#123;</span><br><span class="line">        <span class="comment">// 构造函数体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里，构造函数通过在其初始化列表中调用另一个构造函数（即委托给另一个构造函数），实现对对象的初始化。</p><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><p>考虑一个简单的 Rectangle 类，它有两个成员变量：长度和宽度。我们可以使用委托构造函数来确保所有的构造逻辑都通过一个主要的构造函数来执行，避免代码的重复。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="comment">// 主构造函数</span></span><br><span class="line">    Rectangle(<span class="type">double</span> width, <span class="type">double</span> height) : width(width), height(height) &#123;</span><br><span class="line">        <span class="comment">// 这里可以包含一些特定的初始化逻辑</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Rectangle(double, double)&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 委托构造函数，委托给主构造函数</span></span><br><span class="line">    Rectangle(<span class="type">double</span> side) : Rectangle(side, side) &#123;</span><br><span class="line">        <span class="comment">// 注意：这里的初始化逻辑会在主构造函数之后执行</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Rectangle(double)&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">area</span><span class="params">()</span> <span class="type">const</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Area: &quot;</span> &lt;&lt; width * height &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    <span class="type">double</span> width, height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Rectangle <span class="title function_">square</span><span class="params">(<span class="number">5</span>)</span>; <span class="comment">// 使用委托构造函数</span></span><br><span class="line">    square.area(); <span class="comment">// 输出: Area: 25</span></span><br><span class="line">    </span><br><span class="line">    Rectangle <span class="title function_">rectangle</span><span class="params">(<span class="number">4</span>, <span class="number">5</span>)</span>; <span class="comment">// 使用主构造函数</span></span><br><span class="line">    rectangle.area(); <span class="comment">// 输出: Area: 20</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，Rectangle类有三个构造函数：</p><ul><li>一个是接受两个参数（宽度和高度）的主构造函数。</li><li>另外两个是委托构造函数，一个不带参数，默认构造一个宽度和高度都为0的矩形；另一个只带一个参数，构造一个正方形。</li></ul><p>这样的设计让构造函数的初始化逻辑更加集中，如果需要修改初始化逻辑，只需要修改主构造函数即可，提高了代码的可维护性。</p><h3 id="继承构造函数"><a href="#继承构造函数" class="headerlink" title="继承构造函数"></a>继承构造函数</h3><p>在C++11中，引入了<strong>继承构造函数</strong>的概念，这允许派生类继承并直接使用基类的构造函数，而不需要在派生类中重新定义相同的构造函数。这个特性通过简化代码，避免不必要的重复，提高了代码的可维护性。</p><h4 id="语法-6"><a href="#语法-6" class="headerlink" title="语法"></a>语法</h4><p>要在派生类中继承基类的构造函数，你可以使用<code>using</code> 声明。基本语法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> public Base &#123;</span><br><span class="line">public:</span><br><span class="line">    using Base::Base;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里，Derived 类通过 <code>using Base::Base;</code>声明，继承了 Base 类所有的构造函数。</p><h4 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h4><p>考虑以下基类Person，它有一个构造函数，接受一个表示人名的字符串参数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    Person(<span class="built_in">std</span>::<span class="built_in">string</span> n) : name(n) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Person(&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在，我们定义一个 Employee 类，它是 Person 的派生类，并且我们想让 Employee 类能够直接使用 Person 类的构造函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> :</span> public Person &#123;</span><br><span class="line">public:</span><br><span class="line">    using Person::Person; <span class="comment">// 继承构造函数</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">printName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Employee Name: &quot;</span> &lt;&lt; name &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接着，我们可以这样使用 Employee 类：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Employee <span class="title function_">emp</span><span class="params">(<span class="string">&quot;John Doe&quot;</span>)</span>;</span><br><span class="line">    emp.printName(); <span class="comment">// 输出：Employee Name: John Doe</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，Employee 类继承了 Person 类的构造函数，所以我们可以直接使用一个字符串参数来构造 Employee 对象。这就避免了在 Employee 类中重新定义一个接受相同参数的构造函数。</p><h3 id="显式虚函数重载-override"><a href="#显式虚函数重载-override" class="headerlink" title="显式虚函数重载(override)"></a>显式虚函数重载(override)</h3><p>C++11引入了一种新的方式来控制虚函数的重载，称为“显式虚函数重载”(Explicit Virtual Function Override)。这通过在派生类中的成员函数声明时使用<code>override</code>关键字实现。这个关键字明确指出一个成员函数意图重写一个基类的虚函数。使用<code>override</code>可以提高代码的可读性，并且帮助编译器检查派生类是否真正重载了基类中的虚函数，避免因拼写错误或函数签名不匹配而导致的问题。</p><h4 id="语法：-2"><a href="#语法：-2" class="headerlink" title="语法："></a>语法：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    virtual <span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> public Base &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">func</span><span class="params">()</span> override; <span class="comment">// 明确指明重载基类的虚函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    virtual <span class="type">void</span> <span class="title function_">sayHello</span><span class="params">()</span>  &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hello from Base&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> public Base &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">sayHello</span><span class="params">()</span>  override &#123; <span class="comment">// 正确重载 Base 的 sayHello</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hello from Derived&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Base* base = new Derived();</span><br><span class="line">    base-&gt;sayHello(); <span class="comment">// 输出: Hello from Derived</span></span><br><span class="line">    delete base;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，Derived 类通过 <code>override</code> 关键字明确表示 sayHello 函数重写了 Base 类中的虚函数。如果签名不匹配，编译器将报错。</p><h3 id="final-关键字"><a href="#final-关键字" class="headerlink" title="final 关键字"></a>final 关键字</h3><p>在C++11中，<code>final</code>关键字被引入作为类和虚函数的新修饰符。当<code>final</code>用于类时，它阻止该类被继承。当用于虚函数时，它阻止该函数在派生类中被进一步重写。这提供了一种明确表达设计意图的方式，并能够避免不必要的运行时错误。</p><h4 id="用于类"><a href="#用于类" class="headerlink" title="用于类"></a>用于类</h4><p>当 <code>final</code> 用于一个类时，任何尝试继承该类的行为都将导致编译错误。</p><p><strong>语法</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> <span class="keyword">final</span> &#123;</span> </span><br><span class="line">  <span class="comment">/* 类定义实现 */</span>  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>代码示例</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> <span class="keyword">final</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> public Base &#123; <span class="comment">// 这将导致编译错误</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个示例中，尝试从 Base 类派生 Derived 类会导致编译错误，因为 Base 类被标记为 final。</p><h4 id="用于虚函数"><a href="#用于虚函数" class="headerlink" title="用于虚函数"></a>用于虚函数</h4><p>当 <code>final</code> 用于虚函数时，它表示该函数不能在任何派生类中被重写。</p><p><strong>语法</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virtual <span class="type">void</span> <span class="title function_">function</span><span class="params">()</span> final;</span><br></pre></td></tr></table></figure><p><strong>示例</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    virtual <span class="type">void</span> <span class="title function_">show</span><span class="params">()</span> final &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base show&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> public Base &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">show</span><span class="params">()</span> override &#123; <span class="comment">// 这将导致编译错误</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Derived show&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个示例中，Derived 类尝试重写 Base 类中的 show 函数会导致编译错误，因为 show 函数在 Base 类中被标记为 final。</p><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景:"></a>使用场景:</h4><p>final关键字的使用场景主要包括：</p><ul><li><strong>性能优化</strong>：防止类的继承或虚函数的重写可以让编译器进行更多的优化，因为编译器知道没有更多的派生类或重写的函数需要考虑。</li><li><strong>设计安全</strong>：当你的设计不希望或不需要继承或重写时，使用final可以防止其他开发者不小心破坏你的设计意图。</li></ul><p>final关键字的引入增强了C++的类型安全性和性能优化能力，同时也提供了更明确的类设计意图表达方式。</p><h3 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h3><p>C++11 引入了 Lambda 表达式，为 C++ 程序员提供了一种方便的匿名函数对象创建方式。Lambda 表达式广泛用于简化代码，尤其是在需要小段函数逻辑作为参数传递给算法或线程时。</p><h4 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h4><p><strong>Lambda 表达式的基本语法如下</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[ capture ] ( parameters ) -&gt; return_type &#123;</span><br><span class="line">    <span class="comment">// Function body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>capture</strong>：捕获列表，定义了 Lambda 函数体外部变量的访问方式。可以是值捕获、引用捕获或隐式捕获等。</li><li><strong>parameters</strong>：参数列表，与普通函数的参数列表相同。可以为空。</li><li><strong>return_type</strong>：返回类型，可以省略，编译器会自动推导返回类型。</li><li><strong>Function body</strong>：函数体，包含了 Lambda 表达式的逻辑。</li></ul><p><strong>示例</strong>:</p><p><strong>1. 基本Lambda表达式</strong></p><p>不带参数，自动推导返回类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> greet = []() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hello, World!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;;</span><br><span class="line">greet();  <span class="comment">// 调用Lambda表达式</span></span><br></pre></td></tr></table></figure><p><strong>2. 带参数的Lambda表达式</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> add = [](<span class="type">int</span> x, <span class="type">int</span> y) &#123; <span class="keyword">return</span> x + y; &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;3 + 4 = &quot;</span> &lt;&lt; add(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p><strong>3. 指定返回类型的Lambda表达式</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> divide = [](<span class="type">double</span> x, <span class="type">double</span> y) -&gt; <span class="type">double</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (y == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 防止除以0</span></span><br><span class="line">    <span class="keyword">return</span> x / y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;5.0 / 2.0 = &quot;</span> &lt;&lt; divide(<span class="number">5.0</span>, <span class="number">2.0</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p><strong>4. 捕获外部变量</strong></p><p>值捕获：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">4</span>;</span><br><span class="line"><span class="comment">// [x] 以值的方式捕获变量x</span></span><br><span class="line"><span class="keyword">auto</span> square = [x]() &#123; <span class="keyword">return</span> x * x; &#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Square of 4 is &quot;</span> &lt;&lt; square() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>引用捕获：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::for_each(numbers.begin(), numbers.end(), [&amp;total](<span class="type">int</span> x) &#123;</span><br><span class="line">    total += x;  <span class="comment">// &#x27;total&#x27;通过引用捕获，可以修改其值</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Total: &quot;</span> &lt;&lt; total &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p><strong>5. 捕获所有外部变量</strong></p><p>使用<code>[=]</code>捕获所有外部变量（通过值），使用<code>[&amp;]</code>捕获所有外部变量（通过引用）。</p><p><strong>总结</strong>:</p><p>Lambda表达式是C++11中引入的强大特性，它提供了一种便捷的方式来定义和使用匿名函数。通过捕获列表，Lambda表达式可以捕获并使用定义它们的作用域中的变量。Lambda表达式广泛应用于标准库算法、异步编程和事件处理等场景。</p><h3 id="尾返回类型"><a href="#尾返回类型" class="headerlink" title="尾返回类型"></a>尾返回类型</h3><p>C++11引入了尾返回类型（Trailing Return Type）的概念，允许开发者将函数的返回类型声明在函数参数列表之后。这在某些情况下，尤其是当返回类型依赖于函数参数类型的时候，变得非常有用。使用尾返回类型，你可以利用<code>auto</code>关键字和<code>-&gt;</code>运算符来指定返回类型。</p><h4 id="尾返回类型的基本语法"><a href="#尾返回类型的基本语法" class="headerlink" title="尾返回类型的基本语法"></a>尾返回类型的基本语法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> <span class="title function_">functionName</span><span class="params">(parameters)</span> -&gt; returnType;</span><br></pre></td></tr></table></figure><p>这里，<code>returnType</code>是一个类型表达式，它描述了函数的返回类型，并且它可以使用函数参数。</p><h4 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码:"></a>示例代码:</h4><p><strong>简单示例</strong>:</p><p>在最简单的形式中，尾返回类型让函数的声明更清晰：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> -&gt; <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管在这个简单例子中使用尾返回类型可能看起来没有必要，它展示了基本的语法结构。</p><p><strong>依赖于模板参数的返回类型</strong>:</p><p>尾返回类型特别有用于模板编程中，当函数的返回类型依赖于其模板参数时：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T, typename U&gt;</span><br><span class="line"><span class="keyword">auto</span> <span class="title function_">add</span><span class="params">(T x, U y)</span> -&gt; <span class="title function_">decltype</span><span class="params">(x + y)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，add 函数的返回类型是 T 和 U 类型相加的结果类型。使用 decltype 关键字和尾返回类型，我们可以精确地指定这个返回类型。</p><p><strong>使用于lambda表达式</strong>:</p><p>尾返回类型同样适用于C++11中的 lambda 表达式，允许在更复杂的场景下指定返回类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> getLambda = []() -&gt; <span class="built_in">std</span>::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> [](<span class="type">int</span> x, <span class="type">int</span> y) -&gt; <span class="type">int</span> &#123; <span class="keyword">return</span> x + y; &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个例子中，getLambda是一个返回类型为std::function&lt;int(int, int)&gt;的 lambda 表达式，它本身返回另一个计算两个整数和的 lambda 表达式。</p><p><strong>为什么需要尾返回类型</strong>?</p><p>在C++11之前，函数的返回类型必须在函数名之前声明，这在大多数情况下工作得很好。然而，对于返回类型依赖于函数参数的情况（特别是模板编程中），这种方法就显得力不从心了。尾返回类型提供了一种灵活的方式来声明这些依赖于参数的返回类型，使得函数签名更加清晰和灵活。</p><p>尾返回类型是现代C++（C++11及以后版本）中推荐的一种高级特性，它在编写泛型代码和lambda表达式时特别有用。通过这种方式，C++程序员可以编写出更清晰、更灵活、更安全的代码。</p><h3 id="内联命名空间（Inline-Namespaces）"><a href="#内联命名空间（Inline-Namespaces）" class="headerlink" title="内联命名空间（Inline Namespaces）"></a>内联命名空间（Inline Namespaces）</h3><p>C++11引入了内联命名空间（Inline Namespaces）的概念，这是一种特殊的命名空间，其成员在外层命名空间中也可以直接访问，无需通过内联命名空间的名称。这个特性主要用于版本控制和兼容性，允许库开发者在不破坏现有代码基础上引入新版本的API。</p><h4 id="语法-7"><a href="#语法-7" class="headerlink" title="语法"></a>语法</h4><p>使用<code>inline</code>关键字来定义内联命名空间：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">namespace outer &#123;</span><br><span class="line">    <span class="keyword">inline</span> namespace inner &#123;</span><br><span class="line">        <span class="comment">// void func() &#123;&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，inner是一个内联命名空间，outer是它的外层命名空间。由于inner被声明为内联的，所以outer命名空间中的代码可以直接访问 inner 中的成员，无需显式地通过 inner 命名空间的名称。</p><h4 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a>代码示例</h4><p>假设我们有一个库，该库提供了一个函数 foo。随着时间的推移，库的版本更新，我们添加了一个新的实现，但我们想保持对旧版本的兼容。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">namespace Library &#123;</span><br><span class="line">    <span class="comment">// 旧版本</span></span><br><span class="line">    namespace Version1 &#123;</span><br><span class="line">        <span class="type">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Version 1 of foo\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新版本</span></span><br><span class="line">    <span class="keyword">inline</span> namespace Version2 &#123;</span><br><span class="line">        <span class="type">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Version 2 of foo\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Library::foo(); <span class="comment">// 直接访问最新版本</span></span><br><span class="line">    Library::Version1::foo(); <span class="comment">// 显式访问旧版本</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，Version2 是一个内联命名空间。当我们调用 Library::foo() 时，由于 Version2 是内联的，编译器会直接在 Library 的内联命名空间中查找 foo 函数，因此调用的是 Version2 中的 foo。如果需要显式调用旧版本的 foo 函数，可以通过完整的命名空间路径 Library::Version1::foo() 来实现。</p><h4 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h4><p>内联命名空间的一个典型应用场景是库版本管理。通过将最新版本的定义放在内联命名空间中，库的用户可以不做任何修改地自动使用最新版本的功能。同时，如果需要引用特定版本的定义，也可以通过指定命名空间的名称来实现。</p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项:"></a>注意事项:</h4><ul><li>一个命名空间内只能有一个内联命名空间是活跃的，也就是说，如果有多个内联命名空间，只有最后一个声明为内联的命名空间才会被视为活跃的。</li><li>内联命名空间主要用于版本控制和向后兼容性，不推荐在日常编程中过度使用。</li></ul><p>内联命名空间提供了一种优雅的方式来处理库和应用程序在不同版本间的平滑过渡和兼容性问题，是 C++11 中对库设计者非常有用的一个特性。</p><h3 id="静态断言（static-assert）"><a href="#静态断言（static-assert）" class="headerlink" title="静态断言（static_assert）"></a>静态断言（static_assert）</h3><p>C++11 引入了<strong>静态断言（static_assert）</strong>，这是一种在编译时进行断言检查的机制。静态断言让开发者能够在编译期间检查表达式是否为真，如果表达式结果为假，则编译器会产生一个编译错误并显示开发者提供的消息。这个特性特别适合用于检查模板参数、常量表达式、等编译时信息，以确保代码的正确性和类型安全。</p><h4 id="语法-8"><a href="#语法-8" class="headerlink" title="语法"></a>语法</h4><p>static_assert 的基本语法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static_assert</span>(常量表达式, 错误消息);</span><br></pre></td></tr></table></figure><ul><li><strong>常量表达式</strong>：需要在编译时求值的表达式，结果为布尔值。如果表达式的结果为 false，则编译器会产生一个错误。</li><li><strong>错误消息</strong>：这是一个字符串字面量，用于在常量表达式的求值结果为 false 时提供错误信息。</li></ul><h4 id="示例代码-3"><a href="#示例代码-3" class="headerlink" title="示例代码:"></a>示例代码:</h4><p><strong>检查类型大小</strong> : 使用 <code>static_assert</code> 来确保特定类型的大小符合预期：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static_assert</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) == <span class="number">4</span>, <span class="string">&quot;int类型必须是4字节大小&quot;</span>);</span><br></pre></td></tr></table></figure><p>这个static_assert会检查 int 类型是否是4字节（32位）大小。如果在某些平台上 int 不是4字节大小，编译器将会报错。</p><p><strong>模板参数约束</strong>:<br>在模板编程中，static_assert 可以用来约束模板参数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> &#123;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    std::is_arithmetic&lt;T&gt;::value 用于在编译时检查一个类型是否为算术类型（即整数类型和浮点类型）。</span></span><br><span class="line"><span class="comment">    如果类型是算术类型，std::is_arithmetic&lt;T&gt;::value会是true，否则是false。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">static_assert</span>(<span class="built_in">std</span>::is_arithmetic&lt;T&gt;::value, <span class="string">&quot;MyArray只能用于算术类型&quot;</span>);</span><br><span class="line">    <span class="comment">// 类实现...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个例子中，static_assert用来确保MyArray模板只能用于算术类型（如int、float等）。如果尝试用非算术类型实例化MyArray，编译器将报错。</p><p><strong>验证编译时条件</strong>:<br>static_assert 也可以用于验证其他编译时能够确定的条件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">constexpr <span class="type">int</span> <span class="title function_">getNumber</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="number">5</span>; &#125;</span><br><span class="line"><span class="keyword">static_assert</span>(getNumber() == <span class="number">5</span>, <span class="string">&quot;函数getNumber必须返回5&quot;</span>);</span><br></pre></td></tr></table></figure><p>这里，static_assert验证getNumber函数是否总是返回5。由于getNumber被声明为constexpr，它的返回值可以在编译时确定，因此适合用于static_assert。</p><h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><p>C++11引入了<code>右值引用</code>，这是一个指向临时对象（即右值）的引用，允许开发者安全地从临时对象中移动数据，而不仅仅是复制。这个特性是实现<code>移动语义</code>（Move Semantics）和<code>完美转发</code>（Perfect Forwarding）的基础，对于提高程序性能尤其在涉及大量数据操作时非常关键。</p><h4 id="语法-9"><a href="#语法-9" class="headerlink" title="语法:"></a>语法:</h4><p>右值引用使用<code>&amp;&amp;</code>符号来声明。与左值引用（使用<code>&amp;</code>）不同，右值引用绑定到临时对象上。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Type&amp;&amp; name = expression;</span><br></pre></td></tr></table></figure><ul><li><strong>Type</strong>：变量的类型。</li><li><strong>name</strong>：变量的名称。</li><li><strong>expression</strong>：必须是一个右值表达式，通常是一个临时对象或者是通过<code>std::move</code>转换的。</li></ul><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><p><strong>简单的右值引用示例</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp;&amp; rref = <span class="number">5</span>; <span class="comment">// 5 是一个整数字面量，是右值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 std::move 转换左值为右值引用</span></span><br><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp;&amp; moved_x = <span class="built_in">std</span>::move(x);</span><br></pre></td></tr></table></figure><p>右值引用主要用于实现<code>移动语义和完美转发</code>。</p><h3 id="移动语义（Move-Semantics）"><a href="#移动语义（Move-Semantics）" class="headerlink" title="移动语义（Move Semantics）"></a>移动语义（Move Semantics）</h3><p>移动语义是 C++11 引入的一项重要特性，它允许资源（如动态分配的内存）在对象之间转移，而不是复制。这一特性显著提高了性能，尤其是在处理大型数据对象时，因为它避免了不必要的复制操作。移动语义主要通过两个新的构造函数实现：<strong>移动构造函数和移动赋值操作符</strong>，它们都使用了右值引用这一特性。</p><h4 id="移动构造函数"><a href="#移动构造函数" class="headerlink" title="移动构造函数"></a>移动构造函数</h4><p>移动构造函数允许从一个即将被销毁的对象中“窃取”资源。它的参数是该对象类型的右值引用。</p><p><strong>语法</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ClassName 表示类名</span></span><br><span class="line">ClassName(ClassName&amp;&amp; other) ;</span><br></pre></td></tr></table></figure><h4 id="移动赋值操作符"><a href="#移动赋值操作符" class="headerlink" title="移动赋值操作符"></a>移动赋值操作符</h4><p>移动赋值操作符允许将一个即将被销毁的对象的资源赋值给另一个对象。它的参数也是该对象类型的右值引用。</p><p><strong>语法</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassName&amp; operator=(ClassName&amp;&amp; other) ;</span><br></pre></td></tr></table></figure><h4 id="示例代码-4"><a href="#示例代码-4" class="headerlink" title="示例代码"></a>示例代码</h4><p>假设有一个简单的 Buffer 类，它管理一块动态分配的内存：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Buffer</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    Buffer(<span class="type">size_t</span> size) : size(size), data(new <span class="type">int</span>[size]) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 移动构造函数</span></span><br><span class="line">    Buffer(Buffer&amp;&amp; other) noexcept : size(other.size), data(other.data) &#123;</span><br><span class="line">        other.data = nullptr; <span class="comment">// 防止析构时释放内存</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 移动赋值操作符</span></span><br><span class="line">    Buffer&amp; operator=(Buffer&amp;&amp; other) noexcept &#123;</span><br><span class="line">        <span class="keyword">if</span> (this != &amp;other) &#123;</span><br><span class="line">            delete[] data; <span class="comment">// 释放原来的资源</span></span><br><span class="line">            data = other.data; <span class="comment">// 窃取资源</span></span><br><span class="line">            size = other.size;</span><br><span class="line">            other.data = nullptr; <span class="comment">// 防止析构时释放内存</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *this;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~Buffer() &#123; delete[] data; &#125;</span><br><span class="line">    </span><br><span class="line">private:</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">    <span class="type">int</span>* data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个例子中，Buffer 类定义了一个移动构造函数和一个移动赋值操作符。当一个 Buffer 对象通过移动构造函数或移动赋值操作符与另一个 Buffer 对象交互时，它实际上是从源对象窃取了资源（这里是指针 data），而不是复制资源。这样可以避免不必要的复制开销，并提高性能。</p><h4 id="使用-std-move-触发移动语义"><a href="#使用-std-move-触发移动语义" class="headerlink" title="使用 std::move 触发移动语义:"></a>使用 std::move 触发移动语义:</h4><p>要触发移动操作，通常需要使用 <code>std::move</code> 函数将对象显式转换为<code>右值引用</code>，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Buffer <span class="title function_">buffer1</span><span class="params">(<span class="number">1024</span>)</span>; <span class="comment">// 创建一个Buffer对象</span></span><br><span class="line">Buffer <span class="title function_">buffer2</span><span class="params">(<span class="built_in">std</span>::move(buffer1))</span>; <span class="comment">// 使用移动构造函数</span></span><br></pre></td></tr></table></figure><p>在这个示例中，std::move(buffer1) 将 buffer1 转换为右值引用，从而允许使用移动构造函数来初始化 buffer2。这意味着 buffer1 的资源被转移到了 buffer2，并且 buffer1 不再拥有这些资源。</p><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p>移动语义通过引入移动构造函数和移动赋值操作符，以及配合右值引用，为 C++ 提供了一种高效的资源管理方式。这改善了 C++ 程序的性能，特别是在涉及到大量数据处理的场景中。通过减少不必要的数据复制，移动语义使得资源的转移变得更加高效和直接。</p><h3 id="完美转发（Perfect-Forwarding）"><a href="#完美转发（Perfect-Forwarding）" class="headerlink" title="完美转发（Perfect Forwarding）"></a>完美转发（Perfect Forwarding）</h3><p>C++11 引入的完美转发是一种技术，允许函数将其接收到的参数以完全不变的形式转发给另一个函数。这意味着参数的左值、右值特性和类型都被保持不变。完美转发非常有用，尤其是在<strong>模板编程和泛型编程</strong>中，它可以帮助我们编写能够接受任意参数并将其正确转发的代码。</p><h4 id="使用-std-forward"><a href="#使用-std-forward" class="headerlink" title="使用 std::forward"></a>使用 std::forward</h4><p>完美转发通常通过 <code>std::forward</code> 实现，它允许你根据模板参数的类型来保持参数的左值或右值特性。</p><p><strong>语法</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line"><span class="type">void</span> <span class="title function_">wrapper</span><span class="params">(T&amp;&amp; arg)</span> &#123;</span><br><span class="line">    <span class="comment">// 使用 std::forward&lt;T&gt; 来完美转发 arg</span></span><br><span class="line">    callee(<span class="built_in">std</span>::forward&lt;T&gt;(arg));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>T&amp;&amp;</code> 表示一个通用引用（universal reference），它可以绑定到左值或右值。</li><li><code>std::forward&lt;T&gt;(arg)</code> 负责保持 arg 的原始类型，确保参数 arg 的值类别（左值或右值）被保持不变地转发。</li></ul><p><strong>示例代码</strong>:</p><p>假设我们有以下 callee 函数，它有两个重载，分别处理左值和右值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">callee</span><span class="params">(<span class="type">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; arg)</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;callee called with a left value: &quot;</span> &lt;&lt; arg &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">callee</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>&amp;&amp; arg)</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;callee called with a right value: &quot;</span> &lt;&lt; arg &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们使用完美转发来实现 wrapper 函数，它可以将其接收到的参数以原样转发给 callee：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line"><span class="type">void</span> <span class="title function_">wrapper</span><span class="params">(T&amp;&amp; arg)</span> &#123;</span><br><span class="line">    callee(<span class="built_in">std</span>::forward&lt;T&gt;(arg));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> lv = <span class="string">&quot;left value&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    wrapper(lv);  <span class="comment">// 调用 callee(const std::string&amp;)</span></span><br><span class="line">    waapper(<span class="built_in">std</span>::move(lv)); <span class="comment">// 调用 callee(std::string&amp;&amp;)</span></span><br><span class="line">    wrapper(<span class="string">&quot;right value&quot;</span>);  <span class="comment">// 调用 callee(std::string&amp;&amp;)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 main 函数中，wrapper 首先以一个左值字符串调用，接着使用std::move(lv)调用，然后以一个右值字符串字面量调用。由于使用了 std::forward，wrapper 能够保持参数的原始值类别（左值或右值），因此能够触发 callee 的正确重载。</p><h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结:"></a>总结:</h4><p>完美转发是一个非常有用的技术，它使得模板函数能够接受任意类型的参数，并将这些参数以其原始的左值或右值状态传递给其他函数。这在编写泛型代码或模板库时尤其重要，因为它允许代码以一种类型安全且效率高的方式处理各种调用场景。通过结合使用<code>通用引用（T&amp;&amp;）</code>和 <code>std::forward</code>，开发者可以编写出既灵活又高效的模板函数。</p><h2 id="标准库增强"><a href="#标准库增强" class="headerlink" title="标准库增强"></a>标准库增强</h2><h3 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h3><h4 id="线程（std-thread）"><a href="#线程（std-thread）" class="headerlink" title="线程（std::thread）"></a>线程（std::thread）</h4><p>C++11 引入了原生线程支持，通过 <code>&lt;thread&gt;</code> 头文件提供了 std::thread 类，使得创建和管理线程变得直接且易于使用。这是对 C++ 标准库的重要扩展，允许直接在 C++ 代码中实现多线程编程，而不再依赖于操作系统特定的线程库。</p><p><strong>基本使用</strong>:</p><p>要使用 <code>std::thread</code>，你需要创建一个 <code>std::thread</code> 对象并向其传递一个函数，这个函数将在新线程中执行。</p><p><strong>示例代码</strong>：创建并启动一个线程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程执行的函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">threadTask</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hello, Thread!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建并启动新线程</span></span><br><span class="line">    <span class="built_in">std</span>::thread <span class="title function_">t</span><span class="params">(threadTask)</span>;</span><br><span class="line">    <span class="comment">// 等待线程完成任务</span></span><br><span class="line">    t.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>传递参数</strong>:</p><p>如果你需要向线程函数传递参数，可以直接将它们作为 std::thread 构造函数的参数传递。</p><p><strong>示例代码</strong>：向线程函数传递参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printMessage</span><span class="params">(<span class="type">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; message)</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; message &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> message = <span class="string">&quot;Hello from the thread with arguments!&quot;</span>;</span><br><span class="line">    <span class="comment">// message作为参数传递给线程函数</span></span><br><span class="line">    <span class="built_in">std</span>::thread <span class="title function_">t</span><span class="params">(printMessage, message)</span>;</span><br><span class="line">    t.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>线程管理</strong>:</p><p><strong>加入线程</strong> : 当你创建一个线程时，你需要决定程序何时等待这个线程完成其工作。调用 <code>std::thread</code> 对象的 <code>join()</code> 方法，会使当前线程（通常是主线程或创建该子线程的线程）暂停执行，直到被 <code>join()</code> 的那个线程完成执行。<strong>这保证了两个重要的事项</strong>：</p><ul><li><strong>线程同步</strong>：确保所有必要的线程操作在程序继续之前完成。</li><li><strong>资源回收</strong>：一旦子线程完成执行，系统会回收它使用的所有资源。</li></ul><p><strong>使用方法</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t.join();</span><br></pre></td></tr></table></figure><p><strong>分离线程</strong> : 有时，你可能希望线程“独立”执行，而不是等待它结束。通过调用线程对象的 <code>detach()</code> 方法，你可以实现这一点。分离线程意味着：</p><ul><li><strong>线程的自主性</strong>：分离的线程会在自己的执行流中独立运行，主线程（或任何其他线程）不会等待它结束。</li><li><strong>资源管理</strong>：一旦分离的线程完成其任务，它占用的资源将由操作系统自动回收。你不需要（也不能）对其调用 join()。</li></ul><p><strong>使用方法</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t.detach();</span><br></pre></td></tr></table></figure><p><strong>获取线程ID</strong>:<br>每个线程都有一个唯一的 <code>ID</code>，可以通过 <code>get_id()</code> 方法获取。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Thread ID: &quot;</span> &lt;&lt; t.get_id() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p><strong>当前线程的 ID</strong></p><p>可以使用 <code>std::this_thread::get_id()</code> 获取当前线程的 ID。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Current thread ID: &quot;</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p><strong>线程休眠</strong>:</p><p><code>std::this_thread::sleep_for()</code> 函数可以使当前线程暂停执行指定的时间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="comment">// 使当前线程休眠 1 秒</span></span><br><span class="line"><span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>));</span><br></pre></td></tr></table></figure><h4 id="多线程同步"><a href="#多线程同步" class="headerlink" title="多线程同步"></a>多线程同步</h4><p>C++11 引入了多线程同步的机制，来帮助程序员控制并发执行的线程之间的执行顺序，确保数据的一致性和防止竞态条件。这包括了<code>互斥锁（mutexes）</code>、<code>条件变量（condition variables）</code>、以及<code>原子操作（atomic operations）</code>等。下面是这些同步机制的基本介绍和示例。</p><p><strong>1. 互斥锁（Mutex）</strong></p><p>互斥锁（mutex）是用于管理对共享资源的访问的同步原语。当多个线程尝试同时访问同一个资源时，互斥锁确保每次只有一个线程能够访问该资源，从而防止数据竞争和保证数据的一致性。</p><p>C++11 在 <code>&lt;mutex&gt;</code> 头文件中提供了几种类型的互斥锁：</p><p><strong>std::mutex</strong></p><p><code>std::mutex</code> 提供了基本的互斥锁功能。</p><p><strong>基本语法</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::mutex mtx;</span><br><span class="line">mtx.lock();   <span class="comment">// 加锁</span></span><br><span class="line"><span class="comment">// 临界区代码</span></span><br><span class="line">mtx.unlock(); <span class="comment">// 解锁</span></span><br></pre></td></tr></table></figure><p><strong>主要成员函数</strong>:</p><ul><li><strong>lock()</strong>    : 锁定互斥锁。如果互斥锁已被其他线程锁定，则调用线程将阻塞，直到互斥锁变为可用。</li><li><strong>unlock()</strong>  : 解锁互斥锁，使其变为可用状态。</li><li><strong>try_lock()</strong>: 尝试锁定互斥锁而不阻塞。如果互斥锁已经被其他线程锁定，则立即返回 false；如果成功锁定，则返回 true。</li></ul><p><strong>示例代码</strong>：使用 <code>std::mutex</code> 保护共享数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::mutex mtx; <span class="comment">// 创建互斥锁</span></span><br><span class="line"><span class="type">int</span> shared_data = <span class="number">0</span>; <span class="comment">// 共享数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">incrementSharedData</span><span class="params">()</span> &#123;</span><br><span class="line">    mtx.lock(); <span class="comment">// 加锁</span></span><br><span class="line">    ++shared_data;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">&quot; incremented shared_data to &quot;</span> &lt;&lt; shared_data &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    mtx.unlock(); <span class="comment">// 解锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::thread <span class="title function_">t1</span><span class="params">(incrementSharedData)</span>;</span><br><span class="line">    <span class="built_in">std</span>::thread <span class="title function_">t2</span><span class="params">(incrementSharedData)</span>;</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>std::recursive_mutex</strong></p><p><code>std::recursive_mutex</code>是可递归的互斥锁，允许同一个线程多次对同一个互斥锁对象加锁。它维护了一个锁计数和拥有线程的标识，当计数降到 0 时锁被释放。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::recursive_mutex rec_mtx;</span><br><span class="line">rec_mtx.lock();   <span class="comment">// 第一次加锁</span></span><br><span class="line">rec_mtx.lock();   <span class="comment">// 第二次加锁，合法</span></span><br><span class="line"><span class="comment">// 临界区代码</span></span><br><span class="line">rec_mtx.unlock(); <span class="comment">// 第一次解锁</span></span><br><span class="line">rec_mtx.unlock(); <span class="comment">// 第二次解锁，锁被完全释放</span></span><br></pre></td></tr></table></figure><p><strong>std::timed_mutex</strong></p><p><code>std::timed_mutex</code>提供了基本的互斥锁功能，并支持尝试加锁一段时间。如果在指定时间内没有获取到锁，操作会失败并返回。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::timed_mutex tm_mtx;</span><br><span class="line"><span class="keyword">if</span> (tm_mtx.try_lock_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>))) &#123;</span><br><span class="line">    <span class="comment">// 临界区代码</span></span><br><span class="line">    tm_mtx.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>std::recursive_timed_mutex</strong></p><p><code>std::recursive_timed_mutex</code>结合了<code>std::recursive_mutex</code>的可递归特性和<code>std::timed_mutex</code>的定时尝试加锁功能。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::recursive_timed_mutex rt_mtx;</span><br><span class="line"><span class="keyword">if</span> (rt_mtx.try_lock_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>))) &#123;</span><br><span class="line">    <span class="comment">// 临界区代码，可以多次加锁</span></span><br><span class="line">    rt_mtx.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用注意</strong>:</p><ul><li><p>在使用互斥锁时，推荐使用<code>std::lock_guard</code>或<code>std::unique_lock</code>等 RAII（Resource Acquisition Is Initialization）封装，以自动管理锁的加锁和解锁过程，避免因异常而导致的死锁问题。</p></li><li><p>根据具体需求选择合适的互斥锁类型。比如，如果不需要递归加锁或定时尝试加锁的功能，使用最简单的std::mutex即可。</p></li></ul><p>C++11的互斥锁类型提供了灵活的同步机制，帮助开发者在多线程程序中安全地管理对共享数据的访问。</p><p><strong>2. 条件变量（Condition Variable）</strong></p><p>C++11中的条件变量也是线程同步的一种机制，用于在某些条件发生变化时通知一个或多个正在等待的线程。条件变量通常与互斥量（mutex）一起使用，以确保线程安全地访问共享数据。条件变量主要通过<code>std::condition_variable</code>类提供。</p><p><strong>条件变量常见接口</strong>：</p><p><strong>1. wait</strong></p><p>该函数用于等待一个条件成立。它会原子地释放锁并使当前线程挂起，直到被其他线程通过 notify_one 或 notify_all 唤醒。一旦当前线程被唤醒，wait 会再次获取锁。</p><p><strong>语法</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv.wait(unique_lock&lt;<span class="built_in">std</span>::mutex&gt;&amp; lock);</span><br></pre></td></tr></table></figure><p><strong>2. wait_for</strong></p><p>等待条件变量被通知一段时间。如果在指定的时间内条件变量没有被通知，则超时并返回。</p><p><strong>语法</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv.wait_for(unique_lock&lt;<span class="built_in">std</span>::mutex&gt;&amp; lock, duration);</span><br></pre></td></tr></table></figure><p><strong>3. wait_until</strong><br>等待直到某个时间点，如果条件变量在这个时间点之前没有被通知，则超时并返回。</p><p><strong>语法</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv.wait_until(unique_lock&lt;<span class="built_in">std</span>::mutex&gt;&amp; lock, time_point);</span><br></pre></td></tr></table></figure><p><strong>4. notify_one</strong><br>用于唤醒一个等待（挂起）在条件变量上的线程。如果有多个线程在等待，只有一个会被随机唤醒。</p><p><strong>语法</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv.notify_one();</span><br></pre></td></tr></table></figure><p><strong>5. notify_all</strong></p><p>该函数用于唤醒所有等待（挂起）在条件变量上的线程。</p><p><strong>语法</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv.notify_all();</span><br></pre></td></tr></table></figure><p><strong>示例代码</strong>：使用 <code>std::condition_variable</code> 实现线程同步</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::mutex mtx;</span><br><span class="line"><span class="built_in">std</span>::condition_variable cv;</span><br><span class="line"><span class="type">bool</span> ready = <span class="literal">false</span>; <span class="comment">// 条件变量关联的条件</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">doPrint</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// std::unique_lock :锁管理工具，自动管理互斥锁的锁定与解锁。</span></span><br><span class="line">    <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title function_">lck</span><span class="params">(mtx)</span>;</span><br><span class="line">    <span class="keyword">while</span> (!ready) </span><br><span class="line">        cv.wait(lck); <span class="comment">// 等待条件成立，即：ready 变为true</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">&quot; is running\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">go</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title function_">lck</span><span class="params">(mtx)</span>;</span><br><span class="line">    ready = <span class="literal">true</span>;</span><br><span class="line">    cv.notify_all(); <span class="comment">// 通知所有等待的线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::thread threads[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">        threads[i] = <span class="built_in">std</span>::thread(doPrint);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;10 threads ready to race...\n&quot;</span>;</span><br><span class="line">    go(); <span class="comment">// 让所有线程开始执行</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; th : threads) th.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 原子操作（Atomic）</strong></p><p>原子操作是指不可分割的操作，这些操作要么完全执行，要么完全不执行，不会出现部分执行的情况。这对于多线程编程至关重要，因为它们可以用来保护在多线程环境中共享的数据，而无需使用互斥锁。C++11 通过 <code>&lt;atomic&gt;</code> 头文件引入了原子类型和操作。</p><p><strong>原子类型</strong>:</p><p>C++11 提供了一系列原子类型，如 <code>std::atomic_int</code>, <code>std::atomic_long</code>, <code>std::atomic_bool</code> 等，以及一个模板类 <code>std::atomic&lt;T&gt;</code>，允许创建任意类型 <code>T</code> 的原子对象。</p><p><strong>基本用法</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="type">int</span>&gt; <span class="title function_">count</span><span class="params">(<span class="number">0</span>)</span>;  <span class="comment">// 原子整型变量</span></span><br></pre></td></tr></table></figure><p><strong>主要成员函数</strong>:</p><ul><li><strong>store()</strong>: 存储（赋值）一个值到原子对象。</li><li><strong>load()</strong>: 从原子对象加载（获取）一个值。</li><li><strong>exchange()</strong>: 原子地替换原子对象的值。</li><li><strong>compare_exchange_weak() 和 compare_exchange_strong()</strong>: 比较原子对象的值，如果与期望值相同，则替换为新值。</li><li><strong>fetch_add(), fetch_sub(), fetch_or(), fetch_and(), fetch_xor()</strong>: 原子地执行加、减、或、与、异或操作。</li></ul><p><strong>示例代码</strong>:</p><p><strong>简单原子操作</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="type">int</span>&gt; <span class="title function_">count</span><span class="params">(<span class="number">0</span>)</span>;  <span class="comment">// 原子计数器</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i) &#123;</span><br><span class="line">        count.fetch_add(<span class="number">1</span>);  <span class="comment">// 原子地增加计数器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt; threads;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        threads.push_back(<span class="built_in">std</span>::thread(increment));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; th : threads) &#123;</span><br><span class="line">        th.join();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Final count: &quot;</span> &lt;&lt; count.load() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子创建了 10 个线程，每个线程都对一个原子计数器执行 10000 次增加操作。因为 count 是原子类型，所以即使多个线程同时修改它，最终的结果也是准确的，不会发生数据竞争。</p><p><strong>比较并交换</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="type">int</span>&gt; <span class="title function_">value</span><span class="params">(<span class="number">10</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">check_and_increase</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> oldValue = value.load();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!value.compare_exchange_weak(oldValue, oldValue + <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="comment">// 循环直到成功更新</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    check_and_increase();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子展示了如何使用 <code>compare_exchange_weak</code> 来原子地更新一个值，只有当当前值等于期望的旧值时，才将其更新为新值，否则重试操作。</p><p><code>value.compare_exchange_weak(oldValue, oldValue + 1)</code><br>这是一个原子的比较并交换操作，它尝试将 value 的当前值与 oldValue 比较：</p><ul><li><p><strong>如果相等</strong>（说明期间 value 的值未被其他线程改变），则将 value 更新为 oldValue + 1。</p></li><li><p><strong>如果不相等</strong>（说明期间 value 的值被其他线程改变了），操作失败，oldValue 被更新为 value 的新值，然后循环再尝试。</p><p><code>compare_exchange_weak</code>方法返回 true 表示成功更新，false 表示更新失败。</p></li></ul><p>通过使用原子操作，可以在多线程环境中安全地操作共享数据，而无需引入可能导致性能下降的互斥锁。</p><h4 id="std-once-flag-和-std-call-once"><a href="#std-once-flag-和-std-call-once" class="headerlink" title="std::once_flag 和 std::call_once"></a>std::once_flag 和 std::call_once</h4><p>在C++11中，<code>std::once_flag</code>和<code>std::call_once</code>共同提供了一种线程安全的方式来执行一次性初始化。这种机制尤其用于延迟初始化和单例模式中，确保某个函数或某段初始化代码在多线程环境下仅被执行一次，无论有多少线程尝试。</p><p><strong>std::once_flag</strong>:</p><p><code>std::once_flag</code>是一个不能被复制的类型，用来与 std::call_once 一起标记某个函数或初始化代码是否已经被执行。每个<code>std::once_flag</code>对象通常与一次性初始化任务相关联。</p><p><strong>std::call_once</strong>:</p><p><code>std::call_once</code>函数接受一个 std::once_flag 对象和一个要执行的函数，保证无论有多少线程尝试调用<code>std::call_once</code>，该函数仅被执行一次。</p><p><strong>语法</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">call_once</span><span class="params">(<span class="built_in">std</span>::once_flag&amp; flag, Callable&amp;&amp; func, Args&amp;&amp;... args)</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>flag</strong>：一个std::once_flag对象，标记func是否被执行过。</li><li><strong>func</strong>：要执行的函数或可调用对象。</li><li><strong>args</strong>：传递给func的参数列表。</li></ul><p><strong>示例代码</strong>:</p><p>下面是一个使用<code>std::once_flag</code>和<code>std::call_once</code>实现的线程安全的延迟初始化示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::once_flag flag; <span class="comment">// 用于标记延迟初始化是否执行</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_once</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Called once&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_work</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 尝试执行do_once，由于使用了std::once_flag，</span></span><br><span class="line">    <span class="comment">// 即使有多个线程调用do_work，do_once也只会执行一次</span></span><br><span class="line">    <span class="built_in">std</span>::call_once(flag, do_once);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::thread <span class="title function_">t1</span><span class="params">(do_work)</span>;</span><br><span class="line">    <span class="built_in">std</span>::thread <span class="title function_">t2</span><span class="params">(do_work)</span>;</span><br><span class="line">    <span class="built_in">std</span>::thread <span class="title function_">t3</span><span class="params">(do_work)</span>;</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">    t3.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，do_work 函数尝试执行 do_once 函数，但由于 do_once 与一个 std::once_flag 对象 flag 相关联，并通过 std::call_once 来调用，因此无论有多少线程调用 do_work，do_once 只会被执行一次。这种模式对于资源的延迟初始化非常有用，尤其是在资源初始化开销较大或只有在真正需要时才应被初始化的情况下。</p><h4 id="std-future和std-promise"><a href="#std-future和std-promise" class="headerlink" title="std::future和std::promise"></a>std::future和std::promise</h4><p>在C++11中，<code>std::future</code>和<code>std::promise</code>是处理异步操作的两个重要类。它们协同工作，提供了一种从异步操作中获取结果的机制。</p><p><strong>std::promise</strong>:</p><p><code>std::promise</code>对象可以存储某一类型的值，该值可以在将来某个时刻被获取。通过 std::promise，你可以在一个线程中设置一个值，然后在另一个线程中通过与之关联的 std::future 对象来获取这个值。</p><p><strong>语法</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  T：存储的值的类型。</span></span><br><span class="line"><span class="built_in">std</span>::promise&lt;T&gt; promise;</span><br></pre></td></tr></table></figure><p><strong>主要接口</strong>:</p><ul><li>set_value(const T&amp;)：设置一个值，该值可以通过关联的 std::future 对象来获取。</li><li>get_future()：返回一个<code>std::future&lt;T&gt;</code>对象，用于获取通过 set_value 设置的值。</li></ul><p><strong>std::future</strong>:</p><p><code>std::future</code> 对象持有一个异步操作的结果。它从关联的 std::promise 对象获取值或异常。</p><p><strong>语法</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  T：存储的值的类型。</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">future</span>&lt;T&gt; <span class="built_in">future</span> = promise.get_future();</span><br><span class="line"></span><br><span class="line">value = <span class="built_in">future</span>.get();</span><br></pre></td></tr></table></figure><p><strong>主要接口</strong>:</p><ul><li>get()：获取由 std::promise 设置的值。调用get()会阻塞，直到值被设置。</li><li>wait()：等待异步操作完成，但不获取结果。</li></ul><p><strong>示例代码</strong>:</p><p>下面是一个使用<code>std::promise</code>和<code>std::future</code>来传递异步操作结果的简单示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步任务：计算一个数的平方</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">compute</span><span class="params">(<span class="built_in">std</span>::promise&lt;<span class="type">int</span>&gt;&amp;&amp; prom, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="type">int</span> result = x * x;</span><br><span class="line">    prom.set_value(result);  <span class="comment">// 在子线程中设置结果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::promise&lt;<span class="type">int</span>&gt; prom;  <span class="comment">// 创建一个std::promise&lt;int&gt;对象</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="type">int</span>&gt; fut = prom.get_future();  <span class="comment">// 获取与promise关联的future</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::thread <span class="title function_">th</span><span class="params">(compute, <span class="built_in">std</span>::move(prom), <span class="number">10</span>)</span>;  <span class="comment">// 创建一个线程执行异步任务</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取异步操作的结果</span></span><br><span class="line">    <span class="type">int</span> value = fut.get();  <span class="comment">// 阻塞，直到异步操作完成并设置了结果</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The square of 10 is &quot;</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    th.join();  <span class="comment">// 等待子线程完成</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，compute 函数在一个新线程中执行，并计算一个数的平方，然后通过传入的 std::promise 对象设置结果。主线程通过与 promise 对象关联的 future 对象等待并获取这个结果。</p><p><strong>总结</strong>:</p><p><code>std::promise</code>和<code>std::future</code>为 C++11 引入的异步编程提供了强大的支持，允许在不同线程之间传递数据和状态信息。它们使得编写并发程序变得更加简洁和安全，尤其是在需要从异步操作中获取结果时。</p><h4 id="打包任务（packaged-task）"><a href="#打包任务（packaged-task）" class="headerlink" title="打包任务（packaged_task）"></a>打包任务（packaged_task）</h4><p>C++11引入了<code>std::packaged_task</code>，它是一个模板类，用于封装任何可以调用的目标（比如函数、lambda表达式、绑定表达式或其他函数对象），以便异步调用。<code>std::packaged_task</code>将调用的结果存储为一个<code>std::future</code>对象，这样就可以在未来某个时刻获取该结果。这使得<code>std::packaged_task</code>成为实现任务异步执行并获取其结果的强大工具。</p><p><strong>语法</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::packaged_task&lt;ReturnType(ArgsTypes...)&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>ReturnType</strong>：调用的返回类型。</li><li><strong>ArgsTypes</strong>：调用的参数类型列表。</li></ul><p><strong>主要接口</strong>:</p><ul><li>operator()(Args…)：执行封装的任务。</li><li>get_future()：返回一个<code>std::future&lt;ReturnType&gt;</code>对象，用于获取任务的结果。</li></ul><p><strong>示例代码</strong>:</p><p>假设我们有一个函数，计算两个整数的和，并希望异步执行这个函数并获取结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个简单的函数，计算两个整数的和</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 封装sum函数到packaged_task中</span></span><br><span class="line">    <span class="built_in">std</span>::packaged_task&lt;<span class="title function_">int</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>&gt; <span class="title function_">task</span><span class="params">(sum)</span>;</span><br><span class="line">    <span class="comment">// 获取与packaged_task关联的future对象，以便之后获取结果</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="type">int</span>&gt; result = task.get_future();</span><br><span class="line">    <span class="comment">// 在一个新线程中执行任务</span></span><br><span class="line">    <span class="built_in">std</span>::thread <span class="title function_">th</span><span class="params">(<span class="built_in">std</span>::move(task), <span class="number">2</span>, <span class="number">3</span>)</span>; <span class="comment">// 传递参数2和3给sum函数</span></span><br><span class="line">    <span class="comment">// 等待任务完成并获取结果</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The sum is: &quot;</span> &lt;&lt; result.get() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出：The sum is: 5 </span></span><br><span class="line">    <span class="comment">// 等待线程完成</span></span><br><span class="line">    th.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们创建了一个 std::packaged_task 对象 task，它封装了 sum 函数。通过调用 task.get_future()，我们获得了一个std::future对象，它将在task执行完成后包含 sum 函数的返回值。然后，我们创建了一个线程th，并将task（通过std::move移动）和sum函数需要的参数传递给这个线程，以异步执行task。通过result.get()，我们阻塞等待任务完成，并获取sum函数的结果。</p><p><strong>总结</strong>:</p><p><code>std::packaged_task</code> 是C++11中处理异步任务的强大工具。它允许程序员封装任何可调用的目标，以便异步执行，同时通过<code>std::future</code>提供了一种机制来获取异步操作的结果。这种模式非常适用于需要将计算密集型任务移出主线程以避免阻塞主执行流的场景。</p><h4 id="异步（Async）"><a href="#异步（Async）" class="headerlink" title="异步（Async）"></a>异步（Async）</h4><p>C++11 通过引入 <code>std::async</code> 函数提供了一种更简洁、更高层的方式来创建异步任务。<code>std::async</code> 会启动一个异步任务，该任务可以在新线程中执行或延迟执行，具体取决于给定的策略参数，并返回一个 <code>std::future</code> 对象，用于访问异步操作的结果。</p><p><strong>函数声明</strong>:</p><p><strong>普通版本的函数声明</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template &lt;<span class="class"><span class="keyword">class</span> <span class="title">F</span>, <span class="title">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">future</span>&lt;typename <span class="built_in">std</span>::result_of&lt;F(Args...)&gt;::type&gt; async(F&amp;&amp; f, Args&amp;&amp;... args);</span><br></pre></td></tr></table></figure><p><strong>指定启动策略的重载版本的函数声明</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template &lt;<span class="class"><span class="keyword">class</span> <span class="title">F</span>, <span class="title">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">future</span>&lt;typename <span class="built_in">std</span>::result_of&lt;F(Args...)&gt;::type&gt; async(<span class="built_in">std</span>::launch policy, F&amp;&amp; f, Args&amp;&amp;... args);</span><br></pre></td></tr></table></figure><ul><li><strong>policy</strong>：指定执行策略，可以是 std::launch::async（强制在新线程中执行任务）、std::launch::deferred（延迟执行任务，直到调用 std::future::get 或 std::future::wait）、或者这两者的位或组合。</li><li><strong>f</strong>：要异步执行的函数或可调用对象。</li><li><strong>args</strong>：传递给 f 的参数。</li></ul><p><strong>返回值是</strong>： <code>std::future</code> 类型的对象，它持有异步任务的结果。</p><p><strong>示例代码</strong>:</p><p><strong>异步执行任务</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">compute</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 启动异步任务，自动选择执行策略</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="type">int</span>&gt; result = <span class="built_in">std</span>::async(compute, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 做一些其他的事情...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取异步任务的结果，如果任务尚未完成，则这里会阻塞等待</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The result is: &quot;</span> &lt;&lt; result.get() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用执行策略</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">task</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Task runs in a thread.&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 强制在新线程中启动异步任务</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="type">void</span>&gt; f1 = <span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::async, task);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 延迟执行任务，直到调用 get() 或 wait()</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="type">void</span>&gt; f2 = <span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::deferred, task);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此时，第一个任务已经在新线程中执行</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第二个任务将在调用 get() 或 wait() 时在当前线程(主线程)中执行</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 等待第一个任务完成</span></span><br><span class="line">    f1.get();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 启动第二个任务，并等待它完成</span></span><br><span class="line">    f2.get();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结</strong>:</p><p><code>std::async</code> 提供了一种便捷的方式来执行异步任务，无需直接处理线程的创建和管理。通过返回一个 <code>std::future</code> 对象，它允许以线程安全的方式访问异步任务的结果。使用 <code>std::async</code> 可以使并发编程变得更简单、更直观。</p><h4 id="线程局部存储（Thread-Local-Storage，TLS）"><a href="#线程局部存储（Thread-Local-Storage，TLS）" class="headerlink" title="线程局部存储（Thread Local Storage，TLS）"></a>线程局部存储（Thread Local Storage，TLS）</h4><p>C++11 引入了线程局部存储（Thread Local Storage，TLS），允许数据在每个线程中都有自己的独立实例。这意味着每个线程都有自己的数据副本，修改一个线程中的数据不会影响到其他线程中的相同数据。这是通过<code>thread_local</code>关键字来实现的，它指定了变量的存储期为线程的生命周期。</p><p><strong>语法</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">thread_local</span> Type variableName = initialValue;</span><br></pre></td></tr></table></figure><ul><li><strong>thread_local</strong>：关键字，用于声明线程局部存储变量。</li><li><strong>Type</strong>：变量的类型。</li><li><strong>variableName</strong>：变量的名称。</li><li><strong>initialValue</strong>（可选）：变量的初始值。</li></ul><p><strong>示例代码</strong>：</p><p>以下是一个展示如何使用<code>thread_local</code>关键字的简单示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个线程局部变量</span></span><br><span class="line"><span class="keyword">thread_local</span> <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">incrementCounter</span><span class="params">(<span class="type">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; threadName)</span> &#123;</span><br><span class="line">    ++counter; <span class="comment">// 访问和修改线程局部变量</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Counter in &quot;</span> &lt;&lt; threadName &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; counter &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::thread <span class="title function_">t1</span><span class="params">([&amp;]() &#123;</span></span><br><span class="line"><span class="params">        incrementCounter(<span class="string">&quot;t1&quot;</span>);</span></span><br><span class="line"><span class="params">        incrementCounter(<span class="string">&quot;t1&quot;</span>);</span></span><br><span class="line"><span class="params">    &#125;)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::thread <span class="title function_">t2</span><span class="params">([&amp;]() &#123;</span></span><br><span class="line"><span class="params">        incrementCounter(<span class="string">&quot;t2&quot;</span>);</span></span><br><span class="line"><span class="params">        incrementCounter(<span class="string">&quot;t2&quot;</span>);</span></span><br><span class="line"><span class="params">    &#125;)</span>;</span><br><span class="line"></span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，counter是一个线程局部存储变量，因为它前面有<code>thread_local</code>关键字。这意味着每个线程调用 incrementCounter 函数时，都会修改它自己的 counter 副本，而不是共享一个全局 counter。因此，尽管 incrementCounter 函数在两个不同的线程中都被调用了两次，每个线程的输出将独立地显示 counter 从1递增到2，证明每个线程都有自己的 counter 副本。</p><p><strong>总结</strong>:</p><p>使用 <code>thread_local</code> 声明的变量为每个线程提供了一个独立的变量副本，这有助于减少对全局状态的依赖，从而使代码在并发环境中更安全、更容易理解。线程局部存储特别适用于保持线程的状态或避免不必要的锁争用，提高程序的效率和性能。</p><h3 id="函数包装器（function-wrapper）"><a href="#函数包装器（function-wrapper）" class="headerlink" title="函数包装器（function wrapper）"></a>函数包装器（function wrapper）</h3><p>在C++11中，<code>std::function</code>是一个函数包装器（function wrapper），它提供了一种通用、类型安全的方式来存储和调用任何可调用对象，包括普通函数、Lambda 表达式、函数指针、以及具有 operator() 成员函数的对象（如函数对象或类实例）。</p><h4 id="语法-10"><a href="#语法-10" class="headerlink" title="语法"></a>语法</h4><p><code>std::function</code> 的语法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::function&lt;ReturnType(ArgumentTypes...)&gt;</span><br></pre></td></tr></table></figure><p>其中 <code>ReturnType</code> 是可调用对象返回的类型，<code>ArgumentTypes...</code> 是可调用对象接受的参数类型列表。</p><p><strong>示例代码</strong>:</p><p><strong>1. 存储和调用普通函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; func = print;</span><br><span class="line">    func(<span class="number">10</span>);  <span class="comment">// 输出：10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 存储和调用Lambda表达式</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; add = [](<span class="type">int</span> a, <span class="type">int</span> b) &#123; <span class="keyword">return</span> a + b; &#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;3 + 4 = &quot;</span> &lt;&lt; add(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出：3 + 4 = 7</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 存储和调用成员函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">triple</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span> * x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    MyClass obj;</span><br><span class="line">    <span class="built_in">std</span>::function&lt;<span class="type">int</span>(MyClass&amp;, <span class="type">int</span>)&gt; func = &amp;MyClass::triple;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;3 tripled is &quot;</span> &lt;&lt; func(obj, <span class="number">3</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出：3 tripled is 9</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4. 存储和调用函数对象</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Adder</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; func = Adder();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;1 + 2 = &quot;</span> &lt;&lt; func(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出：1 + 2 = 3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h4><p><code>std::function</code> 是 C++11 提供的一个非常灵活的机制，它使得函数的存储、传递和调用变得非常简单和统一。无论是普通函数、成员函数、Lambda 表达式还是函数对象，都可以用 <code>std::function</code> 来处理。这种统一的接口使得编写接受函数作为参数的泛型代码变得更加容易和直观。</p><h3 id="绑定器（std-bind）"><a href="#绑定器（std-bind）" class="headerlink" title="绑定器（std::bind）"></a>绑定器（std::bind）</h3><p>C++11标准引入了<code>std::bind</code>，这是一个非常有用的函数适配器，它位于<code>&lt;functional&gt;</code>头文件中。<code>std::bind</code>可以被用来将一个函数或可调用对象（如函数指针、成员函数指针、Lambda表达式、函数对象等）与其参数绑定，生成一个新的可调用对象。这意味着你可以预设某些参数的值，创建一个新的函数版本，这个新版本只需要剩余的参数即可被调用。</p><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> newCallable = <span class="built_in">std</span>::bind(callable, arg1, arg2, ..., argN);</span><br></pre></td></tr></table></figure><ul><li>callable：原始的可调用对象，可以是函数指针、成员函数指针、Lambda 表达式或其他函数对象。</li><li>arg1, arg2, …, argN：要绑定的参数列表，可以是具体的值或引用，也可以是 <code>std::placeholders::_1</code>, <code>std::placeholders::_2</code>, … 来占位，这表示该位置的参数将在新生成的可调用对象被调用时指定。</li></ul><p><strong>示例</strong>:</p><p><strong>1. 绑定普通函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> n1, <span class="type">int</span> n2, <span class="type">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; str)</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n1 &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; n2 &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; str &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">auto</span> f = <span class="built_in">std</span>::bind(print, <span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    f(); <span class="comment">// 输出：1, 2, Hello</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 使用占位符</strong></p><p>使用 <code>std::placeholders</code> 中的占位符，可以在绑定时留下未指定的参数，这些参数需要在新可调用对象被调用时提供：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> n1, <span class="type">int</span> n2, <span class="type">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; str)</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n1 &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; n2 &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; str &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    using namespace <span class="built_in">std</span>::placeholders; <span class="comment">// 对于 _1, _2, _3...</span></span><br><span class="line">    <span class="keyword">auto</span> f = <span class="built_in">std</span>::bind(print, _2, _1, <span class="string">&quot;Bound&quot;</span>);</span><br><span class="line">    f(<span class="number">3</span>, <span class="number">5</span>); <span class="comment">// 输出：5, 3, Bound</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 绑定类的成员函数</strong></p><p>对于类的成员函数，<code>std::bind</code> 也能够被用来绑定，但需要提供<strong>成员函数的地址</strong>作为第一个参数，而第二个参数是<strong>要绑定的对象的指针或引用</strong>，之后的参数则是成员函数的参数，这些参数可以是具体的值，也可以是占位符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">memberFunc</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Member function called with &quot;</span> &lt;&lt; x &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    MyClass obj;</span><br><span class="line">    <span class="keyword">auto</span> f = <span class="built_in">std</span>::bind(&amp;MyClass::memberFunc, &amp;obj, <span class="number">100</span>);</span><br><span class="line">    f(); <span class="comment">// 输出：Member function called with 100</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结-5"><a href="#总结-5" class="headerlink" title="总结:"></a>总结:</h4><p><code>std::bind</code> 是 C++11 引入的一个功能强大的工具，它使得函数调用更加灵活，允许预先绑定参数，创建新的可调用对象。但在 C++11 以后，<code>Lambda 表达式</code>因其更简洁的语法和更好的性能，通常被推荐为更好的替代方案。</p><h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><p>C++11 引入了几种智能指针类型，这些智能指针主要存在于 <code>&lt;memory&gt;</code> 头文件中，它们自动管理内存，帮助避免内存泄露，使得资源管理更加安全和容易。智能指针的类型包括 <code>std::unique_ptr</code>、<code>std::shared_ptr</code> 和 <code>std::weak_ptr</code>。</p><h4 id="std-unique-ptr"><a href="#std-unique-ptr" class="headerlink" title="std::unique_ptr"></a>std::unique_ptr</h4><p><code>std::unique_ptr</code>是一种独占所有权的智能指针，确保同一时刻只有一个智能指针实例可以指向一个给定的对象。当<code>std::unique_ptr</code>被销毁时，它所指向的对象也会被销毁。</p><p><strong>语法</strong>：</p><p>创建 <code>std::unique_ptr</code> 的基本语法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Type&gt; <span class="title function_">ptr</span><span class="params">(new Type(arguments))</span>;</span><br></pre></td></tr></table></figure><p><strong>主要特性</strong>:</p><ul><li><strong>独占所有权</strong>：一个 std::unique_ptr 同时只能拥有一个对象的所有权。</li><li><strong>自动资源管理</strong>：std::unique_ptr 负责自动释放其所拥有的对象。</li><li><strong>不可复制</strong>：为保证资源独占性，std::unique_ptr 不能被复制，但可以被移动，从而转移资源所有权。</li></ul><p><strong>示例代码</strong>:</p><p>创建和使用 <code>std::unique_ptr</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    MyClass() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;MyClass created\n&quot;</span>; &#125;</span><br><span class="line">    ~MyClass() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;MyClass destroyed\n&quot;</span>; &#125;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Doing something\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;MyClass&gt; <span class="title function_">myPtr</span><span class="params">(new MyClass())</span>;</span><br><span class="line">    myPtr-&gt;doSomething();</span><br><span class="line">    <span class="comment">// 当 myPtr 离开作用域时，MyClass 的实例会自动被销毁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这个例子中，我们通过 new MyClass() 显式地创建了一个 MyClass 的实例，并将其传递给 <code>std::unique_ptr&lt;MyClass&gt;</code> 的构造函数来初始化 myPtr。</p><p>转移 <code>std::unique_ptr</code> 的所有权:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;MyClass&gt; <span class="title function_">ptr1</span><span class="params">(new MyClass())</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;MyClass&gt; ptr2 = <span class="built_in">std</span>::move(ptr1);</span><br><span class="line"><span class="comment">// 现在 ptr2 拥有 MyClass 实例的所有权，而 ptr1 为空（nullptr）</span></span><br></pre></td></tr></table></figure><p>在这个例子中，使用 std::move 将 ptr1 的所有权转移给 ptr2。之后，ptr1 变为 nullptr。</p><p>从 <code>C++14</code> 开始，推荐使用 <code>std::make_unique</code> 函数来创建 <code>std::unique_ptr</code>，因为这种方式更安全，可以防止潜在的内存泄漏：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> ptr = <span class="built_in">std</span>::make_unique&lt;Type&gt;(arguments);</span><br></pre></td></tr></table></figure><h4 id="std-shared-ptr"><a href="#std-shared-ptr" class="headerlink" title="std::shared_ptr"></a>std::shared_ptr</h4><p><code>std::shared_ptr</code> 是一种引用计数的智能指针，也称共享型智能指针，它允许多个 std::shared_ptr 实例共享同一个对象的所有权。当最后一个拥有对象的 std::shared_ptr 被销毁或重置时，对象会被自动删除。</p><p><strong>语法</strong>：</p><p>使用构造函数创建 <code>std::shared_ptr</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Type&gt; <span class="title function_">ptr</span><span class="params">(new Type(args...))</span>;</span><br></pre></td></tr></table></figure><p>也可以使用 <code>std::make_shared</code> 模板函数来创建<code>std::shared_ptr</code>， <code>std::make_shared</code>函数在C++11 引入的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> ptr = <span class="built_in">std</span>::make_shared&lt;Type&gt;(args...);</span><br></pre></td></tr></table></figure><ul><li><strong>Type</strong>：要创建的对象的类型。</li><li><strong>args</strong>：传递给对象构造函数的参数列表。</li></ul><p><strong>代码示例</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    MyClass() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;MyClass created\n&quot;</span>; &#125;</span><br><span class="line">    ~MyClass() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;MyClass destroyed\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// std::shared_ptr&lt;MyClass&gt; sharedPtr1(new MyClass());</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;MyClass&gt; sharedPtr1 = <span class="built_in">std</span>::make_shared&lt;MyClass&gt;();</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;MyClass&gt; sharedPtr2 = sharedPtr1; <span class="comment">// 共享所有权</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Inside block\n&quot;</span>;</span><br><span class="line">    &#125; <span class="comment">// sharedPtr2 被销毁，对象不会被删除，因为 sharedPtr1 仍然存在</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Outside block\n&quot;</span>;</span><br><span class="line">&#125; <span class="comment">// sharedPtr1 被销毁，对象现在被删除</span></span><br></pre></td></tr></table></figure><h4 id="std-weak-ptr"><a href="#std-weak-ptr" class="headerlink" title="std::weak_ptr"></a>std::weak_ptr</h4><p><code>std::weak_ptr</code>是一种非拥有（弱）引用计数的智能指针，它指向由某个 <code>std::shared_ptr</code> 所管理的对象。它不会增加对象的引用计数，这样就避免了潜在的循环引用问题。</p><p><strong>语法</strong>：</p><p>你可以通过从一个 std::shared_ptr 或另一个 std::weak_ptr 创建一个 std::weak_ptr：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::weak_ptr&lt;Type&gt; <span class="title function_">weakPtr</span><span class="params">(sharedPtr)</span>;</span><br></pre></td></tr></table></figure><p><strong>示例代码</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span> <span class="comment">// 前向声明</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;B&gt; bPtr;</span><br><span class="line">    ~A() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;A destroyed\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">std</span>::weak_ptr&lt;A&gt; aPtr; <span class="comment">// 使用 weak_ptr 解决循环引用</span></span><br><span class="line">    ~B() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;B destroyed\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;A&gt; <span class="title function_">a</span><span class="params">(new A())</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;B&gt; <span class="title function_">b</span><span class="params">(new B())</span>;</span><br><span class="line">    a-&gt;bPtr = b;</span><br><span class="line">    b-&gt;aPtr = a; <span class="comment">// B 持有 A 的弱引用，不增加引用计数</span></span><br><span class="line">&#125; <span class="comment">// a 和 b 能够正确被销毁，避免了循环引用导致的内存泄露</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这个示例中，A 和 B 相互引用。如果它们都使用 std::shared_ptr 进行引用，则会创建循环引用，导致对象无法被正确销毁。通过让 B 中的 A 引用成为 std::weak_ptr，我们打破了循环引用，使对象能够在不再被需要时正确地被销毁。</p><h4 id="总结-6"><a href="#总结-6" class="headerlink" title="总结:"></a>总结:</h4><p><code>std::shared_ptr 和 std::weak_ptr</code> 提供了强大的内存管理功能，帮助避免了内存泄露和循环引用问题。std::shared_ptr 通过引用计数机制管理对象生命周期，而 std::weak_ptr 允许对这些对象进行弱引用，这对于实现如缓存、观察者模式等功能非常有用。</p><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><h4 id="noexcept-关键字"><a href="#noexcept-关键字" class="headerlink" title="noexcept 关键字"></a>noexcept 关键字</h4><p><code>noexcept</code> 是 C++11 引入的一个关键字，用于指定函数不会抛出异常。它有两种主要用法：<strong>一种是作为异常规范</strong>，用来标明函数不会抛出任何异常；<strong>另一种是作为运算符</strong>，用来检查表达式是否可能抛出异常。</p><p><strong>作为异常规范</strong></p><p>当 <code>noexcept</code> 用作异常规范时，它直接跟在函数声明的参数列表之后。这表明函数保证不抛出任何异常。如果函数违反了这一保证，即它抛出了异常，程序将调用 <code>std::terminate</code>，通常会导致程序终止。</p><p><strong>语法</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">function</span><span class="params">()</span> noexcept;</span><br></pre></td></tr></table></figure><p><strong>示例</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">noThrow</span><span class="params">()</span> noexcept &#123;</span><br><span class="line">    <span class="comment">// 这个函数保证不会抛出异常</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        noThrow(); <span class="comment">// 安全调用，不会抛出异常</span></span><br><span class="line">    &#125; catch (...) &#123;</span><br><span class="line">        <span class="comment">// 这里不会被执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>作为运算符</strong></p><p><code>noexcept</code> 运算符用来检查一个表达式是否保证不抛出异常。它的结果是一个编译时的布尔值，如果表达式保证不抛出异常，结果为 <code>true</code>，否则为 <code>false</code>。</p><p><strong>语法</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">noexcept(expression)</span><br></pre></td></tr></table></figure><p><strong>示例</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mayThrow</span><span class="params">()</span> &#123;</span><br><span class="line">    throw <span class="built_in">std</span>::runtime_error(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">noThrow</span><span class="params">()</span> noexcept &#123;</span><br><span class="line">    <span class="comment">// 不会抛出异常</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::boolalpha;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;mayThrow() noexcept? &quot;</span> &lt;&lt; noexcept(mayThrow()) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: false</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;noThrow() noexcept? &quot;</span> &lt;&lt; noexcept(noThrow()) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  <span class="comment">// 输出: true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>noexcept 规范和 noexcept 运算符的区别</strong>:</p><ul><li><strong>noexcept 规范</strong>：用来标明一个函数不会抛出任何异常。如果函数声明为 noexcept 但抛出了异常，程序将调用 std::terminate。</li><li><strong>noexcept 运算符</strong>：用来检查一个表达式是否保证不抛出异常。这对于模板编程和泛型编程中根据是否可能抛出异常来进行不同的代码路径优化特别有用。</li></ul><p>使用 noexcept 的优势:</p><ul><li><strong>性能优化</strong>：编译器可以对标记为 noexcept 的函数进行更多优化，因为它知道这些函数不会抛出异常。</li><li><strong>异常安全保证</strong>：通过明确指出哪些函数是不会抛出异常的，可以帮助编写更清晰、更健壮的代码。</li></ul><p>总之，<code>noexcept</code>是 C++11 引入的一个重要特性，它提高了异常安全性，并且在编写需要异常保证的函数时提供了更多的灵活性。</p><h4 id="异常传递工具"><a href="#异常传递工具" class="headerlink" title="异常传递工具"></a>异常传递工具</h4><p>在 C++11 中，引入了一组异常传递工具，允许在程序的不同部分之间传递异常信息。这些工具主要包括 <code>std::exception_ptr</code>、<code>std::current_exception</code> 和 <code>std::rethrow_exception</code>，它们定义在 <code>&lt;exception&gt; </code>头文件中。这些机制特别适用于多线程编程，其中异常可能在一个线程中抛出并需要在另一个线程中被捕获和处理。</p><p><strong>std::exception_ptr</strong></p><p><code>std::exception_ptr</code> 是一个智能指针，用于存储和传递异常对象的信息。它可以捕获任何抛出的异常，并允许在稍后的时间点重新抛出该异常，无论异常的类型如何。</p><p><strong>std::current_exception</strong></p><p><code>std::current_exception</code> 用于捕获当前抛出的异常，并返回一个 std::exception_ptr，指向该异常对象的拷贝。如果当前没有异常被抛出，它返回一个空的 std::exception_ptr。</p><p><strong>std::rethrow_exception</strong></p><p><code>std::rethrow_exception</code> 接受一个 std::exception_ptr 作为参数，并重新抛出由该指针所指向的异常。这允许在异常被捕获后的任何时间点重新抛出相同的异常。</p><p><strong>示例代码</strong>：</p><p>下面的代码演示了如何使用这些异常传递工具来捕获、存储、传递和重新抛出异常：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">processException</span><span class="params">(<span class="built_in">std</span>::exception_ptr eptr)</span> &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        <span class="keyword">if</span> (eptr) &#123;</span><br><span class="line">            <span class="built_in">std</span>::rethrow_exception(eptr); <span class="comment">// 重新抛出异常</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (<span class="type">const</span> <span class="built_in">std</span>::exception&amp; e) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Handled exception: &quot;</span> &lt;&lt; e.what() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::exception_ptr eptr;</span><br><span class="line">    </span><br><span class="line">    try &#123;</span><br><span class="line">        throw <span class="built_in">std</span>::runtime_error(<span class="string">&quot;A runtime error occurred&quot;</span>);</span><br><span class="line">    &#125; catch (...) &#123;</span><br><span class="line">        eptr = <span class="built_in">std</span>::current_exception(); <span class="comment">// 捕获并存储当前异常</span></span><br><span class="line">    &#125;</span><br><span class="line">    processException(eptr); <span class="comment">// 处理存储的异常</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在这个示例中</strong>：</p><ul><li>首先，在 main 函数中，一个 std::runtime_error 异常被抛出。</li><li>接着使用 catch (…) 捕获这个异常，并通过调用 std::current_exception 将其存储在 std::exception_ptr 中。</li><li>然后，将这个 std::exception_ptr 传递给 processException 函数。</li><li>在 processException 函数中，使用 std::rethrow_exception 重新抛出异常，然后在另一个 catch 块中捕获并处理它。</li></ul><p>重新抛出异常而不是直接处理，主要是为了：</p><ul><li><strong>保持灵活性</strong>：可以在更合适的地方或时间处理异常。</li><li><strong>保存信息</strong>：保留完整的异常信息，便于后续调试和诊断。</li><li><strong>统一处理</strong>：方便在程序的一个集中地点处理所有异常。</li></ul><p>这套异常传递工具为异常的传递和处理提供了极大的灵活性，尤其是在复杂的程序结构或多线程环境中。</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>本篇文章旨在为热衷于掌握 C++11 新特性的朋友们提供一份实用的学习指南。通过介绍各项新特性并辅以实际代码示例，希望初学者能够不仅理解这些特性背后的概念，还能<strong>学会如何在实际项目中应用它们</strong>。</p><p>C++11 的新特性覆盖了<strong>语言核心和标准库</strong>的方方面面，从简化代码书写、提高性能，到增强代码的安全性和可读性，接下来我们简单来回顾下上面所讲的。</p><ul><li>自动类型推断 (auto 和 decltype) 使得变量声明更加简洁，让编译器为我们做更多的工作。</li><li>基于范围的 for 循环 让遍历容器和序列变得更加直观。</li><li>统一的初始化方式 和 初始器列表 为各种对象和容器的初始化提供了一致的语法。</li><li>智能指针（如 std::unique_ptr, std::shared_ptr 和 std::weak_ptr）管理动态分配的内存，使得资源管理更加安全和方便。</li><li>并发编程 特性（包括 std::thread, std::async 等）允许我们更好地利用现代多核处理器的计算能力。</li><li>异常处理 得到增强，noexcept 关键字和新的异常传递工具让异常的处理和传递更加灵活和安全。</li><li>Lambda 表达式 和 函数对象 让编写匿名函数变得简单，为 STL 算法等的使用提供了巨大的便利。</li></ul><h3 id="最后："><a href="#最后：" class="headerlink" title="最后："></a>最后：</h3><p>如果你对 C&#x2F;C++&#x2F;Go 语言学习 + 计算机基础 + Linux编程 + 容器技术等内容感兴趣，不妨关注我的公众号—「跟着小康学编程」。这里会定时更新相关的技术文章，感兴趣的读者可以关注一下：</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png">   </p><p>另外，小康最近新创建了一个技术交流群，大家如果在阅读的过程中有遇到问题或者有不理解的地方，欢迎大家加群询问或者评论区询问，我能解决的都尽可能给大家回复。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程语言学习 </category>
          
          <category> C++ 编程教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11 新特性 </tag>
            
            <tag> Modern C++ </tag>
            
            <tag> auto 关键字 </tag>
            
            <tag> Lambda 表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何快速学习 C 语言？</title>
      <link href="/how-to-learn-C/"/>
      <url>/how-to-learn-C/</url>
      
        <content type="html"><![CDATA[<p>大家好，我是小康，今天我们来聊下如何学习 C 语言。</p><p>C 语言，强大而灵活，是许多现代编程语言的基石。本文将带你快速了解 C语言 的基础知识，无论你是编程新手还是希望回顾基础，这里都有你需要的。</p><p>初学者在开始学习 C 语言的时候，往往不知道怎样高效的学习这门课，网上很多人都会推荐去看各种 C 语言书籍，我觉得没必要去看那么多，贪多嚼不烂！为了让更多初学的朋友快速入门 C 语言，我这里将 C 的各个知识点进行了汇总，并附有代码示例，以便大家理解，掌握这些就可以啦。如果你时间比较充足，可以看<strong>丹尼斯·里奇的《C程序设计语言》</strong> 这本书，再搭配浙大<strong>翁恺</strong>的 C 语言课程：<a href="https://www.bilibili.com/video/BV1Ls411w7rx/?spm_id_from=333.337.search-card.all.click&vd_source=404f52a7ebbf2477ea859f9609a15c65">C语言程序设计 浙江大学：翁恺_哔哩哔哩_bilibili</a></p><p><strong>最佳的学习方法就是</strong>：根据<strong>我的知识点</strong>来看丹尼斯·里奇的《C程序设计语言》，再加上翁恺的 C 语言课程，搭配学习，效果最好。如果你认为自己自学能力很好或者时间有限，那么完全不需要看视频，本篇文章已经囊括了全部的知识点。</p><p>废话不多说了，直接带你快速入门 C 语言编程。</p><p><img src="/images/C%E8%AF%AD%E8%A8%80/1.png"></p><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h3 id="1-标识符和关键字"><a href="#1-标识符和关键字" class="headerlink" title="1.标识符和关键字"></a>1.标识符和关键字</h3><p>标识符用于<strong>变量、函数</strong>的名称。规则：由字母、数字、下划线组成，但不以数字开头。</p><p>关键字是 C 语言中已定义的特殊单词，如 <strong>int、return</strong> 等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line"><span class="type">int</span> variable; <span class="comment">// &#x27;int&#x27; 是关键字, &#x27;variable&#x27; 是标识符</span></span><br></pre></td></tr></table></figure><h3 id="2-变量和常量"><a href="#2-变量和常量" class="headerlink" title="2.变量和常量"></a>2.变量和常量</h3><p>变量是可以改变值的标识符。</p><p>常量是一旦定义，其值不可改变的标识符。常量使用 <code>const</code>来定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line"><span class="type">int</span> age = <span class="number">25</span>;       <span class="comment">// 定义变量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_AGE = <span class="number">99</span>; <span class="comment">// 定义常量</span></span><br></pre></td></tr></table></figure><h3 id="3-运算符和表达式"><a href="#3-运算符和表达式" class="headerlink" title="3.运算符和表达式"></a>3.运算符和表达式</h3><p>在 C 语言中，运算符是用于执行特定数学和逻辑计算的符号。运算符可以根据它们的功能和操作数的数量被分为几个不同的类别。</p><h4 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h4><p>这些运算符用于执行基本的数学计算。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ 加法</span><br><span class="line">- 减法</span><br><span class="line">* 乘法</span><br><span class="line">/ 除法</span><br><span class="line">% 取余（模运算，只适用于整数）</span><br></pre></td></tr></table></figure><h4 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h4><p>关系运算符用于比较两个值之间的大小关系。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">== 等于</span><br><span class="line">!= 不等于</span><br><span class="line">&gt; 大于</span><br><span class="line">&lt; 小于</span><br><span class="line">&gt;= 大于等于</span><br><span class="line">&lt;= 小于等于</span><br></pre></td></tr></table></figure><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><p>逻辑运算符用于连接多个条件（布尔值）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;&amp; 逻辑与</span><br><span class="line">|| 逻辑或</span><br><span class="line">! 逻辑非</span><br></pre></td></tr></table></figure><h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h4><p>赋值运算符用于将值分配给变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">= 简单赋值</span><br><span class="line">+= 加后赋值</span><br><span class="line">-= 减后赋值</span><br><span class="line">*= 乘后赋值</span><br><span class="line">/= 除后赋值</span><br><span class="line">%= 取余后赋值</span><br></pre></td></tr></table></figure><h4 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h4><p>位运算符对整数的二进制表示进行操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&amp; 位与</span><br><span class="line">| 位或</span><br><span class="line">^ 位异或</span><br><span class="line">~ 位非</span><br><span class="line">&lt;&lt; 左移</span><br><span class="line">&gt;&gt; 右移</span><br></pre></td></tr></table></figure><h4 id="递增和递减运算符"><a href="#递增和递减运算符" class="headerlink" title="递增和递减运算符"></a>递增和递减运算符</h4><p>这些运算符用于增加或减少变量的值。此类运算符都只作用于一个操作数，因此也被称之为一元运算符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">++ 递增运算符</span><br><span class="line">-- 递减运算符</span><br></pre></td></tr></table></figure><h4 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h4><p>C 语言提供了一个三元运算符用于基于条件选择两个值之一。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">? : 条件运算符</span><br></pre></td></tr></table></figure><p>下面是一些使用这些运算符的简单示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> result;</span><br><span class="line"></span><br><span class="line">result = a + b; <span class="comment">// 加法</span></span><br><span class="line">result = a &gt; b ? a : b; <span class="comment">// 条件运算符，选择a和b之间的较大者</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line">flag = !flag; <span class="comment">// 逻辑非，flag的值变为0</span></span><br><span class="line"></span><br><span class="line">result = a &amp; b; <span class="comment">// 位与运算</span></span><br><span class="line"></span><br><span class="line">a++; <span class="comment">// 递增a的值</span></span><br></pre></td></tr></table></figure><p>表达式是<strong>运算符和操作数</strong>组合成的序列。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line"><span class="type">int</span> sum = <span class="number">10</span> + <span class="number">5</span>; <span class="comment">// &#x27;+&#x27; 是运算符, &#x27;10 + 5&#x27; 是表达式,10，5 是操作数</span></span><br></pre></td></tr></table></figure><h3 id="4-语句"><a href="#4-语句" class="headerlink" title="4.语句"></a>4.语句</h3><p>C语言中的<strong>语句</strong>是构成程序的<strong>基本单位</strong>，用于表达特定的操作或逻辑。它们可以控制程序的流程、执行计算、调用函数等。语句以分号（;）结束，形成了程序的执行步骤。</p><p> C 语言的语句可以分为以下几类：</p><h4 id="表达式语句："><a href="#表达式语句：" class="headerlink" title="表达式语句："></a>表达式语句：</h4><p>最常见的语句，执行一个操作，如赋值、函数调用等，并以分号结束。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = b + c;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello, World!\n&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="复合语句（块）"><a href="#复合语句（块）" class="headerlink" title="复合语句（块）"></a>复合语句（块）</h4><p>由花括号{}包围的一系列语句和声明，允许将多个语句视为单个语句序列。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h4><p>根据表达式的真假来执行不同的代码块。</p><ul><li><p>if语句：是最基本的条件语句，根据条件的真假来执行相应的代码块。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    <span class="comment">// 条件为真时执行</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 条件为假时执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>switch语句</strong>：根据表达式的值选择多个代码块之一执行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(expression) &#123;</span><br><span class="line">    <span class="keyword">case</span> constant1:</span><br><span class="line">        <span class="comment">// 表达式等于 constant1 时执行</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> constant2:</span><br><span class="line">        <span class="comment">// 表达式等于 constant2 时执行</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// 无匹配时执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h4><p>重复执行一段代码直到给定的条件不满足。</p><ul><li><p><strong>while循环</strong>：先判断条件，条件满足则执行循环体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (condition) &#123;</span><br><span class="line">    <span class="comment">// 条件为真时执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>do-while循环</strong>：先执行一次循环体，然后判断条件。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// 至少执行一次</span></span><br><span class="line">&#125; <span class="keyword">while</span> (condition);</span><br></pre></td></tr></table></figure><ul><li><strong>for循环</strong>：在循环开始时初始化变量，然后判断条件，最后在每次循环结束时执行更新表达式。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (initialization; condition; increment) &#123;</span><br><span class="line">         <span class="comment">// 条件为真时执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 示例：</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="跳转语句"><a href="#跳转语句" class="headerlink" title="跳转语句"></a>跳转语句</h4><p>提供了改变代码执行顺序的能力。</p><ul><li><strong>break语句</strong>：用于立即退出最近的<code>switch</code>或循环（<code>while</code>、<code>do-while</code>、<code>for</code>）语句。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">5</span>) </span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// 当 i 等于5时退出循环 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>continue语句</strong>：跳过当前循环的剩余部分，并继续下一次循环的执行（仅适用于<code>while</code>、<code>do-while</code>、<code>for</code>循环）。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">5</span>) <span class="keyword">continue</span>; <span class="comment">// 当i等于5时，跳过当前循环的剩余部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong><code>goto</code>语句</strong>：将控制转移到程序中标记的位置。尽管存在，但建议避免使用<code>goto</code>，因为它使得程序的流程变得难以追踪和理解。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">label:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This is a label.&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">goto</span> label;     </span><br></pre></td></tr></table></figure></li></ul><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>数据类型的一个常见用途就是：<strong>定义变量</strong>。常见的数据类型可以大致分为以下几个类别：</p><h4 id="1-基本类型"><a href="#1-基本类型" class="headerlink" title="1.基本类型"></a>1.基本类型</h4><p><strong>整型</strong>：</p><p>整数类型用于存储整数值，可以是有符号的（可以表示负数）或无符号的（仅表示非负数）。其中 int 是最常用的整数类型。为了适应不同的精度需求和内存大小限制，C语言提供了几种不同大小的整数类型。</p><p><strong>有符号整型</strong>：</p><ul><li>short int 或简写为short，用于存储较小范围的整数。它至少占用16位（2个字节）的存储空间。</li><li>int 是最基本的整数类型，用于存储标准整数。在大多数现代编译器和平台上，它占用32位（4个字节）。</li><li>long int 或简写为 long，用于存储比int更大范围的整数。它至少占用32位，但在一些平台上可能会占用64位（8个字节）。</li><li>long long int 或简写为 long long，是C99标准引入的，用于提供更大范围的整数存储。它保证至少占用64位（8个字节）。</li></ul><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>;         <span class="comment">// 定义一个整形变量，初始值为5</span></span><br><span class="line"><span class="type">long</span> b = <span class="number">100000L</span>;  <span class="comment">// 定义一个长整形变量，初始值为100000</span></span><br></pre></td></tr></table></figure><p><strong>无符号整型</strong>：</p><ul><li><p>unsigned short int 或简写为 unsigned short，专门用于存储较小范围的正整数或零。这种类型至少占用16位（2个字节）的存储空间。</p></li><li><p>unsigned int 是用于存储标准大小的非负整数的基本类型。在大多数现代编译器和平台上，它占用32位（4个字节）。</p></li><li><p>unsigned long int 或简写为 unsigned long，用于存储大范围的非负整数。这种类型至少占用32位，在其他平台上可能占用64位（8个字节）</p></li><li><p>unsigned long long int 或简写为 unsigned long long，是为了在需要非常大范围的正整数时使用的。按照C99标准规定，它至少占用64位（8个字节）。</p></li></ul><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> x = <span class="number">150</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> y = <span class="number">100000UL</span>;</span><br></pre></td></tr></table></figure><p><strong>浮点型:</strong></p><p>浮点类型用于存储实数（小数点数字），包括 float 和 double。</p><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> f = <span class="number">5.25f</span>;</span><br><span class="line"><span class="type">double</span> d = <span class="number">10.75</span>;</span><br></pre></td></tr></table></figure><p><strong>浮点型使用场景</strong>：float 和 double：用于需要表示小数的场景，如科学计算、金融计算等。float 提供了足够的精度，适合大多数应用，而 double 提供了更高的精度，适用于需要非常精确的计算结果的场景。</p><p><strong>布尔类型:</strong><br>布尔类型 bool 用于表示真（true）或假（false）。</p><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> flag = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p><strong>布尔类型使用场景</strong>：bool 类型一般用于逻辑判断，表示条件是否满足。常用于控制语句（如if、while）的条件表达式，或表示函数返回的成功、失败状态。</p><p><strong>枚举类型:</strong><br>枚举（enum）允许定义一组命名的整数常量。使用关键字<code>enum</code>定义枚举类型变量。</p><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">day</span> &#123;</span>sun, mon, tue, wed, thu, fri, sat&#125;;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">day</span> <span class="title">today</span> =</span> mon;</span><br></pre></td></tr></table></figure><p><strong>枚举类型使用场景</strong>：<br>枚举类型 enum 用于定义一组命名的整数常量，使程序更易于阅读和维护。常用于表示状态、选项、配置等固定的集合。</p><h4 id="2-复合类型"><a href="#2-复合类型" class="headerlink" title="2.复合类型:"></a>2.复合类型:</h4><p><strong>结构体</strong></p><p>结构体（struct）允许将多个不同类型的数据项组合成一个类型。使用关键字<code>struct</code>定义结构体。</p><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义 Person 结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义结构体变量 person1</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">person1</span>;</span></span><br></pre></td></tr></table></figure><p><strong>结构体类型使用场景</strong>：用于组合不同类型的数据项，表示具有结构的数据。</p><ul><li><p><strong>表示实体或对象</strong>：用于封装和表示具有多个属性的复杂实体，如人、书籍、产品等。</p></li><li><p><strong>数据记录</strong>：组织和管理具有多个相关字段的数据记录，适用于数据库记录、日志条目等。</p></li><li><p><strong>网络编程</strong>：构造和解析网络协议的数据包，适用于客户端和服务器之间的通信。</p></li><li><p><strong>创建复杂的数据结构</strong>：作为链表、树、图等复杂数据结构的基本构建块，通过指针连接结构体实现。</p></li></ul><p><strong>联合体</strong></p><p>联合体（union）在 C 语言中是一个用于优化内存使用的特殊数据类型，允许在同一内存位置存储不同的数据类型，但任一时刻只能使用其中一个成员。联合体变量使用关键字<code>union</code> 来定义。</p><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Data</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">float</span> f;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Data</span> <span class="title">data</span>;</span></span><br></pre></td></tr></table></figure><p><strong>联合体类型使用场景</strong>：</p><ul><li><p><strong>节省内存</strong>：当程序中的变量可能代表不同类型的数据，但不会同时使用时，联合体能有效减少内存占用。</p></li><li><p><strong>底层编程</strong>：在需要直接与硬件交互，或需要精确控制数据如何存储和解读时，联合体提供了直接访问内存表示的能力。</p></li><li><p><strong>网络通信</strong>：用于根据不同的协议或消息类型解析同一段网络数据。</p></li><li><p><strong>类型转换</strong>：允许以一种数据类型写入联合体，然后以另一种类型读取，实现不同类型之间的快速转换。</p></li></ul><h4 id="3-派生类型："><a href="#3-派生类型：" class="headerlink" title="3.派生类型："></a>3.派生类型：</h4><p><strong>数组</strong></p><p>数组是一种派生类型，它允许存储固定数量的同类型元素。当然，类型可以是多种，整形，浮点型，结构体等类型。在内存中，数组的元素按顺序紧密排列。数组的使用使得数据管理更加方便，尤其是当你需要处理大量<strong>同质数据</strong>时。</p><blockquote><p><strong>同质数据</strong>:具有相同数据类型的元素或值</p></blockquote><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, numbers[<span class="number">0</span>]); <span class="comment">// 输出数组的第一个元素</span></span><br></pre></td></tr></table></figure><p>数组的索引从<code>0</code>开始，<code>numbers[0]</code>表示数组中的第一个元素。</p><p><strong>指针</strong></p><p>指针是存储另一个变量地址的变量。指针在C语言中非常重要，它提供了直接访问内存的能力，使得程序可以通过地址来操作变量。</p><p><strong>声明和使用指针</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> var = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *ptr = &amp;var; <span class="comment">// 声明一个指针 ptr，并将其初始化为 var 的地址</span></span><br></pre></td></tr></table></figure><p>通过指针访问值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;Value of var: %d\n&quot;, *ptr); // 使用解引用操作符*来访问指针指向的值</span><br></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>上面有提到过数组的概念，接下来让我们来详细讲解下数组：</p><p>数组是一种存储固定数量同类型元素的线性集合。在C语言中，这意味着如果你<strong>有一组相同类型的数据</strong>要存储，比如一周内每天的温度，那数组就是你的首选。</p><h3 id="声明与初始化"><a href="#声明与初始化" class="headerlink" title="声明与初始化"></a>声明与初始化</h3><p>声明数组的语法相当直观。比如，你想存储5个整数，可以这样声明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> days[len];</span><br></pre></td></tr></table></figure><p>这里，int表明了数组中元素的类型，days是数组的名称，而[len]则指定了数组可以存储元素的个数，len 必须是数值常量。</p><p>初始化数组可以在声明的同时进行，确保数组中的每个元素都有一个明确的起始值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> days[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure><p>如果数组的大小在初始化时已知，你甚至可以省略大小声明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> days[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure><h3 id="访问与遍历"><a href="#访问与遍历" class="headerlink" title="访问与遍历"></a>访问与遍历</h3><p>数组的元素可以通过索引（或下标）进行访问，索引从<code>0</code>开始，这意味着在上面的 days 数组中，第一个元素是<code>days[0]</code>，最后一个元素是<code>days[4]</code>。</p><p>遍历数组，即访问数组中的每个元素，通常使用循环结构，如for循环：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, days[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><p>多维数组是一种直接在类型声明时定义多个维度的数组。它们通常用于存储具有多个维度的数据，如矩阵或数据表。</p><h4 id="定义和初始化"><a href="#定义和初始化" class="headerlink" title="定义和初始化"></a>定义和初始化</h4><p>多维数组的定义遵循这样的格式：类型 名称[维度1大小][维度2大小]…[维度N大小];</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> matrix[<span class="number">2</span>][<span class="number">3</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这定义了一个2x3的整型矩阵，并进行了初始化。</p><h4 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h4><p>访问多维数组的元素需要提供每一个维度的索引：数组名[索引1][索引2]…[索引N];</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> value = matrix[<span class="number">1</span>][<span class="number">2</span>]; <span class="comment">// 访问第二行第三列的元素</span></span><br></pre></td></tr></table></figure><h3 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h3><p>动态数组提供了一种在运行时确定数组大小的能力，通过动态内存分配函数来实现。</p><h4 id="动态一维数组"><a href="#动态一维数组" class="headerlink" title="动态一维数组:"></a>动态一维数组:</h4><p>动态一维数组通常通过指针和 malloc 或 calloc 函数创建：</p><p>malloc 分配的内存是未初始化的，而 calloc 会将内存初始化为零。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *arr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">10</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 分配10个整数的空间</span></span><br></pre></td></tr></table></figure><h4 id="动态多维数组"><a href="#动态多维数组" class="headerlink" title="动态多维数组:"></a>动态多维数组:</h4><p>动态多维数组的创建稍微复杂，因为需要为每个维度分别进行内存分配：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> **matrix = (<span class="type">int</span>**)<span class="built_in">malloc</span>(<span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>*)); <span class="comment">// 创建2个指针的数组，对应2行</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">    matrix[i] = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 为每行分配3个整数的空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用完动态数组后，必须<strong>手动释放其内存以避免内存泄漏</strong>：</p><h4 id="动态一维数组内存的释放："><a href="#动态一维数组内存的释放：" class="headerlink" title="动态一维数组内存的释放："></a>动态一维数组内存的释放：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">free</span>(arr)</span><br></pre></td></tr></table></figure><h4 id="动态多维数组内存的释放："><a href="#动态多维数组内存的释放：" class="headerlink" title="动态多维数组内存的释放："></a>动态多维数组内存的释放：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">free</span>(matrix[i]); <span class="comment">// 释放每一行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(matrix); <span class="comment">// 最后释放指针数组</span></span><br></pre></td></tr></table></figure><h3 id="数组与函数"><a href="#数组与函数" class="headerlink" title="数组与函数"></a>数组与函数</h3><p>在 C 语言中，数组可以作为参数传递给函数。不过，由于数组在传递时会退化为指向其首元素的指针，我们需要另外传递数组的大小：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="built_in">array</span>[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line"><span class="type">int</span> len = <span class="keyword">sizeof</span>(<span class="built_in">array</span>)/<span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>]); <span class="comment">//计算数组的长度</span></span><br><span class="line">printArray(<span class="built_in">array</span>,len);</span><br><span class="line"><span class="comment">//printArray(array,len) 被调用时，printArray函数形参arr会退化成 int*</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printArray</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组使用场景："><a href="#数组使用场景：" class="headerlink" title="数组使用场景："></a>数组使用场景：</h3><ul><li><strong>固定大小集合</strong>：适用于存储已知数量的数据元素。</li><li><strong>顺序访问和高效索引</strong>：数组元素存储在连续的内存地址中，可以通过索引快速访问。</li><li><strong>多维数据表示</strong>：可以方便地表示多维数据结构，如二维数组表示矩阵。</li></ul><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>在 C 语言中，指针是一种特殊的变量类型，它的值是内存中另一个变量的地址。指针提供了一种方式来间接访问和操作内存中的数据。</p><p>可以把指针想象成一个指向内存中某个位置的箭头。每个变量都占用内存中的一定空间，指针的作用就是记录那个空间的起始地址。</p><h3 id="定义指针"><a href="#定义指针" class="headerlink" title="定义指针"></a>定义指针</h3><p>指针的定义需要指定指针类型，它表明了指针所指向的数据的类型。定义指针的一般形式是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type* pointerName;</span><br></pre></td></tr></table></figure><p>其中 type 是指针所指向的数据的类型，*表示这是一个指针变量，pointerName 是指针变量的名称。</p><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* ptr; <span class="comment">// 定义一个指向int类型数据的指针</span></span><br></pre></td></tr></table></figure><p>这个声明创建了一个名为ptr的指针，它可以指向int类型的数据。开始时，ptr未被初始化，它可能包含任意值（即任意地址）。在使用指针之前，通常会将其初始化为某个变量的地址，或者通过动态内存分配函数分配的内存块的地址。</p><h3 id="指针的初始化"><a href="#指针的初始化" class="headerlink" title="指针的初始化"></a>指针的初始化</h3><p>指针可以通过使用地址运算符 &amp; 来获取变量的地址进行初始化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> var = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* ptr = &amp;var; <span class="comment">// ptr现在指向var</span></span><br></pre></td></tr></table></figure><p>或者，指针也可以被初始化为动态分配的内存地址：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// ptr指向一块新分配的int大小的内存</span></span><br></pre></td></tr></table></figure><h3 id="使用指针"><a href="#使用指针" class="headerlink" title="使用指针"></a>使用指针</h3><h4 id="解引用（Dereferencing）"><a href="#解引用（Dereferencing）" class="headerlink" title="解引用（Dereferencing）"></a>解引用（Dereferencing）</h4><p>通过解引用操作*，可以访问或修改指针所指向的内存位置中存储的数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*ptr = <span class="number">20</span>; <span class="comment">// 修改ptr所指向的内存中的值为20</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,*ptr); <span class="comment">// 输出指针指向的数据</span></span><br></pre></td></tr></table></figure><h4 id="指针运算"><a href="#指针运算" class="headerlink" title="指针运算"></a>指针运算</h4><p>指针的真正强大之处在于它能进行算术运算，这使得通过指针遍历数组和访问数据变得非常高效。</p><ul><li><strong>递增（++）</strong>：指针递增，其值增加了指向类型的大小（如int是4字节）。</li><li><strong>递减（–）</strong>：与递增相反，指针递减会减去指向类型的大小。</li><li><strong>指针的加减</strong>：可以将指针与整数相加或相减，改变其指向。</li></ul><p>指针递增（++）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">10</span>, <span class="number">20</span>&#125;;</span><br><span class="line"><span class="type">int</span> *ptr = arr;</span><br><span class="line">ptr++; <span class="comment">// 现在指向arr[1]</span></span><br></pre></td></tr></table></figure><p>指针递减（–）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptr--; <span class="comment">// 回到arr[0]</span></span><br></pre></td></tr></table></figure><p>指针的加减</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ptr += <span class="number">1</span>; <span class="comment">// 移动到arr[1]</span></span><br><span class="line">ptr -= <span class="number">1</span>; <span class="comment">// 回到arr[0]</span></span><br></pre></td></tr></table></figure><h3 id="指针与数组"><a href="#指针与数组" class="headerlink" title="指针与数组"></a>指针与数组</h3><p>数组名在表达式中会被当作指向其首元素的指针。这意味着数组和指针在很多情况下可以互换使用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> *p = arr; <span class="comment">// 指向数组首元素的指针</span></span><br></pre></td></tr></table></figure><h3 id="指针与函数"><a href="#指针与函数" class="headerlink" title="指针与函数"></a>指针与函数</h3><p>函数参数为指针，通过传递指针给函数，可以让函数直接修改变量的值，而不是在副本上操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">addTen</span><span class="params">(<span class="type">int</span> *p)</span> &#123;</span><br><span class="line">    *p += <span class="number">10</span>; <span class="comment">// 直接修改原始值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="返回指针的函数"><a href="#返回指针的函数" class="headerlink" title="返回指针的函数"></a>返回指针的函数</h3><p>函数也可以返回指针，但要确保指针指向的是静态内存或者是动态分配的内存，避免悬挂指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回静态内存地址</span></span><br><span class="line"><span class="type">int</span>* <span class="title function_">getStaticValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> value = <span class="number">10</span>; <span class="comment">// 静态局部变量</span></span><br><span class="line">    <span class="keyword">return</span> &amp;value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回动态分配内存地址</span></span><br><span class="line"><span class="type">int</span>* <span class="title function_">getDynamicArray</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>*)<span class="built_in">malloc</span>(size * <span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 动态分配内存</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>避免悬挂指针</strong>：</p><p>悬挂指针是指向已经释放或无效内存的指针。如果函数返回了指向局部非静态变量的指针，就会导致悬挂指针的问题，因为局部变量的内存在函数返回后不再有效。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="title function_">getLocalValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">10</span>; <span class="comment">// 局部变量</span></span><br><span class="line">    <span class="keyword">return</span> &amp;value; <span class="comment">// 错误：返回指向局部变量的指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是错误的做法，因为 value 是局部变量，在函数结束时被销毁，返回的指针指向一个已经不存在的内存位置。</p><h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><p>函数指针存储了函数的地址，可以用来动态调用函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数原型</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">greet</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, World!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数指针声明</span></span><br><span class="line"><span class="type">void</span> (*funcPtr)(<span class="type">void</span>) = &amp;greet;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过函数指针调用函数</span></span><br><span class="line">funcPtr();</span><br></pre></td></tr></table></figure><h3 id="指针数组与函数"><a href="#指针数组与函数" class="headerlink" title="指针数组与函数"></a>指针数组与函数</h3><p>指针数组可以用来存储函数指针，实现函数的动态调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义两个简单的函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">world</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;World\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个函数指针数组并初始化</span></span><br><span class="line">    <span class="type">void</span> (*funcPtrs[<span class="number">2</span>])() = &#123;hello, world&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 动态调用函数</span></span><br><span class="line">    funcPtrs[<span class="number">0</span>](); <span class="comment">// 调用hello函数</span></span><br><span class="line">    funcPtrs[<span class="number">1</span>](); <span class="comment">// 调用world函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个示例中，funcPtrs是一个存储函数指针的数组。通过指定索引，我们可以动态地调用hello或world函数。</p><h3 id="多级指针"><a href="#多级指针" class="headerlink" title="多级指针"></a>多级指针</h3><p>多级指针，例如二级指针，是指针的指针。它们在处理多维数组、动态分配的多维数据结构等场景中非常有用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> var = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> *ptr = &amp;var;</span><br><span class="line"><span class="type">int</span> **pptr = &amp;ptr; <span class="comment">// 二级指针</span></span><br></pre></td></tr></table></figure><h3 id="指针使用场景："><a href="#指针使用场景：" class="headerlink" title="指针使用场景："></a>指针使用场景：</h3><ul><li><strong>动态内存管理</strong>：配合malloc、realloc、calloc等函数，实现运行时的内存分配和释放。</li><li><strong>函数参数传递</strong>：允许函数通过指针参数修改调用者中的变量值。</li><li><strong>数组和字符串操作</strong>：通过指针算术运算灵活地遍历和操作数组和字符串。</li><li><strong>构建数据结构</strong>：是实现链表、树、图等复杂数据结构的基础。</li></ul><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>在 C 语言中，字符串是以字符数组的形式存在的，以空字符 <code>\0</code>（ASCII码为<code>0</code>的字符）结尾。这意味着，当 C 语言处理字符串时，它会一直处理直到遇到这个空字符。理解这一点对于正确操作 C 语言中的字符串至关重要。</p><h3 id="声明和初始化字符串"><a href="#声明和初始化字符串" class="headerlink" title="声明和初始化字符串"></a>声明和初始化字符串</h3><p>在 C 语言中，可以使用字符数组来声明和初始化字符串：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> greeting[<span class="number">6</span>] = &#123;<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure><p>更简单的方式是使用<strong>字符串字面量</strong>，编译器会自动在字符串末尾加上\0：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> greeting[] = <span class="string">&quot;Hello&quot;</span>;</span><br></pre></td></tr></table></figure><p>字符串除了使用字符数组来表示还可以用字符指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *greeting = <span class="string">&quot;Hello&quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="字符串的输入和输出"><a href="#字符串的输入和输出" class="headerlink" title="字符串的输入和输出"></a>字符串的输入和输出</h3><p>使用 <code>printf</code> 函数输出字符串，使用%s格式指定符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, greeting);</span><br></pre></td></tr></table></figure><p>使用 <code>scanf</code> 函数读取字符串（注意，scanf在读取字符串时会因空格、制表符或换行符而停止读取）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> var;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;var); <span class="comment">// 输入整型值</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, name); <span class="comment">// 输入字符串</span></span><br><span class="line"><span class="comment">// 不需要&amp;符号，因为数组名本身就是地址</span></span><br></pre></td></tr></table></figure><h3 id="字符串操作函数"><a href="#字符串操作函数" class="headerlink" title="字符串操作函数"></a>字符串操作函数</h3><p>C 标准库（string.h）提供了一系列操作字符串的函数，包括字符串连接、复制、长度计算等。</p><h4 id="字符串复制"><a href="#字符串复制" class="headerlink" title="字符串复制"></a>字符串复制</h4><ul><li>strcpy(destination, source)：复制source字符串到destination。</li><li>strncpy(destination, source, n)：复制最多n个字符从source到destination。</li></ul><h4 id="字符串连接"><a href="#字符串连接" class="headerlink" title="字符串连接"></a>字符串连接</h4><ul><li>strcat(destination, source)：将source字符串追加到destination字符串的末尾。</li><li>strncat(destination, source, n)：将最多n个字符从source字符串追加到destination字符串的末尾。</li></ul><h4 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h4><ul><li>strcmp(str1, str2)：比较两个字符串。如果str1与str2相同，返回<code>0</code>。</li><li>strncmp(str1, str2, n)：比较两个字符串的前n个字符。</li></ul><h4 id="字符串长度"><a href="#字符串长度" class="headerlink" title="字符串长度"></a>字符串长度</h4><ul><li>strlen(str)：返回str的长度，不包括结尾的<code>\0</code>。</li></ul><h4 id="字符串查找"><a href="#字符串查找" class="headerlink" title="字符串查找"></a>字符串查找</h4><ul><li>strchr(str, c)：查找字符c在str中首次出现的位置。</li><li>strrchr(str, c)：查找字符c在str中最后一次出现的位置。</li><li>strstr(haystack, needle)：查找字符串needle在haystack中首次出现的位置。</li><li>strspn(str1, str2)：返回str1中包含的仅由str2中字符组成的最长子串的长度。</li><li>strcspn(str1, str2)：返回str1中不含有str2中任何字符的最长子串的长度。</li><li>strpbrk(str1, str2)：搜索str1中的任何字符是否在str2中出现，返回第一个匹配字符的位置。</li></ul><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li>strdup(str)：复制str字符串，使用malloc动态分配内存（非标准函数，但常见）。</li><li>memset(ptr, value, num)：将ptr开始的前num个字节都用value填充。</li><li>memcpy(destination, source, num)：从source复制num个字节到destination。</li><li>memmove(destination, source, num)：与memcpy相似，但正确处理重叠的内存区域。</li></ul><p>下面是一个简单的示例，展示如何使用部分字符串函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> str1[<span class="number">20</span>] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="type">char</span> str2[<span class="number">20</span>] = <span class="string">&quot;World&quot;</span>;</span><br><span class="line">    <span class="type">char</span> str3[<span class="number">40</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 字符串连接</span></span><br><span class="line">    <span class="built_in">strcpy</span>(str3, str1);</span><br><span class="line">    <span class="built_in">strcat</span>(str3, <span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="built_in">strcat</span>(str3, str2);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str3); <span class="comment">// 输出 &quot;Hello World&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字符串比较</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(str1, str2) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\&quot;%s\&quot; is less than \&quot;%s\&quot;\n&quot;</span>, str1, str2);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 字符串查找</span></span><br><span class="line">    <span class="type">char</span> *p = <span class="built_in">strstr</span>(str3, <span class="string">&quot;World&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (p) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Found \&quot;World\&quot; in \&quot;%s\&quot;\n&quot;</span>, str3);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数是一种让程序结构化的重要方式，允许代码的重用、模块化设计和简化复杂问题。<br>C 语言支持自定义函数和标准库函数。</p><h3 id="函数定义与声明"><a href="#函数定义与声明" class="headerlink" title="函数定义与声明:"></a>函数定义与声明:</h3><p>定义指明了函数的实际代码体（即函数做什么和如何做）。</p><p>声明告诉编译器函数的名称、返回类型和参数（类型和数量），但不定义具体的操作。</p><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">函数声明</span></span><br><span class="line"><span class="comment">int ：函数返回类型， add ： 函数名</span></span><br><span class="line"><span class="comment">int x, int y ：参数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数参数传递"><a href="#函数参数传递" class="headerlink" title="函数参数传递"></a>函数参数传递</h3><ul><li><strong>按值传递</strong>：函数收到参数值的副本。在函数内部对参数的修改不会影响原始数据。</li><li><strong>按指针（地址）传递</strong>：通过传递参数的地址（使用指针），函数内的变化可以影响原始数据。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按值传递</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">changeValue</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    num = <span class="number">100</span>; <span class="comment">// 尝试修改，实际不会影响原始值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">// x的副本被传递</span></span><br><span class="line">    changeValue(x);  <span class="comment">// 函数调用：执行函数</span></span><br><span class="line">    <span class="comment">// x的值不变，仍然是5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按指针（地址）传递</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">changeReference</span><span class="params">(<span class="type">int</span> *num)</span> &#123;</span><br><span class="line">    *num = <span class="number">100</span>; <span class="comment">// 通过指针修改原始值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line">    change(x); <span class="comment">// 传递x的地址</span></span><br><span class="line">    <span class="comment">// x的值现在变成了100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数调用："><a href="#函数调用：" class="headerlink" title="函数调用："></a>函数调用：</h3><p>函数调用是 C 语言中一个核心概念，它允许在程序的任何地方执行一个函数。函数调用的基本过程包括将控制权从调用函数（caller）转移到被调用函数（callee），执行被调用函数的代码体，然后返回控制权给调用函数。</p><h4 id="函数调用过程："><a href="#函数调用过程：" class="headerlink" title="函数调用过程："></a>函数调用过程：</h4><p><strong>1. 参数传递</strong>：当调用函数时，会按照函数定义的参数列表，将实际参数的值（按值传递）或地址（按指针传递）传递给函数。</p><p><strong>2. 执行函数体</strong>：一旦参数被传递，控制权转移到被调用函数，开始执行函数体内的代码。</p><p><strong>3. 返回值</strong>：函数完成其任务后，可以通过 return 语句返回一个值给调用者。如果函数类型为 void，则不返回任何值。</p><p><strong>4. 控制权返回</strong>：函数执行完毕后，控制权返回到调用函数的位置，程序继续执行下一条语句。</p><h3 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h3><p>递归函数是一种直接或间接调用自身的函数。它通常用于解决可以分解为相似子问题的问题。</p><p><strong>示例</strong>：计算阶乘：n！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">factorial</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用场景</strong>：递归在算法领域非常有用，尤其适合处理分治法、快速排序、二叉树遍历等问题。</p><h3 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h3><p>使用 inline 关键字声明的函数，在编译时会将函数体的代码直接插入每个调用点，而不是进行常规的函数调用。这可以减少函数调用的开销，但增加了编译后的代码大小。</p><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; y ? x : y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用场景</strong>：对于那些体积小、调用频繁的函数，使用inline可以减少函数调用的开销，如简单的数学运算和逻辑判断函数。</p><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>函数指针使得 C 语言支持回调函数，即将函数作为参数传递给另一个函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">greet</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, World!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">repeat</span><span class="params">(<span class="type">void</span> (*callbackFunc)(), <span class="type">int</span> times)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; times; i++) &#123;</span><br><span class="line">        callbackFunc(); <span class="comment">// 调用回调函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    repeat(greet, <span class="number">3</span>); <span class="comment">// 将greet函数作为参数传递给repeat函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用场景</strong>：<br>允许库或框架的用户提供自定义代码片段，根据需要在框架内部调用，以实现特定功能。例如，自定义排序函数中的比较操作。</p><h3 id="函数的分类"><a href="#函数的分类" class="headerlink" title="函数的分类:"></a>函数的分类:</h3><ul><li><p><strong>用户定义函数</strong>：由程序员定义的函数，用于执行特定任务。</p></li><li><p><strong>标准库函数</strong>：C 语言标准库提供的函数，常见的标准库函数包括以下几类：</p><p><strong>1. 输入和输出</strong>（stdio.h）：用于格式化输入和输出，如printf和scanf，以及文件操作的fgets和fputs。</p><p><strong>2. 字符串处理</strong>（string.h）：提供字符串操作的基本函数，包括复制(strcpy)、连接(strcat)、长度计算(strlen)和比较(strcmp)。</p><p><strong>3. 数学计算</strong>（math.h）：包括幂函数(pow)、平方根(sqrt)和三角函数(sin, cos, tan)等数学运算。</p><p><strong>4. 内存管理</strong>（stdlib.h）：用于动态内存分配和释放，包括malloc、free和realloc等函数。</p></li></ul><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>在 C 语言中，内存管理是一个核心概念，涉及到动态内存分配、使用和释放。理解如何在C语言中管理内存对于编写高效、可靠的程序至关重要。</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>C语言中的内存大致可以分为两大部分：<strong>静态&#x2F;自动内存分配和动态内存分配</strong>。</p><h4 id="静态内存分配："><a href="#静态内存分配：" class="headerlink" title="静态内存分配："></a>静态内存分配：</h4><p>静态内存分配发生在程序编译时，它为全局变量和静态变量分配固定大小的内存。这些变量在程序启动时被创建，在程序结束时才被销毁。例如，全局变量、static 静态变量都属于这一类。它的生命周期贯穿整个程序执行过程。</p><h4 id="自动内存分配："><a href="#自动内存分配：" class="headerlink" title="自动内存分配："></a>自动内存分配：</h4><p>自动内存分配是指在函数调用时为其局部变量分配栈上的内存。这些局部变量只在函数执行期间存在，函数返回时它们的内存自动被释放。自动内存分配的变量的生命周期仅限于它们所在的函数调用栈帧内。</p><p>简而言之，静态内存分配涉及到整个程序运行期间都存在的变量，而自动内存分配涉及到只在特定函数调用期间存在的局部变量。</p><h4 id="动态内存分配："><a href="#动态内存分配：" class="headerlink" title="动态内存分配："></a>动态内存分配：</h4><p>C语言中的动态内存分配是一种在程序运行时（而不是在编译时）分配和释放内存的机制。这允许程序根据需要分配任意大小的内存块，使得内存使用更加灵活。C 提供了几个标准库函数来管理动态内存，主要包括malloc、calloc、realloc和free。</p><p>下面让我们来看下这几个内存分配函数如何使用？</p><p><code>malloc :</code><br>malloc函数用来分配一块指定大小的内存区域。分配的内存未初始化，可能包含任意数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：size 是要分配的字节大小。</span></span><br><span class="line"><span class="comment">返回值：成功时返回指向分配的内存的指针；如果分配失败，则返回NULL。</span></span><br><span class="line"><span class="comment">注意：malloc 分配的内存内容是未初始化的，数据可能是未知的。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> size)</span>; <span class="comment">// 函数原型</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> *ptr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">5</span>); <span class="comment">// 分配一个5个整数大小的内存块</span></span><br><span class="line"><span class="keyword">if</span> (ptr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">// 使用ptr</span></span><br><span class="line">    <span class="built_in">free</span>(ptr); <span class="comment">// 释放内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>释放内存</strong></p><p>使用 free 函数来释放之前通过malloc、calloc或realloc分配的内存。释放后的内存不能再被访问，否则会导致未定义行为（如程序崩溃）。</p><p>释放内存后，已释放内存的指针称为<strong>悬挂指针</strong>。尝试访问已释放的内存将导致未定义行为。为了避免这种情况，释放内存后应将指针设置为 NULL。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">free</span>(ptr);</span><br><span class="line">ptr = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><p>如果忘记释放已分配的动态内存，这部分内存将无法被再次利用，导致内存泄漏。长时间运行的程序如果频繁泄漏内存，可能会耗尽系统资源。 </p><h4 id="检测和避免"><a href="#检测和避免" class="headerlink" title="检测和避免"></a>检测和避免</h4><p><strong>检测工具</strong>：</p><ul><li><strong>Valgrind</strong>：Linux下一个广泛使用的内存调试工具，可以帮助开发者发现内存泄漏、使用未初始化的内存、访问已释放的内存等问题。</li><li><strong>Visual Leak Detector</strong> (VLD)：专为 Windows 平台开发的内存泄露检测工具，集成于Visual Studio，用于检测基于C&#x2F;C++的应用程序。</li></ul><p><strong>避免策略</strong>：<br>及时释放内存：确保每次malloc或calloc后，相应的内存不再需要时使用 free 释放。</p><h2 id="预处理指令"><a href="#预处理指令" class="headerlink" title="预处理指令"></a>预处理指令</h2><p>C 语言中的预处理指令是在编译之前由预处理器执行的指令。它们不是 C 语言的一部分，而是在编译过程中的一个步骤，用于文本替换、条件编译等。预处理指令以井号（#）开头。</p><p>下面是一些常见的预处理指令及其使用示例：</p><h3 id="include-指令"><a href="#include-指令" class="headerlink" title="#include 指令"></a>#include 指令</h3><p>#include指令用于包含一个源代码文件或标准库头文件。它告诉预处理器在实际编译之前，将指定的文件内容插入当前位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> <span class="comment">// 包含标准输入输出头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myheader.h&quot;</span> <span class="comment">// 包含用户定义的头文件</span></span></span><br></pre></td></tr></table></figure><h3 id="define-指令"><a href="#define-指令" class="headerlink" title="#define 指令"></a>#define 指令</h3><p>#define用于定义宏。它告诉预处理器，将后续代码中所有的宏名称替换为定义的内容。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQUARE(x) ((x) * (x))</span></span><br></pre></td></tr></table></figure><h3 id="undef-指令"><a href="#undef-指令" class="headerlink" title="#undef 指令"></a>#undef 指令</h3><p>#undef 用于取消宏的定义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TABLE_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> TABLE_SIZE <span class="comment">// 取消 TABLE_SIZE 的定义</span></span></span><br></pre></td></tr></table></figure><h3 id="if-else-elif-endif-指令"><a href="#if-else-elif-endif-指令" class="headerlink" title="#if, #else, #elif, #endif 指令"></a>#if, #else, #elif, #endif 指令</h3><p>这些指令用于条件编译。只有当给定的条件为真时，编译器才会编译这部分代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DEBUG</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Debug information\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>#ifdef 和 #ifndef 指令</p><p>#ifdef检查一个宏是否被定义，#ifndef检查一个宏是否未被定义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义宏 DEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Debug mode is on.\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DEBUG</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Debug mode is off.\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="error-和-pragma-指令"><a href="#error-和-pragma-指令" class="headerlink" title="#error 和 #pragma 指令"></a>#error 和 #pragma 指令</h3><p>#error 指令允许程序员在代码中插入一个编译时错误。当预处理器遇到#error指令时，它会停止编译过程，并显示紧跟在#error后面的文本消息。这对于指出代码中的问题、配置错误或不支持的编译环境非常有用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined(_WIN64) || defined(__x86_64__)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> SUPPORTED_PLATFORM</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SUPPORTED_PLATFORM</span></span><br><span class="line">    <span class="meta">#<span class="keyword">error</span> <span class="string">&quot;This code must be compiled on a supported platform.&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>_WIN64和__x86_64__是预定义的宏，它们通常在编译器层面被定义，用于指示特定的平台或架构。<br>这些宏不是在用户的源代码中定义的，而是由编译器根据目标编译平台自动定义。</p><p>#pragma 指令用于提供编译器特定的指令，其行为依赖于使用的编译器。它通常用于控制编译器的特定行为，如禁用警告、优化设置或其他编译器特定的特性。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once  <span class="comment">// 防止头文件内容被多次包含</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize (<span class="string">&quot;O3&quot;</span>) <span class="comment">// 指示GCC编译器使用O3级别的优化</span></span></span><br></pre></td></tr></table></figure><p>下面是一个简单的示例，展示了如何使用预处理指令来控制代码的编译。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG 1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Debugging is enabled.\n&quot;</span>);</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Program is running.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，如果DEBUG被定义，则程序会打印调试信息。这是通过条件编译指令#ifdef实现的。</p><p>C 语言的预处理指令是编写灵活和高效代码的强大工具。通过合理使用预处理指令，可以实现<strong>条件编译、调试开关</strong>等功能，从而提升代码的可维护性和性能。</p><h2 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h2><p>在C语言中，输入和输出（I&#x2F;O）是基于数据流的概念。数据流可以是输入流或输出流，用于从源（如键盘、文件）读取数据或向目标（如屏幕、文件）写入数据。C标准库stdio.h提供了丰富的I&#x2F;O处理函数。</p><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><h4 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h4><p><strong>1. 输入流</strong>：数据从输入源（如键盘、文件）流向程序。</p><p><strong>2. 输出流</strong>：数据从程序流向输出目标（如显示器、文件）。</p><p><strong>3. 标准流</strong></p><ul><li><strong>stdin</strong>：标准输入流，通常对应于键盘输入。</li><li><strong>stdout</strong>：标准输出流，通常对应于屏幕输出。</li><li><strong>stderr</strong>：标准错误流，用于输出错误消息，即使在标准输出被重定向的情况下，错误信息通常也会显示在屏幕上。</li></ul><p><strong>4. 文件流</strong></p><p>  除了标准的输入和输出流，C语言允许操作文件流，即直接从文件读取数据或向文件写入数据。</p><h4 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h4><p>缓冲区是临时存储数据的内存区域，在数据在源和目标之间传输时使用。</p><p><strong>分类</strong>：</p><ul><li><strong>全缓冲</strong>：当缓冲区满时，数据才会被实际地写入目的地。例如，向文件写入数据通常是全缓冲的。</li><li><strong>行缓冲</strong>：当遇到换行符时，数据才会被实际地写入目的地。例如，标准输出stdout（通常是终端或屏幕）就是行缓冲的。</li><li><strong>无缓冲</strong>：数据立即被写入目的地，不经过缓冲区。例如，标准错误 stderr 通常是无缓冲的</li></ul><h3 id="格式化输入、输出函数"><a href="#格式化输入、输出函数" class="headerlink" title="格式化输入、输出函数"></a>格式化输入、输出函数</h3><h4 id="scanf和printf"><a href="#scanf和printf" class="headerlink" title="scanf和printf:"></a>scanf和printf:</h4><p>printf 函数用于向标准输出（通常是屏幕）打印格式化的字符串。</p><p>scanf 函数用于从标准输入（通常是键盘）读取格式化的输入。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Enter your age: &quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;age);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;You are %d years old.\n&quot;</span>, age);</span><br></pre></td></tr></table></figure><h4 id="getchar和putchar-字符输入、输出"><a href="#getchar和putchar-字符输入、输出" class="headerlink" title="getchar和putchar: 字符输入、输出"></a>getchar和putchar: 字符输入、输出</h4><p>getchar 函数用于读取下一个可用的字符从标准输入，并返回它。</p><p>putchar 函数用于写一个字符到标准输出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> ch;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Enter a character: &quot;</span>);</span><br><span class="line">ch = getchar();</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">&#x27;You entered: &#x27;</span>);</span><br><span class="line"><span class="built_in">putchar</span>(ch);</span><br></pre></td></tr></table></figure><h4 id="gets和puts-字符串输入、输出"><a href="#gets和puts-字符串输入、输出" class="headerlink" title="gets和puts : 字符串输入、输出"></a>gets和puts : 字符串输入、输出</h4><p>gets 函数用于从标准输入读取一行字符串直到遇到换行符。gets函数已经被废弃，因为它存在缓冲区溢出的风险，推荐使用fgets。</p><p>puts 函数用于输出一个字符串到标准输出，并在末尾自动添加换行符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Enter a string: &quot;</span>);</span><br><span class="line">fgets(str, <span class="number">100</span>, <span class="built_in">stdin</span>); <span class="comment">// 使用fgets代替gets</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;You entered: &quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(str);</span><br></pre></td></tr></table></figure><h4 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h4><p><strong>fopen、fclose、fgetc、fputc、fscanf、fprintf、feof、fseek、ftell、rewind</strong></p><p>fopen 和 fclose 函数用于打开和关闭文件。</p><p>fgetc 和 fputc 用于读写单个字符到文件。</p><p>fscanf 和 fprintf 用于读写格式化的数据到文件。</p><p>feof 用于检测文件结束。</p><p>fseek 设置文件位置指针到指定位置。</p><p>ftell 返回当前文件位置。</p><p>rewind 重置文件位置指针到文件开始。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FILE *file = fopen(<span class="string">&quot;example.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;Error opening file&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">fprintf</span>(file, <span class="string">&quot;Hello, file!\n&quot;</span>);</span><br><span class="line">fclose(file);</span><br></pre></td></tr></table></figure><h4 id="错误处理-perror"><a href="#错误处理-perror" class="headerlink" title="错误处理: perror"></a>错误处理: perror</h4><p>perror 函数用于打印一个错误消息到标准错误。它将根据全局变量 errno 的值输出一个描述当前错误的字符串。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FILE *file = fopen(<span class="string">&quot;nonexistent.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">fclose(file);</span><br></pre></td></tr></table></figure><h2 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h2><p>C语言的标准库提供了一系列广泛使用的函数，使得处理输入输出、字符串操作、内存管理、数学计算和时间操作等任务变得简单。下面是一些基本的标准库及其常用函数的简单介绍：</p><h3 id="stdio-h"><a href="#stdio-h" class="headerlink" title="stdio.h"></a>stdio.h</h3><p><strong>用途</strong>：输入和输出</p><p><strong>常用函数</strong>：printf()（输出格式化文本），scanf()（输入格式化文本）</p><h3 id="stdlib-h"><a href="#stdlib-h" class="headerlink" title="stdlib.h"></a>stdlib.h</h3><p><strong>用途</strong>：通用工具，如内存管理、程序控制</p><p><strong>常用函数</strong>：malloc()（分配内存），free()（释放内存），atoi()（字符串转整数）</p><h3 id="string-h"><a href="#string-h" class="headerlink" title="string.h"></a>string.h</h3><p><strong>用途</strong>：字符串处理</p><p><strong>常用函数</strong>：strcpy()（复制字符串），strlen()（计算字符串长度）</p><h3 id="math-h"><a href="#math-h" class="headerlink" title="math.h"></a>math.h</h3><p><strong>用途</strong>：数学计算</p><p><strong>常用函数</strong>：pow()（幂运算），sqrt()（平方根）</p><h3 id="time-h"><a href="#time-h" class="headerlink" title="time.h"></a>time.h</h3><p><strong>用途</strong>：时间和日期处理</p><p><strong>常用函数</strong>：time()（获取当前时间），localtime()（转换为本地时间）</p><h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h2><h3 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h3><p>typedef 是一种关键字，用于为现有的数据类型创建一个新的名称（别名）。这在提高代码的可读性和简化复杂类型定义方面非常有用。</p><h4 id="用途"><a href="#用途" class="headerlink" title="用途:"></a>用途:</h4><ul><li><strong>定义复杂的数据结构</strong>：当你有一个复杂的结构体或联合体时，可以使用 typedef 给它一个更简单的名字。</li><li><strong>提高代码的可移植性</strong>：通过 typedef 定义平台相关的类型，使得代码更容易在不同平台间移植。</li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> ulong;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125; Point;</span><br></pre></td></tr></table></figure><p>在这个例子中，ulong   现在可以用作 unsigned long 类型的别名，而 Point 可以用作上述结构体的类型名称。</p><h3 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h3><p>命令行参数允许用户在程序启动时向程序传递信息。C 程序的 main 函数可以接受命令行参数，这是通过 main 函数的参数实现的：<code>int argc, char *argv[]</code>。</p><h4 id="用途-1"><a href="#用途-1" class="headerlink" title="用途"></a>用途</h4><ul><li>参数个数（argc）：表示传递给程序的命令行参数的数量。</li><li>参数值（argv）：是一个指针数组，每个元素指向一个参数的字符串表示。</li></ul><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Program name: %s\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Arguments: \n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; argc; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, argv[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No additional arguments were passed.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，程序首先打印出程序自己的名字（<code>argv[0]</code>），然后检查是否有其他命令行参数传递给程序，并打印它们。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章主要是提供一个 C 语言入门的学习指南，帮助初学者快速入门 C 语言。</p><p>下面，让我们简短回顾下上文提到的知识点：</p><ul><li><strong>基础语法</strong>：我们介绍了 C 语言的基本构建块，包括变量声明、数据类型和控制流结构，这是编写任何 C 程序的基础。</li><li><strong>数组和指针</strong>：这两个概念是 C 语言中管理数据集的核心工具。我们学习了如何通过它们高效地访问和操作数据。</li><li><strong>字符串处理</strong>：学习了 C 语言中字符串的操作和处理方法，包括字符串的基本操作如连接、比较和搜索。</li><li><strong>函数</strong>：介绍了函数的定义和使用，强调了封装和模块化代码的重要性，以提高程序的可读性和可维护性。</li><li><strong>内存管理</strong>：了解了C语言如何与计算机内存直接交互，包括动态分配、使用和释放内存的方法。</li><li><strong>预处理指令</strong>：讨论了预处理器如何在编译之前处理源代码，以及如何使用预处理指令来增强程序的可配置性和灵活性。</li><li><strong>输入和输出</strong>：我们学习了标准输入输出库的基本使用，理解了如何实现程序与用户之间的交互。</li><li><strong>标准库</strong>：介绍了C语言提供的强大标准库，它包括了一系列实用的函数和工具，用于处理字符串、数学计算、时间日期等。</li></ul><h2 id="最后："><a href="#最后：" class="headerlink" title="最后："></a>最后：</h2><p>当然，学习 C 语言只是学习编程的第一步，作为一门直接与硬件和操作系统打交道的计算机底层语言，要想掌握 C，你还得学习这两门课程：计算机组成原理、操作系统。甚至，你还得学习汇编语言。除此之外，学会在 Linux 环境下进行 C 编程也是必须要掌握的。 如果你想学习 Linux 编程，包括系统编程和网络编程相关的内容，可以关注我的公众号「<strong>跟着小康学编程</strong>」，这里会定时更新计算机编程相关的技术文章，感兴趣的读者可以关注一下：</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>另外，我最近新创建了一个技术交流群，大家如果在阅读的过程中有遇到问题或者有不理解的地方，欢迎大家加群询问或者评论区询问，我能解决的都尽可能给大家回复。微信扫下下方的二维码，备注「<strong>加群</strong>」即可。 </p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程语言学习 </category>
          
          <category> C 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言入门 </tag>
            
            <tag> C语言基础 </tag>
            
            <tag> C快速学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 网络编程从入门到进阶 学习指南</title>
      <link href="/netprog/"/>
      <url>/netprog/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>大家好，我是小康。在上一篇文章中，我们探讨了 Linux 系统编程的诸多基础构件，包括文件操作、进程管理和线程同步等，接下来，我们将视野扩展到网络世界。在这个新篇章里，我们要让应用跳出单机限制，学会在网络上跨机器交流信息。</p><p>接下来，我们要深入套接字（sockets）和 TCP&#x2F;IP 协议，揭示如何在 Linux 下构建通信和网络服务。我们会从基础说起，逐步深入。目标是为初学者提供一个 <strong>Linux 网络编程从入门到进阶</strong>的学习指南！</p><h1 id="网络通信基础"><a href="#网络通信基础" class="headerlink" title="网络通信基础"></a>网络通信基础</h1><p>思考一下，如果计算机想要“交朋友”，它们需要怎样互相沟通？正如人们交流需要使用语言一样，计算机通信也必须遵守一套规则 — 这就是<strong>网络协议</strong>。</p><p>协议确保信息可以在不同的设备和平台之间清晰、准确地传递。要深入理解协议，我们首先要熟悉两个基础的通信模型：OSI 和 TCP&#x2F;IP 模型。</p><h2 id="OSI-模型和-TCP-IP-模型"><a href="#OSI-模型和-TCP-IP-模型" class="headerlink" title="OSI 模型和 TCP&#x2F;IP 模型"></a>OSI 模型和 TCP&#x2F;IP 模型</h2><p>在网络通信的世界里，OSI（开放式系统互联通信参考模型）和 TCP&#x2F;IP（传输控制协议&#x2F;网际协议）模型扮演着基础框架的角色。它们各自描述了网络通信的多个层次和阶段，但以不同的方式来分类和处理数据传输的细节。</p><ul><li><p><strong>OSI模型</strong> </p><p>OSI（Open Systems Interconnection）模型是一个概念性框架，用于描述网络中不同操作层次的功能。由七层组成，从物理硬件的电气信号（物理层），到应用层（如网页浏览器），每一层都有其独特的功能和协议。</p></li><li><p><strong>TCP&#x2F;IP模型</strong></p><p>TCP&#x2F;IP 模型，则更加贴近实际网络中的运作。Linux 的网络协议栈就是基于该模型实现的。它是基于四层架构，将网络通信过程简化并集中在协议族上，如传输控制协议（TCP）和互联网协议（IP），这两种协议是现代网络通信中最为核心的部分。</p></li></ul><h3 id="简单图示："><a href="#简单图示：" class="headerlink" title="简单图示："></a>简单图示：</h3><p><img src="/images/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/1.png"></p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="地址簿：IP地址和MAC地址"><a href="#地址簿：IP地址和MAC地址" class="headerlink" title="地址簿：IP地址和MAC地址"></a>地址簿：IP地址和MAC地址</h3><p>想象一下，互联网是一个巨大的数字城市，而每台计算机或网络设备就像是住在这个城市里的居民。</p><p><strong>IP地址：数字世界的“家庭住址”</strong></p><p>每台设备的 IP 地址就像是它在这个数字城市里的家庭住址。当计算机需要发送信息或访问网络资源时，它会使用目的地设备的 IP 地址来确保信息正确地送达。这个地址有点像是我们现实世界中的邮寄地址，可以根据网络环境的变化而变化（例如，当设备从家庭网络移动到办公室网络时）。</p><p><strong>MAC地址：网络中的“身份证”</strong></p><p>然后，我们有 MAC 地址，这是网络设备的另一个关键标识。每台设备的 MAC 地址都是独一无二的，类似于每个人的身份证号码。它是在设备制造时就被分配的，并且在大多数情况下，这个地址是固定不变的。MAC 地址在本地网络（如家庭或办公室网络）内起着重要作用，它帮助确保信息被准确地送达到特定设备，就像邮递员需要知道收件人的详细身份信息才能将包裹准确递交。</p><p><strong>总结一下</strong>：ip 地址可以让数据包找到目的主机所在的网络，而 MAC 地址确保数据包能准确送到目的主机上。</p><h4 id="导航路线：子网掩码和网关"><a href="#导航路线：子网掩码和网关" class="headerlink" title="导航路线：子网掩码和网关"></a>导航路线：子网掩码和网关</h4><p><strong>子网掩码：定位网络的“区域地图”</strong></p><p>子网掩码可以被视为定位网络内部和外部地址的“区域地图”。就像在一个大城市中，你需要知道哪些街道属于你的社区，哪些通往城市的其他部分。子网掩码帮助计算机确定一个 IP 地址是属于本地网络（即同一个子网）还是位于外部网络。</p><ul><li><strong>内部导航</strong>：如果目的地IP地址与计算机所在的子网相匹配（根据子网掩码判断），则数据包在本地网络内传送。</li><li><strong>外部导航</strong>：如果目的地不在本地子网内，计算机知道它需要将数据发送到更远的目的地。</li></ul><p><strong>网关：网络间的“中转站”</strong></p><p>网关在网络通信中扮演中转站的角色。当你的数据包需要从一个网络（比如你的家庭网络）发送到另一个网络（比如你的工作地点的网络）时，网关是这个旅程的第一站。</p><ul><li><strong>路由决策</strong>：网关检查数据包的目的 IP 地址，然后使用它的路由表来决定最佳的路径将数据包发送到目标网络。</li></ul><p><strong>总结：</strong> 子网掩码和网关共同协作，帮助数据包在复杂的网络结构中找到最有效的路径。子网掩码确定数据包是否在本地网络内，而网关指导跨网络的数据传输。</p><h4 id="端口-：确保数据到达正确的“应用程序门牌号”"><a href="#端口-：确保数据到达正确的“应用程序门牌号”" class="headerlink" title="端口 ：确保数据到达正确的“应用程序门牌号”"></a>端口 ：确保数据到达正确的“应用程序门牌号”</h4><p>好了，现在我们的数据包已经知道了去哪里，但它如何确保被正确的程序接收呢？这就是端口登场的时候了。端口号就像是收件人的门牌号，确保数据不只是送到了正确的地址，而且被正确的应用程序接收。</p><h2 id="Linux-套接字编程"><a href="#Linux-套接字编程" class="headerlink" title="Linux 套接字编程"></a>Linux 套接字编程</h2><p><img src="/images/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/2.png"></p><h3 id="套接字是什么"><a href="#套接字是什么" class="headerlink" title="套接字是什么"></a>套接字是什么</h3><p>在网络编程中，<strong>套接字</strong>就像是网络世界的<strong>通信端口</strong>。每一个联网的应用程序，为了能够互发消息，都会使用到这样一个端口。这个端口允许数据从一个程序流向另一个程序。简而言之，套接字是应用程序用来在网络上交流的桥梁。</p><p>想象一下，你要用手机给朋友发一条信息。你只需要知道他们的手机号码，这样信息就可以直接发送到他们的手机上。在网络编程中，套接字的作用类似。它使用IP地址 （类似于手机号码） 来确定数据发送的目标位置，而端口号则像是确定信息应该送达到对方手机中的哪个应用程序。这样，套接字（使用 ip 地址和端口）确保了数据能够准确地发送给正在监听那个特定端口的程序。</p><p><strong>套接字的工作原理</strong>：</p><p>套接字的工作原理就像是电话通话的过程。首先，你需要拨打一个号码（即IP地址+端口号）来建立连接。一旦连接建立，电话线（网络连接）就激活了，你的声音（数据）就可以通过它传送。</p><p>在这个过程中：</p><p><strong>拨号</strong>对应于网络编程中的<strong>连接建立</strong>，这是通过调用套接字API来完成的，比如 connect( )函数。</p><p><strong>通话</strong>对应于<strong>数据传输</strong>，你可以通过套接字发送 send( ) 和接收 recv( )数据。</p><p><strong>挂断</strong>对应于<strong>结束连接</strong>，完成通信后，你需要关闭套接字 close( )函数，以结束会话并清理资源。</p><p>在整个通信过程中，套接字保证了数据从一个程序准确地传送到另一个程序，无论这两个程序是在同一台计算机上还是跨越了广阔的互联网。</p><p>在 Linux 中，套接字其实就是一系列的编程接口，Linux 提供了很多特定的 API 来创建和使用套接字，接下来，让我们学习如何使用 Linux 套接字 api 来编写各种网络服务程序。</p><h3 id="套接字类型"><a href="#套接字类型" class="headerlink" title="套接字类型"></a>套接字类型</h3><p>在 Linux 中，有三种套接字类型，<strong>前两种是重点掌握的</strong>，第三种了解即可。</p><p><strong>TCP套接字 (SOCK_STREAM):</strong> </p><ul><li>这是一种可靠的套接字连接，保证数据传输的完整性和顺序。</li><li>必须先建立连接，才能传输数据。</li><li>常用于需要准确数据传输的应用，如网页浏览和文件传输。</li></ul><p><strong>UDP套接字 (SOCK_DGRAM):</strong></p><ul><li>不需要建立连接，但是数据传输可能会丢失，没有先后顺序。</li><li>适用于视频流和在线游戏，这些应用可以容忍一定的数据丢失。</li></ul><p><strong>原始套接字 (SOCK_RAW):</strong></p><ul><li>允许直接对较低层次的协议如 IP 或 ICMP 进行访问和操作，它绕过了 TCP 和 UDP 的处理。</li><li>开发者可以使用原始套接字来构建自定义的协议或直接处理来自网络的数据包。</li><li>通常用于需要进行网络诊断或网络安全应用，如自定义的ping实现，或者网络嗅探器。</li></ul><p>选择哪种类型取决于你的应用需求—是否需要可靠传输（TCP），还是速度更快但可能丢失数据也没关系（UDP）。</p><p>选择使用原始套接字通常意味着你需要对网络协议有深入的理解，因为你将直接与网络层面的数据交互。这比处理 TCP 和 UDP 套接字更复杂，通常只在特殊情况下使用，例如网络工具的开发或定制协议的实现。</p><h3 id="套接字常用-API"><a href="#套接字常用-API" class="headerlink" title="套接字常用 API"></a>套接字常用 API</h3><p>接下来，看下常用的套接字 API：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">socket()                    : 创建套接字</span><br><span class="line">bind()                      : 绑定套接字到本地地址</span><br><span class="line">listen()                    : 监听网络连接</span><br><span class="line">accept()                    : 接受网络连接</span><br><span class="line">connect()                   : 连接到远程主机</span><br><span class="line">send(), recv()              : 发送和接收数据（面向连接的套接字）</span><br><span class="line">sendto(), recvfrom()        : 发送和接收数据（无连接的套接字）</span><br><span class="line">close() ,shutdown()         : 关闭套接字</span><br><span class="line">getsockopt(), setsockopt()  : 获取和设置套接字选项</span><br></pre></td></tr></table></figure><h3 id="套接字地址结构以及地址转换-API"><a href="#套接字地址结构以及地址转换-API" class="headerlink" title="套接字地址结构以及地址转换 API"></a>套接字地址结构以及地址转换 API</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sockaddr 是一个通用的套接字地址结构，它通常与特定的地址族结构（如 sockaddr_in ）一起使用。</span></span><br><span class="line"><span class="comment"> 这是因为多数套接字函数，如 bind(), connect(), 和 accept()，需要使用指向 sockaddr 结构的指针的参数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">   <span class="type">sa_family_t</span>     sa_family;      <span class="comment">/* Address family */</span></span><br><span class="line">   <span class="type">char</span>            sa_data[];      <span class="comment">/* Socket address */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 套接字地址结构（适用于IPv4网络通信的地址结构）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">sa_family_t</span>    sin_family; <span class="meta"># address family: AF_INET </span></span><br><span class="line">    <span class="type">in_port_t</span>      sin_port;   <span class="meta"># port in network byte order </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>   <span class="meta"># ip address </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     <span class="type">uint32_t</span>       s_addr;    <span class="meta"># address in network byte order </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">网络地址转换函数 (用于将IP地址在可打印的格式和二进制结构之间转换)</span></span><br><span class="line"><span class="comment">将点分十进制的IP地址（如&quot;192.168.1.1&quot;）转换成网络字节顺序的二进制形式</span></span><br><span class="line"><span class="comment">inet_pton()   </span></span><br><span class="line"><span class="comment">将网络字节顺序的二进制IP地址转换为点分十进制字符串格式</span></span><br><span class="line"><span class="comment">inet_ntop()   </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># demo 示例:</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INET_ADDRSTRLEN 16；</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str[INET_ADDRSTRLEN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">ipv4addr</span>;</span></span><br><span class="line">inet_pton(AF_INET, <span class="string">&quot;192.168.1.1&quot;</span>, &amp;ipv4addr);</span><br><span class="line">inet_ntop(AF_INET, &amp;ipv4addr, str, INET_ADDRSTRLEN);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The IPv4 address is: %s\n&quot;</span>, str);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="字节序转换-API"><a href="#字节序转换-API" class="headerlink" title="字节序转换 API"></a>字节序转换 API</h3><p>在网络编程中，字节序（也称为端序）指的是数值在内存中保存的顺序。不同的计算机体系结构可能会采用不同的字节序来表示数据。最常见的两种字节序是<strong>大端字节序</strong>（Big-Endian）和<strong>小端字节序</strong>（Little-Endian）。在网络通信中，为了确保数据在不同的系统间正确传输和解释，定义了一个统一的字节序，即：<strong>网络字节序</strong>，它采用<strong>大端字节序</strong>。</p><p>由于主机字节序与网络字节序可能不同，因此在发送数据前，发送方需要将其主机字节序的数值转换为网络字节序；接收方收到数据后，需要将网络字节序的数值转换回主机字节序。</p><p>Linux 提供了一组 API 来处理字节序的转换：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将无符号长整型数/无符号短整型数从主机字节顺序转换为网络字节顺序。</span></span><br><span class="line">htonl() 和 htons()  </span><br><span class="line"><span class="comment">// 将一个无符号长整型数/无符号短整型数从网络字节顺序转换为主机字节顺序。</span></span><br><span class="line">ntohl() 和 ntohs()  </span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">为了方便记忆，大家可以这样理解：h 代表 host(主机)，n 代表 network(网络)，</span></span><br><span class="line"><span class="comment">l 代表 long(四字节：代表ip)，s 代表 short（两字节：代表端口） 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">以 htons() 举例，host to network short 即：将端口从主机字节序转成网络字节序。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>注意：htonl 和 ntohl 一般处理的是 IP 地址，而 htons 和 ntohs 一般处理的是端口。</strong></p><h3 id="Linux-常见的-IO-模型"><a href="#Linux-常见的-IO-模型" class="headerlink" title="Linux 常见的 IO 模型"></a>Linux 常见的 IO 模型</h3><p>前面我们已经学习了 Linux 基础的 socket API，这样我们便可以编写简单的网络服务程序。但现在，我们面临一个新挑战：如何利用有限的服务器资源，来同时高效处理大量的并发请求呢？</p><p>传统的单线程处理方式在现代网络服务中已不合时宜，因为它无法同时处理多个请求，导致效率低下。为了突破这一限制，我们需探究 Linux 提供的各种 I&#x2F;O 模型。这些模型提供了从阻塞到非阻塞，从多路复用到完全异步的不同解决方案，以适应各种网络应用场景，确保服务器在面对大量请求时也能保持高效运行。</p><p><strong>在讨论这些 IO 模型之前，我们先简单回顾一下 I&#x2F;O 是什么</strong>：</p><p>在计算机中，“I&#x2F;O”就是输入和输出的简称，它描述了数据在计算机系统和外部世界之间的流动。具体来说：</p><ul><li><p><strong>输入</strong>：数据进入计算机，比如你在键盘上敲击字母时，字母被读入计算机。</p></li><li><p><strong>输出</strong>：数据离开计算机，例如屏幕上显示信息。</p></li></ul><p>当提到网络时，“I&#x2F;O”扩展了含义：</p><ul><li><p><strong>网络输入</strong>：从外部网络接收数据到你的本地计算机，如通过网络下载文件到你的计算机。</p></li><li><p><strong>网络输出</strong>：这是指将数据从你的本地计算机发送到外部网络，比如通过计算机发送文件给你的好友。</p></li></ul><p>简而言之，I&#x2F;O 是数据在计算机和其他设备或网络之间传递的方式。</p><p><strong>用户进程如何进行 IO 操作？</strong></p><p>让我们通过一个示意图来直观展示用户进程如何从网络获取数据并将其存储到磁盘的整个过程：</p><p><img src="/images/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/3.png"></p><p>从上图我们也能够清楚的看到，进程进行一次 I&#x2F;O 操作需要经过两个步骤:</p><p>以 read 读操作为例：</p><p><strong>第一步：等待网络数据的到来</strong></p><p>当网络数据到达时，网络接口卡（NIC）首先通过直接内存访问（DMA）将数据传输到内核空间分配的 socket 接收缓冲区中，无需 CPU 参与。</p><p><strong>第二步：CPU 复制数据至用户空间</strong></p><p>一旦数据通过 DMA 传输到内核的 socket 接收缓冲区，用户进程的 read 系统调用会被唤醒（如果它在等待数据的话）。接下来，CPU 会介入，将数据从内核缓冲区复制到用户空间提供的缓冲区中。</p><p>也就是说，在 I&#x2F;O 操作的过程中，<strong>存在两个潜在的等待时间点 ：一个是等待网络数据到达 socket 接收缓冲区，另一个是等待 CPU 复制数据至用户空间。</strong></p><p>为了减少这些等待时间对应用程序性能的影响，Linux 提供了五种 I&#x2F;O 模型，它们分别针对这两个步骤的效率问题提供不同的解决方案。</p><p><strong>接下来，我们将深入了解 Linux 支持的五种 I&#x2F;O 模型:</strong></p><h4 id="阻塞IO（Blocking-I-O）"><a href="#阻塞IO（Blocking-I-O）" class="headerlink" title="阻塞IO（Blocking I&#x2F;O）"></a>阻塞IO（Blocking I&#x2F;O）</h4><p><strong>简单图示</strong>：</p><p><img src="/images/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/4.png"></p><p>在阻塞 I&#x2F;O 中，<strong>进程在等待网络数据到达和内核复制数据到用户空间这两个步骤中都需要等待</strong>。当一个进程发起 I&#x2F;O 请求时，它会一直等待直到数据被复制到它的应用层缓冲区中，然后才继续执行。</p><h4 id="非阻塞I-O（Non-blocking-I-O）"><a href="#非阻塞I-O（Non-blocking-I-O）" class="headerlink" title="非阻塞I&#x2F;O（Non-blocking I&#x2F;O）"></a>非阻塞I&#x2F;O（Non-blocking I&#x2F;O）</h4><p><strong>简单图示</strong>：</p><p><img src="/images/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/5.png"></p><p>在非阻塞 I&#x2F;O 模型中，当进程尝试从 socket 读取数据时，如果数据尚未到达，read调用不会阻塞进程。相反，它会立即返回一个 EWOULDBLOCK 或 EAGAIN 错误。也就是说，进程不需要等待网络数据到达 socket 接收缓冲区就可以返回继续执行其他任务。</p><p>一旦数据到达并存储在内核缓冲区中，而当进程尝试再次读取，这次 read 操作将成功，并将数据从内核空间复制到用户空间，但这里的数据复制过程是需要等待的。</p><p><strong>总结一下</strong>：<strong>在非阻塞 I&#x2F;O 模型中，进程需要等待 socket 数据从内核空间复制到用户空间。</strong> 而在等待网络数据到达 socket 接收缓冲区这个时间点是不需要等待的。但是进程需要不断地“轮询”文件描述符，检查 socket 接收缓冲区是否有数据，频繁的轮询可能会导致 CPU 资源的浪费。</p><h4 id="I-O多路复用（I-O-Multiplexing）"><a href="#I-O多路复用（I-O-Multiplexing）" class="headerlink" title="I&#x2F;O多路复用（I&#x2F;O Multiplexing）"></a>I&#x2F;O多路复用（I&#x2F;O Multiplexing）</h4><p><strong>简单图示</strong>：</p><p><img src="/images/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/6.png"></p><p><strong>工作原理：</strong></p><p>I&#x2F;O 多路复用允许一个进程或线程同时监控多个网络 sockets 的状态。它通过单个系统调用（select）来检查多个 sockets 是否有数据可读、可写或是否有异常。Linux 提供了多种 I&#x2F;O 复用技术，包括上面提到的 select、以及 poll、epoll。</p><p><strong>那 I&#x2F;O 多路复用是如何减少上述提到的两个潜在的等待时间的？</strong></p><p><strong>等待网络数据到达</strong></p><ul><li><p>在 I&#x2F;O 多路复用模式下，进程不会在单个 socket 上阻塞等待数据到达。相反，当任何一个被监控的 socket 接收到数据，系统调用（如select）会返回。当 select 返回时，它指示一个或多个 sockets 已接收到数据。这意味着数据已经被网络接口卡（NIC）通过 DMA 操作传输到相应的 socket 接收缓冲区中。</p></li><li><p>这样，进程不必在每个 socket 上分别等待，而是在多个sockets上集中等待，提高了效率。</p></li></ul><p><strong>但是，在 I&#x2F;O 多路复用中， select、poll 或 epoll 系统调用依然会阻塞等待网络数据的到达</strong></p><p><strong>等待CPU复制数据至用户空间</strong></p><p>进程随后可以立即对准备就绪的 socket fd 进行 read 操作。因为数据已经在内核的缓冲区中，CPU 只需要将数据从内核空间复制到用户空间。但这个拷贝数据的完成</p><p>也就是说在 I&#x2F;O 多路复用中，<strong>select、poll 或 epoll 系统调用依然会阻塞等待网络数据的到达</strong>，但是他的<strong>优势在于可以监控多个 sockets 的接收缓冲区是否有数据到来</strong>。当多个 sockets 的接收缓冲区有数据到来，<strong>进程会一直等待 CPU 复制数据至用户空间才能干其他任务</strong>。</p><h4 id="信号驱动I-O（Signal-driven-I-O）"><a href="#信号驱动I-O（Signal-driven-I-O）" class="headerlink" title="信号驱动I&#x2F;O（Signal-driven I&#x2F;O）"></a>信号驱动I&#x2F;O（Signal-driven I&#x2F;O）</h4><p><strong>简单图示</strong>：</p><p><img src="/images/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/7.png"></p><p>信号驱动 I&#x2F;O 也是属于Linux 中的一种 IO 模型，它允许应用程序在不阻塞等待 I&#x2F;O 操作完成的情况下继续执行其他任务。当 I&#x2F;O 操作（如数据的读取或写入）准备就绪时，操作系统会向应用程序发送一个信号，通知它可以开始执行 I&#x2F;O 操作了。这种模式主要通过使用信号（如 SIGIO）来实现。</p><p><strong>两个等待时间点对信号驱动 I&#x2F;O 的影响</strong> :</p><p><strong>等待网络数据到达</strong>：在信号驱动 I&#x2F;O 模型中，应用程序在等待数据到达时<strong>不需要阻塞等待</strong>。它可以继续执行其他任务或处于休眠状态，直到操作系统发出数据已准备就绪的信号（如 SIGIO）。</p><p><strong>等待内核复制数据到用户空间</strong>：当应用程序收到信号并开始实际的 I&#x2F;O 操作（如 read）时，<strong>它仍然需要等待操作系统将数据从内核空间复制到用户空间</strong>。</p><p>尽管信号驱动 I&#x2F;O 提供了一种异步通知机制，使得应用程序能够在I&#x2F;O事件准备好时接收通知，但它在实践中不如其他模型（如IO复用）那么广泛使用，原因包括：</p><ul><li><p><strong>编程复杂性</strong>：使用信号驱动I&#x2F;O要求程序员熟悉信号处理和非阻塞I&#x2F;O操作，这增加了编程的复杂性。</p></li><li><p><strong>信号合并和丢失</strong><br>Linux 信号处理机制通常不会为同一类型的信号排队。这意味着如果在处理一个信号时另一个相同类型的信号发生，后者可能不会触发额外的信号处理调用，导致应用程序可能错过一些I&#x2F;O事件的通知。这种信号的合并行为限制了信号驱动I&#x2F;O模型在高并发场景下准确响应每个I&#x2F;O事件的能力。</p></li><li><p><strong>更好的替代方案</strong>：对于需要处理多个并发I&#x2F;O操作的应用程序，I&#x2F;O复用（特别是epoll）提供了更高的效率和更好的控制。epoll特别适用于高并发场景，并且相对于信号驱动I&#x2F;O更易于管理和使用。</p></li></ul><h4 id="异步I-O（Asynchronous-I-O）"><a href="#异步I-O（Asynchronous-I-O）" class="headerlink" title="异步I&#x2F;O（Asynchronous I&#x2F;O）"></a>异步I&#x2F;O（Asynchronous I&#x2F;O）</h4><p><strong>简单图示</strong>：</p><p><img src="/images/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/8.png"></p><p>aio_read 是 POSIX 异步 I&#x2F;O 接口的一部分，它专门用于执行异步文件读取操作。不太适用于网络 I&#x2F;O 。因此上面的图示是基于文件读取对异步 IO 的工作过程进行说明的。</p><p><strong>工作原理：</strong></p><p>在异步 I&#x2F;O 模型中，当应用程序发起一个I&#x2F;O操作（例如 aio_read 读取）时，它不需要等待操作完成就可以继续执行其他任务。应用程序仅仅是向操作系统发出 I&#x2F;O 请求，并且当 I&#x2F;O 操作真正完成时，操作系统会通知应用程序。这种方式允许应用程序更有效地利用 CPU 时间，因为它不需要在 I&#x2F;O 操作完成前空闲等待。</p><p>那前面提到的两个潜在等待时间对异步 IO 是否会有影响呢？</p><p><strong>等待内核 PageCache 数据准备好：</strong></p><p>在异步 I&#x2F;O 中，应用程序在发出读写请求后立即返回，不需要等待数据在内核中准备好。这意味着应用程序可以继续执行其他任务，而内核会异步的从磁盘读取数据至内核缓存 PageCache 中。</p><p><strong>注意：</strong> 上面我是通过 aio_read 系统调用来说明异步 I&#x2F;O 的工作原理的，aio_read 是 Linux 的 POSIX 异步 I&#x2F;O (AIO) 库提供的接口，主要设计用于文件和块设备的异步读写操作，而不支持网络 I&#x2F;O。因此这里是等待内核的 PageCache 数据准备好而不是等待网络数据准备好，但都可以归纳为等待数据准备好。</p><p><strong>等待CPU复制数据至用户空间</strong>：</p><p> 一旦数据在 pagecache 中准备好，操作系统负责将这些数据从内核空间复制到用户空间指定的缓冲区。<strong>这个复制过程是由内核自动执行的，而不是由用户进程主动复制的。</strong> 用户程序不需要等待这一过程的完成，可以继续进行其他工作。只有在数据完全复制到用户空间后，应用程序才会收到一个完成的信号或通知。进而处理拷贝至用户空间的数据。</p><p><strong>也就是说：在异步 IO 中，不管是等待数据准备好还是等待 CPU 复制数据至用户空间，用户进程都不需要等待。</strong></p><h4 id="Linux-网络-I-O-性能优化"><a href="#Linux-网络-I-O-性能优化" class="headerlink" title="Linux 网络 I&#x2F;O 性能优化"></a>Linux 网络 I&#x2F;O 性能优化</h4><p>在前面的部分，我们探讨了 Linux的 各种I&#x2F;O模型。每种模型都有其独特的使用场景和性能特点。特别是在网络编程中，选择合适的I&#x2F;O模型对于提高服务器的处理能力至关重要。但是，仅仅选择合适的I&#x2F;O模型并不足以确保最佳性能。实际上，网络I&#x2F;O性能还受到许多其他因素的影响，比如<strong>网卡配置、带宽、服务器的并发处理能力</strong>等。因此，我们需要进一步优化 Linux 网络 I&#x2F;O 性能，以确保我们的应用可以充分利用服务器资源，提供更快、更可靠的服务。</p><p><strong>那么，如何优化 Linux 网络 I&#x2F;O 性能呢？</strong></p><p>网络 I&#x2F;O 性能优化主要就是从硬件和软件两个方面来进行：</p><p><strong>首先来看下硬件优化：</strong><br>硬件优化无非就是提升服务器硬件性能，包括 CPU、网卡配置升级、内存配置升级等。</p><ul><li><strong>使用多核 CPU</strong> ：确保服务器有足够的CPU核心来处理高网络负载。</li><li><strong>内存升级</strong>：增加足够的内存以支持高速网络操作，特别是对于需要大量内存缓存的应用。</li><li><strong>网络接口卡</strong>：升级NIC：使用更高速率的NIC，例如从1Gbps升级到10Gbps或更高。<br>或者使用 NIC 多队列（Multi-queue）：使用支持多队列的NIC，以便分散处理负载到多个CPU核心。</li></ul><p><strong>接下来来看下软件优化：</strong></p><p> <strong>1.首先来看下应用程序设计，应用程序本身的设计对网络 I&#x2F;O 性能有着重大影响：</strong></p><ul><li><p><strong>选择合适的 I&#x2F;O 模型</strong>：<br>选择合适的 I&#x2F;O 模型，根据应用的特点和需求选择合适的 I&#x2F;O 模型。对于高并发的网络服务，I&#x2F;O 多路复用（如 epoll、kqueue）通常是最佳选择。它们允许单个线程高效地监控和处理多个网络连接，减少了线程切换的开销。而对于 I&#x2F;O 密集型的应用，异步 I&#x2F;O模型可能会更高效，异步 I&#x2F;O （如 io_uring、libaio）提供了一种不阻塞应用程序主逻辑的方式来处理 I&#x2F;O 请求。这种模型允许应用程序在 I&#x2F;O 请求正在处理时继续执行其他任务。</p></li><li><p><strong>使用零拷贝技术</strong>：<br>传统的数据传输过程涉及多次数据拷贝，包括从内核缓冲区到用户缓冲区。零拷贝技术（如 sendfile）可以减少这些拷贝操作，直接在内核中处理数据，从而减少 CPU 使用和提高效率。</p></li><li><p><strong>批量处理和缓冲</strong> : 聚集数据，以减少网络交互和磁盘操作的次数。</p><p> <strong>a:聚集数据</strong>：通过累积数据到达一定量后再进行处理，而不是每次接收到数据就立即处理。以读取网络数据下载至本地磁盘为例：可以等待数据积累到一定量的时候在写入磁盘，这样可以减少磁盘 I&#x2F;O 次数。</p><p><strong>b.缓冲区管理</strong>：需要合理管理缓冲区，以避免溢出，并在适当的时候重置或清空缓冲区。</p><p><strong>c.适用场景</strong>：这种模式适合于数据量大、数据频繁到达的场景，如日志收集、批量数据处理等。</p></li><li><p><strong>并发和并行处理</strong>：利用多核处理器的优势，通过多线程或多进程来提高并发处理能力。</p></li></ul><p> <strong>2. 接下来看下关于操作系统方面的调整，操作系统级别的调整对于优化网络 I&#x2F;O 也是至关重要的</strong></p><ul><li><p><strong>增加文件描述符限制</strong>：对于高并发的网络服务器，提高文件描述符的限制是必要的，以避免因达到文件描述符上限而无法接受新连接。你可以通过 ulimit -n 命令或修改 &#x2F;etc&#x2F;security&#x2F;limits.conf 文件来增加这个限制。</p></li><li><p><strong>调整 TCP 协议栈参数</strong>：常见的 TCP协议栈参数有如下的几类：</p><p><strong>a：缓冲区大小和资源管理</strong>：<br>这些参数控制 TCP 缓冲区的大小和整体 TCP 缓冲区的资源管理，以优化数据传输性能和内存使用。</p><p><strong>tcp_rmem 和 tcp_wmem</strong> ：分别控制 TCP 接收和发送缓冲区的大小。</p><p><strong>tcp_mem</strong> ：控制整体 TCP 缓冲区在系统范围内的使用情况。</p><p><strong>b: 连接建立和终止：</strong><br>这类参数涉及 TCP 连接的建立过程和连接终止时的行为。</p><p><strong>tcp_syn_retries 和 tcp_synack_retries</strong> : 分别控制 TCP SYN 连接请求和 SYN-ACK 包的重试次数。</p><p> <strong>tcp_fin_timeout</strong> ： tcp_fin_timeout 参数设置了 TCP 连接在 FIN-WAIT-2 状态下的超时时间。这个参数定义了在一个 TCP 连接被本地端关闭后，系统等待对方发送 FIN 包以完成连接终止过程的最长时间。如果在这个超时时间内没有收到对方的 FIN 包，连接将被强制关闭。</p><p><strong>c :连接保活和状态管理：</strong><br>这些参数用于检测和维持空闲连接，以及管理连接状态。</p><p><strong>tcp_keepalive_time</strong> ：设置在开始发送 keepalive 探测之前，一个 TCP 连接必须处于空闲状态的时间。</p><p><strong>tcp_keepalive_probes</strong> ：设置在断开连接之前，最多发送多少个 keepalive 探测包。</p><p><strong>tcp_keepalive_intvl</strong> ： 设置两个连续 keepalive 探测包之间的时间间隔。</p><p><strong>tcp_tw_reuse</strong> :  设置允许在 TIME_WAIT 状态的套接字上的端口被重新用于新的连接。</p><p><strong>d:性能优化 :</strong> 这些参数用于提升网络性能，减少延迟。</p><p><strong>tcp_nodelay</strong> : 禁用 Nagle 算法，减少发送小块数据的延迟。（Nagle 算法是一种为了减少网络上小数据包数量而设计的 TCP 特性。它通过累积较小的数据包并将它们组合成更大的数据块来发送，从而减少了网络上的总数据包数量）。</p><p><strong>tcp_max_syn_backlog</strong> : 设置 SYN 接收队列的最大长度，优化高并发连接的接收。</p><p>除了 SYN 接收队列，TCP 连接还涉及到一个“已连接队列”（也称为 accept 队列），该队列用于存储已经完成三次握手、等待应用程序 accept 的连接。</p><p><strong>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;somaxconn</strong>： 该参数控制着已连接队列的最大长度。 </p><p><strong>调整方法:</strong><br>这些参数通常通过修改 &#x2F;etc&#x2F;sysctl.conf 文件或使用 sysctl 命令进行调整。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sysctl -w net.ipv4.tcp_rmem=&#x27;4096 87380 6291456&#x27;</span><br><span class="line">sysctl -w net.ipv4.tcp_wmem=&#x27;4096 16384 4194304&#x27;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 调整这些参数时，应谨慎考虑系统的整体资源和应用的具体需求。不恰当的设置可能导致性能下降或系统资源耗尽。在生产环境中应用更改前，最好在测试环境中进行充分的测试。</p></li></ul><h3 id="Linux-常见的服务器模型"><a href="#Linux-常见的服务器模型" class="headerlink" title="Linux 常见的服务器模型"></a>Linux 常见的服务器模型</h3><p>服务器模型是网络服务器程序设计的基石，它决定了服务器如何管理多个客户端的连接和请求。接下来，让我们来看看 <strong>Linux</strong> 下的几种常见的服务器模型是怎样工作的？</p><h4 id="单进程服务器：一对一服务"><a href="#单进程服务器：一对一服务" class="headerlink" title="单进程服务器：一对一服务"></a>单进程服务器：一对一服务</h4><p>在单进程服务器模型中。服务器使用一个主进程来逐个处理客户端的连接请求。这意味着，当服务器正在服务一个客户端时，其他客户端必须等待直到当前客户端服务结束。</p><p><strong>图示</strong>：</p><p><img src="/images/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/9.png"></p><p><strong>单进程回射服务器示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">server_fd = socket();</span><br><span class="line">bind();</span><br><span class="line">listen();</span><br><span class="line"><span class="comment">// The main server loop</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    newsockfd = accept(server_fd，...);</span><br><span class="line">    <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="number">256</span>);</span><br><span class="line">    <span class="comment">// Read and write to the connection in a loop</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        n = read(newsockfd, buffer, <span class="number">255</span>);</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">// If read returns 0, the client has closed the connection</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// printf(&quot;Client: %s\n&quot;, buffer);</span></span><br><span class="line">        write(newsockfd, buffer, <span class="built_in">strlen</span>(buffer));</span><br><span class="line">    &#125;</span><br><span class="line">    close(newsockfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>缺点</strong>：</p><ul><li><p><strong>无法实现并发</strong>： 单进程服务器在任何时刻只能处理一个客户端的请求。这意味着如果有多个客户端同时请求服务，除了第一个之外的所有请求都必须等待，这限制了服务器的并发处理能力。</p></li><li><p><strong>性能瓶颈</strong>： 由于服务器在处理当前请求时无法接受新的连接，这会导致服务器对其他客户端的响应时间延长，特别是在高流量的情况下，效率低下。</p></li><li><p><strong>资源利用不充分</strong>： 在多核心处理器上，单进程模型无法充分利用多核的优势，因为它只在一个核心上运行，没有并行处理能力。</p></li></ul><h4 id="多进程服务器"><a href="#多进程服务器" class="headerlink" title="多进程服务器"></a>多进程服务器</h4><p>了解了单进程服务器模型的缺点后，我们自然会寻求更高效的方案来处理多客户端并发的情况。这就引出了多进程服务器模型，它是解决单进程模型限制的常见方案。</p><p>在多进程模型中，服务器为每个新的客户端连接创建一个独立的进程。这允许服务器同时处理多个客户端请求，极大地提高了并发处理能力和资源利用率。</p><p><strong>图示</strong>：</p><p><img src="/images/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/10.png"></p><p><strong>多进程回射服务器示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">server_fd = socket();</span><br><span class="line">bind();</span><br><span class="line">listen();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="type">int</span> new_socket =accept(server_fd, ...);    </span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        close(new_socket);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">      close(server_fd); <span class="comment">// Child does not need the listener</span></span><br><span class="line">      handle_client(new_socket);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        close(new_socket); <span class="comment">// Parent does not need this socket</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">handle_client</span><span class="params">(<span class="type">int</span> new_socket)</span> &#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> bytes_read;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        bytes_read = read(new_socket, buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">        <span class="keyword">if</span> (bytes_read &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// Break the loop if read error or end of file</span></span><br><span class="line">        &#125;</span><br><span class="line">        write(new_socket, buffer, bytes_read);</span><br><span class="line">    &#125;</span><br><span class="line">    close(new_socket);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>多进程服务器优点</strong>：</p><ul><li><p><strong>稳定性</strong>: 多进程服务器中，每个进程是独立的。如果一个进程崩溃，通常不会影响到其他进程，从而提高了服务器的整体稳定性。</p></li><li><p><strong>隔离性</strong>: 每个进程有自己的地址空间，这意味着进程之间的内存是隔离的。这样可以防止某个进程的错误操作影响到其他进程。</p></li><li><p><strong>利用多核优势</strong>: 多进程模型能够在多核处理器上运行，每个进程可以被操作系统调度到不同的CPU核心上，充分利用硬件资源。</p></li></ul><p><strong>缺点</strong>：</p><ul><li><p><strong>资源消耗</strong>: 每个进程都需要一定量的内存和系统资源，如果进程数过多，会占用大量的系统资源，这可能导致服务器的性能下降。</p></li><li><p><strong>上下文切换开销</strong>: 多进程意味着操作系统需要频繁地在进程之间进行上下文切换，这个过程涉及到保存和加载寄存器、更新各种表等操作，会消耗一定的CPU时间。</p></li></ul><h4 id="多线程服务器"><a href="#多线程服务器" class="headerlink" title="多线程服务器"></a>多线程服务器</h4><p>虽然多进程模型提高了服务器的稳定性和隔离性，但它也带来了<strong>资源消耗、上下文切换开销</strong>等限制。针对多进程模型的这些限制，多线程服务器模型提供了一个更为高效的解决方案。</p><p>多线程服务器模型在同一个进程内创建多个线程来处理客户端请求，每个线程能够独立执行，<strong>它们共享进程的资源，如内存空间等资源。而且上下文切换也更快。</strong></p><p><strong>图示</strong>：<br><img src="/images/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/11.png"></p><p><strong>多线程回射服务器的示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">server_fd = socket();</span><br><span class="line">bind(server_fd, ...);</span><br><span class="line">listen(server_fd, ...);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="type">int</span> new_socket = accept(server_fd, ...);</span><br><span class="line">    <span class="type">pthread_t</span> thread_id;</span><br><span class="line">    <span class="keyword">if</span> (pthread_create(&amp;thread_id, <span class="literal">NULL</span>, handle_client, (<span class="type">void</span>*)&amp;new_socket) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Handle error</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">handle_client</span><span class="params">(<span class="type">void</span>* socket)</span> &#123;</span><br><span class="line">    <span class="type">int</span> new_socket = *(<span class="type">int</span>*)socket;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> bytes_read;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        bytes_read = read(new_socket, buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">        <span class="keyword">if</span> (bytes_read &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// Break the loop if read error or end of file</span></span><br><span class="line">        &#125;</span><br><span class="line">        write(new_socket, buffer, bytes_read);</span><br><span class="line">    &#125;</span><br><span class="line">    close(new_socket);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>多线程服务器优缺点</strong>：</p><ul><li><strong>资源效率</strong>: 线程共享进程的内存空间，相较于多进程模型，多线程服务器在内存和资源上的开销更小。</li><li><strong>上下文切换效率</strong>: 线程间的上下文切换比进程间的切换要快，因为线程共享许多资源，切换时所需的资源较少（<strong>线程切换一般只需要切换各自寄存器和栈上的数据</strong>）。</li><li><strong>利用多核优势</strong>: 线程可以分布在多个 CPU 核心上运行，这使得多线程服务器能够充分利用多核 CPU 的计算能力。</li></ul><p><strong>缺点</strong>：</p><ul><li><strong>同步复杂性</strong>: 因为线程共享内存和资源，所以必须仔细设计同步机制来避免竞态条件和其他并发问题。</li><li><strong>稳定性风险</strong>: 一个线程的错误可能影响整个进程，因为它们共享同一内存空间。这可能导致整个服务器程序崩溃。</li><li><strong>资源限制</strong>: 虽然线程比进程轻量，但大量线程仍然会消耗大量系统资源，尤其是在高并发情况下。</li><li><strong>调试困难</strong>: 多线程程序的调试较为复杂，尤其是当出现了线程安全问题时，这些问题可能难以重现和定位。</li></ul><h4 id="线程池模型"><a href="#线程池模型" class="headerlink" title="线程池模型"></a>线程池模型</h4><p>在多线程服务器模型中，每个客户端请求都由一个新的线程来处理。这种方法虽然有效，<strong>但在面对大量并发请求时，频繁地创建和销毁线程会导致服务器的性能下降。</strong> 特别是在请求数量剧增的情况下，线程创建和销毁的开销会变得显著，同时过多的活跃线程也会竞争有限的CPU和内存资源，进一步影响服务的响应时间和吞吐量。</p><p>而在线程池模型中，服务器启动时会预先创建一定数量的线程，这些线程存放在池中，并不立即执行任务。当客户端请求到达时，请求会被分配给线程池中的一个空闲线程，该线程负责处理整个请求过程。处理完毕后，线程并不销毁，而是返回到池中等待处理下一个请求。</p><p><strong>图示</strong>：</p><p><img src="/images/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/12.png"></p><p><strong>说明</strong>：</p><p><strong>服务器（Server）</strong>：这是整个流程开始的地方。服务器初始化一个线程池，并不断监听客户端的连接请求。当一个客户端连接请求到来时，服务器接受这个连接（accept()），然后把相应的任务（job：一般是读写客户端数据的逻辑）添加到线程池的任务队列中去。最终，当服务器不再需要线程池时，会销毁它。</p><p><strong>线程池（ThreadPool</strong>）：线程池是预先创建的线程集合，用于执行多个任务。它分为两个主要部分：</p><ul><li><strong>任务队列（Job Queue）</strong>：这里存放所有待处理的任务（jobs）。当服务器接受一个客户端的连接，它会创建一个任务，并将其添加到这个队列中。</li><li><strong>线程队列（Thread Queue）</strong>：这里存放的是线程池中所有可用的线程。当任务队列中有任务时，线程池会分配一个线程去执行这个任务。</li></ul><p><strong>客户端（Clients）</strong>：客户端通过网络连接与服务器进行通信。</p><h4 id="I-O多路复用服务器"><a href="#I-O多路复用服务器" class="headerlink" title="I&#x2F;O多路复用服务器"></a>I&#x2F;O多路复用服务器</h4><p><strong>什么是 I&#x2F;O 多路复用？</strong></p><p>在 Linux 中，I&#x2F;O 多路复用是一种允许<strong>单个进程或线程同时监控多个文件描述符</strong>（通常是网络套接字）上的读写就绪状态的技术。这使得程序能够在一个或多个文件描述符上发生 I&#x2F;O 事件时被通知，从而对这些事件作出响应（比如进行读写操作）。这种机制极大地提高了处理多个并发网络连接的效率，因为它允许使用较少的系统资源（如进程和线程）来管理大量的连接。</p><p>上面我们在讲解 I&#x2F;O 模型的时候，提到了 IO 多路复用，而在讲解服务器模型我们又再次提到了IO 多路复用。<strong>可能大家会有疑问：IO 多路复用到底属于 I&#x2F;O 模型还是服务器模型？</strong></p><p>其实 I&#x2F;O 多路复用技术是两者之间的桥梁：它是一种有效的 I&#x2F;O 处理方式，同时也是构建服务器模型的基础。</p><ul><li>I&#x2F;O 多路复用作为 I&#x2F;O 模型，关注的是如何有效地管理和执行 I&#x2F;O 操作，特别是在涉及多个 I&#x2F;O 源（如网络套接字）时。</li><li>I&#x2F;O 多路复用作为服务器模型，则是在这种 I&#x2F;O 操作的管理方式基础上构建整个服务器的架构，决定如何接收和处理多个客户端请求，如何分配处理程序来响应这些请求，以及如何利用系统资源。</li></ul><p><strong>简单来说，I&#x2F;O 模型是关于”如何执行 I&#x2F;O”的，而服务器模型是基于某种 I&#x2F;O 模型来构建服务的，以及如何组织服务器程序以响应客户端请求。</strong></p><p><strong>常见的 I&#x2F;O 多路复用技术</strong>：</p><p>Linux 提供了多种 I&#x2F;O 多路复用的机制，如 select, poll, 和 epoll。这些技术的主要区别在于它们处理大量文件描述符的方式和效率。</p><p><strong>IO 复用之 Select</strong>：</p><p><strong>基本概念</strong>：<br>Linux 中的 select 函数是一种常用的 I&#x2F;O 复用技术。它允许程序监视多个文件描述符（FDs），以检测是否有任何一个或多个 FD 准备好进行读取、写入或是否有异常发生。这种技术特别适用于同时处理多个网络连接或其他类型的 I&#x2F;O 操作（如：文件I&#x2F;O）。</p><p><strong>函数声明</strong></p><p>select 函数的基本声明如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, <span class="keyword">struct</span> timeval *timeout)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数结构</span></span><br><span class="line"><span class="comment">nfds：监视的文件描述符集合中最大的文件描述符加一。</span></span><br><span class="line"><span class="comment">readfds：一个指向 fd_set 结构的指针，用于监视哪些 FD 准备好进行读操作。</span></span><br><span class="line"><span class="comment">writefds：一个指向 fd_set 结构的指针，用于监视哪些 FD 准备好进行写操作。</span></span><br><span class="line"><span class="comment">exceptfds：一个指向 fd_set 结构的指针，用于监视哪些 FD 有异常发生。</span></span><br><span class="line"><span class="comment">timeout：指定 select 等待准备就绪的 FD 的最长时间。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>fd_set 结构图解展示</strong>：</p><p>fd_set 是一个文件描述符数组，用于指示 select 函数应该监视的 FDs。</p><p><strong>fd_set 结构图解展示</strong>：</p><p><img src="/images/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/13.jpg"></p><p><strong>说明</strong>：</p><p>参数 readfds、writefds、exceptfds 从用户空间传入内核空间和从内核空间返回用户空间，文件描述符数组中的值代表的含义不同：</p><p><strong>以可读事件 readfds 为例</strong>：</p><p><strong>从用户空间传入内核空间</strong>：数组值为 0 代表不监控该文件描述符（fd），数组值为 1 代表要监控该文件描述符（fd）。</p><p><strong>从内核空间返回用户空间</strong>：数组值为 0 代表该文件描述符数据未准备就绪，数组值为 1 代表该文件描述符数据准备就绪。用户进程可以进行读操作了。</p><p><strong>select 并发回射服务器程序示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 8080</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_CLIENTS 30</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> server_fd, new_socket, client_socket[MAX_CLIENTS];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    <span class="type">int</span> addrlen = <span class="keyword">sizeof</span>(address);</span><br><span class="line">    fd_set readfds;</span><br><span class="line">    <span class="type">int</span> max_sd, sd, activity, i, valread;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">1025</span>];  <span class="comment">// 数据缓冲区</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化所有客户端套接字</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_CLIENTS; i++) &#123;</span><br><span class="line">        client_socket[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建套接字</span></span><br><span class="line">    server_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 绑定套接字</span></span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    address.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    address.sin_port = htons(PORT);</span><br><span class="line">    bind(server_fd, (<span class="keyword">struct</span> sockaddr *)&amp;address, <span class="keyword">sizeof</span>(address))&lt;<span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听套接字</span></span><br><span class="line">    listen(server_fd, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        FD_ZERO(&amp;readfds);<span class="comment">// 清空 fd_set</span></span><br><span class="line">        FD_SET(server_fd, &amp;readfds); <span class="comment">// 添加 server_fd 到 fd_set</span></span><br><span class="line">        max_sd = server_fd;</span><br><span class="line">        <span class="comment">// 添加客户端套接字到 fd_set</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_CLIENTS; i++) &#123;</span><br><span class="line">            sd = client_socket[i];</span><br><span class="line">            <span class="keyword">if</span> (sd &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                FD_SET(sd, &amp;readfds);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sd &gt; max_sd) &#123;</span><br><span class="line">                max_sd = sd;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 select 监听套接字</span></span><br><span class="line">        activity = select(max_sd + <span class="number">1</span>, &amp;readfds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接受新连接</span></span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(server_fd, &amp;readfds)) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((new_socket = accept(server_fd, (<span class="keyword">struct</span> sockaddr *)&amp;address, (<span class="type">socklen_t</span>*)&amp;addrlen))&lt;<span class="number">0</span>) &#123;</span><br><span class="line">              <span class="comment">// 错误处理并退出</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将新套接字添加到数组</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_CLIENTS; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (client_socket[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                    client_socket[i] = new_socket;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     <span class="comment">// 其他套接字的数据处理</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_CLIENTS; i++) &#123;</span><br><span class="line">        sd = client_socket[i];</span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(sd, &amp;readfds)) &#123;</span><br><span class="line">            <span class="comment">// 检查是否是断开连接，否则接收数据</span></span><br><span class="line">            <span class="keyword">if</span> ((valread = read(sd, buffer, <span class="number">1024</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">                close(sd);</span><br><span class="line">                client_socket[i] = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                buffer[valread] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                <span class="comment">// 将接收到的数据发送回客户端</span></span><br><span class="line">                send(sd, buffer, <span class="built_in">strlen</span>(buffer), <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>select优缺点</strong>：</p><p><strong>优点</strong>:</p><ul><li><p><strong>能够同时监视多个套接字</strong>:  select 允许服务器以单线程的方式监视多个套接字，来检测它们是否有可读、可写或异常条件发生。</p></li><li><p><strong>无需多线程或多进程</strong>：select 采用单线程的处理方式，使用 select 可以避免复杂的多线程或多进程管理，减少了上下文切换的开销，简化了并发处理。</p></li><li><p><strong>适用于小到中等规模的负载</strong>：对于不是很高的并发连接数（几百的连接数），select 通常可以满足需求，且效率不错。</p></li></ul><p><strong>缺点</strong>:</p><ul><li><p><strong>文件描述符限制</strong>：select 可以监视的文件描述符数量是有限的，通常由 <strong>FD_SETSIZE</strong> 常量决定，这在很多系统上默认是1024。这限制了服务器可以处理的最大并发连接数。当然 select 也会受限于系统级别的文件描述符数量限制。</p></li><li><p><strong>效率问题</strong>：随着文件描述符数量的增加，select 的性能会线性下降。每次调用select时，都需要重新传入整个文件描述符集合，内核需要遍历这个集合来更新状态，这在文件描述符很多时会成为瓶颈。</p></li><li><p><strong>响应时间变长</strong>：在 select 返回的文件描述符列表集合中，如果有多个文件描述符同时变为活跃状态，服务器通常会按顺序处理它们。这可能导致对列表前面的连接有偏见，使得后面的连接等待时间较长。</p></li></ul><p><strong>IO 复用之 Poll</strong>：</p><p><strong>基本概念</strong>：<br>poll 也是一种 IO 复用技术，用于监视多个文件描述符（通常是网络套接字）的可读性、可写性和异常状态。与 select 类似，poll 允许您的程序监视多个文件描述符，直到一个或多个文件描述符准备好进行 IO 操作。这使得您可以同时管理多个网络连接，而不是逐个阻塞地处理它们。</p><p><strong>函数声明</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span>;</span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">fds：指向一个 pollfd 结构数组的指针，该数组包含要监视的文件描述符及其请求的事件（如 POLLIN 表示可读，POLLOUT 表示可写）。</span></span><br><span class="line"><span class="comment">nfds：指定数组 fds 中的元素数量。</span></span><br><span class="line"><span class="comment">timeout：指定等待时间（毫秒）。特殊值有：0 立即返回（非阻塞），-1 无限等待直到某个事件发生。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>pollfd 结构</strong></p><p>poll 函数使用 pollfd 结构来指定要监视的文件描述符和事件类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> fd;         <span class="comment">// 文件描述符</span></span><br><span class="line">    <span class="type">short</span> events;   <span class="comment">// 请求的事件</span></span><br><span class="line">    <span class="type">short</span> revents;  <span class="comment">// 实际发生的事件</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">fd：文件描述符</span><br><span class="line">events：要监视的事件，如 POLLIN、POLLOUT</span><br><span class="line">revents：由 poll 函数设置，表明哪些事件实际发生了</span><br></pre></td></tr></table></figure><p><strong>Poll 底层采用的数据结构图解</strong></p><p><img src="/images/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/14.jpg"></p><p><strong>底层数据结构：</strong></p><p><strong>用户空间数组</strong>：用户空间程序使用数组（类型为 struct pollfd）来提供要监视的文件描述符及其感兴趣的事件</p><p>但在内核中，为了有效地处理这些文件描述符，poll 的实现转而使用链表。</p><p><strong>内核空间链表</strong>：</p><ul><li>当 poll 系统调用被执行时，内核首先将这个数组中的数据复制到内核空间。</li><li>在内核中，为了更灵活地处理可能的大量文件描述符，这些 pollfd 结构被组织成链表形式。</li><li>链表的每个节点可能包含一个或多个 pollfd 结构，具体取决于可用的内存和文件描述符的数量。</li></ul><p><strong>poll 优缺点</strong>：</p><p><strong>优点</strong>：</p><p><strong>无内置文件描述符限制</strong>：与 select 不同，poll 不受文件描述符数量的限制。select 通常受限于 FD_SETSIZE，这在处理大量并发连接时可能成为瓶颈。<strong>但它仍然受限于系统级别的文件描述符限制。</strong></p><p><strong>简化的接口</strong>：poll 使用单个结构体数组来表示所有监视的文件描述符和相关事件，相比 select 需要使用三个文件描述符集（读、写、异常），接口更为简洁。</p><p><strong>更直观的事件模型</strong>：poll 使用位字段来表示不同的事件类型，这使得事件模型比 select 的方式更直观和易于理解。</p><p><strong>缺点</strong>：</p><p><strong>线性扫描开销</strong>：poll 在处理文件描述符时，需要对整个数组进行线性扫描。当监视的文件描述符数量非常大时，这可能导致性能下降。</p><p>总的来说，poll 是 select 的一种改进，特别是在可处理的文件描述符数量上没有限制，但在高性能和大规模并发处理方面，epoll 在现代 Linux 系统上通常是更佳的选择。</p><p><strong>poll 并发回射服务器程序示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 8080</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_CLIENTS 30</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> listen_fd, new_socket, valread;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    <span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> addrlen = <span class="keyword">sizeof</span>(address);</span><br><span class="line">    <span class="type">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">client_fds</span>[<span class="title">MAX_CLIENTS</span>];</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建监听套接字</span></span><br><span class="line">   listen_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)；</span><br><span class="line">    <span class="comment">// 绑定套接字</span></span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    address.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    address.sin_port = htons(PORT);</span><br><span class="line"></span><br><span class="line">    bind(listen_fd, (<span class="keyword">struct</span> sockaddr *)&amp;address, <span class="keyword">sizeof</span>(address)</span><br><span class="line">    listen(listen_fd, <span class="number">3</span>); <span class="comment">// 开始监听</span></span><br><span class="line">    <span class="comment">// 初始化 pollfd 结构</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_CLIENTS; i++) &#123;</span><br><span class="line">        client_fds[i].fd = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    client_fds[<span class="number">0</span>].fd = listen_fd;</span><br><span class="line">    client_fds[<span class="number">0</span>].events = POLLIN;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主循环</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> activity = poll(client_fds, MAX_CLIENTS, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (activity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">//出错处理并退出</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查是否有新的连接</span></span><br><span class="line">        <span class="keyword">if</span> (client_fds[<span class="number">0</span>].revents &amp; POLLIN) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((new_socket = accept(listen_fd, (<span class="keyword">struct</span> sockaddr *)&amp;address, (<span class="type">socklen_t</span>*)&amp;addrlen)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="comment">//出错处理并退出</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加新的套接字到数组</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; MAX_CLIENTS; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (client_fds[i].fd == <span class="number">-1</span>) &#123;</span><br><span class="line">                    client_fds[i].fd = new_socket;</span><br><span class="line">                    client_fds[i].events = POLLIN;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查客户端活动</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; MAX_CLIENTS; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (client_fds[i].fd &gt; <span class="number">0</span> &amp;&amp; (client_fds[i].revents &amp; POLLIN)) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((valread = read(client_fds[i].fd, buffer, BUFFER_SIZE)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    buffer[valread] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                    send(client_fds[i].fd, buffer, valread, <span class="number">0</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    close(client_fds[i].fd);</span><br><span class="line">                    client_fds[i].fd = <span class="number">-1</span>; <span class="comment">// 标记为可用</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>IO 复用之 Epoll</strong></p><p><strong>基本概念</strong>：<br>epoll 是 Linux 系统中一种高效的 I&#x2F;O 事件通知机制，特别适用于处理大量并发网络连接。与传统的 select 或 poll 方法相比，epoll 的独特之处在于其对活跃连接的高效处理能力。它通过维护一个活跃事件集合，避免了对所有文件描述符的遍历，显著提升了性能。这使得 epoll 成为构建高性能网络应用程序的理想选择。</p><p><strong>函数声明</strong></p><p>epoll 主要涉及三个系统调用：epoll_create、epoll_ctl 和 epoll_wait。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// epoll_create：创建一个 epoll 实例。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>;</span><br><span class="line"><span class="comment">// poll_ctl：管理（添加、修改或删除）监视的文件描述符。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">epfd：由 epoll_create 返回的 epoll 实例文件描述符。</span></span><br><span class="line"><span class="comment">op：要执行的操作，如 EPOLL_CTL_ADD（添加）、EPOLL_CTL_MOD（修改）、EPOLL_CTL_DEL（删除）。</span></span><br><span class="line"><span class="comment">fd：关联的文件描述符。</span></span><br><span class="line"><span class="comment">event：指向 epoll_event 结构的指针，指定感兴趣的事件和任何关联的用户数据。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 待在 epoll 文件描述符上注册的事件发生</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event *events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">epfd：epoll 实例的文件描述符。</span></span><br><span class="line"><span class="comment">events：用于从内核获取事件的 epoll_event 结构数组。</span></span><br><span class="line"><span class="comment">maxevents：指示数组中可以返回的最大事件数。</span></span><br><span class="line"><span class="comment">timeout：等待事件的最大时间（毫秒），-1 表示无限等待。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>epoll_event 结构</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span>     events;    <span class="comment">/* Epoll events */</span></span><br><span class="line">    <span class="type">epoll_data_t</span> data;      <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">events 字段用于指定感兴趣的事件类型，例如 EPOLLIN（可读）、EPOLLOUT（可写）等。</span></span><br><span class="line"><span class="comment">data 字段通常用于存储用户定义的数据，如文件描述符、指向对象的指针等。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//epoll_data_t 是一个联合（union），它用于存储用户定义的数据，可以是文件描述符、指针或任何其他用户需要的数据类型。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *ptr;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">uint32_t</span> u32;</span><br><span class="line">    <span class="type">uint64_t</span> u64;</span><br><span class="line">&#125; <span class="type">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">例如，您可以在 epoll_ctl 调用时，使用 epoll_data_t 的 fd 字段来存储正在监视的文件描述符，</span></span><br><span class="line"><span class="comment">或者使用 ptr 字段来存储指向某个对象或结构的指针。这样，在事件发生时，您可以快速访问与该事件相关联的数据。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>Epoll 的两种触发模式</strong>：</p><p>在 Linux 中，epoll 提供了两种触发模式：<strong>水平触发（Level-Triggered, LT）和边缘触发（Edge-Triggered, ET）</strong>。理解这两种模式对于使用 epoll 来说非常关键，因为它们决定了在文件描述符（FD）上发生事件时，epoll 如何通知应用程序。</p><p><strong>水平触发（Level-Triggered, LT）</strong></p><p><strong>触发条件</strong>：只要文件描述符关联的 socket 缓冲区上有数据可读或有空间可写，epoll_wait 就会返回该文件描述符。这意味着，只要有未处理的数据（如缓冲区中还有数据未读），epoll_wait 会不断地通知应用程序去读数据至用户空间缓存，从而进行处理。</p><p><strong>处理方式</strong>：这种模式更加容易处理，因为即使应用程序没有一次性处理所有的可用数据，epoll_wait 会再次通知你该文件描述符上仍有待处理的数据。</p><p><strong>水平触发的优点</strong>：</p><ul><li><p><strong>简单易懂</strong>：水平触发的行为更直观，容易理解和实现，尤其是对于那些不太熟悉非阻塞 I&#x2F;O 编程的开发者。</p></li><li><p><strong>容错性高</strong>：在水平触发模式下，只要文件描述符的状态仍满足条件（如有数据可读），epoll_wait 会持续通知应用程序，减少了因遗漏事件处理导致的错误。</p></li></ul><p><strong>水平触发的缺点</strong>：</p><ul><li><p><strong>可能的性能开销</strong>：在高负载或大量并发连接的情况下，水平触发可能导致频繁的 epoll_wait 响应。因为只要文件描述符仍然处于活跃状态（例如，仍有数据可读），它就会不断地触发事件。</p></li><li><p><strong>资源使用效率</strong>：由于频繁的事件触发，水平触发模式可能导致更高的CPU使用率，尤其是当有大量活跃的文件描述符时。</p></li></ul><p><strong>水平触发示例代码：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line"><span class="type">int</span> epoll_fd, fd;</span><br><span class="line"></span><br><span class="line">event.events = EPOLLIN; <span class="comment">// LT 是默认模式</span></span><br><span class="line">event.data.fd = fd;</span><br><span class="line">epoll_ctl(epoll_fd, EPOLL_CTL_ADD, fd, &amp;event);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件循环</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[<span class="title">MAX_EVENTS</span>];</span></span><br><span class="line">    <span class="type">int</span> n = epoll_wait(epoll_fd, events, MAX_EVENTS, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (events[i].data.fd == fd) &#123;</span><br><span class="line">            <span class="comment">// 可以读取部分数据，即使不全部读取完，该 FD 仍然会再次报告</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>边缘触发（Edge-Triggered, ET）</strong></p><p><strong>触发条件</strong>：只有文件描述符的状态发生改变时，epoll_wait 才会通知应用进程来读写数据（只通知一次），直到文件描述符的状态再次发生变化。</p><p><strong>那什么才是文件描述符的状态发生改变呢？</strong></p><p>文件描述符的状态发生改变指的是 <strong>fd 从不可读的状态改变成可读的状态或者fd 从不可写的状态改变成可写的状态。</strong></p><p><strong>对于 socket 可读事件来说</strong>：</p><p>fd 从不可读的状态改变成可读的状态，简单理解就是：<strong>fd 对应的 socket 接收缓冲区从无数据到有数据。</strong> </p><p><strong>具体点</strong>：就是当数据首次到达一个空的 socket 接收缓冲区时，epoll_wait 会通知应用程序一次。此时，缓冲区状态从“无数据可读”变为“有数据可读”。又或者应用程序开始读取数据，并将缓冲区中的数据读完（读操作返回 EAGAIN），然后又有新数据到达。这两种情况都是属于 socket 接收缓冲区从无数据到有数据的例子。</p><p><strong>再来看个特殊情况：</strong></p><p>在 ET 模式下，一旦应用程序开始读取数据，如果没有一次性将缓冲区中的所有数据都读取完（即仍有未读取的数据留在缓冲区中），此时不会触发新的 epoll_wait 通知。但是如果此时接收缓冲区又来了新数据，即使文件描述符的状态并没有发生改变，但也会触发新的 epoll_wait 通知的。</p><p><strong>对于 socket 可写事件来说</strong>：</p><p>文件描述符的状态发生改变指的是：fd 从不可写的状态改变成可写的状态。简单理解就是：<strong>fd 对应的 socket 发送缓冲区从满到不满。</strong> 对于可写事件，存在以下两个场景：</p><h4 id="场景一：持续有空间"><a href="#场景一：持续有空间" class="headerlink" title="场景一：持续有空间"></a>场景一：持续有空间</h4><p>假设你有一个socket连接，你正在向它发送数据。在边缘触发（ET）模式下：</p><ul><li><strong>初始状态</strong>：连接建立后，发送缓冲区为空，所以你可以开始发送数据。</li><li><strong>持续发送</strong>：只要发送缓冲区有空间，你可以继续发送数据。在这个过程中，如果缓冲区从未真正变满过（即，你的发送速度不超过网络层处理和发送数据的速度），epoll_wait不会因为缓冲区有空间而特别通知你，因为从epoll的角度看，这不是一个“状态变化”。</li></ul><h4 id="场景二：缓冲区满后又有空间"><a href="#场景二：缓冲区满后又有空间" class="headerlink" title="场景二：缓冲区满后又有空间"></a>场景二：缓冲区满后又有空间</h4><p>现在，让我们看一个缓冲区实际变满的情况：</p><p><strong>1.发送直至满</strong>：你继续发送数据，直到达到一个点，发送缓冲区满了，这时，尝试再发送数据会失败（通常返回EAGAIN或EWOULDBLOCK）。</p><p><strong>2.等待可写</strong>：这时，你应该停止发送数据，等待 epoll_wait 通知你 socket 再次可写。</p><p><strong>3.缓冲区部分清空</strong>：随着时间的推移，网络层将缓冲区中的数据发送出去，缓冲区从“满”变为“有空间”（即，部分数据被发送出去，为新数据腾出了空间）。</p><p><strong>4.收到通知</strong>：因为缓冲区的状态从“满”变为“有空间”，这是一个状态变化，epoll_wait 会通知你 socket 现在可写。</p><p><strong>处理方式</strong>：ET 模式要求你必须一次性处理所有可用的数据。如果处理不完全，epoll_wait 不会再次通知你该文件描述符上的事件，除非新的数据到达或再次变为可写。</p><p><strong>边缘触发示例代码：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line"><span class="type">int</span> epoll_fd, fd;</span><br><span class="line"></span><br><span class="line">event.events = EPOLLIN | EPOLLET; <span class="comment">// 启用 ET 模式</span></span><br><span class="line">event.data.fd = fd;</span><br><span class="line">epoll_ctl(epoll_fd, EPOLL_CTL_ADD, fd, &amp;event);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件循环</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[<span class="title">MAX_EVENTS</span>];</span></span><br><span class="line">    <span class="type">int</span> n = epoll_wait(epoll_fd, events, MAX_EVENTS, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (events[i].data.fd == fd) &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">ssize_t</span> count = read(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                <span class="keyword">if</span> (count == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (errno != EAGAIN) &#123;</span><br><span class="line">                        <span class="comment">// 处理非 EAGAIN 错误</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>; <span class="comment">// 没有更多数据可读</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 处理读取的数据</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>边缘触发的优缺点：</strong></p><p><strong>优点：</strong></p><p><strong>减少通知频率：</strong></p><p>在 ET 模式中，epoll_wait 只在文件描述符（如套接字）的状态发生变化时通知一次（例如，从不可读变为可读）。这减少了系统不断检查状态的需要，尤其在管理大量连接时非常有效。</p><p><strong>提高事件处理效率：</strong></p><p>由于减少了频繁的事件通知，应用程序可以更集中地处理每次通知的事件。这在同时处理许多连接时提升了效率。每次事件都得到了充分的处理，而不是浪费资源在重复或不必要的检查上，从而整体提高了处理大量并发连接的效率。</p><p><strong>降低资源占用：</strong></p><p>ET 模式通过减少频繁的事件检查和处理，有助于减少 CPU 和内存的使用，尤其在高负载下。</p><p><strong>更好的扩展性：</strong></p><p>对于需要处理大量并发连接的高性能服务器，ET 模式能够更高效地利用资源，使服务器能够承载更多的连接，从而提升整体的扩展能力。</p><p><strong>缺点：</strong></p><p><strong>处理逻辑更加复杂：</strong></p><p>在 ET 模式下，必须在每次通知时尽可能完整地处理 I&#x2F;O 事件（读取或写入所有数据），因为相同条件下不会再次收到通知。这要求程序能够有效地一次性处理大量数据。</p><p><strong>可能会错过一些数据：</strong></p><p>如果在处理通知时没有完全读取或写入所有数据，剩余的数据可能不会触发新的通知，导致程序错过一些重要数据。</p><p><strong>依赖于非阻塞 I&#x2F;O：</strong></p><p>ET 模式通常和非阻塞 I&#x2F;O 结合使用。在这种模式下，编程变得更复杂，因为需要处理非阻塞调用可能遇到的特殊情况，如 EAGAIN 或 EWOULDBLOCK。</p><p><strong>总结：</strong></p><p><strong>水平触发</strong>：更易于使用和理解，但可能会导致更多的 epoll_wait 调用，尤其是在高负载下。</p><p><strong>边缘触发</strong>：更高的性能潜力，减少了 epoll_wait 调用的次数，但需要更谨慎的缓冲区管理和错误处理。</p><p><strong>Epoll 优缺点</strong></p><p><strong>优点：</strong></p><p><strong>1.高效的文件描述符管理</strong></p><p>在 epoll 中，高效的文件描述符管理首先依赖于高效的数据结构（红黑树和链表）以及回调函数。epoll 使用红黑树来组织所有监控的文件描述符，提供快速的查找、插入和删除操作。链表则用于存储准备就绪的事件，使得 epoll_wait 能迅速返回这些事件。每当监控的文件描述符发生状态变化（例如，socket 上有数据到来）时，与之关联的回调函数被内核自动触发。这些回调函数直接将就绪的文件描述符事件添加到 epoll 的就绪链表中。使得 epoll_wait 快速返回，这种集成了回调机制和高效数据结构的方法，使 epoll 在处理大量并发连接时比传统的 select 和 poll 方法更高效。</p><p>  相比之下，select 和 poll 每次调用时都需要遍历整个文件描述符集合，以检查每个描述符的状态。当文件描述符数量很大时，这种方法的效率显著降低。</p><p><strong>2.更好的可扩展性</strong></p><p>epoll 能够处理的文件描述符数量远超过 select 的 FD_SETSIZE 限制（通常为1024），使其能够更有效地处理成千上万的并发连接。这使 epoll 成为高并发网络应用的理想选择，例如大型网站的服务器。</p><p><strong>3.减少复制操作</strong></p><p>在传统的 select 和 poll 方法中，应用程序需要在每次调用时将整个文件描述符集合从用户空间复制到内核空间，内核处理完后再将结果复制回用户空间。这种来回复制操作效率比较低。</p><p>而在 epoll 中，只需要将就绪事件从内核空间的就绪链表复制到用户空间，而非整个被监控的文件描述符集合。这种机制大大减少了数据在用户空间和内核空间之间频繁来回复制的需求，特别是在只有少数文件描述符就绪的大规模并发连接场景中，显著降低了上下文切换和数据复制的开销，从而提高了整体的效率和性能。</p><p><strong>4.支持边缘触发（ET）和水平触发（LT）</strong></p><ul><li><strong>两种触发模式</strong>：epoll 提供了边缘触发（ET）和水平触发（LT）两种模式。边缘触发仅在文件描述符状态发生变化时通知一次，而水平触发则在描述符保持某状态时持续通知。</li><li><strong>适应不同的使用场景</strong>：<br>这种灵活性使得开发者可以根据具体的应用需求和行为特点选择最合适的模式，以优化性能。</li></ul><p><strong>缺点：</strong></p><p><strong>平台依赖性：</strong> epoll 是 Linux 特有的，不具备 select 和 poll 那样的跨平台特性。这意味着基于 epoll 的应用程序不能在非 Linux 系统上直接运行，限制了其可移植性。</p><p><strong>边缘触发模式的挑战</strong></p><p>在边缘触发（ET）模式下，epoll 只在状态变化时通知一次。这意味着应用程序必须正确处理所有的数据，否则可能会丢失未处理的事件。 </p><p><strong>Epoll 并发回射服务器程序示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_EVENTS 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> READ_BUF_SIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 8080</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> listen_fd, conn_fd, epoll_fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>, <span class="title">events</span>[<span class="title">MAX_EVENTS</span>];</span></span><br><span class="line">    <span class="type">int</span> event_count, i;</span><br><span class="line">    <span class="type">char</span> read_buf[READ_BUF_SIZE];</span><br><span class="line"></span><br><span class="line">    socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    server_addr.sin_port = htons(PORT);</span><br><span class="line">    bind(listen_fd, (<span class="keyword">struct</span> sockaddr *)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr))</span><br><span class="line">    listen(listen_fd, SOMAXCONN)</span><br><span class="line"></span><br><span class="line">    epoll_fd = epoll_create1(<span class="number">0</span>);</span><br><span class="line">    event.events = EPOLLIN;</span><br><span class="line">    event.data.fd = listen_fd;</span><br><span class="line"></span><br><span class="line">    epoll_ctl(epoll_fd, EPOLL_CTL_ADD, listen_fd, &amp;event)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        event_count = epoll_wait(epoll_fd, events, MAX_EVENTS, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; event_count; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (events[i].data.fd == listen_fd) &#123;</span><br><span class="line">                conn_fd = accept(listen_fd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">                <span class="keyword">if</span> (conn_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">                    perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                event.events = EPOLLIN | EPOLLET;</span><br><span class="line">                event.data.fd = conn_fd;</span><br><span class="line">                <span class="keyword">if</span> (epoll_ctl(epoll_fd, EPOLL_CTL_ADD, conn_fd, &amp;event) == <span class="number">-1</span>) &#123;</span><br><span class="line">                    perror(<span class="string">&quot;epoll_ctl&quot;</span>);</span><br><span class="line">                    close(conn_fd);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> nbytes = read(events[i].data.fd, read_buf, READ_BUF_SIZE);</span><br><span class="line">                <span class="keyword">if</span> (nbytes &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    close(events[i].data.fd);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    write(events[i].data.fd, read_buf, nbytes);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(listen_fd);</span><br><span class="line">    close(epoll_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="异步I-O服务器模型"><a href="#异步I-O服务器模型" class="headerlink" title="异步I&#x2F;O服务器模型"></a>异步I&#x2F;O服务器模型</h4><p>在讲述了 I&#x2F;O 多路复用服务器模型后，我们看到它如何使单个进程能够有效地管理多个网络连接。通过 select、poll 或 epoll，进程可以在多个连接上同时等待数据，而无需为每个连接阻塞等待。这种方法提升了并发处理的效率，<strong>但它有一个局限性：一旦某个连接的 I&#x2F;O 操作开始，该进程必须等待该操作完成才能继续处理下一个连接。</strong> 简单理解就是：处理各个连接的 IO 读写是同步的，是串行的。</p><p>为了解决这一问题，引入了异步I&#x2F;O服务器模型。这种模型极大提升了服务器的任务处理能力，它允许进程在发起I&#x2F;O操作后立即转而执行其他工作，而无需等待I&#x2F;O操作的完成。这一过程由操作系统在后台管理，一旦I&#x2F;O操作完成，进程便会收到通知。进程只需要去处理已被拷贝至应用层缓冲区的数据。</p><p><strong>Linux中的异步I&#x2F;O实现</strong>：</p><p>在Linux中，异步 IO 模型主要由 <strong>Linux aio</strong>（通过libaio库）和 <strong>io_uring</strong> 两种技术来实现。</p><p><strong>Linux aio(libaio)</strong></p><p>Linux aio 是 Linux 系统中较早支持的异步I&#x2F;O机制。它通过 libaio 库提供了一系列的API，允许应用程序非阻塞地启动和管理I&#x2F;O操作。当一个I&#x2F;O请求被提交后，libaio负责将其发送到操作系统，应用程序可以继续执行而无需等待。一旦I&#x2F;O操作完成，应用程序将通过回调函数或其他机制得到通知。</p><p><strong>libaio提供的 API</strong> :</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">io_setup       ：创建一个异步I/O上下文。</span><br><span class="line">io_submit      ：向异步I/O上下文提交一个或多个I/O请求。</span><br><span class="line">io_getevents   ：从异步I/O上下文中获取已完成的事件。</span><br><span class="line">io_destroy     ：销毁一个异步I/O上下文。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>尽管 libaio 为异步 I&#x2F;O 提供了基础支持，但它有一定的局限性，<strong>比如：它只适用于文件 I&#x2F;O，并不适合用于网络 I&#x2F;O。</strong></p><p>以下是一个简洁的 libaio 使用示例，演示了如何在 Linux 系统中以异步方式进行文件读取。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libaio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/eventfd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FILE_PATH <span class="string">&quot;example_file.txt&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">io_context_t</span> ctx;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iocb</span> <span class="title">cb</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iocb</span> *<span class="title">cbs</span>[1];</span></span><br><span class="line">    <span class="type">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">    <span class="type">int</span> file_fd, efd, ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_event</span> <span class="title">events</span>[1];</span></span><br><span class="line">    <span class="type">uint64_t</span> u;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;ctx, <span class="number">0</span>, <span class="keyword">sizeof</span>(ctx));</span><br><span class="line">    io_setup(<span class="number">10</span>, &amp;ctx);</span><br><span class="line">    file_fd = open(FILE_PATH, O_RDWR | O_CREAT, <span class="number">0644</span>);</span><br><span class="line">    <span class="comment">// 创建eventfd用于通知</span></span><br><span class="line">    efd = eventfd(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 准备异步读请求</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;cb, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> iocb));</span><br><span class="line">    io_prep_pread(&amp;cb, file_fd, buffer, BUFFER_SIZE, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 设置eventfd作为完成事件的通知</span></span><br><span class="line">    cb.data = (<span class="type">void</span> *)(<span class="type">uintptr_t</span>)efd;</span><br><span class="line">    cbs[<span class="number">0</span>] = &amp;cb;</span><br><span class="line">    <span class="comment">// 提交异步I/O请求</span></span><br><span class="line">    io_submit(ctx, <span class="number">1</span>, cbs)</span><br><span class="line">    <span class="comment">// 在这里，主线程可以执行其他业务逻辑</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    read(efd, &amp;u, <span class="keyword">sizeof</span>(<span class="type">uint64_t</span>));  <span class="comment">// 在主线程中等待通知</span></span><br><span class="line">    io_getevents(ctx, <span class="number">1</span>, <span class="number">1</span>, events, <span class="literal">NULL</span>);  <span class="comment">// 读取异步I/O事件</span></span><br><span class="line">    <span class="comment">// 处理完成的I/O事件</span></span><br><span class="line">    <span class="keyword">if</span>(events[<span class="number">0</span>].data == (<span class="type">void</span> *)(<span class="type">uintptr_t</span>)efd) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Read %zd bytes: %.*s\n&quot;</span>, events[<span class="number">0</span>].res, (<span class="type">int</span>)events[<span class="number">0</span>].res, buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    close(file_fd);</span><br><span class="line">    io_destroy(ctx);</span><br><span class="line">    close(efd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>io_uring</strong>：</p><p>io_uring 是 Linux 内核 5.1 版本引入的全新异步 I&#x2F;O 框架，io_uring 旨在提供一种高效、灵活且功能丰富的方式来执行异步 I&#x2F;O 操作。与 libaio 相比，io_uring 提供了更低的系统调用开销，更简单的接口，以及更好的性能。</p><p><strong>如何工作</strong>：</p><p>io_uring 的核心思想是通过两个队列来管理异步 I&#x2F;O 请求。一个叫做提交队列（SQ），另一个叫完成队列（CQ）。</p><p>1.<strong>提交请求</strong>：当你的程序想要执行一个 I&#x2F;O 操作，比如读取网络数据，它会创建一个请求并把它放到提交队列（SQ）中。</p><p>2.<strong>内核处理</strong>：Linux 内核会查看提交队列，取出请求并处理它们。你的程序不需要等待内核完成这个操作，它可以继续做其他事情。</p><p>3.<strong>完成通知</strong>：一旦内核完成了一个请求，它会把结果放入完成队列（CQ）中。这样程序就知道该操作已经完成，可以继续处理结果了。</p><p><strong>io_uring 的优势：</strong></p><ul><li><strong>性能</strong>：它允许应用程序一次性地批量提交多个 I&#x2F;O 请求，减少了系统调用的数量，所以 io_uring 能够提供比传统的异步 I&#x2F;O 更好的性能。</li><li><strong>减少等待</strong>：应用程序不需要每次提交一个请求就等待结果，它可以继续执行其他任务，同时内核在背后处理这些 I&#x2F;O 请求。</li><li><strong>功能丰富</strong>：io_uring 支持各种类型的 I&#x2F;O 操作，包括但不限于文件读写、网络操作等。</li><li><strong>易用性</strong>：io_uring 提供了一个更为简洁和一致的接口，相比于旧的异步 I&#x2F;O 接口，它更易于使用和理解。</li></ul><p>关于异步 IO 服务器模型的学习，大家只需要理解异步IO的工作方式，以及了解在 Linux 中可以通过 libaio 和 io_uring 技术可以构建异步 IO 服务器模型。如果想深入学习 io_uring 的底层原理，则可以去官网或者谷歌搜索相关资料去深入学习。</p><p><strong>这篇文章，大家可以去了解：</strong><br><a href="https://cloud.tencent.com/developer/article/2187655">https://cloud.tencent.com/developer/article/2187655</a> </p><p><strong>关于具体的代码示例，则可以去了解 liburing 这个库的 example 代码示例</strong>：<a href="https://github.com/axboe/liburing">https://github.com/axboe/liburing</a></p><h3 id="服务器架构模式"><a href="#服务器架构模式" class="headerlink" title="服务器架构模式"></a>服务器架构模式</h3><p>在前面的介绍中，我们了解了常见的服务器模型，但是这些模型在应对高并发场景都会遇到一些挑战，特别是在处理大量并发连接和高效率 I&#x2F;O 操作方面。尽管模型如多线程、线程池和 I&#x2F;O 多路复用提供了并发处理的基础架构，但它们各自都有局限性，特别是在高并发和低延迟要求的场景中。</p><p>这些挑战促使了对一种更高效、更可扩展的并发处理模式的需求— 这就是 Reactor 模式。Reactor 模式采用事件驱动的方法，结合同步 I&#x2F;O 多路复用技术，如 select、poll 或 epoll，提供了一种不同于传统线程模型的并发处理机制。</p><p><strong>为什么需要 Reactor 模式？</strong></p><p><strong>并发和 I&#x2F;O 效率</strong>：传统的多线程和多进程模型在处理成千上万的并发连接时可能会遇到性能瓶颈。这些模型往往涉及重的上下文切换和资源分配，特别是在频繁的 I&#x2F;O 操作下。</p><p><strong>简化事件处理</strong>：在 I&#x2F;O 多路复用模型中，虽然可以高效地监控多个 I&#x2F;O 流，但在事件分发和处理方面往往缺乏组织和结构。Reactor 模式提供了一种清晰的框架来处理多个并发 I&#x2F;O 事件，简化了事件驱动程序的开发。</p><h4 id="Reactor-模式详解"><a href="#Reactor-模式详解" class="headerlink" title="Reactor 模式详解"></a>Reactor 模式详解</h4><p><strong>Reactor 是什么？</strong></p><p>Reactor 模式可以理解为一种在网络编程中常用的设计模式，用于高效地处理多个并发 I&#x2F;O 事件，如用户请求或网络通信。它的核心概念是使用一个中心化的处理器（称为 Reactor）来监控所有的 I&#x2F;O 请求。当一个 I&#x2F;O 事件发生时（例如，新的客户端连接或者数据到达），Reactor 会捕获这个事件，并将其分派给相应的处理程序进行处理。</p><p><strong>核心组件：</strong></p><p><strong>1.Handles (句柄)：</strong></p><p><strong>定义</strong>：句柄是对操作系统资源的引用，通常是<strong>文件描述符</strong>（file descriptor）。在网络编程中，这通常是指代网络套接字（sockets）。</p><p><strong>用途</strong>：它用于标识一个特定的网络连接或其他 I&#x2F;O 资源，如打开的文件、管道等。</p><p><strong>示例</strong>：当一个客户端连接到服务器，服务器会为这个连接创建一个套接字，并为其分配一个文件描述符，这个文件描述符就是一个句柄。</p><p><strong>2.Synchronous Event Demultiplexer (事件多路分发器)：</strong></p><p><strong>定义</strong>：事件多路分发器是负责等待多个句柄上事件发生的组件。它可以同时监控多个句柄，如网络套接字上的可读或可写事件。</p><p><strong>实现</strong>：在 Linux 中，这通常通过系统调用如 select, poll 或 epoll 实现。</p><p><strong>功能</strong>：当一个或多个句柄上发生事件时（例如，新的客户端连接、数据到达等），事件多路分发器通知 Reactor。</p><p><strong>3.Event Handler (事件处理器)：</strong></p><p><strong>定义：</strong> 它是一个定义了处理不同类型事件所需接口或协议的抽象概念。通常包含一系列的方法或函数，用于处理各种事件，如读取数据（可读事件）、写入数据（可写事件）或处理错误（错误事件）。事件处理器定义了在发生特定事件时应当调用哪些方法，但不涉及这些方法的具体实现。</p><p><strong>例如：</strong> 一个事件处理器接口可能有一个 handle_read 方法用于处理可读事件，但它并不实现该方法。</p><p><strong>4.Concrete Event Handlers (具体事件处理器)：</strong></p><p><strong>定义：</strong> 具体事件处理器实现了定义在事件处理器接口中的所有方法，提供了如何处理特定事件的具体逻辑。</p><p>例如，一个具体事件处理器可能实现 handle_read 方法来从套接字中读取数据并处理这些数据。又或者实现 handle_accept 方法来处理客户端的连接请求。</p><p>具体事件处理器是实际工作的组件，每个具体的事件处理器实例通常与应用程序中的一个特定资源（一个socket 文件描述符）关联。</p><p><strong>5.Initiation Dispatcher (初始化分发器)：</strong></p><p><strong>定义</strong>：初始化分发器是 Reactor 模式的核心组件，负责管理事件循环、监听事件并将它们分发到相应的具体事件处理器。</p><p><strong>职责</strong>：它初始化事件多路分发器，注册事件处理器，并在事件发生时调用相应的具体事件处理器。</p><p><strong>事件循环</strong>：在整个应用程序的生命周期内，初始化分发器运行一个循环，等待和分发事件。</p><p><strong>select 实现的 Reactor 网络服务器程序</strong></p><p>这里只是提供一个简单示例，但以上的5个组件都包含。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 8080</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_CLIENTS 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">handler_t</span> handlers[MAX_CLIENTS];</span><br><span class="line"><span class="type">int</span> num_clients = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">handler_t</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> handle; <span class="comment">//句柄：在我们的上下文中就是套接字描述符。</span></span><br><span class="line">    <span class="type">void</span> (*handle_func)(<span class="type">int</span> handle, <span class="type">void</span> *arg);  <span class="comment">//事件处理器</span></span><br><span class="line">&#125; <span class="type">handler_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体事件处理器 ： 处理客户端的连接请求</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">acceptor_handler_func</span><span class="params">(<span class="type">int</span> handle, <span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> client_len = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line">    <span class="type">int</span> client_fd = accept(handle, (<span class="keyword">struct</span> sockaddr*)&amp;client_addr, &amp;client_len);</span><br><span class="line">    <span class="keyword">if</span> (client_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Accepted connection from %s\n&quot;</span>, inet_ntoa(client_addr.sin_addr));</span><br><span class="line">    <span class="comment">// 将新客户端加入到 handlers 中</span></span><br><span class="line">    handlers[num_clients].handle = client_fd;</span><br><span class="line">    handlers[num_clients].handle_func = client_handler_func;</span><br><span class="line">    num_clients++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体事件处理器：处理客户端的数据处理请求</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">client_handler_func</span><span class="params">(<span class="type">int</span> handle, <span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="type">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">    <span class="type">int</span> nbytes = recv(handle, buffer, <span class="keyword">sizeof</span>(buffer), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nbytes &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        close(handle);</span><br><span class="line">        <span class="comment">// 将handle从handlers数组中移除</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_clients; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (handlers[i].handle == handle) &#123;</span><br><span class="line">                handlers[i] = handlers[num_clients - <span class="number">1</span>];</span><br><span class="line">                num_clients--;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        send(handle, buffer, nbytes, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">event_demultiplexer</span><span class="params">()</span> &#123;</span><br><span class="line">    fd_set read_fds;</span><br><span class="line">    <span class="type">int</span> fd_max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    FD_ZERO(&amp;read_fds);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_clients; i++) &#123;</span><br><span class="line">        FD_SET(handlers[i].handle, &amp;read_fds);</span><br><span class="line">        <span class="keyword">if</span> (handlers[i].handle &gt; fd_max) &#123;</span><br><span class="line">            fd_max = handlers[i].handle;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待 socket 上的可读事件</span></span><br><span class="line">    <span class="keyword">if</span> (select(fd_max + <span class="number">1</span>, &amp;read_fds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;select&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分发事件</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_clients; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(handlers[i].handle, &amp;read_fds)) &#123;</span><br><span class="line">            handlers[i].handle_func(handlers[i].handle, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Initiation Dispatcher (初始化分发器)</span></span><br><span class="line"><span class="comment">Initiation Dispatcher 是 Reactor 模式的核心，允许应用程序注册事件、注销事件。并且它负责启动事件循环，等待事件并分发事件。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">run_reactor</span><span class="params">(<span class="type">int</span> listen_fd)</span> &#123;</span><br><span class="line">    <span class="comment">// 注册事件</span></span><br><span class="line">    handlers[num_clients].handle = listen_fd;</span><br><span class="line">    handlers[num_clients].handle_func = acceptor_handler_func;</span><br><span class="line">    num_clients++;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 启动事件循环</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        event_demultiplexer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> listen_fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    listen_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_port = htons(PORT);</span><br><span class="line">    server_addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    bind(listen_fd, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr);</span><br><span class="line">    listen(listen_fd, <span class="number">10</span>);</span><br><span class="line">  </span><br><span class="line">    run_reactor(listen_fd);</span><br><span class="line">    close(listen_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于 <strong>epoll</strong> 的高效性，我们一般会基于 epoll 去实现 reactor。<strong>具体实现可参考这篇文章：</strong><br><a href="https://zhuanlan.zhihu.com/p/539556726">https://zhuanlan.zhihu.com/p/539556726</a></p><p><strong>Reactor 事件处理流程</strong></p><p>下面通过时序图来图示上述代码的执行过程，方便大家理解：</p><p><img src="/images/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/15.png"></p><h4 id="Reactor-模式的优势和应用场景"><a href="#Reactor-模式的优势和应用场景" class="headerlink" title="Reactor 模式的优势和应用场景"></a>Reactor 模式的优势和应用场景</h4><p><strong>Reactor 模式的主要优势包括：</strong></p><ul><li><strong>高效的资源利用</strong>：<br>通过单线程或少量线程来管理多个并发连接，减少了线程上下文切换和资源消耗，提高了资源利用效率。</li><li><strong>快速响应能力</strong>：<br>非阻塞和事件驱动机制确保了快速响应外部事件，提高了程序的响应速度。</li><li><strong>更好的可扩展性</strong>：<br>能够处理成千上万的并发连接，而不会遇到传统多线程或多进程模型中线程资源限制的问题。</li></ul><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>这种模式特别适合于需要高并发处理的网络服务器，如 Web 服务器、数据库服务器等。</p><p><strong>结论：</strong><br>Reactor 模式是现代高性能网络编程的基石之一。它通过事件驱动和非阻塞 I&#x2F;O 机制有效地解决了传统并发模型在高并发环境下的限制，为构建可扩展的网络应用提供了强大的工具。</p><h4 id="Proactor-模式详解"><a href="#Proactor-模式详解" class="headerlink" title="Proactor 模式详解"></a>Proactor 模式详解</h4><p>在前面的讲解中，我们探讨了 Reactor 模式。该模式主要依赖于同步 I&#x2F;O，然而，随着并发需求的增加，尤其在高负载环境下，同步 I&#x2F;O 的局限性逐渐凸显。</p><p>应对这一挑战，异步编程模型的 <strong>Proactor 模式</strong>提供了一种全新的解决方案。它区别于 Reactor 的同步等待，转而采用<strong>完全异步的 I&#x2F;O 操作</strong>。在这个模式下，应用程序无需在 I&#x2F;O 完成前等待，而是在 I&#x2F;O 完成后接收通知。Proactor 模式有效减少了等待时间，提高了对并发连接的处理效率，尤其适合于构建<strong>高性能</strong>、<strong>I&#x2F;O 密集型</strong>的网络应用。这一模式不仅提升了性能，也代表了网络编程范式的一次重要转变，为开发高效和可扩展的网络服务提供了新思路。</p><p><strong>Proactor 是什么？</strong></p><p>Proactor 模式是一种高级的异步编程模型，用于处理 I&#x2F;O 操作。与传统的同步 I&#x2F;O 操作（如 Reactor 模式）不同，Proactor 模式允许应用程序在不阻塞主执行线程的情况下执行 I&#x2F;O 操作。应用程序发起异步 I&#x2F;O 请求后可以继续执行其他任务，而无需阻塞等待 I&#x2F;O 操作的完成。当 I&#x2F;O 操作实际完成时，操作系统会通知应用程序，并触发预定义的回调函数或事件处理程序来处理 I&#x2F;O 操作的结果。</p><p><strong>核心组件</strong></p><p><strong>异步操作对象：</strong> 该对象代表了单个的异步 I&#x2F;O 操作，如异步读取或写入。它 们通常封装了操作的细节，如操作类型、目标资源(文件描述符)、缓冲区地址等。</p><p><strong>异步操作对象的定义</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    ADD_TYPE_ACCEPT,</span><br><span class="line">    ADD_TYPE_READ,</span><br><span class="line">    ADD_TYPE_WRITE</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">io_data</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> type; <span class="comment">// ADD_TYPE_ACCEPT, ADD_TYPE_READ, ADD_TYPE_WRITE 等</span></span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">size_t</span> bytes_read;</span><br><span class="line">    <span class="type">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p><strong>Proactor 初始器（Proactor Initiator）</strong> ：<br>Proactor 初始器是负责启动和配置异步 I&#x2F;O 操作流程的组件。它通常由用户空间的代码执行，负责准备和提交异步 I&#x2F;O 请求到内核。</p><p>在 io_uring 中，Proactor 初始器 对应的是用户空间代码，特别是负责初始化 io_uring 实例、以及提交异步 I&#x2F;O 请求到内核的逻辑。</p><p><strong>来看下在 io_uring 中， Proactor Initiator 的代码示例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化 io_uring实例</span></span><br><span class="line"><span class="type">int</span> ret = io_uring_queue_init(<span class="number">256</span>, &amp;ring, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交一个异步读取请求</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">submit_async_read</span><span class="params">(<span class="keyword">struct</span> io_uring *ring, <span class="type">int</span> fd)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_data</span> *<span class="title">data</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span>  io_data));</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">io_uring_sqe</span> *<span class="title">sqe</span>  =</span> io_uring_get_sqe(ring); </span><br><span class="line">    data-&gt;fd = fd;</span><br><span class="line">    data-&gt;type = ADD_TYPE_READ;</span><br><span class="line">    io_uring_prep_read(sqe, fd, data-&gt;buffer, BUFFER_SIZE, <span class="number">0</span>);      <span class="comment">// 准备读取请求</span></span><br><span class="line">    io_uring_sqe_set_data(sqe, data); <span class="comment">// 设置用户数据</span></span><br><span class="line">    io_uring_submit(ring);  <span class="comment">// 提交请求</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>异步操作处理器（Asynchronous Operation Processor）</strong>：<br>异步操作处理器是 Proactor 模式的核心，在内核中执行，负责启动异步 I&#x2F;O 操作并在操作完成时通知用户空间的 Proactor 实例。</p><p>在 io_uring 中，异步操作处理器 实际上是 io_uring 的内核组件。这包括提交队列（SQ）和完成队列（CQ），以及内核中负责处理这些队列的逻辑。</p><p><strong>完成处理器（Completion Handler）</strong></p><p>完成处理器是由应用程序定义的回调函数，它们在异步 I&#x2F;O 操作完成时被调用以处理 I&#x2F;O 操作的结果。</p><p>在 io_uring 中，完成处理器 对应于那些被提交到 io_uring 并在 I&#x2F;O 操作完成后执行的回调函数。这些回调函数处理 io_uring 从完成队列中获取的 CQEs(多个完成队列条目)。</p><p><strong>异步读取回调函数代码示例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">handle_read</span><span class="params">(<span class="keyword">struct</span> io_uring *ring, <span class="keyword">struct</span> io_uring_cqe *cqe)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">io_data</span> *<span class="title">data</span> =</span> io_uring_cqe_get_data(cqe);</span><br><span class="line">    <span class="keyword">if</span> (!data) &#123;</span><br><span class="line">        <span class="keyword">return</span>;  <span class="comment">// 数据为空则直接返回</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cqe-&gt;res &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 客户端断开连接或读取错误</span></span><br><span class="line">        close(data-&gt;fd);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 读取数据，准备回写(data-&gt;buffer缓冲区已经有数据了)</span></span><br><span class="line">        data-&gt;bytes_read = cqe-&gt;res;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Received: %.*s\n&quot;</span>, (<span class="type">int</span>)data-&gt;bytes_read, data-&gt;buffer);</span><br><span class="line">        <span class="comment">// 可以在这里添加写回逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(data);  <span class="comment">// 释放内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Proactor 实例</strong>：<br>Proactor 实例是负责管理整个异步 I&#x2F;O 流程的组件，它管理着异步操作处理器和完成处理器，调度完成处理器，并处理所有的异步事件。</p><p>在 io_uring 中，Proactor 实例 对应的是用户空间中维护 io_uring 接口和逻辑的部分，<strong>其实就是一个事件循环</strong>，它负责监控完成队列（CQ），确定哪些 I&#x2F;O 操作已经完成，并触发相应的完成处理器。</p><p><strong>Proactor 实例代码示例：</strong></p><pre><code class="c">// 运行事件循环以处理异步 I/O 操作void run_io_uring_loop(struct io_uring *ring) &#123;    struct io_uring_cqe *cqe;    unsigned head;    while (1) &#123;        // 提交所有挂起的请求并等待至少一个请求完成        io_uring_submit_and_wait(ring, 1);        // 处理所有已完成的事件        io_uring_for_each_cqe(ring, head, cqe) &#123;            if (cqe-&gt;res &lt; 0) &#123;                fprintf(stderr, &quot;IO operation failed: %s\n&quot;, strerror(-cqe-&gt;res));            &#125; else &#123;                handle_read(ring, cqe); // 调用完成处理器            &#125;            // 标记该事件已处理            io_uring_cqe_seen(ring, cqe);        &#125;    &#125;&#125;</code></pre><p><strong>Proactor 事件处理流程</strong></p><p><strong>启动异步操作（Proactor 初始器）</strong>：</p><p>你的程序（通过 Proactor 初始器）准备一个异步 I&#x2F;O 操作，比如说读取文件或接收网络数据。这个准备过程涉及指定要进行的操作类型（例如读取或写入）、哪个文件或网络连接，以及数据存放的位置。</p><p>一旦准备好，这个异步操作被提交给操作系统。如果使用 io_uring，这意味着将操作请求放入 io_uring 的提交队列（SQ）。操作系统内核处理异步操作（由异步操作处理器执行）。</p><p>一旦异步操作被提交，操作系统接管这个任务。在 io_uring 中，内核会处理这些 I&#x2F;O 请求。<strong>与此同时，你的程序可以继续执行其他任务，不必等待 I&#x2F;O 操作完成。</strong></p><p><strong>通知 Proactor实例</strong> ：</p><p>当操作系统完成了一个异步 I&#x2F;O 操作，它会将此操作的结果放入完成队列（CQ）。</p><p>你的程序中的 Proactor 实例会定期检查这个完成队列，看看是否有任何操作已经完成。</p><p><strong>处理完成的操作（完成处理器）：</strong></p><p>对于每一个已经完成的操作，Proactor 实例会调用相应的完成处理器。完成处理器是你事先定义好的，专门用来处理异步操作完成后的数据的函数。比如说，如果操作对象是网络套接字，处理器可能会处理读取到的数据。</p><p><strong>清理和准备下一步操作</strong>：</p><p>一旦完成处理器运行完毕，Proactor 实例会进行必要的清理工作，并准备接收和处理更多的完成事件。</p><p><strong>总结一下</strong>：Proactor 模式允许你的程序异步地执行 I&#x2F;O 操作，同时继续进行其他任务。操作系统在后台处理这些 I&#x2F;O 请求，当它们完成时，你的程序会得到通知，并调用相应的回调函数来处理结果。这个过程优化了资源的使用，提高了应用程序的响应性和效率。</p><h4 id="Proactor-模式的优势"><a href="#Proactor-模式的优势" class="headerlink" title="Proactor 模式的优势"></a>Proactor 模式的优势</h4><p><strong>完全的异步处理：</strong></p><p>Proactor 模式实现了真正的异步 I&#x2F;O。在 Proactor 模式中，所有的 I&#x2F;O 操作（包括读写）都是异步完成的。这意味着应用程序可以在 I&#x2F;O 操作进行时继续执行其他任务，而无需等待 I&#x2F;O 操作的完成。<br>相比之下，Reactor 模式通常只能异步地处理 I&#x2F;O 请求的准备阶段（例如等待数据到达或可发送状态），而实际的读写操作仍然是同步进行的。</p><p><strong>减少线程阻塞：</strong></p><p>在 Proactor 模式中，由于 I&#x2F;O 操作完全异步，应用程序线程不会因等待 I&#x2F;O 操作而阻塞，这对于保持高性能和响应性是非常重要的。<br>Reactor 模式虽然减少了直接的 I&#x2F;O 等待（例如等待数据到达），但在处理数据时仍然可能出现阻塞（如：数据处理操作耗时较长）。</p><p><strong>简化编程模型：</strong></p><p>Proactor 模式通过预定义的回调或事件处理器简化了异步 I&#x2F;O 的编程模型，使得代码更加清晰和易于维护。<br>在 Reactor 模式中，编程者需要显式处理 I&#x2F;O 事件的分发和响应，可能导致更复杂的事件处理逻辑。</p><h4 id="Proactor-模式的应用场景"><a href="#Proactor-模式的应用场景" class="headerlink" title="Proactor 模式的应用场景"></a>Proactor 模式的应用场景</h4><p><strong>高性能网络服务器</strong>：</p><p>如 Web 服务器、数据库服务器等，特别是在需要处理大量并发网络请求的场景。</p><p><strong>文件 I&#x2F;O 密集型应用</strong>：</p><p>例如日志处理、大数据分析，以及任何需要频繁读写大型文件的应用。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在本系列文章中，我们深入探讨了Linux下的套接字编程，一个在网络通信中不可或缺的核心技术-<strong>套接字</strong>。套接字作为网络通信的基石，使得不同主机间的数据交换变得可能。</p><p><strong>套接字的本质</strong></p><p>我们首先解析了套接字的概念，它是支持TCP&#x2F;IP网络通信的基础API，为应用层与网络层之间提供了一个抽象层。通过套接字，应用程序可以不用关心底层的网络细节，就能进行网络通信。</p><p><strong>套接字类型</strong></p><p>接着，我们探讨了<strong>套接字的三种基本类型</strong>：</p><ul><li><strong>流式套接字（SOCK_STREAM</strong>）：提供序列化的、可靠的、双向的连接通信。</li><li><strong>数据报套接字（SOCK_DGRAM）</strong>：提供非连接的、不可靠的通信。</li><li><strong>原始套接字（SOCK_RAW）</strong>：允许直接访问底层协议，用于需要细粒度控制的场景。</li></ul><p><strong>关键API与结构</strong></p><p>我们详细介绍了套接字编程中的关键API，如 <strong>socket、bind、listen、accept、connect以及send和recv函数</strong>，以及套接字地址结构（如sockaddr）和地址转换API，这些是进行套接字编程的基础。</p><p><strong>数据处理</strong></p><p>字节序转换API的讨论，帮助我们处理跨平台的数据一致性问题。</p><p><strong>Linux的IO模型</strong></p><p>本系列文章还覆盖了Linux系统中的多种IO模型，包括阻塞IO、非阻塞IO、I&#x2F;O多路复用、信号驱动IO和异步IO，它们各有优势，适用于不同的场景。</p><p><strong>网络I&#x2F;O性能优化</strong></p><p>在网络I&#x2F;O性能优化部分，我们讨论了<strong>硬件优化和软件优化</strong>策略，强调了应用程序设计的重要性和内核参数调整的作用。</p><p><strong>服务器模型</strong></p><p>最后，我们探讨了 Linux 环境下常见的服务器模型，包括单进程、多进程、多线程、线程池和I&#x2F;O多路复用模型以及异步I&#x2F;O服务器模型，每种模型都有其应用场景和优缺点。</p><p><strong>架构模式</strong></p><p>服务器架构模式，如 <strong>Reactor</strong> 和 <strong>Proactor</strong>，提供了高效处理并发网络事件的方法，是构建高性能网络应用的关键。</p><p><strong>至此：</strong> 我们已经探索了 Linux 网络编程的核心领域，涵盖了从基本套接字类型与 API 的使用，到复杂的 I&#x2F;O 模型和服务器架构设计等关键知识点。这些内容构成了搭建高可用网络服务的基础框架。本篇文章主要是帮助大家提供一个清晰的 Linux 网络编程学习指南，希望这篇文章能够为你们学习编程提供帮助。</p><p>如果你对 <strong>Linux 网络编程</strong>有更深的兴趣，或者<strong>想要探索更多关于Linux编程、以及计算机基础相关的知识，不妨关注我的公众号「跟着小康学编程」</strong>。这里不仅有丰富的学习资源，还有持续更新的技术文章。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>另外，小康最近创建了一个技术交流群，专门用来探讨技术相关或者解答读者的问题。大家在阅读这篇文章的时候，如果觉得有问题的或者有不理解的知识点，欢迎大家加群或者评论区询问。我能够解决的，尽量给大家回复。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> Linux网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux网络编程 </tag>
            
            <tag> Linux 网络I/O模型 </tag>
            
            <tag> Linux 服务器模型 </tag>
            
            <tag> Linux 网络IO性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 系统编程从入门到进阶 学习指南</title>
      <link href="/systemprog/"/>
      <url>/systemprog/</url>
      
        <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>大家好，我是小康 ，今天我们来学习一下 Linux 系统编程相关的知识。Linux 系统编程是连接高级语言和硬件的桥梁，它对深入理解计算机系统至关重要。无论你是打算构建高性能服务器还是开发嵌入式设备，掌握 Linux 系统编程是 C 和 C++ 开发者的基本技能。</p><p>本文旨在为初学者提供一个清晰的 Linux 系统编程入门指南，带你步入 Linux 系统编程的世界，从基本概念到实用技能，一步步建立起您的知识体系。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>什么是系统编程？</strong></p><p>系统编程，指的是开发那些直接与计算机硬件或操作系统进行交互的程序。这些程序负责管理和控制计算机系统的资源，包括但不限于进程、内存、文件系统和设备驱动。确保为应用程序提供一个稳定、高效的运行环境。</p><p><strong>系统编程与应用编程的主要区别</strong>：</p><ul><li><strong>目的性</strong>：系统编程旨在为计算机或操作系统本身提供功能和服务，而应用编程是为了满足最终用户的特定需求。</li><li><strong>交互对象</strong>：系统编程直接与硬件或操作系统交互，而应用编程与操作系统或其他应用交互。</li><li><strong>复杂性</strong>：由于系统编程需要管理和控制计算机的底层资源，因此通常比应用编程更为复杂。</li><li><strong>开发工具</strong>：系统编程通常使用低级语言，如 C 或汇编，因为这些语言提供了直接访问硬件的能力。而应用编程可能使用更高级的语言，如 Python 或 Java，以提高开发效率。</li></ul><h2 id="Linux系统编程核心技术概览"><a href="#Linux系统编程核心技术概览" class="headerlink" title="Linux系统编程核心技术概览"></a>Linux系统编程核心技术概览</h2><p>在电脑的世界中，操作系统起到桥梁的作用，连接用户与计算机硬件。其中，Linux 由于其开源、稳定和安全的特点，成为了许多工程师的首选。为了更深入地理解它，我们首先需要了解其系统架构的神秘面纱。</p><p><img src="/images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/1.jpg"></p><h3 id="Linux-系统架构解析"><a href="#Linux-系统架构解析" class="headerlink" title="Linux 系统架构解析"></a>Linux 系统架构解析</h3><h4 id="用户空间和内核空间的布局"><a href="#用户空间和内核空间的布局" class="headerlink" title="用户空间和内核空间的布局"></a>用户空间和内核空间的布局</h4><p><img src="/images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/2.jpg"></p><p><strong>各个内核组件说明</strong>:</p><ul><li><p><strong>系统调用 （Syscalls）</strong>：</p><p>当应用程序需要访问硬件资源时，它们使用系统调用来与内核通信。</p></li><li><p><strong>进程管理</strong>：</p><p>负责处理进程创建、调度和终止。确保系统中的进程公平、有效地获得 CPU 时间，并管理进程间的通信和同步。</p></li><li><p><strong>内存管理</strong>：</p><p>管理物理内存，提供虚拟内存和分页功能。确保每个进程都有它自己的地址空间，同时保护进程间的内存不被非法访问。</p></li><li><p><strong>文件系统</strong>：</p><p>提供文件和目录的创建、读取、写入和删除功能。它抽象了物理存储设备，为用户和应用程序提供了一个统一的文件访问接口。</p></li><li><p><strong>虚拟文件系统（VFS）</strong>：</p><p>用户和应用程序不直接与各种文件系统交互。而是通过 VFS（虚拟文件系统）进行操作。VFS为各种不同的文件系统（如EXT4, FAT, NFS等）提供一个统一的接口。这样，无论底层使用的是哪种文件系统，用户和应用的文件访问方式都保持一致，实现在 Linux 中的无缝集成。</p></li><li><p><strong>网络协议栈</strong>：</p><p>负责处理计算机之间的通信，使设备能够在网络上发送和接收数据。它包含了多层协议，如 <strong>TCP&#x2F;IP</strong>，使计算机能够连接到互联网和其他网络，并与其他计算机进行数据交换。</p></li><li><p><strong>设备驱动</strong>：</p><p>设备驱动是一种特殊的软件程序，它允许 Linux 内核和计算机的硬件组件进行交互。这些硬件组件可以是任何物理设备，如显卡、声卡、网络适配器、硬盘或其他输入&#x2F;输出设备。设备驱动为硬件设备提供了一个抽象层，使得内核和应用程序不需要知道硬件的具体细节，就能与其进行通信和控制。<strong>简而言之，设备驱动是硬件和操作系统之间通信的桥梁。</strong></p></li></ul><h4 id="用户空间-User-Space"><a href="#用户空间-User-Space" class="headerlink" title="用户空间 (User Space)"></a>用户空间 (User Space)</h4><p>所有的应用程序，如浏览器、文档编辑器或音乐播放器都运行在这个空间。</p><ul><li><strong>安全性</strong>：用户空间的程序运行在受限的环境中，它们只能访问分配给它们的资源，不能直接访问硬件或其他程序的数据。</li><li><strong>稳定性</strong>：如果一个应用程序崩溃，它不会影响其他应用程序或系统的核心功能。</li></ul><h4 id="内核空间-Kernel-Space"><a href="#内核空间-Kernel-Space" class="headerlink" title="内核空间 (Kernel Space)"></a>内核空间 (Kernel Space)</h4><p>内核空间是操作系统的核心。</p><ul><li><strong>权限</strong>：内核可以直接访问硬件，并有权执行任何命令。</li><li><strong>安全性</strong>：虽然内核拥有广泛的权限，但只有那些已知且经过严格测试和验证的代码才被允许在内核空间执行。</li><li><strong>稳定性</strong>：如果内核遇到问题，整个系统可能会崩溃。</li></ul><h3 id="系统调用与库函数"><a href="#系统调用与库函数" class="headerlink" title="系统调用与库函数"></a>系统调用与库函数</h3><p>在 <strong>Linux</strong> 编程中，我们经常听到“系统调用”和“库函数”这两个词，但你知道它们之间的区别吗？接下来就让我们来详细了解一下。</p><h4 id="什么是系统调用？"><a href="#什么是系统调用？" class="headerlink" title="什么是系统调用？"></a>什么是系统调用？</h4><p>系统调用是一个程序向操作系统发出的请求。当应用程序需要访问某些资源（如磁盘、网络或其他硬件设备）或执行某些特定的操作（如创建进程或线程）时，它通常会通过系统调用来完成。</p><p><strong>工作原理</strong></p><ul><li><strong>模式切换</strong>：应用程序在用户空间运行，而操作系统内核在内核空间运行。系统调用涉及从用户空间切换到内核空间。</li><li><strong>参数传递</strong>：程序将参数传递给系统调用，通常通过特定的寄存器。</li><li><strong>执行</strong>：内核根据传递的参数执行相应的操作。</li><li><strong>返回结果</strong>：操作完成后，内核将结果返回给应用程序，并将控制权返回给应用程序。</li></ul><p><strong>常见的系统调用函数：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">read() 和 write()：分别用于读取和写入文件。</span><br><span class="line">open() 和 close()：打开和关闭文件。</span><br><span class="line">fork()：创建一个新的进程。</span><br><span class="line">wait()：等待进程结束。</span><br><span class="line">exec()：执行一个新程序。</span><br></pre></td></tr></table></figure><p>这只是系统调用的冰山一角。<strong>Linux</strong> 提供了上百个系统调用，每个都有其特定的功能。</p><h4 id="什么是库函数？"><a href="#什么是库函数？" class="headerlink" title="什么是库函数？"></a>什么是库函数？</h4><p>库函数是预编写的代码，存储在库文件中，供程序员使用。它们通过系统调用和操作系统的内核通信。例如，printf（） 是 C 语言的一个库函数，它内部使用 write（） 系统调用来和内核进行交互。</p><h3 id="文件-IO"><a href="#文件-IO" class="headerlink" title="文件 IO"></a>文件 IO</h3><p>文件IO（输入&#x2F;输出）是计算机程序与文件系统交互的基本方式，允许程序读取和写入文件。要深入理解和使用文件IO，首先需要了解一些关键概念和操作。</p><p><img src="/images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/20.jpg"></p><h4 id="文件描述符是什么？"><a href="#文件描述符是什么？" class="headerlink" title="文件描述符是什么？"></a>文件描述符是什么？</h4><p>文件描述符「 fd 」是一个整数，它代表了一个打开的文件。在 Linux 中，每次我们打开或创建一个文件时，系统都会返回一个文件描述符。而应用程序正是通过这个文件描述符「 fd 」来进行文件的读写的。</p><p><strong>特殊的文件描述符</strong>:</p><ul><li>标准输入<strong>「stdin」</strong> 是 0</li><li>标准输出<strong>「stdout」</strong> 是 1</li><li>标准错误 <strong>「stderr」</strong> 是 2</li></ul><h4 id="常见的文件操作"><a href="#常见的文件操作" class="headerlink" title="常见的文件操作"></a>常见的文件操作</h4><p>当应用程序要与文件交互时，最基本的操作包括打开、读取、写入和关闭文件。这可以通过以下函数来实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">打开文件：open()</span><br><span class="line">读取文件：read()</span><br><span class="line">写入文件：write()</span><br><span class="line">关闭文件：close()</span><br><span class="line"></span><br><span class="line"><span class="meta"># demo</span></span><br><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;example.txt&quot;</span>, O_RDWR | O_CREAT);</span><br><span class="line">write(fd, <span class="string">&quot;Hello, File!&quot;</span>, <span class="number">12</span>);</span><br><span class="line">close(fd);</span><br></pre></td></tr></table></figure><h4 id="文件位置与移动"><a href="#文件位置与移动" class="headerlink" title="文件位置与移动"></a>文件位置与移动</h4><p>有时，我们可能需要移动到文件的特定位置进行读写。使用 lseek（） 可以实现这一点。举个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">假设我们有一个名为 &quot;data.txt&quot; 的文件，内容为：Hello World!</span></span><br><span class="line"><span class="comment"> 现在我们有一个简单需求：我们想将文件中的&quot;World&quot;替换为&quot;Linux&quot;，但不想重写整个文件。 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># demo 展示：</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buffer[<span class="number">6</span>];  <span class="comment">// 存放从文件中读取的数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;data.txt&quot;</span>, O_RDWR);  # 以读写模式打开文件</span><br><span class="line">lseek(fd, <span class="number">6</span>, SEEK_SET);  <span class="comment">// 使用 lseek() 移动到&quot;World&quot;的开头位置</span></span><br><span class="line">read(fd, buffer, <span class="number">5</span>);     <span class="comment">// 读取5个字符（&quot;World&quot;的长度）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(buffer, <span class="string">&quot;World&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 重新定位文件指针以替换&quot;World&quot;,这里需要重新定位的原因是：上面 read 操作使得文件指针已经指向文件末尾了，因此需要重新定位。</span></span><br><span class="line">    lseek(fd, <span class="number">6</span>, SEEK_SET);</span><br><span class="line">    write(fd, <span class="string">&quot;Linux&quot;</span>, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line">close(fd) ; </span><br></pre></td></tr></table></figure><h4 id="高级文件-I-O"><a href="#高级文件-I-O" class="headerlink" title="高级文件 I&#x2F;O"></a>高级文件 I&#x2F;O</h4><p>有时，简单的读写操作无法满足我们的需求，尤其当我们追求高效率或特殊功能时。为了更优雅、高效地处理文件数据，我们引入了一些高级文件 I&#x2F;O 技巧。</p><p><strong>分散读取和集中写入</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 读取操作</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">readv</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec *iov, <span class="type">int</span> iovcnt)</span>;</span><br><span class="line"><span class="comment">// 写入操作</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">writev</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec *iov, <span class="type">int</span> iovcnt)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta"># iovec 结构的定义如下：</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> &#123;</span></span><br><span class="line">    <span class="type">void</span>  *iov_base;  </span><br><span class="line">    <span class="type">size_t</span> iov_len; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">iov_base 是指向缓冲区起始地址的指针。</span><br><span class="line">iov_len 是缓冲区的大小。</span><br></pre></td></tr></table></figure><p>这两个函数主要用于多缓冲区的输入&#x2F;输出操作，允许您在单次系统调用中，从文件读取到多个缓冲区或从多个缓冲区写入文件。</p><p>它们的主要目的是提高效率，因为常规的读&#x2F;写函数每次只能在一个缓冲区进行操作。</p><p><strong>内存映射文件I&#x2F;O</strong></p><p>内存映射文件 I&#x2F;O 允许程序员将文件的一部分直接映射到进程的内存中。这样，程序可以通过直接访问这块内存来访问文件的内容，而不是使用传统的 read 、write 系统调用。这可以提高效率，特别是对于大文件的访问。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 相关函数声明</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">mmap</span><span class="params">(<span class="type">void</span>* addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span>* addr, <span class="type">size_t</span> length)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// demo 举例:</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;example.txt&quot;</span>, O_RDWR);</span><br><span class="line"><span class="comment">// 获取文件的大小</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sb</span>;</span></span><br><span class="line"><span class="keyword">if</span> (fstat(fd, &amp;sb) == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;fstat&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> *mapped = mmap(<span class="literal">NULL</span>, sb.st_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后续的所有对文件的操作就可以通过 mapped 指针来进行。</span></span><br><span class="line"><span class="comment">// 例如：将第一个字符改为 &#x27;J&#x27;）</span></span><br><span class="line">mapped[<span class="number">0</span>] = <span class="string">&#x27;J&#x27;</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>使用 mmap ，你可以直接在内存中访问文件内容，如同访问数组或其他数据结构一样。</p><p><strong>同步文件操作</strong></p><p>当您向文件写入数据时，操作系统可能会缓存这些数据，而不是立即写入磁盘,这样可以提高效率。 但在某些情况下，您可能需要确保数据确实已经写入磁盘。这就是同步文件操作的用处。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">msync</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fsync</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fdatasync</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sync</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><ul><li>msync  用于同步内存映射（通过 mmap 函数创建）文件的内容。它将内存中的更改写回到映射的文件中。</li><li>fsync 函数用于将指定文件描述符（fd）关联的文件的所有修改（包括数据和元数据）同步到磁盘</li><li>fdatasync 函数类似于 fsync，但它只同步文件的数据部分，而不同步元数据。</li><li>sync 同步整个文件系统的所有修改的数据到磁盘，包括所有打开的文件。</li></ul><h4 id="文件锁定"><a href="#文件锁定" class="headerlink" title="文件锁定"></a>文件锁定</h4><p><strong>什么是文件锁定？</strong></p><p>文件锁定是一个在多个进程或线程之间协调对共享资源访问的机制。在这里，这个”共享资源”指的是文件。简单说，<strong>文件锁</strong>就是确保当一个进程正在使用一个文件时，其他进程不能修改它。</p><p><strong>为什么需要文件锁定？</strong></p><p>考虑这样一个场景：两个程序同时写入一个文件。不锁定文件可能会导致数据混乱。例如，一个进程可能会覆盖另一个进程的更改。所以，文件锁定是确保数据完整性的关键。</p><p><strong>文件锁的两种模式</strong>：</p><ul><li><p><strong>共享锁（Shared Locks）</strong>：也被称为读锁。当一个进程持有共享锁时，其他进程可以获得该文件的共享锁以进行读取，但不能获得独占锁进行写入。</p></li><li><p><strong>独占锁（Exclusive Locks）</strong>：也被称为写锁。当一个进程持有独占锁时，其他进程不能获得该文件的任何类型的锁。这意味着其他进程不可以读取或写入该文件。</p></li></ul><p><strong>如何实现文件锁定？</strong></p><p>在 Linux  编程中，文件锁定可以使用以下函数实现：</p><p><code>fcntl()</code> : 允许对文件中的特定部分进行锁定。</p><p><code>flock()</code> ：提供了一个简化的锁定机制，直接锁定整个文件。</p><h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><p><strong>什么是重定向？</strong></p><p><strong>重定向</strong>，顾名思义，指的是改变数据流的方向。在 <strong>Linux</strong> 系统编程中，程序通常与三种标准I&#x2F;O 流进行交互：标准输入（stdin）、标准输出（stdout）、和标准错误输出（stderr）。</p><ul><li>标准输入（stdin）         : 来自键盘的输入。</li><li>标准输出（stdout）        : 显示到屏幕上。</li><li>标准错误输出（stderr)     : 也显示到屏幕上。</li></ul><p><strong>重定向的核心是将这些标准的 I&#x2F;O 流改变到其他地方，如文件或其他程序。</strong></p><p>例如，当我们在命令行中执行命令并将结果保存到文件中，或者从文件中获取命令的输入而不是从键盘中获取，我们都是在使用重定向。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 将 ls -l 命令的输出（即当前目录的详细列表）重定向到 filelist.txt 文件中</span><br><span class="line">ls -l &gt; filelist.txt   </span><br></pre></td></tr></table></figure><p>重定向不仅局限于命令行界面，它在程序中也很有用，允许我们动态地更改程序的输入和输出来源，为构建更复杂、灵活的应用程序提供了基础。</p><p>在 <strong>Linux</strong> 系统编程中，实现重定向的一个核心函数是 <strong>dup2</strong> 函数。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup2</span><span class="params">(<span class="type">int</span> oldfd, <span class="type">int</span> newfd)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">其中：</span></span><br><span class="line"><span class="comment">oldfd 是原始文件描述符。</span></span><br><span class="line"><span class="comment">newfd 是要复制到的目标文件描述符。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># demo 举例:</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 打开一个文件用于写入</span></span><br><span class="line">    <span class="type">int</span> file_fd = open(<span class="string">&quot;output.txt&quot;</span>, O_WRONLY | O_CREAT | O_TRUNC, <span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span> (file_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 错误处理</span></span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 dup2 将标准输出重定向到文件</span></span><br><span class="line">    <span class="keyword">if</span> (dup2(file_fd, STDOUT_FILENO) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="comment">// 错误处理</span></span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在，所有标准输出都会被写入文件</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This will be written to the file &#x27;output.txt&#x27;\n&quot;</span>);</span><br><span class="line">    close(file_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Linux-进程"><a href="#Linux-进程" class="headerlink" title="Linux 进程"></a>Linux 进程</h3><p>你有没有想过，当你在 <strong>Linux</strong> 操作系统上运行一个程序时，都发生了哪些神奇的事情？接下来，我们将一步一步地深入探讨 Linux 进程的世界。</p><p><img src="/images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/3.jpg"></p><h4 id="进程究竟是什么？"><a href="#进程究竟是什么？" class="headerlink" title="进程究竟是什么？"></a>进程究竟是什么？</h4><p>每当你启动一个程序，<strong>Linux</strong> 系统都会创建一个新的进程。这个进程有它自己的内存地址、系统资源和状态。简而言之，进程是程序的一个运行实例。</p><h4 id="进程的创建和终止"><a href="#进程的创建和终止" class="headerlink" title="进程的创建和终止"></a>进程的创建和终止</h4><p><code>fork()</code>：当调用 fork 函数时，它会创建一个新的子进程。这个子进程几乎是父进程的复制品，包括父进程的内存、程序计数器等。</p><p><code>wait() &amp; waitpid()</code>：这些函数允许父进程等待子进程的结束，并收集子进程的退出状态。防止出现僵尸进程。</p><p><code>exec() 系列函数</code>：<strong>exec</strong> 系列函数 允许一个进程运行另一个程序，它实际上替换了当前进程的内容。</p><h4 id="进程的状态转换图"><a href="#进程的状态转换图" class="headerlink" title="进程的状态转换图"></a>进程的状态转换图</h4><p><img src="/images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/4.jpg"></p><p><strong>五态简要说明</strong>:</p><ul><li><p><strong>新建状态</strong>: 这是进程刚被创建时的状态。在这个状态下，操作系统为进程分配了一个唯一的进程标识符（PID）和必要的资源。但进程还没有开始执行任何代码。新建状态通常非常短暂，用户很难观察到，因为进程很快就会转移到 <strong>「就绪状态」</strong>。</p></li><li><p><strong>就绪状态</strong> : 进程已准备好运行并等待操作系统的调度器分配 CPU 时间片。在这个状态下，进程已经加载了所有必要的代码和数据到内存中，且已准备好执行。</p></li><li><p><strong>运行状态</strong> : 进程正在 CPU 上执行。一个进程只有在运行状态时才能执行其指令。</p></li><li><p><strong>阻塞状态</strong> : 进程不能执行，因为它在等待一些事件发生，例如 I&#x2F;O 操作的完成、信号的接收等。在此状态下，即使 CPU 空闲，进程也不能执行。</p></li><li><p><strong>终止状态</strong> : 进程已完成执行或被终止。在这个状态下，进程的资源通常被回收，进程退出。</p></li></ul><h4 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h4><p>在 Linux 的世界里，进程是操作系统进行资源分配的基本单位。但是，进程并不是孤立的存在。当你的应用分成多个独立运行的进程时，这些进程之间如何有效地交换信息呢？这正是通过进程间通信的方式来实现的。</p><p><strong>Linux 提供了以下几种进程间通信的方式</strong>：</p><p>1.管道 （Pipe）</p><p>管道是 Linux 中用于进程间通信的一种机制。它们分为两种类型：<strong>匿名管道</strong>和<strong>有名管道</strong>。</p><p><strong>匿名管道</strong>   : </p><p>  <strong>概念</strong>：匿名管道是一种在有亲缘关系的进程间（如父子进程）进行单向数据传输的通信机制，存在于内存中，通常用于临时通信。如果需要双向通信，则一般需要两个管道。</p><p>  <strong>简单图解：</strong></p><p>  <img src="/images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/5.jpg"></p><p>  <strong>使用场景</strong>：适用于有亲缘关系的进程间的简单数据传输。</p><p>  <strong>简单示例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">  pipe(pipefd); <span class="comment">// 创建匿名管道</span></span><br><span class="line">  <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123; <span class="comment">// 子进程</span></span><br><span class="line">      close(pipefd[<span class="number">1</span>]); <span class="comment">// 关闭写端</span></span><br><span class="line">      <span class="comment">//读取数据</span></span><br><span class="line">      read(pipefd[<span class="number">0</span>],buf,<span class="number">5</span>);</span><br><span class="line">      <span class="comment">// ... </span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 父进程</span></span><br><span class="line">      close(pipefd[<span class="number">0</span>]); <span class="comment">// 关闭读端</span></span><br><span class="line">      <span class="comment">// 写入数据</span></span><br><span class="line">      write(pipefd[<span class="number">1</span>],<span class="string">&quot;hello&quot;</span>,<span class="number">5</span>);</span><br><span class="line">      <span class="comment">// ... </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>有名管道</strong>   ：</p><p><strong>概念：</strong> <strong>有名管道（FIFO，First-In-First-Out）</strong> 是一种特殊类型的文件，用于在不相关的进程之间实现通信。与匿名管道不同，有名管道在文件系统中具有一个实际的路径名。这允许任何具有适当权限的进程打开和使用它，而不仅限于有亲缘关系的进程。</p><p><strong>简单图解：</strong></p><p><img src="/images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/6.jpg"></p><p><strong>简单说明</strong>：</p><p>有名管道是 Linux 中一种特殊的文件，它允许不同的进程通过读写这个文件来相互通信。</p><p><strong>使用场景</strong>：用于本机任何两个进程间的通信，特别是当这些进程没有血缘关系时。</p><p><strong>简单示例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *fifoPath = <span class="string">&quot;/tmp/my_fifo&quot;</span>;</span><br><span class="line">    mkfifo(fifoPath, <span class="number">0666</span>); <span class="comment">// 创建有名管道</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="comment">// 永久循环，持续监听有名管道</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        fd = open(fifoPath, O_RDONLY); <span class="comment">// 打开管道进行读取</span></span><br><span class="line">        read(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印接收到的消息</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Received: %s\n&quot;</span>, buf);</span><br><span class="line">        close(fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// client.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *fifoPath = <span class="string">&quot;/tmp/my_fifo&quot;</span>;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter message: &quot;</span>);    <span class="comment">// 获取要发送的消息</span></span><br><span class="line">    fgets(buf, <span class="keyword">sizeof</span>(buf), <span class="built_in">stdin</span>);</span><br><span class="line">    fd = open(fifoPath, O_WRONLY); <span class="comment">// 打开管道进行写入</span></span><br><span class="line">    write(fd, buf, <span class="built_in">strlen</span>(buf) + <span class="number">1</span>);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.信号 (Signals)</strong></p><p><strong>概念</strong>：<br>在 Linux 中，信号是一种用于进程间通信（IPC）的机制，允许操作系统或一个进程向另一个进程发送简单的消息。信号主要用于传递关于系统事件的通知，例如中断请求、程序异常、或其他重要事件。每个信号代表了一个特定类型的事件，并且进程可以根据收到的信号执行相应的动作。</p><p>信号是异步的，意味着它们可以在任何时间点被发送到进程，通常与进程的正常控制流无关。信号的使用为进程提供了一种处理外部事件和错误的方式。</p><p>可以使用命令 <code>kill -l</code> 来查看 Linux 系统支持的信号有哪些？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">~$ kill -l</span><br><span class="line"> 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP</span><br><span class="line"> 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1</span><br><span class="line">11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>使用场景</strong>：</p><ul><li><strong>异常处理</strong>：当程序遇到运行时错误，比如除以零、非法内存访问等，操作系统会向该进程发送一个适当的信号，如SIGFPE（浮点异常）、SIGSEGV（段错误）。默认情况下：都会使程序终止。</li><li><strong>外部中断</strong>：用户可以通过特定的键盘输入（最常见的是Ctrl+C）来中断正在终端上运行的进程。这会生成 SIGINT 信号，通常导致程序终止。</li><li><strong>进程控制</strong>：如使用 kill 命令发送信号来终止或暂停某个进程。</li><li><strong>定时器和超时</strong>： 程序可以设置定时器，当定时器到期时，会收到 SIGALRM 信号。这常用于限制某些操作的执行时间，确保它们不会占用过多时间。</li><li><strong>子进程状态变化</strong>：当一个子进程结束或停止时，它的父进程会收到 SIGCHLD 信号。这使得父进程可以监控其子进程的状态变化（从运行到正常退出）。</li></ul><p><strong>简单示例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">signal_handler</span><span class="params">(<span class="type">int</span> signal_num)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Received signal: %d\n&quot;</span>, signal_num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    signal(SIGINT, signal_handler);  <span class="comment">// 注册信号处理函数</span></span><br><span class="line">    <span class="comment">// 无限循环，等待信号</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        sleep(<span class="number">1</span>); <span class="comment">// 暂停一秒</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，程序设置了一个信号处理函数来处理 SIGINT 信号（通常由 Ctrl+C 产生）。当收到该信号时，signal_handler 函数会被调用。</p><p><strong>以下是对上述代码执行流程的简单图解说明，方便大家理解</strong>：</p><p><img src="/images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/7.jpg"></p><p><strong>3.文件(Files)</strong></p><p><strong>概念</strong>：</p><p>文件在 Linux 系统中是一种基本的持久化存储机制，可用于<strong>进程间通信</strong>。多个进程可以通过对同一个文件的读取和写入来共享信息。</p><p><strong>简单图解：</strong></p><p><img src="/images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/8.jpg"></p><p><strong>使用场景：</strong></p><ul><li><p><strong>数据交换：</strong></p><p>进程之间可以通过读写同一文件来交换数据。例如，一个进程写入结果数据，另一个进程读取这些数据进行进一步处理。</p></li><li><p><strong>持久化存储：</strong></p><p>文件用于保存需要在应用程序重启后依然保留的数据，例如用户数据、应用状态等。</p></li></ul><p><strong>简单示例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写进程: 向文件中写入数据</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *file = <span class="string">&quot;/tmp/ipc_file&quot;</span>;</span><br><span class="line">    <span class="type">int</span> fd = open(file, O_RDWR | O_CREAT, <span class="number">0666</span>);</span><br><span class="line">    write(fd, <span class="string">&quot;Hello from Process A&quot;</span>, <span class="number">20</span>);  <span class="comment">// 向文件写入数据</span></span><br><span class="line">    close(fd);     <span class="comment">// 关闭文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 读进程: 从文件中读取数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *file = <span class="string">&quot;/tmp/ipc_file&quot;</span>;</span><br><span class="line">    <span class="type">int</span> fd = open(file, O_RDWR | O_CREAT, <span class="number">0666</span>);</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">50</span>];</span><br><span class="line">    read(fd, buf, <span class="number">20</span>);  <span class="comment">// 从文件中读取数据</span></span><br><span class="line">    close(fd);     <span class="comment">// 关闭文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> <strong>注意：</strong><br>  如果存在多个写进程同时操作同一个文件，那么会引发数据竞态和一致性问题。为了解决这个问题，可以使用文件锁或其他同步机制来协调对文件的访问，确保数据的完整性和一致性。</p></blockquote><p><strong>文件锁的作用:</strong></p><ul><li><p><strong>防止数据覆盖</strong>：<br>当一个进程正在写文件时，文件锁可以防止其他进程同时写入，从而避免数据被覆盖。</p></li><li><p><strong>保证写操作的完整性</strong>：</p><p>通过锁定文件，确保每次只有一个进程能够执行写操作，这有助于保持写入数据的完整性。</p></li></ul><p><strong>实现文件锁:</strong></p><p>在 Linux 中，可以使用 fcntl 或 flock 系统调用来实现文件锁。</p><p><strong>示例代码</strong> </p><p>使用 fcntl 实现文件锁，从而保证多个进程在操作同一文件时不会相互干扰，维护数据的一致性和完整性。以下是一个具体的示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *file = <span class="string">&quot;/tmp/ipc_file&quot;</span>;</span><br><span class="line">    <span class="type">int</span> fd = open(file, O_RDWR | O_CREAT, <span class="number">0666</span>);</span><br><span class="line">    <span class="comment">// 设置文件锁</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">flock</span> <span class="title">fl</span>;</span></span><br><span class="line">    fl.l_type = F_WRLCK;  <span class="comment">// 设置写锁</span></span><br><span class="line">    fl.l_whence = SEEK_SET;</span><br><span class="line">    fl.l_start = <span class="number">0</span>;</span><br><span class="line">    fl.l_len = <span class="number">0</span>;  <span class="comment">// 锁定整个文件</span></span><br><span class="line">    <span class="keyword">if</span> (fcntl(fd, F_SETLKW, &amp;fl) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Error locking file&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    write(fd, <span class="string">&quot;Hello from Process A&quot;</span>, <span class="number">20</span>); <span class="comment">// 执行写操作</span></span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    fl.l_type = F_UNLCK;</span><br><span class="line">    fcntl(fd, F_SETLK, &amp;fl);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>4.信号量(Semaphores)</strong></p><p><strong>概念</strong>:<br>信号量是一种在进程间或同一进程的不同线程间提供同步的机制。它是一个计数器，用于控制对共享资源的访问。当计数器值大于0时，表示资源可用；当值为0时，表示资源被占用。进程在访问共享资源前必须减少（wait）信号量，访问后必须增加（post）信号量。</p><p>信号量有两种，一种是 POSIX 信号量，另一种是 System V 信号量。由于 POSIX 信号量提供了更简洁、更易于理解和使用的 API，并且在现代操作系统中得到了广泛支持和优化，所以这里我重点讲解 POSIX 信号量。</p><p>  <strong>简单图解：</strong></p><p><img src="/images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/9.jpg"></p><p>  <strong>分类：</strong></p><p> <strong>匿名信号量</strong></p><p><strong>概念:</strong></p><p> 匿名信号量是内存中的信号量，不与任何文件系统的名称关联。它们通常用于单一进程内不同线程间的同步，或在具有共同祖先的进程之间进行同步。</p><p> <strong>特点：</strong></p><ul><li><strong>作用域</strong>：限于创建它的进程内部或其子进程之间。</li><li><strong>生命周期</strong>：与创建它们的进程的生命周期相同，进程终止时信号量也会消失。</li></ul><p><strong>使用场景</strong>：</p><ul><li><strong>互斥访问</strong>：在多线程程序中，确保同一时刻只有一个线程可以访问某个共享资源。</li><li><strong>同步操作</strong>：协调多个线程的执行顺序，一个线程在另一个线程完成其任务之后再开始执行。如：线程池中的任务队列没任务时，线程必须等待，而当有有线程向队列添加任务时，需要唤醒其他线程来进行消费任务。</li></ul><p> <strong>有名信号量</strong></p><p> <strong>概念:</strong>  有名信号量在文件系统中具有一个唯一的名称，允许不同的独立进程通过这个名称访问同一个信号量，实现进程间同步。</p><p> <strong>特点：</strong></p><ul><li><strong>作用域</strong>：可以跨不同的进程使用。它们在文件系统中具有一个全局唯一的名称，任何知道这个名称的进程都可以访问同一个信号量。</li><li><strong>生命周期</strong>：生命周期可以超过创建它们的进程。即使创建它们的进程已经结束，只要有名信号量的名称存在于文件系统中，它们就继续存在。</li></ul><p><strong>使用场景</strong>：</p><ul><li><strong>进程间互斥：</strong> 多个独立进程共享资源，如文件或内存映射区域，需要互斥访问以避免冲突。</li><li><strong>同步操作</strong>：协调多个进程的执行顺序，一个进程在另一个进程完成其任务之后再开始执行。如：在生产者消费者模型中，只要当生产者向队列添加数据，队列不为空的时候，消费者才能消费数据，否则只能等待。</li></ul><p><strong>来看一个进程互斥的例子：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设日志文件已经打开</span></span><br><span class="line">FILE* logFile;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">writeToLog</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* message)</span> &#123;</span><br><span class="line">    <span class="type">sem_t</span>* sem = sem_open(<span class="string">&quot;/log_semaphore&quot;</span>, O_CREAT, <span class="number">0644</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    sem_wait(sem);  <span class="comment">// 获取信号量</span></span><br><span class="line">    <span class="built_in">fprintf</span>(logFile, <span class="string">&quot;%s\n&quot;</span>, message);  <span class="comment">// 写入日志</span></span><br><span class="line">    fflush(logFile);</span><br><span class="line">    sem_post(sem);  <span class="comment">// 释放信号量</span></span><br><span class="line"></span><br><span class="line">    sem_close(sem);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ... 进程的其它操作 ...</span></span><br><span class="line">    writeToLog(<span class="string">&quot;Log message from Process&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>匿名信号量和有名信号量 API 接口区别：</strong></p><p><img src="/images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/10.jpg"></p><p><strong>5.共享内存(Shared Memory)</strong></p><p><strong>概念</strong>：<br>在 Linux 中，共享内存是进程间通信（IPC）的一种形式。当多个进程需要访问相同的数据时，使用共享内存是一种高效的方式。它允许两个或多个进程访问同一个物理内存区域，这使得数据传输不需要通过内核空间，从而提高了通信效率。</p><p>在讲解共享内存前，我们需要了解内存映射技术？</p><p><strong>内存映射技术（Memory Mapping）</strong> 是一种将文件或设备的数据映射到进程内存地址空间的技术，它允许进程直接对这部分内存进行读写操作，就像访问普通内存一样。这种技术不仅可以用于文件I&#x2F;O操作，提高文件访问效率，而且是实现共享内存的基础。</p><p>在 Linux 系统中，内存映射可以通过 <strong>mmap</strong> 系统调用来实现。<strong>mmap</strong> 允许将文件映射到进程的地址空间，也可以用来创建匿名映射（即不基于任何文件的共享内存区域）。</p><p>在 Linux 中，共享内存可以分为如下几类。</p><p><strong>匿名共享内存</strong></p><p><strong>工作原理</strong>：</p><p>匿名共享内存不与任何具体的文件系统文件直接关联，其内容仅在内存中存在。这意味着当所有使用它的进程都结束时，该内存区域的数据就会消失。这种特性使得匿名共享内存非常适合于那些需要临时共享数据但又不需要将数据持久存储到磁盘的场景。</p><p><strong>简单图解：</strong></p><p><img src="/images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/11.jpg"></p><p><strong>注意</strong>：在 Linux 中，<strong>匿名共享内存主要被设计用于有亲缘关系的进程间通信，如父子进程间</strong>。这是因为匿名共享内存的引用（例如，通过 mmap 创建时返回的内存地址）不会自动出现在其他进程中，而是需要通过某种进程间通信的方式（如Unix域套接字）传递给相关的进程。而通过 Unix 域套接字来实现又稍显复杂，所以我们一般推荐匿名共享内存适用于有亲缘关系的进程间通信。</p><p><strong>创建和使用</strong>：</p><p>在 Linux 系统中，匿名共享内存通常是通过 mmap()函数创建的，调用时需指定MAP_ANONYMOUS标志。此外，还需要设置 PROT_READ 和 PROT_WRITE 权限，以确保内存区域可读写。创建时也可以选择 MAP_SHARED 标志，以便在多个进程间共享这块内存。</p><p><strong>示例代码片段如下：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="type">void</span>* shared_memory = mmap(<span class="literal">NULL</span>, size, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOU</span><br></pre></td></tr></table></figure><p>在这里，size是希望映射的内存区域大小，mmap()调用成功后，返回指向共享内存区域的指针。</p><p><strong>使用场景</strong>：</p><p><strong>大量数据交换</strong> ：当两个或多个进程需要交换大量数据时，使用共享内存比传统的进程间通信方法（如管道或消息队列）更有效率。</p><p><strong>而谈到共享内存，又不得不探讨下关于共享内存的同步问题？</strong></p><p>在使用共享内存时，由于多个进程可以直接并且同时访问同一个物理内存区域，不加以适当控制就可能引起数据竞态和一致性问题。</p><p><strong>数据竞态</strong>：当多个进程尝试同时修改共享内存中的同一数据项时，最终结果可能依赖于各进程操作的具体顺序，可能导致不符合预期的结果。</p><p><strong>一致性问题</strong>：在没有合适同步机制的情况下，一个进程可能在另一个进程写入数据的同时读取共享内存，导致获取到不完整或不一致的数据。</p><p><strong>解决策略：使用信号量</strong></p><p>信号量是一种常用的同步机制，用于控制对共享资源的并发访问。通过增加（释放资源）或减少（占用资源）信号量的值，可以有效地控制对共享内存区域的访问，防止数据竞态和确保数据一致性。</p><p><strong>使用信号量来解决匿名共享内存同步问题的简单示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建或打开有名信号量</span></span><br><span class="line">    <span class="type">sem_t</span> *sem = sem_open(<span class="string">&quot;/mysemaphore&quot;</span>, O_CREAT, <span class="number">0666</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (sem == SEM_FAILED) &#123;</span><br><span class="line">        <span class="comment">// 错误处理，退出程序</span></span><br><span class="line">        perror(<span class="string">&quot;sem_open failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建匿名共享内存</span></span><br><span class="line">    <span class="type">void</span>* shared_memory = mmap(<span class="literal">NULL</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>), PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (shared_memory == MAP_FAILED) &#123;</span><br><span class="line">      <span class="comment">// 错误处理，退出程序</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>* counter = (<span class="type">int</span>*)shared_memory;</span><br><span class="line">    *counter = <span class="number">0</span>; <span class="comment">// 初始化计数器</span></span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">            sem_wait(sem); <span class="comment">// 等待信号量</span></span><br><span class="line">            (*counter)++;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Child process increments counter to %d\n&quot;</span>, *counter);</span><br><span class="line">            sem_post(sem); <span class="comment">// 释放信号量</span></span><br><span class="line">            sleep(<span class="number">1</span>); <span class="comment">// 暂停一段时间，模拟工作负载</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">            sem_wait(sem);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Parent process reads counter as %d\n&quot;</span>, *counter);</span><br><span class="line">            sem_post(sem);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// fork失败</span></span><br><span class="line">        perror(<span class="string">&quot;fork failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理资源</span></span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123; <span class="comment">// 父进程等待子进程完成</span></span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        sem_close(sem);</span><br><span class="line">        sem_unlink(<span class="string">&quot;/mysemaphore&quot;</span>);</span><br><span class="line">        munmap(shared_memory, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>基于文件的共享内存</strong></p><p><strong>工作原理:</strong></p><p>基于文件的共享内存通过将磁盘上的实际文件映射到一个或多个进程的地址空间中来实现。当文件被映射到内存后，进程就可以像访问普通内存一样直接读写文件内容，操作系统负责同步内存修改回磁盘文件。这种机制既提高了数据访问的效率，也实现了数据的持久化存储。</p><p>相比匿名共享内存只能适合有亲缘关系的进程，<strong>基于文件的共享内存特别适合于实现非亲缘关系进程间的数据共享</strong>。</p><p><strong>简单图解：</strong></p><p><img src="/images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/12.jpg"></p><p><strong>创建和使用:</strong></p><p>要创建基于文件的共享内存，首先需要打开（或创建）一个文件，然后使用 mmap()将文件映射到内存中。与匿名共享内存不同，这里需要提供<strong>文件描述符</strong>而不是 MAP_ANONYMOUS 标志。</p><p><strong>示例代码片段如下：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> size = <span class="number">4096</span>; <span class="comment">// 共享内存区域大小</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;shared_file&quot;</span>, O_RDWR | O_CREAT, <span class="number">0666</span>);</span><br><span class="line">ftruncate(fd, size); <span class="comment">// 设置文件大小</span></span><br><span class="line"><span class="type">void</span>* shared_memory = mmap(<span class="literal">NULL</span>, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>在这里，shared_file 是被映射的文件名，size 是文件的预期大小。通过 ftruncate() 调整文件大小以匹配共享内存的需求。mmap()成功后返回指向共享内存区域的指针。</p><p><strong>使用场景：</strong></p><p><strong>大量数据交换</strong> ：基于文件的共享内存同样适用于多个进程需要进行大量数据交换的场景。与匿名共享内存不同的是，这些数据可以持久化存储到磁盘上。</p><p>在使用基于文件的共享内存时，同样需要解决多个进程共享数据的同步问题，以保证数据的一致性和完整性。</p><p><strong>解决方案</strong>：</p><ul><li><p><strong>信号量</strong>：<br>信号量可以理解是一个计数器，用来控制同时访问共享资源（如共享内存）的进程数量。如果信号量计数大于0，表示资源可用，进程可以访问资源并将计数减1；如果信号量计数为0，表示资源不可用，进程必须等待。当资源使用完毕后，进程会增加信号量计数，表示资源再次可用。</p></li><li><p><strong>文件锁</strong>：<br>文件锁允许进程对共享内存所基于的文件加锁，防止其他进程同时访问。如果一个进程要写入共享内存，它可以加一个排他锁，这时其他进程既不能读也不能写；如果只需要读取，进程可以加一个共享锁，这样其他进程也可以加共享锁来读取数据，但不能写入。在 Linux 中，文件锁的实现主要依赖于两个系统调用：fcntl 和 flock。而关于 fcntl 和 flock 的讲解，我在前文也有提到过。</p></li></ul><p><strong>简单来说</strong>：</p><ul><li>使用信号量是为了确保在同一时间只有限定数量的进程可以操作共享内存。</li><li>使用文件锁是为了防止在某个进程读写共享内存时，其他进程进行干扰。</li></ul><p>下面来看一个使用<strong>有名信号量解决基于文件的共享内存同步问题的示例</strong>，这个简单的示例演示了两个进程：一个进程向共享内存写入数据，另一个进程从共享内存读取数据。这两个进程使用同一个有名信号量来同步对共享内存区域的访问。</p><p><strong>示例代码：</strong></p><p>首先，确保你有一个名为 shared_file 的文件和一个名为 &#x2F;mysemaphore 的信号量。</p><p><strong>写入进程</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* filename = <span class="string">&quot;shared_file&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> size = <span class="number">4096</span>;</span><br><span class="line">    <span class="comment">// 打开文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(filename, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 错误处理并退出</span></span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 映射文件</span></span><br><span class="line">    <span class="type">void</span>* addr = mmap(<span class="literal">NULL</span>, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (addr == MAP_FAILED) &#123;</span><br><span class="line">        <span class="comment">// 错误处理并退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打开有名信号量</span></span><br><span class="line">    <span class="type">sem_t</span> *sem = sem_open(<span class="string">&quot;/mysemaphore&quot;</span>, O_CREAT, <span class="number">0666</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (sem == SEM_FAILED) &#123;</span><br><span class="line">        <span class="comment">// 错误处理并退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待信号量，开始写入数据</span></span><br><span class="line">    sem_wait(sem);</span><br><span class="line">    <span class="built_in">strcpy</span>((<span class="type">char</span>*)addr, <span class="string">&quot;Hello, Shared Memory!&quot;</span>);</span><br><span class="line">    sem_post(sem);</span><br><span class="line">    <span class="comment">// 清理</span></span><br><span class="line">    munmap(addr, size);</span><br><span class="line">    close(fd);</span><br><span class="line">    sem_close(sem);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>读取进程：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* filename = <span class="string">&quot;shared_file&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> size = <span class="number">4096</span>;</span><br><span class="line">    <span class="comment">// 打开文件</span></span><br><span class="line">    <span class="type">int</span> fd = open(filename, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 错误处理并退出</span></span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 映射文件</span></span><br><span class="line">    <span class="type">void</span>* addr = mmap(<span class="literal">NULL</span>, size, PROT_READ, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (addr == MAP_FAILED) &#123;</span><br><span class="line">       <span class="comment">// 错误处理并退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打开有名信号量</span></span><br><span class="line">    <span class="type">sem_t</span> *sem = sem_open(<span class="string">&quot;/mysemaphore&quot;</span>, O_CREAT, <span class="number">0666</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (sem == SEM_FAILED) &#123;</span><br><span class="line">        <span class="comment">// 错误处理并退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待信号量，开始读取数据</span></span><br><span class="line">    sem_wait(sem);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Read from shared memory: %s\n&quot;</span>, (<span class="type">char</span>*)addr);</span><br><span class="line">    sem_post(sem);</span><br><span class="line">    <span class="comment">// 清理</span></span><br><span class="line">    munmap(addr, size);</span><br><span class="line">    close(fd);</span><br><span class="line">    sem_close(sem);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明</strong>：上面的信号量初始值为 1 ，实际上信号量在这里充当的就是互斥锁。</p><p><strong>Posix 共享内存</strong></p><p>POSIX 共享内存提供了一种高效的方式，允许多个进程通过共享内存区域进行通信。与基于文件的共享内存相比，POSIX 共享内存不需要直接映射磁盘上的文件，而是通过创建命名的共享内存对象来实现进程间的数据共享。这些对象虽然在逻辑上类似于文件（因为可以通过shm_open创建和打开），但实质上直接存在于内存中，提供了更快的数据访问速度。</p><p><strong>Posix 共享内存接口</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">shm_open()        <span class="comment">// 创建或打开一个共享内存对象</span></span><br><span class="line">shm_unlink()      <span class="comment">// 删除一个共享内存对象的名称</span></span><br><span class="line">ftruncate()       <span class="comment">// 调整共享内存对象的大小</span></span><br><span class="line">mmap()            <span class="comment">// 将共享内存对象映射到调用进程的地址空间</span></span><br><span class="line">munmap()          <span class="comment">// 解除共享内存对象的映射</span></span><br></pre></td></tr></table></figure><p><strong>示例演示</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SHM_NAME <span class="string">&quot;/example_shm&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHM_SIZE 4096</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> shm_fd;</span><br><span class="line">    <span class="type">void</span> *ptr;</span><br><span class="line">    <span class="comment">// 创建共享内存对象</span></span><br><span class="line">    shm_fd = shm_open(SHM_NAME, O_CREAT | O_RDWR, <span class="number">0666</span>);</span><br><span class="line">    <span class="keyword">if</span> (shm_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 错误处理并退出</span></span><br><span class="line">        perror(<span class="string">&quot;shm_open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置共享内存大小</span></span><br><span class="line">    <span class="keyword">if</span> (ftruncate(shm_fd, SHM_SIZE) == <span class="number">-1</span>) &#123;</span><br><span class="line">       <span class="comment">// 错误处理并退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 映射共享内存</span></span><br><span class="line">    ptr = mmap(<span class="number">0</span>, SHM_SIZE, PROT_WRITE, MAP_SHARED, shm_fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ptr == MAP_FAILED) &#123;</span><br><span class="line">        <span class="comment">// 错误处理并退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 写入数据到共享内存</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *message = <span class="string">&quot;Hello, POSIX Shared Memory!&quot;</span>;</span><br><span class="line">    <span class="built_in">sprintf</span>(ptr, <span class="string">&quot;%s&quot;</span>, message);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Data written to shared memory: %s\n&quot;</span>, message);</span><br><span class="line">    <span class="comment">// 解除映射</span></span><br><span class="line">    munmap(ptr, SHM_SIZE);</span><br><span class="line">    <span class="comment">// 关闭共享内存对象</span></span><br><span class="line">    close(shm_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>System V共享内存</strong></p><p>System V共享内存是一种传统的进程间通信（IPC）机制，它允许多个进程通过共享内存区域进行通信。与POSIX共享内存不同，System V共享内存使用IPC键值key_t来标识和管理共享内存段，而不是通过命名的方式。这种机制提供了一套底层控制共享内存的API，允许进行更细粒度的操作，如权限控制、共享内存状态的查询和管理等。</p><p><strong>System V共享内存接口</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shmget()         <span class="comment">// 创建或获取共享内存段的标识符</span></span><br><span class="line">shmat()          <span class="comment">// 将共享内存段附加到进程的地址空间</span></span><br><span class="line">shmdt()          <span class="comment">// 分离共享内存段和进程的地址空间</span></span><br><span class="line">shmctl()         <span class="comment">// 对共享内存段执行控制操作</span></span><br></pre></td></tr></table></figure><p><strong>示例演示</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">key_t</span> key = ftok(<span class="string">&quot;somefile&quot;</span>, <span class="number">65</span>); <span class="comment">// 创建IPC键</span></span><br><span class="line">    <span class="type">int</span> shm_id;</span><br><span class="line">    <span class="type">void</span> *ptr;</span><br><span class="line">    <span class="comment">// 创建共享内存段</span></span><br><span class="line">    shm_id = shmget(key, <span class="number">1024</span>, <span class="number">0666</span>|IPC_CREAT);</span><br><span class="line">    <span class="keyword">if</span> (shm_id &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;shmget&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将共享内存段附加到进程的地址空间</span></span><br><span class="line">    ptr = shmat(shm_id, (<span class="type">void</span>*)<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ptr == (<span class="type">void</span>*) <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;shmat&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在共享内存上操作，例如写入数据</span></span><br><span class="line">    <span class="comment">// 示例：写入一个字符串</span></span><br><span class="line">    <span class="built_in">strcpy</span>(ptr, <span class="string">&quot;Hello, System V Shared Memory!&quot;</span>);</span><br><span class="line">    <span class="comment">// 分离共享内存段</span></span><br><span class="line">    <span class="keyword">if</span> (shmdt(ptr) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;shmdt&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除共享内存段</span></span><br><span class="line">    shmctl(shm_id, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>6.消息队列 (Message Queues)</strong></p><p><strong>概念</strong>：</p><p>消息队列是一种允许一个或多个进程向其写入消息，并由一个或多个进程读取消息的 IPC 机制。每条消息都由一个消息队列标识符（ID）识别， 且可以携带一个特定的类型。消息队列允许不同进程非阻塞地发送和接收记录或数据块，这些记录可以是不同类型和大小的。</p><p><strong>消息队列图解：</strong></p><p><img src="/images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/13.jpg"></p><p><strong>使用场景</strong>：</p><ul><li><p><strong>进程间通信：</strong><br>在涉及多个运行进程的应用中，消息队列提供了一种高效的方式来传递信息。它允许进程之间无需直接相互连接就能交换数据，从而简化了通信过程。</p></li><li><p><strong>异步数据处理：</strong><br>消息队列使进程能够异步处理信息。一个进程（即生产者）可以发送任务或数据至队列，并继续其他操作，而另一进程（即消费者）可以在准备就绪时从队列中取出并处理这些数据。这种模式有效地分离了数据的生成和消费过程，提高了应用的效率和响应速度。实际的应用比如：日志记录，某些系统可能有一个专门的进程负责记录日志，其他进程可以将日志消息发送到消息队列，由该专门进程异步地写入日志文件。</p></li></ul><p><strong>以下是使用 System V IPC 消息队列的一个简单示例:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">message</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;</span><br><span class="line">    <span class="type">char</span> mtext[<span class="number">100</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送消息至消息队列</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">key_t</span> key = ftok(<span class="string">&quot;queuefile&quot;</span>, <span class="number">65</span>);  <span class="comment">// 生成唯一键</span></span><br><span class="line">    <span class="type">int</span> msgid = msgget(key, <span class="number">0666</span> | IPC_CREAT); <span class="comment">// 创建消息队列</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">message</span> <span class="title">msg</span>;</span></span><br><span class="line">    msg.mtype = <span class="number">1</span>; <span class="comment">// 设置消息类型</span></span><br><span class="line">    <span class="built_in">sprintf</span>(msg.mtext, <span class="string">&quot;Hello World&quot;</span>); <span class="comment">// 消息内容</span></span><br><span class="line">    msgsnd(msgid, &amp;msg, <span class="keyword">sizeof</span>(msg.mtext), <span class="number">0</span>); <span class="comment">// 发送消息</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sent message: %s\n&quot;</span>, msg.mtext);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从消息队列中获取消息</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">key_t</span> key = ftok(<span class="string">&quot;queuefile&quot;</span>, <span class="number">65</span>);</span><br><span class="line">    <span class="type">int</span> msgid = msgget(key, <span class="number">0666</span> | IPC_CREAT);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">message</span> <span class="title">msg</span>;</span></span><br><span class="line">    msgrcv(msgid, &amp;msg, <span class="keyword">sizeof</span>(msg.mtext), <span class="number">1</span>, <span class="number">0</span>); <span class="comment">// 接收消息</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Received message: %s\n&quot;</span>, msg.mtext);</span><br><span class="line">    msgctl(msgid, IPC_RMID, <span class="literal">NULL</span>); <span class="comment">// 销毁消息队列</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>7.套接字 (Sockets)</strong></p><p><strong>概念</strong>：</p><p>套接字是一种在不同进程间进行数据交换的通信机制。在 Linux 中，套接字可以用于同一台机器上的进程间通信（IPC）或不同机器上的网络通信。套接字支持多种通信协议，最常见的是TCP（可靠的、连接导向的协议）和UDP（无连接的、不可靠的协议）。</p><p><strong>简单图解：</strong></p><p><img src="/images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/14.jpg"></p><p><strong>使用场景：</strong></p><p><strong>网络通信</strong>：<br>同一台主机或不同主机上的进程之间通过网络套接字进行数据交换。</p><p><strong>简单示例：</strong> - 使用 TCP 套接字进行通信</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务器端（监听和接收数据）:</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> server_fd, new_socket;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    <span class="type">int</span> addrlen = <span class="keyword">sizeof</span>(address);</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    server_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);  <span class="comment">// 创建套接字</span></span><br><span class="line">    <span class="comment">// 定义套接字地址</span></span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    address.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    address.sin_port = htons(<span class="number">8080</span>);</span><br><span class="line">    <span class="comment">// 绑定套接字</span></span><br><span class="line">    bind(server_fd, (<span class="keyword">struct</span> sockaddr *)&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    listen(server_fd, <span class="number">3</span>);    <span class="comment">// 监听套接字</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 接受连接</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Waiting for a connection...\n&quot;</span>);</span><br><span class="line">        new_socket = accept(server_fd, (<span class="keyword">struct</span> sockaddr *)&amp;address, (<span class="type">socklen_t</span>*)&amp;addrlen);</span><br><span class="line">        <span class="comment">// 读取数据</span></span><br><span class="line">        read(new_socket, buffer, <span class="number">1024</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Message: %s\n&quot;</span>, buffer);</span><br><span class="line">        <span class="comment">// 可以在这里处理收到的消息或执行其他任务</span></span><br><span class="line">        close(new_socket);  <span class="comment">// 关闭这次连接的套接字</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭监听的套接字</span></span><br><span class="line">    <span class="comment">// 注意：由于 while(1)，这行代码不会执行，除非在循环中加入退出条件</span></span><br><span class="line">    close(server_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端进程（发送数据）:</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> sock = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">    sock = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>); <span class="comment">// 创建套接字</span></span><br><span class="line">    serv_addr.sin_family = AF_INET; <span class="comment">// 定义套接字地址</span></span><br><span class="line">    serv_addr.sin_port = htons(<span class="number">8080</span>);</span><br><span class="line">    connect(sock, (<span class="keyword">struct</span> sockaddr *)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));    <span class="comment">// 连接到服务器</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 发送数据</span></span><br><span class="line">    <span class="type">char</span> *message = <span class="string">&quot;Hello from the client!&quot;</span>;</span><br><span class="line">    send(sock, message, <span class="built_in">strlen</span>(message), <span class="number">0</span>);</span><br><span class="line">    close(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>8.域套接字 (Unix Domain Sockets)</strong></p><p><strong>概念</strong>：</p><p>域套接字（Unix Domain Sockets）是一种在同一台机器上的进程间进行数据通信的机制。相对于网络套接字，它们提供了更高效的本地通信方式，<strong>因为数据不需要经过网络协议栈</strong>。域套接字支持流（类似TCP）和数据报（类似UDP）两种模式。</p><p><strong>特别说明</strong>：在域套接字通信中，<strong>“不经过网络协议栈”</strong> 指的是数据传输不需要IP层的路由、不需要TCP&#x2F;UDP等传输层协议的封包与解包处理，也不需要网络接口层的参与。这一点与网络套接字不同，后者用于跨网络的通信，需要经过完整的网络协议栈处理，包括数据的封装、传输、路由和解封装等。</p><p><strong>简单图解：</strong></p><p><img src="/images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/15.jpg"></p><p><strong>使用场景：</strong></p><ul><li><p><strong>本地进程间通信</strong>：</p><p>当需要在同一台机器上的不同进程间高效地交换数据时。</p></li><li><p><strong>替代管道和消息队列</strong>：</p><p>当需要比管道和消息队列更复杂的双向通信时。</p></li></ul><p><strong>简单示例：</strong> - 使用 Unix 域套接字进行通信</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务器端（监听和接收数据）:</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> server_fd, client_socket;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">address</span>;</span></span><br><span class="line">    server_fd = socket(AF_UNIX, SOCK_STREAM, <span class="number">0</span>);  <span class="comment">// 创建套接字</span></span><br><span class="line">    address.sun_family = AF_UNIX;     <span class="comment">// 设置套接字地址</span></span><br><span class="line">    <span class="built_in">strcpy</span>(address.sun_path, <span class="string">&quot;/tmp/unix_socket&quot;</span>);</span><br><span class="line">    <span class="comment">// 绑定和监听</span></span><br><span class="line">    bind(server_fd, (<span class="keyword">struct</span> sockaddr *)&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    listen(server_fd, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// 接受连接</span></span><br><span class="line">        client_socket = accept(server_fd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理数据</span></span><br><span class="line">        <span class="type">char</span> buffer[<span class="number">100</span>];</span><br><span class="line">        read(client_socket, buffer, <span class="number">100</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Received: %s\n&quot;</span>, buffer);</span><br><span class="line">        <span class="comment">// 进行其他的业务处理</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        </span><br><span class="line">        close(client_socket);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清理</span></span><br><span class="line">    close(server_fd);</span><br><span class="line">    unlink(<span class="string">&quot;/tmp/unix_socket&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端（发送数据）:</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> sock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">address</span>;</span></span><br><span class="line">    sock = socket(AF_UNIX, SOCK_STREAM, <span class="number">0</span>); <span class="comment">// 创建套接字</span></span><br><span class="line">    address.sun_family = AF_UNIX;           <span class="comment">// 设置套接字地址</span></span><br><span class="line">    <span class="built_in">strcpy</span>(address.sun_path, <span class="string">&quot;/tmp/unix_socket&quot;</span>);</span><br><span class="line">    <span class="comment">// 连接到服务器</span></span><br><span class="line">    connect(sock, (<span class="keyword">struct</span> sockaddr *)&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    <span class="comment">// 发送数据</span></span><br><span class="line">    <span class="type">char</span> *message = <span class="string">&quot;Hello from the client!&quot;</span>;</span><br><span class="line">    write(sock, message, <span class="built_in">strlen</span>(message));</span><br><span class="line">    <span class="comment">// 清理</span></span><br><span class="line">    close(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong>：</p><ul><li>Unix 域套接字的地址是文件系统中的路径，而不是IP地址和端口。</li><li>Unix 域套接字通常用于同一台机器上的进程间通信，而不适用于网络通信。</li><li>使用 Unix 域套接字时，需要确保套接字文件的路径是可访问的，并在通信完成后清理套接字文件。</li></ul><h3 id="Linux-线程"><a href="#Linux-线程" class="headerlink" title="Linux 线程"></a>Linux 线程</h3><p><img src="/images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/16.jpg"></p><h4 id="什么是线程？"><a href="#什么是线程？" class="headerlink" title="什么是线程？"></a>什么是线程？</h4><p>线程，有时被称为“轻量级进程”，是程序执行流的最小单位。它允许多任务在单个进程内部并发执行。</p><h4 id="线程与进程的区别："><a href="#线程与进程的区别：" class="headerlink" title="线程与进程的区别："></a>线程与进程的区别：</h4><ul><li><strong>进程</strong>: 拥有独立的地址空间和资源。</li><li><strong>线程</strong>: 共享其所在进程的资源，但有自己的堆栈空间。</li></ul><h4 id="创建你的第一个线程"><a href="#创建你的第一个线程" class="headerlink" title="创建你的第一个线程"></a>创建你的第一个线程</h4><p>在 Linux 下，我们使用 POSIX Threads （简称 Pthreads）库来操作线程。以下是一个简单的例子，创建并运行两个线程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Thread 1 function</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">func1</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello from thread 1!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thread 2 function</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">func2</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello from thread 2!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> thread1, thread2;</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;thread1, <span class="literal">NULL</span>, func1, <span class="literal">NULL</span>);    <span class="comment">// Create thread 1</span></span><br><span class="line">    pthread_create(&amp;thread2, <span class="literal">NULL</span>, func2, <span class="literal">NULL</span>);    <span class="comment">// Create thread 2</span></span><br><span class="line"></span><br><span class="line">    pthread_join(thread1, <span class="literal">NULL</span>); <span class="comment">// Wait for thread 1 to finish</span></span><br><span class="line">    pthread_join(thread2, <span class="literal">NULL</span>); <span class="comment">// Wait for thread 2 to finish</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="线程同步：何时使用？"><a href="#线程同步：何时使用？" class="headerlink" title="线程同步：何时使用？"></a>线程同步：何时使用？</h4><p>当两个或多个线程想要访问同一个资源时，问题就来了！如何确保资源的安全访问？有以下三种线程同步的方式。</p><ul><li><strong>互斥锁</strong>: 一个线程在使用资源时，锁住它，其他线程等待。一般用在临界区的保护。</li><li><strong>条件变量</strong>: 线程等待直到某个条件满足。一般和互斥锁搭配使用来实现线程同步 。</li><li><strong>信号量</strong>: 一种高级的同步方式，可以控制资源的访问数量。</li></ul><p> <strong>信号量更为通用</strong>，因为它不仅可以用作互斥锁，还可以用来同步线程，例如 ：确保线程按特定的顺序执行或控制对有限资源的访问。</p><p><strong>确保线程按特定的顺序执行</strong>：</p><p>在某些场景下，您可能希望线程以特定的顺序执行。例如，线程 A 必须在线程 B 之前执行。这可以通过使用信号量来实现。</p><p><strong>控制对有限资源的访问</strong>：</p><p>信号量也可用于控制对有限资源的访问。例如，数据库连接池，其中只有一定数量的连接可供线程使用，可以使用信号量来确保只有固定数量的线程可以同时访问这些资源。</p><p><strong>确保线程按特定的顺序执行的示例代码</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">sem_t</span> semA;</span><br><span class="line"><span class="comment">// 线程A</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">threadA</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread A is running\n&quot;</span>);</span><br><span class="line">    sem_post(&amp;semA); <span class="comment">// 释放信号量A</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程B</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">threadB</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    sem_wait(&amp;semA); <span class="comment">// 等待信号量A</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread B is running\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> tA, tB;</span><br><span class="line">    <span class="comment">// 初始化信号量</span></span><br><span class="line">    sem_init(&amp;semA, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">    pthread_create(&amp;tA, <span class="literal">NULL</span>, threadA, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tB, <span class="literal">NULL</span>, threadB, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 等待线程结束</span></span><br><span class="line">    pthread_join(tA, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tB, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 清理资源</span></span><br><span class="line">    sem_destroy(&amp;semA);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线程的优点与缺点"><a href="#线程的优点与缺点" class="headerlink" title="线程的优点与缺点:"></a>线程的优点与缺点:</h4><p><strong>优点</strong>:</p><ul><li>线程之间的切换成本比进程之间的切换成本低。</li><li>线程间的通信速度比进程间的通信速度快，因为线程共享同一地址空间。</li><li>利用多线程可以很容易地在单进程应用中实现并发。</li></ul><p><strong>缺点</strong>:</p><ul><li>因为线程共享同一地址空间，一个线程的错误可能会破坏其他线程的数据或状态。</li><li>需要复杂的同步操作来避免竞争条件。</li></ul><h4 id="常见问题与挑战"><a href="#常见问题与挑战" class="headerlink" title="常见问题与挑战"></a>常见问题与挑战</h4><p><strong>死锁</strong>:</p><p>死锁发生在两个或多个线程永久地等待对方释放锁的情况。它通常发生在多个线程需要多个锁时，如果不按相同的顺序获取锁，就可能陷入互相等待的状态。</p><p><strong>解决方案</strong>：</p><ul><li>确保所有线程以相同的顺序获取锁。</li><li>使用层次结构的锁定系统，其中线程必须按特定顺序获取锁。</li><li>设置超时，以便在等待锁的时间过长时，线程可以放弃等待，尝试其他操作。</li></ul><p><strong>线程安全</strong>：</p><p>线程安全是指确保代码可以在多线程环境中安全运行，不会因为多个线程同时访问共享资源而导致数据损坏或不一致。</p><p><strong>解决方案：</strong></p><ul><li><strong>使用同步机制</strong>，如互斥锁或信号量，来控制对共享资源的访问。</li><li><strong>编写无状态的代码，或者确保状态信息不在多个线程间共享。</strong> 无状态的代码指的是不保存任何与特定实例相关的数据（状态）的代码。在多线程环境中，这意味着代码不依赖于或不修改任何外部状态，如全局变量或类的成员变量。</li><li><strong>使用不可变对象</strong>，这些对象一旦创建就不会更改，因此可以安全地在多个线程间共享。不可变对象是指一旦被创建就不能被修改的对象(如字符串)，这些对象的状态在创建后是固定的，因此在多线程环境中安全。</li></ul><blockquote><p><strong>总结</strong>：编写无状态的代码和使用不可变对象都是避免多线程环境中的数据冲突和竞争条件的策略。无状态代码避免了共享数据，而不可变对象则确保了即使数据被共享，它们也不会被修改，从而保证线程安全。</p></blockquote><h4 id="进一步探索"><a href="#进一步探索" class="headerlink" title="进一步探索"></a>进一步探索</h4><p><strong>线程池</strong>: </p><p>线程池通过重用一组预先创建的线程来处理任务，减少了线程创建和销毁的开销。</p><p><strong>应用</strong>：线程池广泛用于网络服务器应用，特别是在需要处理大量短暂任务的场景中。</p><p><strong>高级同步原语</strong>: </p><p><strong>读写锁（Read-Write Locks）</strong></p><p>读写锁是一种特殊类型的锁，它允许多个线程同时读取共享资源，但写入操作需要独占访问。这意味着只要没有线程正在写入共享资源，多个线程可以同时读取资源而不会被阻塞。</p><p><strong>应用场景</strong>：适用于读操作远多于写操作的情况，比如缓存系统。</p><p><strong>优点</strong>：提高了在读多写少场景下的并发性能。</p><p><strong>实现</strong>：在 POSIX 线程库中，通过 pthread_rwlock_t 类型提供。</p><p><strong>简单示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_rwlock_t</span> rwlock = PTHREAD_RWLOCK_INITIALIZER;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">reader</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    pthread_rwlock_rdlock(&amp;rwlock);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Reader is reading...\n&quot;</span>);</span><br><span class="line">    sleep(<span class="number">1</span>); <span class="comment">// 模拟读取操作</span></span><br><span class="line">    pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">writer</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    pthread_rwlock_wrlock(&amp;rwlock);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Writer is writing...\n&quot;</span>);</span><br><span class="line">    sleep(<span class="number">1</span>); <span class="comment">// 模拟写入操作</span></span><br><span class="line">    pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> t1, t2;</span><br><span class="line">    pthread_rwlock_init(&amp;rwlock, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;t1, <span class="literal">NULL</span>, reader, <span class="literal">NULL</span>);</span><br><span class="line">    sleep(<span class="number">2</span>); <span class="comment">// 确保读者先运行</span></span><br><span class="line">    pthread_create(&amp;t2, <span class="literal">NULL</span>, writer, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(t1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(t2, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_rwlock_destroy(&amp;rwlock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>屏障（Barriers）</strong></p><p>屏障用于同步多个线程在程序中的特定点。当线程到达一个屏障时，它会等待，直到所有其他线程也都到达这个屏障。然后所有线程才能继续执行。</p><p><strong>应用场景</strong>：用于并行算法，确保所有线程完成某个阶段的工作后才开始下一个阶段。</p><p><strong>优点</strong>：确保所有线程同步进行，避免数据不一致。</p><p><strong>实现</strong>：在 POSIX 线程库中，通过 pthread_barrier_t 类型提供。</p><p><strong>简单示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NUM_THREADS 5</span></span><br><span class="line"><span class="type">pthread_barrier_t</span> barrier;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">task</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread %ld waiting at barrier\n&quot;</span>, (<span class="type">long</span>)arg);</span><br><span class="line">    pthread_barrier_wait(&amp;barrier);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread %ld passed barrier\n&quot;</span>, (<span class="type">long</span>)arg);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> threads[NUM_THREADS];</span><br><span class="line">    pthread_barrier_init(&amp;barrier, <span class="literal">NULL</span>, NUM_THREADS);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> i = <span class="number">0</span>; i &lt; NUM_THREADS; i++) &#123;</span><br><span class="line">        pthread_create(&amp;threads[i], <span class="literal">NULL</span>, task, (<span class="type">void</span>*)i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_THREADS; i++) &#123;</span><br><span class="line">        pthread_join(threads[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_barrier_destroy(&amp;barrier);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明</strong>：这个程序演示了如何使用屏障来同步多个线程，确保所有线程都到达一个执行点后才一起继续执行。在这个例子中，所有线程都会在打印“等待”信息后等待，直到它们全部到达 pthread_barrier_wait 调用处。只有当所有线程都到达这个点时，它们才会继续执行并打印“通过”信息。</p><p><strong>原子操作（Atomic Operations）</strong></p><p>原子操作是指在多线程环境中，一系列操作作为一个单独的不可中断的单位执行，确保在读取、修改和更新变量时的原子性。这些操作在执行的全过程中不会被线程调度机制中断。</p><p><strong>应用场景</strong>：</p><p>非常适合于计数器、标志位更新等简单状态的更新场景，其中对单一变量的读取、修改和更新必须作为一个整体来执行，以避免数据竞争和保证数据一致性。</p><p><strong>优点</strong>：</p><ul><li><strong>效率</strong>：相比锁机制，原子操作通常更高效，因为它们避免了锁的开销和潜在的上下文切换。</li><li><strong>简化编程模型</strong>：对于简单的同步需求，原子操作提供了一种简单直接的解决方案，避免了使用锁的复杂性。</li></ul><p><strong>实现</strong>：在 POSIX 线程库中，原子操作并非直接提供，但可以通过 GCC 提供的内建原子操作函数，如__sync_fetch_and_add、__sync_lock_test_and_set等。C++11及更高版本的标准也提供了原子操作的支持，如 std::atomic 类型。</p><p><strong>简单示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个全局计数器</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 线程函数，用于增加计数器</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">increment_counter</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i) &#123;</span><br><span class="line">        <span class="comment">// 使用GCC的内建原子操作函数进行原子增加</span></span><br><span class="line">        __sync_fetch_and_add(&amp;counter, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> t1, t2;</span><br><span class="line">    <span class="comment">// 创建两个线程，都执行increment_counter函数</span></span><br><span class="line">    pthread_create(&amp;t1, <span class="literal">NULL</span>, increment_counter, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;t2, <span class="literal">NULL</span>, increment_counter, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 等待线程完成</span></span><br><span class="line">    pthread_join(t1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(t2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 打印最终的计数器值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Final counter value: %d\n&quot;</span>, counter);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>自旋锁（Spinlocks）</strong></p><p>自旋锁是一种忙等待的锁，当一个线程尝试获取一个已经被其他线程持有的锁时，它会在一个循环中不断检查锁的状态。这意味着线程会一直占用 CPU，直到它能够获取到锁。</p><p><strong>应用场景</strong>：</p><p>特别适合锁持有时间非常短的场景，因为它避免了线程从运行态转为等待态的开销，这在多核处理器上尤其有用。</p><p><strong>实现</strong>：在 POSIX 线程库中，自旋锁通过 pthread_spinlock_t 类型提供，相关的操作包括 pthread_spin_lock、pthread_spin_unlock等。自旋锁的使用和管理相对简单，但需要谨慎使用以避免过度占用 CPU 资源。</p><p><strong>简单示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_spinlock_t</span> spinlock;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">task</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    pthread_spin_lock(&amp;spinlock);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread %ld got the lock\n&quot;</span>, (<span class="type">long</span>)arg);</span><br><span class="line">    sleep(<span class="number">1</span>); <span class="comment">// 模拟任务执行</span></span><br><span class="line">    pthread_spin_unlock(&amp;spinlock);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> t1, t2;</span><br><span class="line">    pthread_spin_init(&amp;spinlock, PTHREAD_PROCESS_PRIVATE);</span><br><span class="line">    pthread_create(&amp;t1, <span class="literal">NULL</span>, task, (<span class="type">void</span>*)<span class="number">1L</span>);</span><br><span class="line">    pthread_create(&amp;t2, <span class="literal">NULL</span>, task, (<span class="type">void</span>*)<span class="number">2L</span>);</span><br><span class="line">    pthread_join(t1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(t2, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_spin_destroy(&amp;spinlock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内存管理入门"><a href="#内存管理入门" class="headerlink" title="内存管理入门"></a>内存管理入门</h3><p>在前面的讲解中，我们已经学习了进程和线程的基本概念，了解了它们是操作系统进行资源分配和任务调度的基本单位。而无论是进程还是线程，它们的运行都离不开一个关键的系统资源——内存。这自然引出了一个重要的问题：操作系统是如何管理这些内存资源的？这正是我们接下来要讨论的主题— <strong>Linux内存管理</strong>。</p><h4 id="内存分配与释放"><a href="#内存分配与释放" class="headerlink" title="内存分配与释放"></a>内存分配与释放</h4><p>首先，我们先来看下内存的分配与释放，常见的内存分配方式包含以下两种：</p><p><strong>静态内存分配</strong> ： 是在编译时完成的，通常用于固定大小的数据结构，比如：普通数组。</p><p><strong>动态内存分配</strong> ： 则在运行时进行，允许程序根据需要分配任意大小的内存块，比如：动态数组。</p><p>我们一般使用 <strong>malloc和free</strong> 来进行动态内存分配与释放。</p><p>来看个动态内存分配的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int *array = malloc(10 * sizeof(int)); # 分配内存</span><br><span class="line">    if (array == NULL) &#123;</span><br><span class="line">        perror(&quot;malloc failed&quot;);</span><br><span class="line">        return EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">    #使用动态内存 array ...</span><br><span class="line"></span><br><span class="line">    free(array); # 释放内存</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h4><p>应用程序如果没有正确的管理内存的分配与回收，就有可能出现内存泄漏，严重点的有可能导致程序异常退出。</p><p><strong>那什么是内存泄露？</strong></p><p>内存泄露是指程序中动态分配的内存没有及时释放，导致这部分内存在程序执行过程中一直占用，无法被再次利用。在长时间运行的程序中，内存泄露可能会导致内存使用不断增加，最终耗尽所有可用内存，影响程序性能甚至引发程序崩溃。</p><p><strong>如何避免内存泄露？</strong></p><ul><li><p><strong>合理设计程序结构</strong>：确保每次 malloc 后都有对应的 free 操作。可以通过使用自动化工具，如 Valgrind 等，来检测程序运行中的内存泄露问题。</p></li><li><p><strong>使用智能指针</strong>：在支持 C++ 等高级语言中，使用智能指针（如 std::unique_ptr, std::shared_ptr 等）可以帮助管理动态内存的生命周期，智能指针会在适当的时候自动释放内存。</p></li><li><p><strong>及时释放内存</strong>：在不需要动态分配的内存后，应立即释放。尤其是在异常处理、错误处理的代码路径中，也不要忘记释放内存。</p></li><li><p><strong>规范化资源管理</strong>：使用 RAII（Resource Acquisition Is Initialization）原则管理资源，<strong>确保资源的获取即是初始化，随着对象的销毁资源被释放</strong>。</p></li></ul><h4 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a>虚拟内存管理</h4><p><strong>虚拟内存概念：</strong></p><p>虚拟内存是计算机系统内存管理的一种技术。它使得应用程序认为它拥有很大连续的、可用的内存空间，即使这些内存可能被分散存储在物理内存和磁盘上。</p><p><strong>虚拟内存的主要好处是</strong>：</p><ul><li>它提供了比实际物理内存更大的地址空间。</li><li>保证每个程序在内存中有一个连续的地址空间。</li><li>允许系统运行大于物理内存的程序。</li><li>通过内存隔离，提高了程序间的安全性。</li></ul><p>操作系统通过使用硬盘上的一块称为“交换空间”的区域来实现这一点，它作为物理内存的一个扩展。当系统的物理 RAM 不足时，它可以将当前不活跃的内存页面移动到磁盘上，从而为需要更多内存的进程腾出空间。</p><p><strong>分页机制</strong></p><p>分页是虚拟内存管理中最常用的技术之一。它将虚拟内存和物理内存分成大小相等的块，这些块在虚拟内存中被称为“页”(pages)，在物理内存中被称为“页框”(page frames)。每个程序都有一个页表，页表将程序的虚拟地址映射到物理内存的页框。</p><p><strong>分页机制如何工作：</strong></p><p>1.当程序试图访问虚拟内存中的地址时，它首先会检查页表。</p><p>2.如果找到了对应的物理地址，那么数据的存取操作就会继续。</p><p>3.如果没有找到，会触发一个缺页中断，由操作系统处理。</p><p><strong>缺页中断</strong></p><p>缺页中断（Page Fault）是分页系统中的一项关键机制，当一个进程访问的虚拟页不在物理内存中时触发。这时候，操作系统会分配一个物理页框，并将该虚拟页所对应的磁盘数据加载至页框中，并在页表中建立虚拟页和物理页的映射关系。这样，当下一次进程在访问相同虚拟页的时候，就可以直接访问内存中的数据了。</p><p>通过以上机制，虚拟内存管理提供了高效灵活的内存使用方式，允许操作系统优化内存分配，同时也给应用程序提供了简单的内存管理模型。</p><h3 id="文件系统：探索-Linux-中的数据管理"><a href="#文件系统：探索-Linux-中的数据管理" class="headerlink" title="文件系统：探索 Linux 中的数据管理"></a>文件系统：探索 Linux 中的数据管理</h3><p>前面我们探讨了 Linux 系统中的内存管理，包括内存分配与释放、内存泄漏和虚拟内存等概念，这些都是操作系统保证程序正常运行的基础。内存管理使得多个应用能够高效、安全地共享系统的物理内存资源，同时还提供了数据的临时存储能力。然而，内存只能提供临时存储，当系统断电或重启时，内存中的数据就会丢失。这就引出了我们下一个重要话题：<strong>文件系统</strong>。</p><p>在谈文件系统之前，我们先来了解下虚拟文件系统。</p><h4 id="虚拟文件系统（VFS）"><a href="#虚拟文件系统（VFS）" class="headerlink" title="虚拟文件系统（VFS）"></a>虚拟文件系统（VFS）</h4><p><strong>什么是VFS？</strong></p><p>Linux内核中的虚拟文件系统（VFS）是一个关键的抽象层，它为各种不同的文件系统提供了一个统一的操作接口。这意味着，不管数据实际上存储在哪个文件系统中（比如EXT4、XFS等），VFS都能提供一致的访问方式。</p><p><strong>VFS的作用</strong></p><p><strong>兼容性</strong>：使得不同的文件系统都能在 Linux 上工作。</p><p><strong>统一性</strong>：它为应用程序提供了一个标准的文件操作接口，简化了文件访问和管理。</p><p>接下来让我们来看下文件系统。</p><p><strong>Linux 的文件系统是什么？</strong></p><p>Linux 文件系统是 Linux 操作系统用于存储、管理和访问文件和目录的一套规则和结构。它提供了一个层次化的目录结构，让用户和程序能够以一致的方式组织和访问数据。Linux 文件系统支持多种类型，如 EXT4、XFS 和 Btrfs，每种都有其特定的优势和用途。文件系统管理文件的存储细节，包括文件的创建、读取、写入和删除操作，同时也处理文件的权限和安全性。通过虚拟文件系统（VFS）层，Linux 能够提供一个统一的接口来访问这些不同的文件系统，使得文件操作对用户和应用程序透明。</p><p><strong>文件系统核心组件:</strong></p><p><strong>超级块（Superblock）</strong></p><p>超级块是文件系统的元数据的一部分，它包含了关于整个文件系统的全局信息，如文件系统的类型、大小、状态、空闲和已用的块和Inode数量等。超级块的主要作用是提供文件系统的关键信息，以便操作系统能够正确地管理和访问文件系统。</p><p><strong>Inode</strong></p><p>Inode 是文件系统中的一个关键数据结构，每个文件和目录都有一个唯一的Inode。它包含了文件的元数据（如文件大小、所有者、权限、时间戳）和指向实际存储文件数据的数据块的指针。Inode 不存储文件名，文件名存储在目录文件中，这些目录文件将文件名映射到 Inode 号。<strong>inode</strong> 号是文件的唯一标识，而不是文件名。</p><p><strong>目录项（Dentry）</strong></p><p>目录项（或Dentry缓存）是内核用来维护文件名与其对应Inode之间映射的结构。目录项缓存是一个重要的性能优化机制，它减少了从文件名到文件内容的查找时间。</p><p><strong>文件数据块</strong></p><p>文件数据块是存储文件实际内容的磁盘空间。Linux文件系统将磁盘空间分割成一系列的块，这些块可以直接被Inode指向，或者通过间接块来存储较大文件的数据。</p><p><strong>文件和目录</strong></p><p>文件和目录是用户与文件系统交互的基本单元。在 Linux 中，一切皆文件：传统的数据文件、目录、设备（如字符设备和块设备）等都通过文件或文件系统的接口来访问。</p><p><strong>下面是文件、目录、inode 、以及数据块之间的映射关系图</strong>：</p><p><img src="/images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/17.jpg"></p><p>我以程序访问磁盘文件为例，来给大家说明下具体的访问过程，方便大家理解上述图示。</p><p><strong>操作系统会执行以下几个步骤</strong>：</p><ul><li><p><strong>解析文件路径</strong>：操作系统首先解析完整的文件路径，确定文件在文件系统中的位置。</p></li><li><p><strong>查找目录项</strong>：利用文件路径，操作系统在文件系统的目录结构中查找对应的目录项（Dentry）。目录项将文件名映射到一个唯一的Inode编号。</p></li><li><p><strong>访问Inode</strong>：每个文件都有一个Inode，其中包含该文件的元数据（如所有者、权限）和指向文件实际数据块的指针。操作系统使用目录项提供的 Inode 编号来访问 Inode Table，进而访问对应的 inode。</p></li><li><p><strong>读取数据块</strong>：通过 Inode 中的信息，操作系统找到存储文件数据的磁盘块位置，然后读取这些数据块以获取文件内容。</p></li></ul><p>除此之外，在 Linux 中，还存在两种特殊的引用文件的方式：<strong>硬链接和软链接</strong></p><h4 id="硬链接和软链接"><a href="#硬链接和软链接" class="headerlink" title="硬链接和软链接"></a>硬链接和软链接</h4><p><strong>什么是硬链接？</strong></p><p>硬链接实际上是目标文件的另一个名称。它与原文件共享相同的 <strong>inode</strong> 号，因此，无论通过哪个名称访问，内容都是一致的。</p><p><strong>图示</strong>：</p><p><img src="/images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/18.jpg"></p><p>这里，“file1”和“link1”都是硬链接，它们指向同一个inode。这意味着它们共享相同的数据块和文件属性。</p><p><strong>如何创建硬链接？</strong></p><p><strong>命令</strong>：<code> ln 源文件 目标文件</code></p><p>例如，创建一个名为 file1 的文件的硬链接 link1，你可以使用：ln file1 link1。</p><p><strong>特点</strong>：</p><ul><li>硬链接不能跨文件系统。</li><li>不能为目录创建硬链接。</li><li>删除原始文件或硬链接中的任何一个不会影响其他文件，因为它们共享相同的数据块。</li></ul><p><strong>什么是软链接？</strong></p><p>与硬链接不同，软链接是一个独立的文件，它并不包含实际的文件内容，而是指向另一个文件或目录的路径。</p><p><strong>图示</strong>：</p><p><img src="/images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/19.jpg"></p><p>在这里，“link1”是一个指向“file1”的软链接。与硬链接不同，软链接只是一个指向另一个文件或目录的路径。当我们访问软链接时，系统会自动重定向我们到它所指向的实际文件。</p><p><strong>如何创建软链接？</strong></p><p><strong>命令</strong>：<code> ln -s 源文件 目标文件</code></p><p>例如，为 file1 创建一个软链接 link1，你可以使用：ln -s file1 link1。</p><p><strong>特点</strong>：</p><ul><li>软链接可以跨文件系统。</li><li>可以为目录创建软链接。</li><li>如果删除了目标文件，软链接会变为死链接，无法再访问原始内容。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章主要是为想学习 Linux 系统编程的初学者提供一个学习指南，从基本概念到高级功能，我们不仅揭示了 Linux 系统的核心技术和架构，还探讨了用户空间与内核空间的关键区别，系统调用与库函数的基本理解，以及文件IO的多样化操作。我们学习了进程和线程的基础，理解了它们之间的差异，以及如何有效地使用线程同步技术来编写稳定的多线程程序。此外，我们还涵盖了内存管理的基础知识，从内存分配与释放到虚拟内存管理，最后学习了 Linux 文件系统的基本概念及其核心组件，以及硬链接和软链接的使用和区别。</p><p>无论你是刚开始接触 Linux 系统编程的新手，还是希望巩固现有知识的经验开发者，本文都提供了宝贵指南。</p><p>通过本文的学习，我希望读者能够：</p><ul><li>掌握 Linux 系统架构的关键组成部分，包括用户空间和内核空间的区别。</li><li>理解系统调用和库函数的作用，以及它们在系统编程中的重要性。</li><li>熟练进行文件IO操作，包括文件描述符的使用，文件位置的移动，以及高级文件I&#x2F;O技术的应用。</li><li>了解进程和线程的基本概念，包括它们的创建、终止和状态转换，以及进程间通信的方法。</li><li>掌握线程同步的技巧，了解线程的优缺点以及在实际编程中的应用。</li><li>建立内存管理的基本知识框架，包括内存分配释放、虚拟内存管理以及如何避免内存泄露。</li><li>探索 Linux 文件系统，理解虚拟文件系统（VFS）的概念，以及硬链接和软链接的使用和区别。</li></ul><h2 id="最后："><a href="#最后：" class="headerlink" title="最后："></a>最后：</h2><p>如果你对 Linux 系统编程以及计算机编程领域相关知识感兴趣，不妨关注我的公众号—<strong>「跟着小康学编程」</strong>。这里会定时更新相关的技术文章，文章通俗易懂，感兴趣的读者可以关注一下：</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p>另外，小康最近新创建了一个技术交流群，大家如果在阅读的过程中有遇到问题或者有不理解的地方，欢迎大家加群询问或者评论区询问，我能解决的都尽可能给大家回复。</p><p>扫一扫小康的个人微信，备注「<strong>加群</strong>」即可。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> Linux系统编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux系统编程 </tag>
            
            <tag> Linux I/O </tag>
            
            <tag> Linux 进程和线程 </tag>
            
            <tag> Linux 内存管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何快速注册 OpenAI 账号</title>
      <link href="/register/"/>
      <url>/register/</url>
      
        <content type="html"><![CDATA[<h1 id="一分钟教你快速注册-OpenAI-账号"><a href="#一分钟教你快速注册-OpenAI-账号" class="headerlink" title="一分钟教你快速注册 OpenAI 账号"></a>一分钟教你快速注册 OpenAI 账号</h1><h4 id="首先，你必须得能科学上网（能够正常访问谷歌），即可注册。"><a href="#首先，你必须得能科学上网（能够正常访问谷歌），即可注册。" class="headerlink" title="首先，你必须得能科学上网（能够正常访问谷歌），即可注册。"></a>首先，你必须得能科学上网（能够正常访问谷歌），即可注册。</h4><p>（如果还不会科学上网，可以用这个： <a href="https://www.52xcjs.xyz/auth/register">科学稳定访问 openai</a>)</p><h2 id="快速注册步骤："><a href="#快速注册步骤：" class="headerlink" title="快速注册步骤："></a>快速注册步骤：</h2><p>国内的邮箱都不再允许注册 ChatGPT，建议申请一个免费的海外邮箱 Proton 来注册，其他海外邮箱，如 Gmail 也可以，但是注册难度高一些，步骤繁琐。</p><h3 id="第一步：注册-proton-邮箱"><a href="#第一步：注册-proton-邮箱" class="headerlink" title="第一步：注册 proton 邮箱"></a>第一步：注册 proton 邮箱</h3><h4 id="1-1-访问-proton"><a href="#1-1-访问-proton" class="headerlink" title="1.1 访问 proton"></a>1.1 访问 proton</h4><p><a href="https://proton.me/">https://proton.me/</a></p><p>选择右上角的 「Create a free account」</p><p><img src="/images/%E6%B3%A8%E5%86%8COpenAI%E8%B4%A6%E5%8F%B7/001.png"></p><h4 id="1-2-选择免费套餐"><a href="#1-2-选择免费套餐" class="headerlink" title="1.2 选择免费套餐"></a>1.2 选择免费套餐</h4><p><img src="/images/%E6%B3%A8%E5%86%8COpenAI%E8%B4%A6%E5%8F%B7/002.png"></p><h4 id="1-3-选择邮箱后缀，设置用户名和密码"><a href="#1-3-选择邮箱后缀，设置用户名和密码" class="headerlink" title="1.3 选择邮箱后缀，设置用户名和密码"></a>1.3 选择邮箱后缀，设置用户名和密码</h4><p>推荐选择 proton.me</p><p><img src="/images/%E6%B3%A8%E5%86%8COpenAI%E8%B4%A6%E5%8F%B7/003.png"></p><h4 id="1-4-通过真人验证"><a href="#1-4-通过真人验证" class="headerlink" title="1.4 通过真人验证"></a>1.4 通过真人验证</h4><p>依次拖动验证码，然后下一步即可</p><p><img src="/images/%E6%B3%A8%E5%86%8COpenAI%E8%B4%A6%E5%8F%B7/004.png"></p><p><img src="/images/%E6%B3%A8%E5%86%8COpenAI%E8%B4%A6%E5%8F%B7/005.png"></p><p><strong>注册完后，可以去登陆邮箱</strong>，方便接收验证码：</p><p><a href="https://proton.me/">https://proton.me/</a></p><h3 id="第二步：注册-OpenAI-账号"><a href="#第二步：注册-OpenAI-账号" class="headerlink" title="第二步：注册 OpenAI 账号"></a>第二步：注册 OpenAI 账号</h3><h4 id="2-1-首先打开-OpenAI-的账户注册页面，然后输入-proton-邮箱。"><a href="#2-1-首先打开-OpenAI-的账户注册页面，然后输入-proton-邮箱。" class="headerlink" title="2.1 首先打开 OpenAI 的账户注册页面，然后输入 proton 邮箱。"></a>2.1 首先打开 OpenAI 的账户注册页面，然后输入 proton 邮箱。</h4><p><a href="https://chat.openai.com/">https://chat.openai.com/</a></p><p><img src="/images/%E6%B3%A8%E5%86%8COpenAI%E8%B4%A6%E5%8F%B7/006.png"></p><p><img src="/images/%E6%B3%A8%E5%86%8COpenAI%E8%B4%A6%E5%8F%B7/007.png"></p><h4 id="2-2-接着设置-OpenAi-密码-如下就是你的-openai-账号和密码"><a href="#2-2-接着设置-OpenAi-密码-如下就是你的-openai-账号和密码" class="headerlink" title="2.2 接着设置 OpenAi 密码(如下就是你的 openai 账号和密码)"></a>2.2 接着设置 OpenAi 密码(如下就是你的 openai 账号和密码)</h4><p><img src="/images/%E6%B3%A8%E5%86%8COpenAI%E8%B4%A6%E5%8F%B7/008.png"></p><p>  <br><br><br>点击继续，接着点击 Resend email <br><br> </p><p><img src="/images/%E6%B3%A8%E5%86%8COpenAI%E8%B4%A6%E5%8F%B7/009.png"></p><p>  <br><br><br>接着验证邮箱，去 Proton.me 收件箱里点击「Verify email address」即可。<br><br> </p><p><img src="/images/%E6%B3%A8%E5%86%8COpenAI%E8%B4%A6%E5%8F%B7/010.png"><br><br><br><br>然后提供你的名和姓及生日，并点击 <strong>Agee</strong> 即可。</p>]]></content>
      
      
      <categories>
          
          <category> ChatGPT </category>
          
          <category> OpenAI 账号注册 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenAI 账号注册 </tag>
            
            <tag> ChatGPT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>欢迎关注我的微信公众号——跟着小康学编程</title>
      <link href="/xiaokangvx/"/>
      <url>/xiaokangvx/</url>
      
        <content type="html"><![CDATA[<p>🚀 大家好，我是小康！</p><p>🌟 如果你对计算机编程感兴趣，想要从基础到进阶系统地学习编程语言和技术，那么你来对地方了！<strong>「跟着小康学编程」</strong>是你的最佳起点！</p><p>👨‍💻 这里是你的一站式编程学习平台，内容涵盖：</p><ul><li><strong>C&#x2F;C++、Java、Go 语言</strong>：无论你是初学者还是希望深化技能的开发者，这里都有适合你的资源。</li><li><strong>计算机基础</strong>：全面理解计算机基本原理，包括操作系统、算法、数据结构、网络和数据库。</li><li><strong>Linux系统和网络编程</strong>：掌握操作系统的核心技术和网络编程的高级技巧。</li><li><strong>MySQL数据库技术</strong>：学习如何利用MySQL进行高效的数据存储和复杂的数据管理。</li><li><strong>Redis高速缓存</strong>：掌握Redis在高速数据处理和缓存方面的应用，让你的应用运行得更快。</li><li><strong>RabbitMQ消息队列</strong>：了解RabbitMQ的高效消息传递机制，确保应用组件间的数据一致性和可靠性。</li><li><strong>微服务架构</strong>：探索将复杂应用分解为更小、更易管理的微服务的策略，使整个应用更容易管理和扩展。</li><li><strong>容器技术</strong>：深入Docker和Kubernetes，掌握现代容器化和自动化部署的关键技术</li><li><strong>未完待续</strong>。。。</li></ul><p>目前，公众号只提供了上述提到的部分技术文章。其他技术相关文章后续会依次补上。<strong>目标就是：为广大编程爱好者提供更加全面的编程指南。</strong></p><p>另外，后续也会增加计算机编程各个领域的面试题，包括：C&#x2F;C++、Java、Go、以及操作系统、计算机网络以及数据结构等面试题。为大家面试提供帮助。</p><p><strong>总之：本号的定位就是 C&#x2F;C++&#x2F;Go&#x2F;Java 语言学习 + 计算机基础原理 + Linux编程 + 容器技术等。</strong> 文章尽可能的通俗易懂，而且文章都会有代码示例，方便初学者理解，有兴趣的朋友可以关注我的公众号「<strong>跟着小康学编程</strong>」。</p><p><br><br> </p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/gzh.png"></p><p><br><br> </p><p><strong>注</strong>：上面提到的计算机学习资料包括<strong>C&#x2F;C++、Java、Go语言，计算机组成原理、操作系统、数据结构与算法、计算机网络以及 Linux 系统编程和网络编程、Linux 内核、数据库</strong>等书籍的电子档 pdf。</p><p><br><br> </p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png"></p><p><br><br> </p><p>另外，小康最近创建了一个技术交流群，专门用来探讨技术相关或者解答读者的问题。大家在阅读技术文章的时候，如果觉得有问题的或者有不理解的知识点，欢迎大家加群询问。我能够解决的，尽量给大家回复。</p><p><img src="/images/%E8%81%94%E7%B3%BB%E6%88%91/grvx.png"></p>]]></content>
      
      
      <categories>
          
          <category> 小康的联系方式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 我的公众号 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何快速升级到 GPT-4</title>
      <link href="/upgrade-gpt4/"/>
      <url>/upgrade-gpt4/</url>
      
        <content type="html"><![CDATA[<h1 id="【保姆级】如何升级-GPT-4？快速升级至ChatGPT-Plus指南-，ChatGPT4-0-注册及升级攻略指南"><a href="#【保姆级】如何升级-GPT-4？快速升级至ChatGPT-Plus指南-，ChatGPT4-0-注册及升级攻略指南" class="headerlink" title="【保姆级】如何升级 GPT-4？快速升级至ChatGPT Plus指南 ，ChatGPT4.0 注册及升级攻略指南"></a>【保姆级】如何升级 GPT-4？快速升级至ChatGPT Plus指南 ，ChatGPT4.0 注册及升级攻略指南</h1><p>首先，你必须得能科学上网（能够正常访问谷歌），如果你还不会，请了解这个：<a href="https://www.52xcjs.xyz/auth/register">科学稳定访问 openai</a></p><h2 id="升级-ChatGPT-Plus-的步骤："><a href="#升级-ChatGPT-Plus-的步骤：" class="headerlink" title="升级 ChatGPT Plus 的步骤："></a>升级 ChatGPT Plus 的步骤：</h2><p>（PS：如果不会操作，也可以提供代充、GPT 账号注册等服务，有需要加微信：<strong>jkfwdkf</strong>，备注：<strong>chatgpt</strong></p><h3 id="方法一：自己充值升级"><a href="#方法一：自己充值升级" class="headerlink" title="方法一：自己充值升级"></a>方法一：自己充值升级</h3><h4 id="步骤指南：轻松升级至-ChatGPT-Plus"><a href="#步骤指南：轻松升级至-ChatGPT-Plus" class="headerlink" title="步骤指南：轻松升级至 ChatGPT Plus"></a>步骤指南：轻松升级至 ChatGPT Plus</h4><p>之前了解到一种升级方式，非常方便和迅速，大概 2 分钟之内就可以搞定，它主要是通过虚拟信用卡 WildCard 来进行升级的！</p><p><strong>通过专属链接</strong> <a href="https://bewildcard.com/i/666GPT">WildCard | 一分钟开卡，轻松订阅海外软件服务 即可快速升级 ChatGPT Plus</a><br>（<strong>PS：大家可以使用我的邀请链接：<a href="https://bewildcard.com/i/666GPT">https://bewildcard.com/i/666GPT</a>  ， 邀请码：666GPT</strong>，开卡的时候需要填写邀请码）</p><p><strong>具体操作过程：</strong><br><strong>第一步：点击上述链接，先开卡</strong></p><p>1.立即注册</p><p><img src="/images/%E5%BF%AB%E9%80%9F%E5%8D%87%E7%BA%A7GPT4/001.png"><br><br><br> </p><p>2.填写手机号（你自己的手机号就行）</p><p><img src="/images/%E5%BF%AB%E9%80%9F%E5%8D%87%E7%BA%A7GPT4/002.png"><br><br><br> </p><p>3.下一步之后，填写你自己的个人身份信息【邮箱地址：你就填你容易记得的就行，比如：你叫张三，你就填zhangsan 即可】，然后点击下一步。</p><p><img src="/images/%E5%BF%AB%E9%80%9F%E5%8D%87%E7%BA%A7GPT4/003.png"></p><p>4.接着进行支付宝验证以及支付卡费即可。</p><p><strong>说明：</strong> 开卡的时候是需要支付卡费的，有 1 年和 2 年有效期的选择的。1年是 11.99 美元，2年是 13.99美元，折合人民币不到 100 左右，也没有其他的月租等费用。开1年和2年均可以。 </p><p><strong>第二步：注册 OpenAI 账户</strong>，得到 OpenAI 账号和密码。（这个需要1美元购买账号，比较方便）.</p><p><img src="/images/%E5%BF%AB%E9%80%9F%E5%8D%87%E7%BA%A7GPT4/004.png"><br><br><br> </p><p>然后购买一个账号（不到1美元），支持支付宝付款</p><p><img src="/images/%E5%BF%AB%E9%80%9F%E5%8D%87%E7%BA%A7GPT4/005.png"><br><br><br><br><strong>第三步：充值 GPT Plus 月费用 20 美元，大概 140 多人民币。</strong></p><p><strong>第四步：</strong> 最后点击 <strong>一键升级 GPT Plus</strong>，接着根据它的教程来完成最后一步升级操作。<br><br><br><br><img src="/images/%E5%BF%AB%E9%80%9F%E5%8D%87%E7%BA%A7GPT4/006.png"><br><br><br> </p><p><strong>第五步： 登录 ChatGPT 网站</strong>，<a href="https://chat.openai.com/">ChatGPT 网站链接</a>，登录的账号(电子邮件)和密码就是上面第二步注册的 OpenAI 账号和密码。</p><ul><li>登录成功之后，就直接点击下方红色箭头的 Upgrade Plan</li></ul><p><img src="/images/%E5%BF%AB%E9%80%9F%E5%8D%87%E7%BA%A7GPT4/007.png"><br><br><br>  </p><ul><li>接着点击 Upgrade to Plus</li></ul><p><img src="/images/%E5%BF%AB%E9%80%9F%E5%8D%87%E7%BA%A7GPT4/008.png"></p><p><br><br> </p><ul><li>然后全选复制下图的支付链接，粘贴至相应位置，点击确定支付并升级</li></ul><p><img src="/images/%E5%BF%AB%E9%80%9F%E5%8D%87%E7%BA%A7GPT4/009.png"></p><p><strong>完成上述步骤之后，你就可以愉快的体验 ChatGPT-PLUS 呢！</strong></p><p><strong>其他问题：</strong></p><p><strong>1.是否安全？</strong></p><p>这家国内的公司是<strong>专门解决支付问题</strong>的，会使用支付宝进行实名认证，大家不用担心安全问题。<br><strong>而且，它是支持随时提现的，大家不用担心充进去多余的钱取不出来，我亲自提现过，秒提支付宝！！。</strong></p><p><img src="/images/%E5%BF%AB%E9%80%9F%E5%8D%87%E7%BA%A7GPT4/010.png"></p><p><strong>关键是！！</strong>，该卡不仅可以用来订阅 ChatGPT，一些常见的国外付费订阅软件如 Midjourney，OnlyFans 都可以使用，强烈推荐开一个~</p><h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><p>如果你还嫌麻烦或者嫌贵，你可以直接找我代充，相比通过方法一自己充优惠些，你也不需要自己操作，省事。</p><p><strong>我的联系方式： 微信号：jkfwdkf 或者 扫码加微信</strong></p><p><img src="/images/%E5%BF%AB%E9%80%9F%E5%8D%87%E7%BA%A7GPT4/011.png"></p>]]></content>
      
      
      <categories>
          
          <category> ChatGPT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ChatGPT </tag>
            
            <tag> GPT-4 </tag>
            
            <tag> OpenAI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>侯捷 C++ 视频系列合集</title>
      <link href="/stl/"/>
      <url>/stl/</url>
      
        <content type="html"><![CDATA[<h2 id="侯捷-C-视频系列合集，包括：C-面向对象高级开发、STL源码剖析、STL标准库与泛型编程、C-11、C-14、C-内存管理"><a href="#侯捷-C-视频系列合集，包括：C-面向对象高级开发、STL源码剖析、STL标准库与泛型编程、C-11、C-14、C-内存管理" class="headerlink" title="侯捷 C++ 视频系列合集，包括：C++面向对象高级开发、STL源码剖析、STL标准库与泛型编程、C++11、C++14、C++内存管理"></a>侯捷 C++ 视频系列合集，包括：C++面向对象高级开发、STL源码剖析、STL标准库与泛型编程、C++11、C++14、C++内存管理</h2><p>想要搞定C++？看侯捷老师的视频就对了。侯捷不仅是C++界的大佬，还特别会把复杂的东西讲得简单明了。他的课从C++的ABC一直讲到那些让人头大的高级话题，比如怎么用STL，C++11和C++14有哪些酷炫的新特性，还有怎么管理内存不让程序崩溃等等。</p><p>这套视频适合所有人，不管你是C++新手，还是想要提升自己的老司机。侯捷老师用他那一套能让你边学边笑的方式，让你不仅学到东西，学习的过程也会变得超有趣。</p><p>总之，如果你想提升或者巩固你的C++技能，侯捷老师的视频绝对值得一看。跟着他学，C++不再难！</p><p>我之前在网上找过侯捷老师的 C++ 视频，发现不太全，于是我最近专门找了下，找到了相对比较全的视频，以供大家学习。</p><p><strong>包括</strong> :</p><ul><li>侯捷 C++面向对象高级开发</li><li>侯捷 C++ 标准 11 -14</li><li>侯捷 STL 和 泛型编程</li><li>侯捷 C++ 内存管理</li><li>侯捷 STL 与泛型编程</li></ul><p><img src="/images/STL/STL.png"></p><p><br><br> </p><blockquote><p>在这里分享给大家，我放在公众号后台了，大家可以扫下方二维码关注「<strong>跟着小康学编程</strong>」公众号，后台回复「<strong>STL</strong>」，即可获取。</p></blockquote><p><br><br> </p><p><img src="/images/STL/xkvxgzh.png"></p><p><br><br> </p><p><img src="/images/STL/gzh.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程视频合集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL 源码视频 </tag>
            
            <tag> 侯捷 C++ 视频合集 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
