<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>如何快速掌握 C++：从新手到高手的学习指南 | 跟着小康学编程</title><meta name="author" content="小康"><meta name="copyright" content="小康"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="大家好，我是小康，今天我们来聊下如何快速学习 C++ 语言。 本篇文章适合于有 C 语言编程基础的小伙伴们，如果还没有学习过 C，请看这篇文章先入个门：C语言快速入门 引言：C++，作为一门集面向过程和面向对象编程于一体的强大语言，既保留了 C 语言的高效性，又引入了类、继承、多态、模板等现代编程概念，是学习计算机编程不可或缺的一环。本文旨在为初学者提供一个清晰的 C++ 学习路径，帮助你快速入门">
<meta property="og:type" content="article">
<meta property="og:title" content="如何快速掌握 C++：从新手到高手的学习指南">
<meta property="og:url" content="http://example.com/how-to-learn-C++/index.html">
<meta property="og:site_name" content="跟着小康学编程">
<meta property="og:description" content="大家好，我是小康，今天我们来聊下如何快速学习 C++ 语言。 本篇文章适合于有 C 语言编程基础的小伙伴们，如果还没有学习过 C，请看这篇文章先入个门：C语言快速入门 引言：C++，作为一门集面向过程和面向对象编程于一体的强大语言，既保留了 C 语言的高效性，又引入了类、继承、多态、模板等现代编程概念，是学习计算机编程不可或缺的一环。本文旨在为初学者提供一个清晰的 C++ 学习路径，帮助你快速入门">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/me.jpg">
<meta property="article:published_time" content="2024-04-28T05:11:15.199Z">
<meta property="article:modified_time" content="2024-05-01T14:12:27.547Z">
<meta property="article:author" content="小康">
<meta property="article:tag" content="C++入门">
<meta property="article:tag" content="C++教程">
<meta property="article:tag" content="C++快速学习">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/me.jpg"><link rel="shortcut icon" href="/img/me.jpg"><link rel="canonical" href="http://example.com/how-to-learn-C++/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 小康","link":"链接: ","source":"来源: 跟着小康学编程","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '如何快速掌握 C++：从新手到高手的学习指南',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-05-01 22:12:27'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/iconfont/iconfont.css"><meta name="generator" content="Hexo 7.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/me.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">16</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">51</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">20</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/category_img.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="跟着小康学编程"><span class="site-name">跟着小康学编程</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">如何快速掌握 C++：从新手到高手的学习指南</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-04-28T05:11:15.199Z" title="发表于 2024-04-28 13:11:15">2024-04-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-05-01T14:12:27.547Z" title="更新于 2024-05-01 22:12:27">2024-05-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/">编程语言学习</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/C-%E7%BC%96%E7%A8%8B%E6%95%99%E7%A8%8B/">C++ 编程教程</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">22.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>78分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="如何快速掌握 C++：从新手到高手的学习指南"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>大家好，我是小康，今天我们来聊下如何快速学习 C++ 语言。</p>
<p>本篇文章适合于有 C 语言编程基础的小伙伴们，如果还没有学习过 C，请看这篇文章先入个门：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzkyNjQyMTMyOA==&mid=2247487373&idx=1&sn=6304025e2c0a846e97999e765667d866&chksm=c236d7b2f5415ea4b12b87fddf981abcd325d7458885aeade0957db5344da97f1b82d7e65cce&token=733890015&lang=zh_CN#rd">C语言快速入门</a></p>
<h3 id="引言："><a href="#引言：" class="headerlink" title="引言："></a>引言：</h3><p>C++，作为一门集面向过程和面向对象编程于一体的强大语言，既保留了 C 语言的高效性，又引入了类、继承、多态、模板等现代编程概念，是学习计算机编程不可或缺的一环。本文旨在为初学者提供一个<strong>清晰的 C++ 学习路径</strong>，帮助你快速入门并掌握这门语言。</p>
<p>大家可以先浏览下本篇文章要讲解的 C++ 知识图谱：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/C++%E8%AF%AD%E8%A8%80/1.png"></p>
<p>C++的基础语法我就不讲解了，包括<code>变量和常量的定义</code>、<code>标识符和关键字</code>、<code>语句</code>等，这些和 C 的一样，如果你还没有学习过 C 语言，可以看我之前的文章：「如何快速学习 C 语言 ？」</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>C++的基本数据类型包括  <code>字符型</code>、<code>整型</code>、<code>浮点型和布尔型</code>。</p>
<p><strong>字符型</strong> (char)：用于存储单个字符。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> letter = <span class="string">&#x27;A&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>整型</strong> (int, short, long, long long)：用于存储整数, 以及它们的 unsigned 变体(unsigned int, unsigned short,unsigned long,unsigned long long)。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> age = <span class="number">30</span>;</span><br><span class="line"><span class="type">long</span> var = <span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> bigInt = <span class="number">1000000</span>;</span><br></pre></td></tr></table></figure>
<p><strong>浮点型</strong> (float, double)：用于存储小数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> temperature = <span class="number">36.6</span>;</span><br><span class="line"><span class="type">double</span> distance = <span class="number">384400.0</span>; <span class="comment">// 从地球到月亮的距离，单位千米</span></span><br></pre></td></tr></table></figure>
<p><strong>布尔型</strong> (bool)：用于存储真（true）或假（false）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> isRainy = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<h3 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h3><p>枚举类型允许定义一个变量，它可以在几个预定义的值之间进行选择。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span> &#123;</span> RED, GREEN, BLUE &#125;;</span><br><span class="line">Color my_color = RED;</span><br></pre></td></tr></table></figure>

<h3 id="复合数据类型"><a href="#复合数据类型" class="headerlink" title="复合数据类型"></a>复合数据类型</h3><p>复合数据类型（也称为复杂数据类型）允许你将多个不同类型的数据项组合成一个单一的实体。这种类型的典型代表是<code>结构体</code>（struct）、<code>共用体</code>（union）和<code>类</code>（class）。</p>
<h4 id="结构体-struct"><a href="#结构体-struct" class="headerlink" title="结构体 (struct)"></a>结构体 (struct)</h4><p>结构体允许将多个不同类型的数据项组合成一个单一的复合类型。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义结构体类型</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义结构体类型变量并初始化</span></span><br><span class="line">Person person = &#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="联合体（union）"><a href="#联合体（union）" class="headerlink" title="联合体（union）"></a>联合体（union）</h4><p>联合体是一个用于优化内存使用的特殊数据类型，允许在同一内存位置存储不同的数据类型，但任一时刻只能使用其中一个成员。联合体变量使用关键字 <strong>union</strong> 来定义。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Data</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">float</span> f;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Data</span> <span class="title">data</span>;</span></span><br></pre></td></tr></table></figure>

<h4 id="类-class"><a href="#类-class" class="headerlink" title="类 (class)"></a>类 (class)</h4><p>类是C++的核心，是支持面向对象编程的基础。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义 Book 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> title;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> author;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">read</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Reading &quot;</span> &lt;&lt; title &lt;&lt; <span class="string">&quot; by &quot;</span> &lt;&lt; author &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 定义 book 对象</span></span><br><span class="line">Book book = &#123;<span class="string">&quot;The C++ Programming Language&quot;</span>, <span class="string">&quot;Bjarne Stroustrup&quot;</span>&#125;;</span><br><span class="line"><span class="comment">// 调用 book 对象的 read 方法</span></span><br><span class="line">book.read();</span><br></pre></td></tr></table></figure>
<p>看不懂代码没关系，这里只需要了解 <code>类</code> 是 C++ 的一种特有数据类型。关于类的讲解下文会提及。</p>
<h3 id="派生数据类型"><a href="#派生数据类型" class="headerlink" title="派生数据类型"></a>派生数据类型</h3><p>派生数据类型是通过对已有的数据类型（基本类型、复合类型）进行某种形式的“扩展”或“派生”而得到的。典型的派生数据类型包括数组和指针。</p>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>数组用来存储固定大小的相同类型元素序列。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> numbers[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="指针："><a href="#指针：" class="headerlink" title="指针："></a>指针：</h4><p>指针用来存储变量的内存地址。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> var = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* ptr = &amp;var;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Value of var: &quot;</span> &lt;&lt; *ptr &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<p>这里我只简单提下。在上一篇文章<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzkyNjQyMTMyOA==&mid=2247487373&idx=1&sn=6304025e2c0a846e97999e765667d866&chksm=c236d7b2f5415ea4b12b87fddf981abcd325d7458885aeade0957db5344da97f1b82d7e65cce&token=733890015&lang=zh_CN#rd">C语言快速入门</a><br>中关于数组和指针有过详细的讲解，不太了解的可以去看那片文章。C++ 的数组和指针和C的用法一样。只不过 C++ 多了一种比较特殊的类型-引用。</p>
<h4 id="引用："><a href="#引用：" class="headerlink" title="引用："></a>引用：</h4><p>C++中的引用是一种给已存在的变量起一个新名字（或别名）的机制。一旦一个引用被初始化为指向一个变量，它就一直指向那个变量：你对引用所做的任何操作都会影响到原始变量。</p>
<h5 id="引用的基本用法："><a href="#引用的基本用法：" class="headerlink" title="引用的基本用法："></a>引用的基本用法：</h5><p>引用在定义时必须被初始化，并且一旦被绑定到一个变量上，就不能再绑定到另一个变量上。引用的语法是在变量类型后面加上 <strong>&amp;</strong> 符号。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp; refA = a; <span class="comment">// refA是变量a的引用</span></span><br></pre></td></tr></table></figure>
<h5 id="引用的特性："><a href="#引用的特性：" class="headerlink" title="引用的特性："></a>引用的特性：</h5><ul>
<li>引用必须在定义时被初始化，并且一旦被初始化绑定到一个变量，就不能再指向其他变量。</li>
<li>引用不占用任何内存空间（引用只是变量的一个别名）。</li>
<li>不存在null引用。引用必须连接到一块合法的内存。</li>
</ul>
<h5 id="引用的用途："><a href="#引用的用途：" class="headerlink" title="引用的用途："></a>引用的用途：</h5><p>引用主要用于以下几个方面：</p>
<p><strong>1. 函数参数传递</strong>：通过传递引用给函数，可以让函数直接修改外部变量的值，而不是拷贝其值。这样做可以提高效率（尤其是对于大型对象）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过使用引用作为函数参数，可以使得函数能够修改调用者提供的参数。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">increment</span><span class="params">(<span class="type">int</span>&amp; value)</span> &#123;</span><br><span class="line">    value += <span class="number">1</span>; <span class="comment">// 直接修改传入的参数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line">    increment(x); <span class="comment">// x被修改为6</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;x after increment: &quot;</span> &lt;&lt; x &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 C++ 中，函数参数传递时，参数是类对象比较常见。</p>
<p><strong>2. 函数返回值</strong>：函数可以返回一个引用，从而允许对函数返回值直接赋值。这在操作重载运算符时尤其有用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="type">int</span> myNumber = <span class="number">10</span>; <span class="comment">// 全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回全局变量myNumber的引用</span></span><br><span class="line"><span class="type">int</span>&amp; <span class="title function_">getMyNumberRef</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> myNumber;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Original myNumber: &quot;</span> &lt;&lt; myNumber &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: 10</span></span><br><span class="line">    <span class="comment">// 通过函数返回的引用直接修改myNumber的值</span></span><br><span class="line">    getMyNumberRef() = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Modified myNumber: &quot;</span> &lt;&lt; myNumber &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出: 20</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对于拷贝代价较大的对象（比如大型的类实例），通过引用传递或返回可以避免拷贝，提高程序效率。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>C++ 中的函数是一组一起执行一个任务的语句。函数允许你定义一次代码块并多次调用它，这有助于代码的重用和模块化。</p>
<h3 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h3><p>一个 C++ 函数定义包括以下几个主要部分：</p>
<ul>
<li><strong>返回类型</strong>：函数可以返回一个值。返回类型是函数返回值的数据类型。如果函数不返回值，则使用void类型。</li>
<li><strong>函数名称</strong>：标识函数的唯一名称。</li>
<li><strong>参数列表</strong>：括号内的参数，用于从函数调用者向函数传递信息。如果函数不接受任何参数，则括号为空。</li>
<li><strong>函数体</strong>：大括号内的一系列语句，定义了函数的执行任务。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数定义示例</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="函数声明（函数原型）"><a href="#函数声明（函数原型）" class="headerlink" title="函数声明（函数原型）"></a>函数声明（函数原型）</h3><p>为了在定义函数之前调用函数，你需要在调用点之前声明函数原型。函数声明（或称为函数原型）仅需要指定函数返回类型、函数名和参数类型，不需要函数体。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>; <span class="comment">// 函数声明</span></span><br></pre></td></tr></table></figure>

<h3 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3><p>定义函数后，你可以通过提供函数名和所需的参数（如果有的话）来调用函数。</p>
<h4 id="函数调用方式"><a href="#函数调用方式" class="headerlink" title="函数调用方式"></a>函数调用方式</h4><p><strong>函数名(参数1，参数2，…)</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> result = add(<span class="number">5</span>, <span class="number">3</span>); <span class="comment">// 函数调用</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出：Result: 8</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>C++支持几种参数传递方式：</p>
<ul>
<li><strong>按值传递</strong>：调用函数时，实参的值被拷贝给形参。在函数内对形参的修改不会影响实参。</li>
<li><strong>按引用传递</strong>：允许函数修改调用者的变量。这通过将形参定义为引用类型实现。</li>
<li><strong>按指针传递</strong>：意味着将变量地址作为参数传递给函数，函数通过这个指针直接访问和修改原始变量的值。</li>
</ul>
<h4 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// 按值传递</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">byValue</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">    value = <span class="number">10</span>; <span class="comment">// 只修改形参的值，对实参无影响</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 按引用传递</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">byReference</span><span class="params">(<span class="type">int</span>&amp; value)</span> &#123;</span><br><span class="line">    value = <span class="number">20</span>; <span class="comment">// 修改了实参的值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 按指针传递</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">byPointer</span><span class="params">(<span class="type">int</span>* value)</span> &#123;</span><br><span class="line">    *value = <span class="number">30</span>; <span class="comment">// 通过解引用修改了实参的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">1</span>, c = <span class="number">1</span>;</span><br><span class="line">    byValue(a);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After byValue: &quot;</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 1</span></span><br><span class="line">    byReference(b);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After byReference: &quot;</span> &lt;&lt; b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 20 </span></span><br><span class="line">    byPointer(&amp;c);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;After byPointer: &quot;</span> &lt;&lt; c &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出 30</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>C++中的函数重载（Function Overloading）是指允许在同一作用域内声明多个具有相同名称的函数，只要它们的参数列表（参数的类型、数量或顺序）不同即可。编译器根据函数调用时提供的参数类型和数量来决定具体调用哪个函数。</p>
<h4 id="代码示例：-1"><a href="#代码示例：-1" class="headerlink" title="代码示例："></a>代码示例：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下两个 print 函数构成重载</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Printing int: &quot;</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">double</span> f)</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Printing float: &quot;</span> &lt;&lt; f &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  print(<span class="number">10</span>);</span><br><span class="line">  print(<span class="number">10.5</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="特殊函数"><a href="#特殊函数" class="headerlink" title="特殊函数"></a>特殊函数</h3><h4 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h4><p>在 C++ 的类中定义的函数称为成员函数（Member Functions）。成员函数可以访问类的私有（private）、保护（protected）和公有（public）成员。</p>
<p>代码示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">myFunction</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 成员函数实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="常量成员函数"><a href="#常量成员函数" class="headerlink" title="常量成员函数"></a>常量成员函数</h4><p>常量成员函数是 C++ 中的一种特殊的成员函数，它保证在函数执行过程中<strong>不会修改对象的任何成员变量</strong>。这种函数通过在成员函数声明的末尾添加 <strong>const</strong> 关键字来定义。常量成员函数可以被任何类型的对象调用，包括常量对象。</p>
<p>在类的实现中，常量成员函数对类内部的状态（成员变量）只能进行只读操作，不能进行修改。这为类的使用提供了额外的安全保证，确保了不会意外改变对象状态的函数逻辑。</p>
<p>代码示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义 MyClass 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">private:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">public:</span><br><span class="line">    MyClass(<span class="type">int</span> v) : value(v) &#123;&#125; <span class="comment">// 构造函数，初始化value</span></span><br><span class="line">    <span class="comment">// 常量成员函数声明，使用const关键字</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span> <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value; <span class="comment">// 这里只是返回成员变量的值，不会修改它</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 尝试在常量成员函数中修改成员变量将导致编译错误</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">tryToModify</span><span class="params">()</span> <span class="type">const</span> &#123;</span><br><span class="line">        <span class="comment">// value = 100; // 错误：不能在常量成员函数中修改成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    MyClass <span class="title function_">obj</span><span class="params">(<span class="number">42</span>)</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The value is: &quot;</span> &lt;&lt; obj.getValue() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出：The value is: 42</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> MyClass <span class="title function_">constObj</span><span class="params">(<span class="number">55</span>)</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The value is: &quot;</span> &lt;&lt; constObj.getValue() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 输出：The value is: 55</span></span><br><span class="line">    <span class="comment">// constObj.tryToModify(); // 错误：不能在常量对象上调用非常量成员函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码看不懂不要紧，这里只要了解常量成员函数的基本概念，以及如何声明即可。看完下文类和对象的讲解，再回过头来看代码就可以理解。</p>
<h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><p>C++的面向对象编程（OOP）是一种编程范式，它使用“对象”来设计软件。对象可以包含数据（称为属性或成员变量）和代码（称为方法或成员函数）。C++的 OOP 建立在几个核心概念之上：类、封装、继承、多态。让我们一一详细讲解这些知识点。</p>
<h3 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h3><h4 id="类的定义："><a href="#类的定义：" class="headerlink" title="类的定义："></a>类的定义：</h4><p>类是创建对象的蓝图。它定义了对象的属性（成员变量）和行为（成员函数或方法），在C++中，使用关键字<code>class</code> 来定义类。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义 MyClass 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="成员的访问权限："><a href="#成员的访问权限：" class="headerlink" title="成员的访问权限："></a>成员的访问权限：</h4><p>在C++中，类的成员（包括变量和函数）可以具有三种不同的访问权限：<code>public</code>、<code>private</code>和<code>protected</code>。这些访问权限控制了类外部的代码对类成员的访问级别，从而实现了封装和数据隐藏。</p>
<ul>
<li><p><strong>public</strong>（公有成员）：可以被任何其他代码访问，无论是类的内部还是外部。如果类的成员声明为public，那么在类的实例化对象外部也可以直接访问这些成员。</p>
</li>
<li><p><strong>private</strong>（私有成员）：只能被该类的成员函数、友元函数和该类的其他实例访问。如果类的成员声明为private，那么这些成员只能在类的内部被访问。这是默认的访问级别，如果没有指定访问权限，则成员默认为private。</p>
</li>
<li><p><strong>protected</strong>（受保护成员）：可以被该类的成员函数、友元函数、该类的派生类中的成员访问。如果类的成员声明为protected，那么这些成员既可以在类的内部被访问，也可以在派生类中被访问，但不能直接通过类的实例在类的外部被访问。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> publicVar;  <span class="comment">// 公有成员变量，任何地方都可访问</span></span><br><span class="line">protected:</span><br><span class="line">    <span class="type">int</span> protectedVar;  <span class="comment">// 受保护成员变量，类内部和派生类可访问</span></span><br><span class="line">private:</span><br><span class="line">    <span class="type">int</span> privateVar;  <span class="comment">// 私有成员变量，仅类内部可访问</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">void</span> <span class="title function_">privateMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 私有成员函数，仅类内部可访问</span></span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">publicMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 公有成员函数，任何地方都可访问</span></span><br><span class="line">        privateVar = <span class="number">0</span>; <span class="comment">// 可以访问私有成员</span></span><br><span class="line">        privateMethod(); <span class="comment">// 可以调用私有成员函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="成员访问权限有什么用？"><a href="#成员访问权限有什么用？" class="headerlink" title="成员访问权限有什么用？"></a>成员访问权限有什么用？</h4><ul>
<li><strong>封装</strong>：通过将成员设为私有或受保护，类可以隐藏其实现细节，仅通过公有接口与外界交互。这样做可以在不影响外部代码的情况下自由修改类的内部实现。</li>
<li><strong>维护性</strong>：限制对成员的访问可以减少因错误使用类成员而产生的bug，使得代码更加可维护。</li>
<li><strong>扩展性</strong>：合理使用访问权限可以在不破坏原有类的基础上进行扩展，增加新的功能。</li>
</ul>
<h4 id="成员变量和成员函数"><a href="#成员变量和成员函数" class="headerlink" title="成员变量和成员函数"></a>成员变量和成员函数</h4><p>类中定义的变量称为成员变量，类中定义的函数称为成员函数。它们定义了类的属性和行为。</p>
<p>成员变量初始化有以下两种方式：</p>
<p><strong>1. 构造函数初始化列表</strong>：使用构造函数的初始化列表直接初始化成员变量，这是最常用且推荐的初始化成员变量的方式，特别是对于常量成员和引用成员。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> &#123;</span></span><br><span class="line">private:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">public:</span><br><span class="line">    Example(<span class="type">int</span> d) : data(d) &#123;&#125; <span class="comment">// 构造函数初始化列表</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>2. 在构造函数体内赋值</strong>：在函数体内对成员进行初始化。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> &#123;</span></span><br><span class="line">private:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">public:</span><br><span class="line">    Example(<span class="type">int</span> d) &#123;</span><br><span class="line">        data = d; <span class="comment">// 在构造函数体内赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h4><p><strong>构造函数</strong>：构造函数的名称与类名相同，可以有参数，也可以重载（即定义多个构造函数，每个构造函数有不同的参数列表）。如果你不提供任何构造函数，C++编译器会自动生成一个默认的无参构造函数。</p>
<p>构造函数在创建对象时自动调用，用于初始化对象。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    Car() &#123; <span class="comment">// 默认构造函数</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Car object created.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Car(<span class="built_in">string</span> brand) &#123; <span class="comment">// 带有参数的构造函数</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; brand &lt;&lt; <span class="string">&quot; car object created.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>析构函数</strong>：析构函数的名称是类名前加上波浪符号<code>~</code>，它不能带参数，因此一个类只能有一个析构函数。析构函数用于执行对象销毁前的清理工作，比如释放分配的资源等。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    ~Car() &#123; <span class="comment">// 析构函数</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Car object destroyed.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通过合理定义和使用构造函数和析构函数，我们可以确保对象在创建和销毁时维持合理的状态，以及有效地管理资源。</p>
<p>一个简单的 Car 类定义示例：</p>
<p>该 Car 类包含构造函数和析构函数，成员变量和成员函数等基本成员。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义 Car 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="built_in">string</span> brand;  <span class="comment">// 汽车的品牌</span></span><br><span class="line">    <span class="comment">// 构造函数，使用初始化列表来初始化成员变量。</span></span><br><span class="line">    Car(<span class="built_in">string</span> b) : brand(b) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; brand &lt;&lt; <span class="string">&quot; car is created.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~Car() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; brand &lt;&lt; <span class="string">&quot; car is destroyed.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 成员函数</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">drive</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Driving &quot;</span> &lt;&lt; brand &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Car <span class="title function_">myCar</span><span class="params">(<span class="string">&quot;Ford&quot;</span>)</span>;  <span class="comment">// 创建一个Car对象，品牌为&quot;Ford&quot;</span></span><br><span class="line">    myCar.drive();      <span class="comment">// 调用drive成员函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="对象的创建："><a href="#对象的创建：" class="headerlink" title="对象的创建："></a>对象的创建：</h4><p>对象是类的实例。通过类，我们可以创建对象，并使用其属性和方法。对象可以通过成员访问运算符<code>.</code>访问其成员变量和成员函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Car <span class="title function_">myCar</span><span class="params">(<span class="string">&quot;Ford&quot;</span>)</span>; <span class="comment">// 福特汽车</span></span><br><span class="line">myCar.drive();     <span class="comment">// 访问 myCar 对象的成员方法</span></span><br></pre></td></tr></table></figure>

<h4 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h4><p>在C++中，this指针是一个特殊的指针，它指向当前对象。每个非静态成员函数（包括构造函数、析构函数以及其他成员函数）都有一个this指针作为其隐式参数，这使得成员函数能够访问调用它的对象的成员。this指针在成员函数内部使用，特别是在需要引用调用函数的当前对象时。</p>
<p>当我们在类的成员函数中需要引用对象本身时，就会用到this指针。这在以下几种情况中尤其有用：</p>
<ul>
<li>当参数名称与成员变量名称相同时，用以区分成员变量和参数。</li>
<li>在实现链式调用时返回对象的引用。</li>
<li>当需要返回对象本身的指针时。</li>
</ul>
<p>示例代码：</p>
<p><strong>1. 区分成员变量和参数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> width;</span><br><span class="line">    Box(<span class="type">int</span> width) &#123;</span><br><span class="line">        <span class="comment">// 使用this指针区分成员变量和构造函数参数</span></span><br><span class="line">        this-&gt;width = width;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">displayWidth</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Width: &quot;</span> &lt;&lt; width &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 直接访问width，实际上是this-&gt;width</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，构造函数的参数width与类的成员变量width同名。通过使用this-&gt;width，我们明确指出了左边的width是对象的成员变量，而不是参数。</p>
<p><strong>2. 实现链式调用</strong></p>
<p>链式调用是一种编程风格，通过在成员函数末尾返回对象本身，可以连续调用多个成员函数。</p>
<p>示例代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span> &#123;</span></span><br><span class="line">private:</span><br><span class="line">    <span class="type">int</span> width;</span><br><span class="line">public:</span><br><span class="line">    Box&amp; <span class="title function_">setWidth</span><span class="params">(<span class="type">int</span> width)</span> &#123;</span><br><span class="line">        this-&gt;width = width;</span><br><span class="line">        <span class="keyword">return</span> *this;  <span class="comment">// 返回当前对象的引用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">displayWidth</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Width: &quot;</span> &lt;&lt; width &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Box box;</span><br><span class="line">    box.setWidth(<span class="number">10</span>).displayWidth();  <span class="comment">// 链式调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在setWidth函数中，返回*this允许链式调用，即连续调用对象的成员函数。</p>
<p><strong>3. 返回对象本身的指针</strong></p>
<p>有时候，我们可能需要在成员函数中返回指向当前对象的指针。</p>
<p>示例代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    Box* <span class="title function_">getPointer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> this;  <span class="comment">// 返回指向当前对象的指针</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在getPointer函数中，通过返回this，我们得到了一个指向当前对象的指针。</p>
<p>this指针是 C++ 中一个强大的工具，它提供了一个自引用的机制。通过 this 指针，类的成员函数可以访问调用它们的对象的其他成员。理解 this 指针对于深入学习C++面向对象编程非常重要。</p>
<p><strong>而理解 this 指针，关键是要了解它的底层原理</strong>：</p>
<p>在C++中，this指针的底层实现其实非常直观。当一个非静态成员函数被调用时，编译器隐式地将当前对象的地址作为一个参数传递给函数。这个隐式参数就是this指针。因此，每个非静态成员函数在内部都有一个名为this的额外参数，指向调用该函数的对象。</p>
<h5 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h5><ul>
<li><p>对于一个类<code>ClassType</code>中的非静态成员函数<code>memberFunction</code>，调用形式<code>object.memberFunction(args...)</code>,实际上在底层被编译器处理为<code>ClassType::memberFunction(&amp;object, args...)</code>，其中<code>&amp;object</code>就是<code>this指针</code>。</p>
</li>
<li><p>因此，即使你在成员函数定义中没有显式地看到<code>this</code>参数，编译器仍然按照每个非静态成员函数都有一个类型为<code>ClassType*</code>的<code>this指针</code>作为其第一个参数的方式来处理。</p>
</li>
</ul>
<p>考虑以下类定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">myFunction</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Value of a: &quot;</span> &lt;&lt; this-&gt;a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当你创建一个MyClass对象并调用其成员函数myFunction时：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyClass obj;</span><br><span class="line">obj.a = <span class="number">10</span>;</span><br><span class="line">obj.myFunction();</span><br></pre></td></tr></table></figure>
<p>在调用 obj.myFunction() 时，实际上编译器在底层将其转换为类似以下形式的调用（这是一种简化的表达，实际转换会依赖于具体的编译器）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyClass::myFunction(&amp;obj);</span><br></pre></td></tr></table></figure>
<p>这里，&amp;obj 是对象 obj 的地址，它被隐式地作为 this 指针传递给 myFunction。所以，在 myFunction 内部，当你访问 this-&gt;a 时，实际上就是通过 obj 的地址来访问它的成员变量 a。</p>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>封装在 C++ 面向对象编程中是一种将数据（属性）和行为（方法）捆绑在一起的机制，同时对外隐藏内部实现的细节，仅通过定义好的接口与外界交互。</p>
<p><strong>简单来说</strong>:封装实质上是关于数据隐藏和接口暴露的。在定义一个类时，你会将某些数据成员标记为 private，这意味着它们只能被类的内部成员函数访问，对类的使用者来说，这些细节被隐藏了。然而，你也会提供public的成员函数作为操作这些数据的接口，这样类的使用者可以在不知道内部实现细节的情况下，通过这些接口来操作对象。</p>
<h4 id="封装的实现"><a href="#封装的实现" class="headerlink" title="封装的实现"></a>封装的实现</h4><p>在C++中，封装通过<strong>类</strong>实现，类中可以定义三种类型的成员：public（公有成员）、private（私有成员）和protected（受保护成员）。这些访问修饰符定义了成员的访问范围：</p>
<ul>
<li><strong>private</strong> 成员只能由同一类的成员函数访问。</li>
<li><strong>public</strong> 成员可以由任何可以访问类对象的代码访问。</li>
<li><strong>protected</strong> 成员可以被基类和派生类中的成员函数访问。</li>
</ul>
<p>通过精心设计公有接口，类的设计者可以控制外部代码对内部数据的访问方式，保护对象的状态不被非法操作破坏。</p>
<h4 id="封装的优势"><a href="#封装的优势" class="headerlink" title="封装的优势"></a>封装的优势</h4><ul>
<li><strong>数据安全</strong>：通过隐藏内部实现细节，减少了外部对内部数据的直接访问，降低了数据被误用或误修改的风险。</li>
<li><strong>接口清晰</strong>：用户只需关注类提供的公有接口，不必深究类的内部实现，使得类更加易于使用和理解。</li>
<li><strong>易于维护和扩展</strong>：类的内部实现可以自由修改，只要公有接口保持不变，就不会影响到使用该类的代码，提高了代码的可维护性和扩展性。</li>
</ul>
<p><strong>一个体现 C++ 封装的类的实现</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">private:</span><br><span class="line">    <span class="built_in">string</span> name;  <span class="comment">// 私有成员变量，存储人的姓名</span></span><br><span class="line">    <span class="type">int</span> age;      <span class="comment">// 私有成员变量，存储人的年龄</span></span><br><span class="line">public:</span><br><span class="line">    <span class="comment">// 构造函数，初始化姓名和年龄，使用初始化列表来初始化成员变量。</span></span><br><span class="line">    Person(<span class="built_in">string</span> n, <span class="type">int</span> a) : name(n), age(a) &#123;&#125;</span><br><span class="line">    <span class="comment">// 公有成员函数，设置姓名</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">setName</span><span class="params">(<span class="built_in">string</span> n)</span> &#123;</span><br><span class="line">        name = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 公有成员函数，获取姓名</span></span><br><span class="line">    <span class="built_in">string</span> <span class="title function_">getName</span><span class="params">()</span> <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 公有成员函数，设置年龄</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(a &gt;= <span class="number">0</span>) &#123; <span class="comment">// 确保年龄是非负数</span></span><br><span class="line">            age = a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 公有成员函数，获取年龄</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 成员函数，打印Person信息</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">printInfo</span><span class="params">()</span> <span class="type">const</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;, Age: &quot;</span> &lt;&lt; age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Person <span class="title function_">person</span><span class="params">(<span class="string">&quot;John Doe&quot;</span>, <span class="number">30</span>)</span>; <span class="comment">// 创建Person对象</span></span><br><span class="line">    person.printInfo(); <span class="comment">// 打印信息</span></span><br><span class="line">    <span class="comment">// 尝试修改Person的姓名和年龄</span></span><br><span class="line">    person.setName(<span class="string">&quot;Jane Doe&quot;</span>);</span><br><span class="line">    person.setAge(<span class="number">25</span>);</span><br><span class="line">    <span class="comment">// 再次打印修改后的信息</span></span><br><span class="line">    person.printInfo(); <span class="comment">// 打印信息</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h4 id="继承的定义"><a href="#继承的定义" class="headerlink" title="继承的定义"></a>继承的定义</h4><p>继承允许新的类（派生类）继承现有类（基类）的属性和方法。它支持代码重用，并建立了类之间的层次关系。</p>
<h4 id="继承的分类"><a href="#继承的分类" class="headerlink" title="继承的分类"></a>继承的分类</h4><h5 id="单一继承"><a href="#单一继承" class="headerlink" title="单一继承"></a>单一继承</h5><p>在单一继承中，一个派生类只继承自一个基类。这意味着派生类包含了基类的所有属性和方法，同时还可以添加自己的属性和方法，或者重写基类的方法。</p>
<p><strong>定义方式</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseClass</span> &#123;</span></span><br><span class="line">    <span class="comment">// 基类的成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedClass</span> :</span> public BaseClass &#123;</span><br><span class="line">    <span class="comment">// 派生类的成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里，DerivedClass 是通过单一继承从 BaseClass派生而来的。</p>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Eating.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span> public Animal &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">bark</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Barking.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Dog myDog;</span><br><span class="line">    myDog.eat(); <span class="comment">// 调用基类的方法</span></span><br><span class="line">    myDog.bark(); <span class="comment">// 调用派生类的方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h5><p>多重继承允许一个派生类同时从多个基类继承属性和方法。这种方式增加了灵活性，但也可能引入复杂性，例如需要处理潜在的命名冲突，以及著名的“菱形问题”。</p>
<p><strong>定义方式</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseClass1</span> &#123;</span></span><br><span class="line">    <span class="comment">// 基类1的成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseClass2</span> &#123;</span></span><br><span class="line">    <span class="comment">// 基类2的成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedClass</span> :</span> public BaseClass1, public BaseClass2 &#123;</span><br><span class="line">    <span class="comment">// 派生类的成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，DerivedClass 同时从 BaseClass1 和BaseClass2 继承，成为它们的派生类。</p>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Eating.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 第二个基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Flying.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类(麻雀)，继承自Animal和Bird</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sparrow</span> :</span> public Animal, public Bird &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="comment">//发出声音，模拟麻雀叫声</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">chirp</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Chirping.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Sparrow mySparrow;</span><br><span class="line">    mySparrow.eat(); <span class="comment">// 调用Animal基类的方法</span></span><br><span class="line">    mySparrow.fly(); <span class="comment">// 调用Bird基类的方法</span></span><br><span class="line">    mySparrow.chirp(); <span class="comment">// 调用派生类的方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多重继承允许一个派生类同时继承自多个基类。这是C++提供的一种强大功能，它可以让派生类继承并实现多个基类定义的接口和属性。然而，在使用多重继承时，我们可能会遇到一种特殊情况：菱形继承（也称为钻石继承）问题。</p>
<p><strong>菱形继承</strong></p>
<p>假设有这样一个场景：我们有一个基类A，然后有两个类B和C分别继承自A，最后有一个类D同时继承自B和C。这样构成的继承结构形状像一个菱形，因此称为菱形继承。如下图：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">     A</span><br><span class="line">    / \</span><br><span class="line">   B   C</span><br><span class="line">    \ /</span><br><span class="line">     D</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对应的代码示例：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> public A &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> public A &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> public B, public C &#123;</span><br><span class="line">    <span class="comment">// D通过B和C继承了A，可能会导致A的成员在D中存在多份拷贝</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>菱形继承引入的问题是D通过B和C继承了两份A的成员，这导致了数据冗余和不一致性的风险。特别是当试图访问从A继承来的成员时，编译器会因为不知道应该通过B还是C的路径去访问而产生歧义。</p>
<p><strong>解决菱形继承问题</strong></p>
<p>C++中通过引入虚继承来解决菱形继承问题。在菱形继承的结构中，将B和C对A的继承声明为虚继承（使用<code>virtual</code>关键字），可以确保D中只有一份A的成员副本。</p>
<p>这样，无论是通过B还是C，访问到的都是同一份来自A的成员，解决了成员访问歧义的问题，并且保证了数据的一致性。</p>
<p><strong>虚继承的声明方式</strong>：</p>
<p>通过在派生类中使用 <strong>virtual</strong> 关键字进行继承。</p>
<p>使用虚继承来解决菱形继承问题示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// B和C虚继承A</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> virtual public A &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> virtual public A &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// D继承自B和C</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> public B, public C &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，通过将 B 和 C 对 A 的继承声明为虚继承，我们确保了在 D 中只有一份来自 A 的成员 value，无论是通过 B 还是 C 的路径访问 value，访问到的都是相同的成员。</p>
<h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><p>在C++中，友元（Friend）是一个允许某些外部函数或类访问另一个类的私有（private）和保护（protected）成员的特性。友元关系不受类之间的公有（public）、私有（private）和保护（protected）访问控制的约束，这使得某些特定的函数或类可以直接访问类的内部成员。</p>
<p>友元机制可以增强程序的灵活性，但同时也可能破坏对象的封装性。</p>
<p>友元可以是：</p>
<ul>
<li>友元函数</li>
<li>友元类</li>
<li>友元成员函数</li>
</ul>
<h4 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h4><p>友元函数在C++中是一种特殊的函数，它虽然不是类的成员函数，但能够访问类的私有（private）和保护（protected）成员。这允许全局函数访问类的私有成员。</p>
<p>友元函数的定义包含两个主要步骤：</p>
<ul>
<li><p><strong>在类内声明友元函数</strong>：你需要在类定义内部使用 <code>friend</code> 关键字声明该函数为友元，这告诉编译器这个特定的函数可以访问类的私有和保护成员。</p>
</li>
<li><p><strong>定义友元函数</strong>：友元函数的定义与普通函数相同，但需要注意的是，友元函数本身不是类的成员函数，因此它不能通过对象或指针来调用，而是像普通函数那样直接调用。</p>
</li>
</ul>
<p>代码示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">private:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">public:</span><br><span class="line">    MyClass(<span class="type">int</span> val) : value(val) &#123;&#125; <span class="comment">// 构造函数初始化value</span></span><br><span class="line">    <span class="comment">// 声明友元函数</span></span><br><span class="line">    friend <span class="type">void</span> <span class="title function_">friendFunction</span><span class="params">(MyClass&amp; obj)</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 定义友元函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">friendFunction</span><span class="params">(MyClass&amp; obj)</span> &#123;</span><br><span class="line">    <span class="comment">// 友元函数可以访问MyClass的私有成员value</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Accessing private member value: &quot;</span> &lt;&lt; obj.value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    MyClass <span class="title function_">myObj</span><span class="params">(<span class="number">100</span>)</span>;</span><br><span class="line">    <span class="comment">// 调用友元函数，并访问MyClass对象的私有数据</span></span><br><span class="line">    friendFunction(myObj); <span class="comment">// 输出: Accessing private member value: 100</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h4><p>当一个类被声明为另一个类的友元时，这个友元类的所有成员函数都可以访问另一个类的私有和保护成员。</p>
<p>示例代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span> &#123;</span></span><br><span class="line">    <span class="type">double</span> width;</span><br><span class="line">public:</span><br><span class="line">    Box(<span class="type">double</span> wid) : width(wid) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    friend <span class="class"><span class="keyword">class</span> <span class="title">Printer</span>;</span> <span class="comment">// 声明Printer为友元类</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Printer</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">printWidth</span><span class="params">(Box box)</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Width of box : &quot;</span> &lt;&lt; box.width &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Box <span class="title function_">box</span><span class="params">(<span class="number">10.0</span>)</span>;</span><br><span class="line">    Printer printer;</span><br><span class="line">    printer.printWidth(box);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子中，Printer 类是 Box 类的友元，因此 Printer 的成员函数 printWidth可以访问 Box 的私有成员 width。</p>
<h4 id="友元成员函数"><a href="#友元成员函数" class="headerlink" title="友元成员函数"></a>友元成员函数</h4><p>一个类的成员函数可以被声明为另一个类的友元。</p>
<p>示例代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span> &#123;</span></span><br><span class="line">    <span class="type">double</span> width;</span><br><span class="line">public:</span><br><span class="line">    Box(<span class="type">double</span> wid) : width(wid) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    friend <span class="type">void</span> <span class="title function_">Printer::printWidth</span><span class="params">(Box box)</span>; <span class="comment">// 前向声明</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Printer</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">printWidth</span><span class="params">(Box box)</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Width of box : &quot;</span> &lt;&lt; box.width &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Box <span class="title function_">box</span><span class="params">(<span class="number">10.0</span>)</span>;</span><br><span class="line">    Printer printer;</span><br><span class="line">    printer.printWidth(box); <span class="comment">// 使用Printer对象打印Box的宽度</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，Printer类的成员函数printWidth是Box类的友元，因此它可以访问Box的私有成员width。</p>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li>使用友元时应谨慎，因为它破坏了类的封装性。一个设计良好的类应该尽量隐藏其实现细节，只通过公共接口与外界交互。</li>
<li>友元关系不能被继承。</li>
<li>友元关系是单向的，即如果类A是类B的友元，类B不一定是类A的友元。</li>
</ul>
<h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><p>运算符重载是 C++ 中一个非常强大的特性，它允许开发者为自定义类型指定运算符操作的行为。这样，我们就可以对自定义类型使用标准的C++运算符，如+、-、&lt;&lt;等。这不仅可以提高代码的直观性，还可以使得自定义类型的操作更加自然。</p>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>运算符重载允许开发者为自定义类型重新定义运算符的功能。它可以作为成员函数或非成员函数(友元函数)实现，但必须至少有一个操作数是用户定义的类型。</p>
<p><strong>使用运算符重载时，需要遵循一些规则</strong>：</p>
<ul>
<li>不能改变运算符的优先级。</li>
<li>不能创造新的运算符。</li>
<li>有些运算符不能被重载，如<code>.</code>、<code>::</code>、<code>?:</code>和<code>sizeof</code>。其他的内置运算符都是可以重载的，比如常见的算术运算符、比较运算符、逻辑运算符等。</li>
<li>大多数重载的运算符可以是成员函数，也可以是非成员函数，但有些必须是成员函数，如赋值运算符<code>=</code>。</li>
</ul>
<h4 id="运算符重载的分类"><a href="#运算符重载的分类" class="headerlink" title="运算符重载的分类"></a>运算符重载的分类</h4><p>根据运算符作用于的对象，运算符重载可以是成员函数或非成员函数。</p>
<h5 id="成员函数运算符重载"><a href="#成员函数运算符重载" class="headerlink" title="成员函数运算符重载"></a>成员函数运算符重载</h5><p>当运算符重载作为成员函数时，它的第一个操作数隐式地成为了调用它的对象，这意味着你不能改变操作数的顺序。这通常用于二元运算符，比如加法运算符+，或一元运算符，比如递增运算符++。</p>
<p>我们先来看个成员函数运算符重载的例子,以重载<code>+</code>运算符为例，定义一个 <code>Point</code> 类，并为它重载 <code>+</code> 运算符。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    Point(<span class="type">int</span> x = <span class="number">0</span>, <span class="type">int</span> y = <span class="number">0</span>) : x(x), y(y) &#123;&#125;</span><br><span class="line">    <span class="comment">// 重载+运算符</span></span><br><span class="line">    Point operator+(<span class="type">const</span> Point&amp; rhs) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Point(x + rhs.x, y + rhs.y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Point <span class="title function_">p1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span>, <span class="title function_">p2</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span>;</span><br><span class="line">    Point p3 = p1 + p2;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;p3 = (&quot;</span> &lt;&lt; p3.x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; p3.y &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们定义了 <code>Point</code> 类的对象可以通过<code>+</code>运算符相加，返回两点坐标的和。</p>
<h5 id="非成员函数运算符重载"><a href="#非成员函数运算符重载" class="headerlink" title="非成员函数运算符重载"></a>非成员函数运算符重载</h5><p>非成员函数运算符重载通常声明为类的友元，这样它们就可以访问类的私有成员。这种方式适用于操作符左侧的对象不是重载运算符所在类的实例的情况，比如<code>输出流运算符&lt;&lt;</code>。</p>
<p><strong>重载&lt;&lt;运算符</strong></p>
<p>接下来，我们看下非成员函数运算符重载的例子，重载<code>&lt;&lt;</code>运算符以便能够直接打印 <code>Point</code> 对象。</p>
<p>由于<code>&lt;&lt;</code>运算符需要操作<code>std::ostream</code>类型的左操作数（如<code>std::cout</code>），它不能作为成员函数重载，而应该是非成员函数(友元函数)。通常，我们会将这样的函数声明为友元，以便它可以访问类的私有成员。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    friend <span class="built_in">std</span>::ostream&amp; operator&lt;&lt;(<span class="built_in">std</span>::ostream&amp; os, <span class="type">const</span> Point&amp; p);</span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    Point(<span class="type">int</span> x = <span class="number">0</span>, <span class="type">int</span> y = <span class="number">0</span>) : x(x), y(y) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 重载&lt;&lt;运算符</span></span><br><span class="line"><span class="built_in">std</span>::ostream&amp; operator&lt;&lt;(<span class="built_in">std</span>::ostream&amp; os, <span class="type">const</span> Point&amp; p) &#123;</span><br><span class="line">    os &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; p.x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; p.y &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Point <span class="title function_">p1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; p1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 现在可以直接打印Point对象了</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这里留个问题</strong>：为什么<code>&lt;&lt;</code>运算符不能作为成员函数重载，而只能是非成员函数？</p>
<p>这个问题，在我开始学习运算符重载的时候就挺疑惑的，不过现在已经搞清楚了，接下来，我尽可能用易懂的文字及代码示例给大家讲解清楚：</p>
<p>在 C++ 中，当你使用如 <code>std::cout &lt;&lt; object</code>; 的形式进行输出时，期望的行为是把<code>object</code>的内容发送到输出流<code>std::cout</code>。为了实现这个行为，我们需要重载&lt;&lt;运算符。但这里的挑战在于，<code>std::cout</code>是一个<code>std::ostream</code>类型的对象，而<code>object</code>是另一个用户自定义类型的类对象。</p>
<p><strong>成员函数的限制</strong>：<br>如果<code>&lt;&lt;</code>运算符是作为用户自定义类型的一个成员函数来重载，它的使用方式将变为<code>object.operator&lt;&lt;(std::cout);</code>。这意味着，从语法上讲，你正在尝试向<code>object</code>发送<code>std::cout</code>，而不是反过来。这与我们通常使用输出流的直觉相违背，因为我们希望<code>std::cout</code>在左边，<code>object</code>在右边，即：<code>std::cout&lt;&lt;object</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    MyClass(<span class="type">int</span> v) : value(v) &#123;&#125;</span><br><span class="line">    <span class="comment">// 假设尝试将 &lt;&lt; 作为成员函数重载</span></span><br><span class="line">    <span class="type">void</span> operator&lt;&lt;(<span class="built_in">std</span>::ostream&amp; os) &#123;</span><br><span class="line">        os &lt;&lt; value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    MyClass <span class="title function_">obj</span><span class="params">(<span class="number">10</span>)</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; obj; <span class="comment">// 这是我们想要的使用方式</span></span><br><span class="line">    obj &lt;&lt; <span class="built_in">std</span>::<span class="built_in">cout</span>; <span class="comment">// 如果&lt;&lt;是成员函数，实际调用将会是这样，这显然不符合我们的预期</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>为什么用非成员函数?</strong></p>
<p>为了让<code>std::cout &lt;&lt; object;</code>按预期工作，我们需要把<code>&lt;&lt;</code>运算符重载为非成员函数，这样它就可以接受两个参数：左边的<code>std::ostream</code>对象和右边的用户自定义类型对象。这种方式符合我们直观的使用习惯。</p>
<p><strong>使用友元函数</strong></p>
<p>此外，由于重载的<code>&lt;&lt;</code>运算符通常需要访问用户自定义类型对象的内部数据（可能包括私有成员），我们一般会把这个重载函数声明为<strong>友元函数</strong>。这样，即使是非成员函数，它也能访问类的私有或受保护成员，从而可以输出对象的内部状态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    MyClass(<span class="type">int</span> val) : value(val) &#123;&#125;</span><br><span class="line">    <span class="comment">// 注意，这里没有作为成员函数重载&lt;&lt;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载&lt;&lt;运算符作为全局函数，并声明为友元，以便可以访问MyClass的内部数据</span></span><br><span class="line"><span class="built_in">std</span>::ostream&amp; operator&lt;&lt;(<span class="built_in">std</span>::ostream&amp; os, <span class="type">const</span> MyClass&amp; obj) &#123;</span><br><span class="line">    os &lt;&lt; obj.value; <span class="comment">// 假设我们要输出MyClass对象的value成员</span></span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    MyClass <span class="title function_">myObject</span><span class="params">(<span class="number">10</span>)</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; myObject; <span class="comment">// 正确地把myObject的内容输出到std::cout</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>在讲解多态之前，我们先来回顾下继承，因为多态是建立在类的继承关系之上的。</p>
<p><strong>简单来说</strong>: 继承允许我们基于一个已有的类（称为基类）来创建新的类（称为派生类）。派生类继承了基类的属性和方法，并且可以添加自己的属性和方法，或者重写继承来的方法。这为代码复用提供了一个强大的机制。</p>
<p>多态，字面意思是“多种形态”。在C++中，它允许我们通过一个共同的接口来操作不同的数据类型。这听起来可能有点抽象，不过别担心，让我们通过一个例子来简化它。</p>
<p>想象一下，你在动物园里，看到了各种各样的动物。虽然每种动物都有自己独特的叫声，但是你可以通过一个统一的行为“发出声音”来描述它们的共性。在C++中，我们可以将这种“发出声音”的行为抽象成一个共同的接口，然后让每种动物类根据自己的特性来实现这个接口。</p>
<h4 id="多态的分类："><a href="#多态的分类：" class="headerlink" title="多态的分类："></a>多态的分类：</h4><p>在C++中，多态主要以两种形式出现：<strong>编译时多态和运行时多态。</strong></p>
<ul>
<li><p><strong>编译时多态</strong>，也称为静态多态，主要是通过函数重载和模板实现的。函数重载允许你在同一个作用域内创建多个同名函数，只要它们的参数列表不同即可。编译器根据调用函数时提供的参数类型和数量，来决定调用哪个函数。</p>
</li>
<li><p><strong>运行时多态</strong>，也称为动态多态，是通过虚函数和继承实现的。这允许你在基类中定义一个接口，并在派生类中以不同的方式实现该接口。运行时多态的关键在于，你在代码运行时才确定调用哪个函数。</p>
</li>
</ul>
<h4 id="运行时多态的实现："><a href="#运行时多态的实现：" class="headerlink" title="运行时多态的实现："></a>运行时多态的实现：</h4><p>要实现C++的运行时多态，你需要掌握两个核心概念：<strong>虚函数和指针或引用</strong>。</p>
<p><strong>虚函数</strong>：</p>
<p>虚函数是在基类中使用关键字 <code>virtual</code> 声明的函数，它可以在派生类中被重覆盖，覆盖指的是派生类被重写的函数和基类声明的虚函数具有相同的函数声明。这样当你通过基类的指针或引用调用虚函数时，C++会根据对象的实际类型来决定调用哪个版本的函数。</p>
<p><strong>简单示例</strong></p>
<p>让我们回到动物园的例子，如果“动物”是一个基类，“狗”和“猫”是派生类，那么即使我们有一个指向“动物”的指针，我们也可以用它来调用“狗”和“猫”特有的方法。</p>
<p>代码示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    virtual <span class="type">void</span> <span class="title function_">speak</span><span class="params">()</span> &#123; </span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Some sound&quot;</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span> public Animal &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">speak</span><span class="params">()</span>  &#123; </span><br><span class="line">          <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Woof&quot;</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span> public Animal &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">speak</span><span class="params">()</span>  &#123; </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Meow&quot;</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Animal* myAnimal = new Dog();</span><br><span class="line">    myAnimal-&gt;speak();  <span class="comment">// Outputs: Woof</span></span><br><span class="line"></span><br><span class="line">    myAnimal = new Cat();</span><br><span class="line">    myAnimal-&gt;speak();  <span class="comment">// Outputs: Meow</span></span><br><span class="line"></span><br><span class="line">    delete myAnimal; <span class="comment">// Assuming myAnimal now points to Cat, delete the Cat object</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们定义了一个基类 Animal 和两个派生类 Dog 和 Cat。每个类都有一个 speak 函数，但实现各不相同。通过基类指针调用 speak 时，C++运行时会根据对象的实际类型来决定调用 Dog 的 speak 还是 Cat 的 speak。</p>
<p><strong>这里问个问题</strong>：myAnimal是基类指针，为什么调用的是派生类(Cat类和Dog类)的方法？</p>
<p>其实就是通过多态和虚函数机制来实现的。简单来说：</p>
<ul>
<li><p><code>虚函数</code>：在基类中用virtual关键字声明的函数。派生类可以重写这些函数。</p>
</li>
<li><p><code>虚表指针</code>：每个包含虚函数的类对象都有一个指针（vptr），指向其类的虚表。</p>
</li>
<li><p><code>虚表</code>：每个包含虚函数的类都有一个虚函数表（简称vtable），里面存储了虚函数的地址。</p>
</li>
</ul>
<p><code>注意</code>：虚函数表（vtable）是在编译期间确定的，而虚表指针（vptr）是在每个对象被构造时创建并初始化的。(<strong>这个也是面试常考的点</strong>)</p>
<p>当通过基类指针调用虚函数时，程序会使用这个指针指向的对象的虚表来确定实际调用哪个函数(这个过程是在运行时做的)。这样，即便是通过基类指针，程序也能调用到派生类中重写的方法，实现了多态。 </p>
<p>在这个例子中，Animal 类中的 speak 函数被声明为 virtual，这使得 Dog 和 Cat类能够提供自己的speak函数实现。当通过类型为 Animal* 的指针 myAnimal 调用 speak 函数时，C++ 运行时会检查 myAnimal 实际指向的对象类型（Dog或Cat），并调用那个类型的 speak 函数。</p>
<h4 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h4><p>当我们希望定义一个通用接口，但又不想在基类中提供任何具体实现时，该怎么办。使用纯虚函数和抽象类即可实现。</p>
<h5 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h5><p>纯虚函数是一种特殊的虚函数，在基类中声明但不提供实现（不定义函数体），并且要求派生类必须提供具体的实现。这通过在函数声明的末尾加上<code>= 0</code>来实现。</p>
<p>纯虚函数的存在使得基类变成所谓的抽象类，这意味着它不能被直接实例化。这样，抽象类为派生类定义了一个或多个必须实现的接口，从而实现了一个完全抽象的概念层。</p>
<h5 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h5><p>抽象类是包含至少一个纯虚函数的类。它主要用作其他类的基类，定义了一组接口，派生类通过实现这些接口实现多态性。抽象类提供了一种强制派生类遵守特定设计契约的机制。</p>
<p>回到我们的动物园例子，假设我们想要强制每种动物都必须实现自己的“发出声音”的方法，但在“动物”这一概念层面，我们无法给出一个具体的实现。这就是纯虚函数和抽象类发挥作用的地方。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象基类Animal</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="comment">// 纯虚函数</span></span><br><span class="line">    virtual <span class="type">void</span> <span class="title function_">speak</span><span class="params">()</span> <span class="type">const</span> = <span class="number">0</span>;</span><br><span class="line">    virtual ~Animal() &#123;&#125; <span class="comment">// 虚析构函数，保证派生类的析构函数被调用</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dog类继承自Animal并实现speak方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span> public Animal &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">speak</span><span class="params">()</span> <span class="type">const</span>  &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Dog says: Woof!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Cat类继承自Animal并实现speak方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span> public Animal &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">speak</span><span class="params">()</span> <span class="type">const</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Cat says: Meow!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">letAnimalSpeak</span><span class="params">(<span class="type">const</span> Animal* animal)</span> &#123;</span><br><span class="line">    animal-&gt;speak(); <span class="comment">// 动态绑定speak方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Dog dog;</span><br><span class="line">    Cat cat;</span><br><span class="line">    letAnimalSpeak(&amp;dog);</span><br><span class="line">    letAnimalSpeak(&amp;cat);</span><br><span class="line">    <span class="comment">// Animal animal; // 错误：不能实例化抽象类</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在这个示例中，Animal类成为了一个抽象基类，因为它包含了一个纯虚函数 speak。我们不能直接实例化 Animal 类，但我们可以通过它的派生类 Dog 和 Cat 来实例化对象，并且通过 Animal 类的引用或指针来调用它们各自的 speak 方法。</p>
<p>通过将 speak 方法定义为纯虚函数，我们确保了所有 Animal 的派生类都必须实现自己的 speak 方法，这样每种动物都有自己独特的发声方式。同时，这也展示了运行时多态的强大之处：即使是通过 Animal 类型的引用或指针，程序在运行时也能正确调用到派生类对象的 speak 方法。</p>
<p>引入纯虚函数和抽象类后，我们的代码设计变得更加清晰和严格。这种方式不仅强制派生类遵守一定的规则，也提供了一个明确的、可扩展的接口框架。</p>
<p><strong>使用多态的好处</strong>：<br>多态的使用提供了几个优点：</p>
<ul>
<li><strong>代码的可复用性</strong>：可以通过基类接口编写通用的代码，这些代码能够与任何派生类对象协同工作，从而减少代码重复。</li>
<li><strong>代码的可扩展性</strong>：新增派生类时，不需要修改现有的基类代码或其他派生类代码，只需覆盖基类的虚函数即可。</li>
<li><strong>接口的一致性</strong>：派生类可以有不同的实现，但是共享相同的基类接口，使得接口一致、清晰。</li>
</ul>
<p>在讲解虚函数的时候，我们提到了覆盖，然而在C++中也存在另外一个相似的概念叫隐藏，这两者也是比较容易混淆的，接下来我们来看下覆盖和隐藏是什么？以及它们之间的区别？</p>
<h3 id="覆盖和隐藏"><a href="#覆盖和隐藏" class="headerlink" title="覆盖和隐藏"></a>覆盖和隐藏</h3><p>在C++中，函数覆盖和函数隐藏是面向对象编程中的两个基本概念，它们都涉及到派生类（子类）与基类（父类）之间方法的关系。</p>
<h4 id="函数覆盖（Function-Overriding）"><a href="#函数覆盖（Function-Overriding）" class="headerlink" title="函数覆盖（Function Overriding）"></a>函数覆盖（Function Overriding）</h4><p>当派生类中的成员函数与基类中的一个虚函数具有相同的签名（即相同的函数名称、返回类型及参数列表）时，我们说派生类的函数覆盖了（overriding）基类的函数。函数覆盖是实现多态的关键机制之一。</p>
<ul>
<li>覆盖发生在派生类与基类之间的虚函数上。</li>
<li>覆盖的目的是在派生类中提供一个特定实现，替换掉基类中的默认实现。</li>
</ul>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    virtual <span class="type">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Display of Base&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> public Base &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">display</span><span class="params">()</span> override &#123; <span class="comment">// 覆盖基类的display函数</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Display of Derived&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Base* ptr = new Derived();</span><br><span class="line">    ptr-&gt;display(); <span class="comment">// 调用Derived类的display方法</span></span><br><span class="line">    delete ptr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，Derived 类的 display 函数覆盖了 Base 类的 display 函数。通过基类指针调用 display 时，实际上调用的是 Derived 类的实现。这其实就是所为的多态。</p>
<h4 id="函数隐藏（Function-Hiding）"><a href="#函数隐藏（Function-Hiding）" class="headerlink" title="函数隐藏（Function Hiding）"></a>函数隐藏（Function Hiding）</h4><p>当派生类中的函数与基类中的某个函数具有相同的名称，但是签名不同，则我们说派生类中的函数隐藏了（hiding）基类中的同名函数。</p>
<ul>
<li>隐藏与覆盖不同，它发生在所有同名函数上，无论它们是否为虚函数。</li>
<li>隐藏的发生仅仅因为函数的名称相同。</li>
</ul>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Display of Base&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> public Base &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">display</span><span class="params">(<span class="type">int</span>)</span> &#123; <span class="comment">// 隐藏了基类的display函数</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Display of Derived with parameter&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Derived obj;</span><br><span class="line">    obj.display(<span class="number">5</span>); <span class="comment">// 调用Derived类的display方法</span></span><br><span class="line">    <span class="comment">// obj.display(); // 错误：Base类的display方法被隐藏</span></span><br><span class="line">    obj.Base::display(); <span class="comment">// 明确调用Base类的display方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，Derived 类的 display 函数隐藏了 Base 类的 display 函数，因为它们的签名不同。尝试直接调用没有参数的 display() 会导致编译错误，除非我们明确指定要调用 Base 类的版本。</p>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>C++提供了四种类型转换运算符，用于在不同类型之间进行显式转换。这些转换方式比C语言中的传统转换提供了更好的类型安全性和可读性。</p>
<h4 id="1-静态类型转换（static-cast）"><a href="#1-静态类型转换（static-cast）" class="headerlink" title="1. 静态类型转换（static_cast）"></a>1. 静态类型转换（static_cast）</h4><p>static_cast是用于类型之间转换的最常见形式，它在编译时检查转换的合法性。如果转换不合法，编译时会报错。它主要用于以下场景：</p>
<ul>
<li><strong>基本数据类型的转换</strong>：如整型与浮点型之间的转换。</li>
<li><strong>类层次结构中的向上转换</strong>（从派生类到基类）：这是安全的。</li>
<li><strong>类层次结构中的向下转换</strong>（从基类到派生类）：可能不安全，因为基类指针可能并不真正指向一个派生类对象。</li>
<li><strong>void指针的转换</strong>：将void<em>转换为具体类型的指针，或将具体类型的指针转换为void</em>。</li>
</ul>
<p>基本数据类型的转换示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> d = <span class="number">10.5</span>;</span><br><span class="line"><span class="type">int</span> i = static_cast&lt;<span class="type">int</span>&gt;(d); <span class="comment">// double转int</span></span><br></pre></td></tr></table></figure>
<p>类层次结构中的向上转换、向下转换代码示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">baseMethod</span><span class="params">()</span> &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base method\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> public Base &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">derivedMethod</span><span class="params">()</span> &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Derived method\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向上转换</span></span><br><span class="line">Derived derivedObj;</span><br><span class="line">Base* basePtr = static_cast&lt;Base*&gt;(&amp;derivedObj); <span class="comment">// 安全的向上转换</span></span><br><span class="line">basePtr-&gt;baseMethod(); <span class="comment">// 正常：可以访问基类方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 向下转换</span></span><br><span class="line">Base baseObj;</span><br><span class="line">Derived* derivedPtr = static_cast&lt;Derived*&gt;(&amp;baseObj); <span class="comment">// 不安全的向下转换</span></span><br><span class="line"><span class="comment">// derivedPtr-&gt;derivedMethod(); // 不安全：baseObj不是Derived的实例</span></span><br></pre></td></tr></table></figure>
<h4 id="2-常量类型转换（const-cast）"><a href="#2-常量类型转换（const-cast）" class="headerlink" title="2. 常量类型转换（const_cast）"></a>2. 常量类型转换（const_cast）</h4><p><code>const_cast</code>主要用于修改类型的<code>const</code>属性，包括：去除<code>const</code>属性：允许修改原本被声明为<code>const</code>的变量。</p>
<p>代码示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp; b = const_cast&lt;<span class="type">int</span>&amp;&gt;(a); <span class="comment">// 去除const属性</span></span><br><span class="line">b = <span class="number">20</span>; <span class="comment">// 修改成功，但修改const变量是未定义行为</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; b&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>

<h4 id="3-动态类型转换（dynamic-cast）"><a href="#3-动态类型转换（dynamic-cast）" class="headerlink" title="3. 动态类型转换（dynamic_cast）"></a>3. 动态类型转换（dynamic_cast）</h4><p><code>dynamic_cast</code>是C++中用于在类的继承体系内进行类型转换的操作符，特别适用于执行安全的向下转换。<strong>向下转换是指将基类的指针（或引用）转换为派生类的指针（或引用）</strong>。这种转换在运行时检查对象的实际类型，以确保转换的合法性和安全性.</p>
<p>dynamic_cast向下转换代码示例：</p>
<p>假设有一个基类 Base 和一个从 Base 派生的类 Derived：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    virtual <span class="type">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base class&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    virtual ~Base() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> public Base &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">print</span><span class="params">()</span> override &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Derived class&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">specificFunction</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Derived class specific function&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>现在，如果我们想安全地将基类 Base 的指针转换为派生类 Derived 的指针，并调用派生类的特定函数，我们可以使用dynamic_cast：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Base* basePtr = new Derived();</span><br><span class="line">    basePtr-&gt;print();  <span class="comment">// 输出: Derived class</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 安全的向下转换</span></span><br><span class="line">    Derived* derivedPtr = dynamic_cast&lt;Derived*&gt;(basePtr);</span><br><span class="line">    <span class="keyword">if</span> (derivedPtr != nullptr) &#123;</span><br><span class="line">        derivedPtr-&gt;specificFunction();  <span class="comment">// 输出: Derived class specific function</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Conversion failed.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    delete basePtr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，basePtr 实际上指向一个 Derived 类的对象，因此使用 dynamic_cast 将 basePtr 转换为 Derived* 类型是安全的，并且转换成功。这允许我们安全地调用 Derived 类的 specificFunction 方法。</p>
<p><code>dynamic_cast</code>类型转换如何使用讲完了，接下来我们来看下 dynamic_cast类型转换的具体过程是怎样的？</p>
<h5 id="dynamic-cast的工作原理"><a href="#dynamic-cast的工作原理" class="headerlink" title="dynamic_cast的工作原理"></a>dynamic_cast的工作原理</h5><p><code>dynamic_cast</code>利用 C++ 的<code>运行时类型信息（RTTI）</code>机制来检查转换的安全性。它在运行时检查对象的实际类型，以确保所执行的转换是合法的。这种检查使得dynamic_cast比其他类型转换操作符（如static_cast或reinterpret_cast）更安全，但也带来了一定的性能开销。</p>
<p><strong>RTTI 是什么？</strong></p>
<p>C++的RTTI（Runtime Type Information，运行时类型信息）是一种机制，它允许C++程序在运行时查询和操作对象的类型信息。这种能力使得dynamic_cast能够在执行类型转换前，检查转换是否安全，从而确保类型转换的正确性和安全性。</p>
<p>dynamic_cast类型转换的具体过程？</p>
<p><strong>1. 确定对象的实际类型</strong></p>
<p><strong>访问虚函数表（vtable）</strong>：在C++中，每个具有虚函数的类的对象都会有一个隐藏的指针（称为虚表指针vptr），指向一个静态的虚函数表（vtable）。vtable主要用于支持多态性，即在运行时决定调用哪个虚函数。</p>
<p><strong>类型信息（RTTI）在vtable中</strong>：除了虚函数的地址外，vtable还包含了指向特定的类型信息的指针，这里说的类型信息就是RTTI。RTTI的核心是type_info类的对象，它为每个类提供了唯一的类型标识。</p>
<p><strong>2. 利用RTTI确定实际类型</strong>：</p>
<ul>
<li>当使用dynamic_cast进行类型转换时，C++运行时会查找原对象的vtable，通过其中的RTTI信息（即指向type_info对象的指针）来获取对象的实际类型。</li>
<li>一旦获得了对象的实际类型信息，dynamic_cast接着检查这个类型与目标类型的关系。对于向下转换（基类指针转换为派生类指针），它验证目标派生类是否确实是源对象实际类型的派生类或相同类型。</li>
</ul>
<p>在多态的使用场景中，上面提到的原对象指的是一个指向基类的指针或引用指向的对象。<br>目标派生类指的是我们希望将原对象的基类指针或引用转换到的目标类。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Base* basePtr = new Derived();</span><br><span class="line">Derived* derivedPtr = dynamic_cast&lt;Derived*&gt;(basePtr);</span><br></pre></td></tr></table></figure>
<p>对于上面的代码示例：原对象指的就是 basePtr 基类指针指向的 Derived 对象。目标派生类指的是 Derived 类。</p>
<p><strong>3.验证转换的合法性并执行转换或失败处理</strong></p>
<ul>
<li>如果转换合法，dynamic_cast修改源指针或引用，使其指向正确的目标类型的对象。</li>
<li>如果转换不合法：对于指针类型，dynamic_cast返回nullptr，表示转换失败。<br>对于引用类型，dynamic_cast 抛出 std::bad_cast 异常，因为引用不能为 nullptr。</li>
</ul>
<h4 id="4-重新解释类型转换-reinterpret-cast"><a href="#4-重新解释类型转换-reinterpret-cast" class="headerlink" title="4.重新解释类型转换 reinterpret_cast"></a>4.重新解释类型转换 reinterpret_cast</h4><p>reinterpret_cast是C++中一种强大但需谨慎使用的类型转换操作符。它允许开发者在几乎任何指针类型之间进行转换，也支持指针与足够大的整数类型之间的转换。其基本作用是重新解释数据的位模式，但不改变数据本身。</p>
<p>由于 reinterpret_cast 不进行类型检查和转换安全性保证，使用时需要特别注意，以防止未定义行为的发生。</p>
<h5 id="指针类型转换"><a href="#指针类型转换" class="headerlink" title="指针类型转换"></a>指针类型转换</h5><p>reinterpret_cast 可以用来将一个指针类型转换为另一个指针类型，即便这两个类型之间并无直接的关联。这种转换基本上是在告诉编译器：<strong>将内存地址当作另一种类型来解释，但不改变位模式本身</strong>。这种转换不会进行任何类型安全检查，因此非常危险且易于产生错误。因此在解引用转换后的指针之前，你需要确保转换是有意义的。</p>
<p>指针类型转换示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">char</span>* cp = &amp;c;</span><br><span class="line"><span class="comment">// 将char*转换为int*，虽然不安全，但可以编译通过</span></span><br><span class="line"><span class="type">int</span>* ip = reinterpret_cast&lt;<span class="type">int</span>*&gt;(cp);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;*ip&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 输出随机值</span></span><br></pre></td></tr></table></figure>
<h5 id="指针与整数类型之间的转换"><a href="#指针与整数类型之间的转换" class="headerlink" title="指针与整数类型之间的转换"></a>指针与整数类型之间的转换</h5><p>reinterpret_cast也可以用于将指针转换为整数类型，或者相反。这在需要在整数和指针之间进行转换，例如，当与需要整数参数的底层系统调用交互时非常有用。为了安全地执行这种转换，整数类型必须足够大以存储指针值，通常使用 uintptr_t 或 intptr_t。</p>
<p>示例代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdint&gt;</span>  <span class="comment">// 包含uintptr_t定义</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">42</span>;</span><br><span class="line">    <span class="comment">// 将int指针转换为整数</span></span><br><span class="line">    <span class="type">uintptr_t</span> ptrAsInt = reinterpret_cast&lt;<span class="type">uintptr_t</span>&gt;(&amp;a);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The pointer as integer: &quot;</span> &lt;&lt; ptrAsInt &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将整数转换回int指针</span></span><br><span class="line">    <span class="type">int</span>* aPtrAgain = reinterpret_cast&lt;<span class="type">int</span>*&gt;(ptrAsInt);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The integer as pointer: &quot;</span> &lt;&lt; *aPtrAgain &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>指针与整数类型之间的转换的使用场景</strong>：</p>
<ul>
<li><p><strong>系统级调用或API</strong>:<br>一些底层的系统调用或API可能要求使用整数类型的“句柄”来代表资源或对象。在这些情况下，如果资源或对象由C++管理，并通过指针访问，我们可以临时将指针转换为整数类型的句柄，进行调用，然后再转换回指针进行操作。</p>
</li>
<li><p><strong>回调函数与用户数据</strong>:<br>在使用回调函数时，通常需要提供一个指向用户数据的指针。如果回调函数的接口仅允许传递整数类型的用户数据，我们可以将指针转换为整数进行传递，然后在回调函数中再转换回指针，以访问实际的用户数据。</p>
</li>
</ul>
<p>示例代码：使用回调函数</p>
<p>假设我们有一个C++库，该库提供了一个设置回调函数的API，但API要求回调函数的用户数据必须是uintptr_t类型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdint&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyCallback</span><span class="params">(<span class="type">uintptr_t</span> userData)</span> &#123;</span><br><span class="line">    <span class="comment">// 在回调中将整数还原回指针</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span>* str = reinterpret_cast&lt;<span class="built_in">std</span>::<span class="built_in">string</span>*&gt;(userData);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *str &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">RegisterCallback</span><span class="params">(<span class="type">void</span>(*callback)(<span class="type">uintptr_t</span>), <span class="built_in">std</span>::<span class="built_in">string</span>* userData)</span> &#123;</span><br><span class="line">    <span class="comment">// 调用回调函数，将指针作为整数传递</span></span><br><span class="line">    callback(reinterpret_cast&lt;<span class="type">uintptr_t</span>&gt;(userData));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> myData = <span class="string">&quot;Hello, callback!&quot;</span>;</span><br><span class="line">    RegisterCallback(MyCallback, &amp;myData);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p>C++的模板是一种强大的编程特性，它允许程序员编写与类型无关的代码，也就是所谓的泛型编程。这使得我们可以编写一个通用的代码框架，它可以用于多种数据类型。使用模板可以大大提高代码的复用性和灵活性。</p>
<p>C++ 模板主要有两种形式：<strong>函数模板和类模板</strong></p>
<p>在讲解函数模板和类模板之前，我们先来了解下 <strong>模板参数</strong> ？</p>
<p>在 C++ 模板编程中，模板参数是定义模板时指定的一种占位符，它在模板实例化时被具体的类型或值所替代。模板参数使模板具有泛型，能够适应不同的数据类型或值。C++ 中的模板参数主要分为两类：<strong>类型参数和非类型参数</strong>。</p>
<h4 id="类型参数"><a href="#类型参数" class="headerlink" title="类型参数"></a>类型参数</h4><p>类型参数允许在模板定义时指定一些<strong>占位符</strong>类型，这些类型在模板实例化时被<strong>具体的类型</strong>所替代。这意味着你可以编写一个通用的模板，然后用不同的类型来实例化它，生成针对那些类型的特化版本。</p>
<p><strong>类型参数声明方式</strong>：使用关键字 typename 或 class 来声明。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">T <span class="title function_">max</span><span class="params">(T x, T y)</span> &#123;</span><br><span class="line">    <span class="comment">// 函数实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述示例中，<code>T</code>是一个类型参数，表示 max 函数的两个参数可以接受任何类型。</p>
<h4 id="非类型参数"><a href="#非类型参数" class="headerlink" title="非类型参数"></a>非类型参数</h4><p>非类型参数允许你将<strong>一个或多个常量值</strong>作为参数传递给模板。非类型参数必须是一个<strong>常量表达式</strong>，因为模板在编译时实例化。</p>
<p>下面来看类模板如何使用非类型参数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">template &lt;  T, <span class="type">size_t</span> N&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FixedArray</span> &#123;</span></span><br><span class="line">    T data[N]; <span class="comment">// N 是一个非类型参数</span></span><br><span class="line">public:</span><br><span class="line">    T&amp; operator[](<span class="type">size_t</span> index) &#123; <span class="keyword">return</span> data[index]; &#125;</span><br><span class="line">    <span class="type">const</span> T&amp; operator[](<span class="type">size_t</span> index) <span class="type">const</span> &#123; <span class="keyword">return</span> data[index]; &#125;</span><br><span class="line">    constexpr <span class="type">size_t</span> <span class="title function_">size</span><span class="params">()</span> <span class="type">const</span> &#123; <span class="keyword">return</span> N; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在这个示例中，N是一个非类型参数，它指定了FixedArray的大小。</p>
<p>非类型参数大多数使用在类模板中，虽然非类型参数在函数模板中的使用不如在类模板中那么频繁，但在某些情况下，它们仍然非常有用，特别是当你需要根据编译时常量来调整函数行为时。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T, <span class="type">int</span> increment&gt;</span><br><span class="line">T <span class="title function_">addIncrement</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value + increment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>addIncrement</code> 函数模板通过非类型参数 <code>increment</code> 允许在编译时确定增加的量，这可以在不同的调用中提供不同的增量值。</p>
<h4 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h4><p>函数模板允许我们创建一个函数原型，它可以用不同的数据类型来实例化。这意味着我们可以用一个函数模板来创建一系列执行相似操作的函数，而无需为每种数据类型编写重复的代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">T <span class="title function_">max</span><span class="params">(T x, T y)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; y ? x : y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>调用函数模板</strong></p>
<p><strong>1. 自动类型推导:</strong>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Max of &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; max(a, b) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line"></span><br><span class="line"><span class="type">double</span> c = <span class="number">3.5</span>, d = <span class="number">2.5</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Max of &quot;</span> &lt;&lt; c &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; d &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; max(c, d) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者这样调用：</span></span><br><span class="line">max(<span class="number">3</span>, <span class="number">5</span>)；</span><br></pre></td></tr></table></figure>

<p><strong>2. 显式指定模板参数类型</strong>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Max of 2 and 3 is &quot;</span> &lt;&lt; max&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">3</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Max of 2.5 and 3.5 is &quot;</span> &lt;&lt; max&lt;<span class="type">double</span>&gt;(<span class="number">2.5</span>, <span class="number">3.5</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>上面整型的调用，函数模板实际上会被实例化为一个接受两个 int 类型参数的函数版本：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; y ? x : y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而对于double类型的调用，函数模板会被实例化为一个接受两个 double 类型参数的函数版本。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">max</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; y ? x : y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h4><p>类模板与函数模板类似，允许我们定义一个类蓝图，用于生成处理不同数据类型的类。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    Box(T value) : value(value) &#123;&#125;</span><br><span class="line">    T <span class="title function_">getValue</span><span class="params">()</span> <span class="type">const</span> &#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">private:</span><br><span class="line">    T value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建类模板实例</span></span><br><span class="line">Box&lt;<span class="type">int</span>&gt; <span class="title function_">intBox</span><span class="params">(<span class="number">123</span>)</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Value in intBox: &quot;</span> &lt;&lt; intBox.getValue() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">Box&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title function_">stringBox</span><span class="params">(<span class="string">&quot;Hello Templates&quot;</span>)</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Value in stringBox: &quot;</span> &lt;&lt; stringBox.getValue() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>通过以上例子，我们了解了模板的基本使用，以及它是如何提高代码的复用性的。</p>
<p>上面的<code>max</code>函数模板的通用性确保了它可以用于整数、浮点数，甚至是字符串等多种类型，展现了模板编程的灵活性。然而，这种通用性有时候也是一把双刃剑。以指针类型为例，如果我们使用上述<code>max</code>函数比较两个指针，它实际上会比较指针的地址，而不是指针所指向的值，这可能并不是我们期望的行为。</p>
<p>在这种情况下，C++提供了一种强大的机制来优化和定制模板行为——<strong>模板特化</strong>。模板特化允许我们为特定的类型或值集合提供专门的实现，以此来处理那些需要特殊考虑的特定情况。模板特化分为两大类：<strong>全特化（Explicit Specialization）和偏特化（Partial Specialization）</strong>。</p>
<h4 id="全特化"><a href="#全特化" class="headerlink" title="全特化"></a>全特化</h4><p>全特化（Explicit Specialization）是为一个已有的模板定义提供一个特定版本的过程，这个特定版本适用于特定的类型或值。全特化意味着为模板的所有参数指定具体的类型或值。全特化不再是模板，而是对模板的一个特定实例提供了一个完全定制的实现。</p>
<h5 id="类模板全特化："><a href="#类模板全特化：" class="headerlink" title="类模板全特化："></a>类模板全特化：</h5><p>当你想为一个特定类型提供一个完全不同的类模板实现时，可以使用全特化。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt;&gt; <span class="comment">// 空尖括号代表全特化的声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span>&lt;</span>Type&gt; &#123;</span><br><span class="line">    <span class="comment">// 特化的实现</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span> <span class="comment">// 通用模板</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">function</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Generic MyClass\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>&lt;</span><span class="type">int</span>&gt; &#123; <span class="comment">// 全特化为int类型</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">function</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Specialized MyClass for int\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="函数模板全特化："><a href="#函数模板全特化：" class="headerlink" title="函数模板全特化："></a>函数模板全特化：</h5><p>与类模板相似，你也可以为特定类型提供特定的函数模板实现。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt;&gt;</span><br><span class="line">ReturnType functionName&lt;SpecificType&gt;(parameters) &#123;</span><br><span class="line">    <span class="comment">// 特化的实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>举一个函数模板全特化的例子，比如对于前面的<code>max</code>函数，我们想要对指针类型进行特化，使其比较指针所指向的值而不是指针地址：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">T <span class="title function_">max</span><span class="params">(T x, T y)</span> &#123; <span class="comment">// 通用模板</span></span><br><span class="line">    <span class="keyword">return</span> x &gt; y ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;&gt;   <span class="comment">//使用全特化</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* max&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(<span class="type">const</span> <span class="type">char</span>* a, <span class="type">const</span> <span class="type">char</span>* b) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(a, b) &gt; <span class="number">0</span> ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过这个例子，展示如何为特定类型（在这里是const char*类型的字符串）提供特化实现。</p>
<h4 id="偏特化"><a href="#偏特化" class="headerlink" title="偏特化"></a>偏特化</h4><p>偏特化允许你为模板的<strong>一部分参数</strong>提供具体的类型或值，而其余参数仍然保持泛型。<strong>偏特化仅适用于类模板，不能用于函数模板</strong>。通过偏特化，你可以对模板的部分参数施加约束，从而为特定的类型组合提供特定的实现。</p>
<p><strong>语法示例</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T, typename U&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span>&#125;; <span class="comment">// 通用模板</span></span><br><span class="line"></span><br><span class="line">template &lt;typename U&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>&lt;</span><span class="type">int</span>, U&gt; &#123;&#125;; <span class="comment">// 对第一个参数为int的偏特化</span></span><br></pre></td></tr></table></figure>

<p>代码示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">template&lt;typename T, typename U&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span> <span class="comment">// 原始模板</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">function</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Generic MyClass&lt;T, U&gt;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename U&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>&lt;</span><span class="type">int</span>, U&gt; &#123; <span class="comment">// 偏特化其中一个参数为int</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">function</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Partially Specialized MyClass&lt;int, U&gt;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    MyClass&lt;<span class="type">double</span>, <span class="type">double</span>&gt; myClass1; <span class="comment">// 将使用原始模板</span></span><br><span class="line">    myClass1.function();</span><br><span class="line">    MyClass&lt;<span class="type">int</span>, <span class="type">double</span>&gt; myClass2; <span class="comment">// 将使用偏特化模板</span></span><br><span class="line">    myClass2.function();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p>在C++中，内存管理是一个非常重要的概念，它关系到程序的性能和稳定性。C++提供了多种内存管理方式，包括<strong>自动、静态、动态分配</strong>等。让我们一步一步来了解。</p>
<p>为了更好地理解这些内存管理方式及其应用场景，我们首先需要了解C&#x2F;C++程序在运行时的内存布局。这里我介绍 Linux C&#x2F;C++ 程序的内存布局，因为大多数 C&#x2F;C++ 程序都是运行在 Linux 操作系统上，因此有必要了解下。</p>
<h4 id="Linux-C-C-程序的内存布局图示"><a href="#Linux-C-C-程序的内存布局图示" class="headerlink" title="Linux C&#x2F;C++ 程序的内存布局图示"></a>Linux C&#x2F;C++ 程序的内存布局图示</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://files.mdnice.com/user/48364/48290d63-a0e4-4242-9393-edb280609e52.png"></p>
<p>上图中，从下往上，地址是增加的，<code>0-3G</code>属于用户空间，<code>3G-4G</code> 属于内核空间.</p>
<p>接下来，我们对上面图示的各个区（段）作个详细的说明： </p>
<h4 id="内核空间（Kernel-Space）"><a href="#内核空间（Kernel-Space）" class="headerlink" title="内核空间（Kernel Space）"></a>内核空间（Kernel Space）</h4><p>Kernel space（内核空间）指的是操作系统内核所占用的内存区域。这部分内存是保留给操作系统内核的，用于执行核心的系统任务和硬件操作。出于安全和稳定性的考虑，用户程序通常无法直接访问这部分内存。在多数操作系统中，内核空间位于内存地址的高区域。在32位Linux系统上，通常最高的1GB内存（如地址从0xC0000000到0xFFFFFFFF）被保留给内核空间，而剩下的下3GB内存用于用户空间。</p>
<h4 id="用户空间（User-Space）"><a href="#用户空间（User-Space）" class="headerlink" title="用户空间（User Space）"></a>用户空间（User Space）</h4><ul>
<li><p><strong>栈（Stack）</strong></p>
<p>栈用于存放函数的局部变量、函数参数和返回地址。栈有着LIFO（后进先出）的特性，每当进入一个新的函数调用时，就会在栈上为其分配空间，函数返回时则释放这些空间。栈的大小通常有限，并且由操作系统预先定义。</p>
</li>
<li><p><strong>内存映射段(Memory Mapping Segment)</strong></p>
<p>内存映射段是一块可以被用来映射文件内容到进程地址空间的内存区域。这不仅包括用于动态库（如libc.so等）的映射，还包括程序运行时可能使用的任何匿名映射或文件映射。</p>
</li>
<li><p><strong>堆（Heap）</strong></p>
<p>堆用于动态内存分配，由new和delete（或malloc和free）控制。不同于栈，堆上的内存分配和释放是不自动的，需要程序员手动管理。堆的大小相对更灵活，受限于系统的可用内存。</p>
</li>
<li><p><strong>BSS段（Block Started by Symbol）</strong></p>
<p>BSS段，全称为“Block Started by Symbol”，主要用于存储程序中未初始化的全局变量和静态变量。与数据段（存放已初始化的全局变量和静态变量）相对，BSS段的特点是在程序启动之前，操作系统会自动将其内容初始化为零。这意味着，如果你在程序中声明了一个未初始化的全局或静态变量，它会被放在BSS段。</p>
</li>
<li><p><strong>数据区</strong></p>
<p>这部分内存用于存放全局变量和静态变量。不同于栈和堆上的变量，全局&#x2F;静态变量的生命周期贯穿整个程序运行期间，从程序开始执行时分配，到程序结束时才被释放。</p>
</li>
<li><p><strong>代码区</strong></p>
<p>存放程序的二进制代码，即编译后的机器指令。这部分内存是只读的。</p>
</li>
</ul>
<p>接下来，我们详细来聊下C++的多种内存管理方式，包括<strong>自动、静态、动态分配</strong>。</p>
<h4 id="常见的内存管理方式"><a href="#常见的内存管理方式" class="headerlink" title="常见的内存管理方式"></a>常见的内存管理方式</h4><h5 id="自动存储（Stack-Allocation）"><a href="#自动存储（Stack-Allocation）" class="headerlink" title="自动存储（Stack Allocation）"></a>自动存储（Stack Allocation）</h5><p>最简单的内存管理方式是自动存储，也就是在函数内部声明的局部变量。这些变量在函数被调用时自动分配内存（在栈上分配），并在函数返回时自动释放。</p>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">function</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> localVar = <span class="number">5</span>; <span class="comment">// 自动存储，函数结束时自动销毁</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="静态存储（Static-Allocation）"><a href="#静态存储（Static-Allocation）" class="headerlink" title="静态存储（Static Allocation）"></a>静态存储（Static Allocation）</h5><p>静态存储用于全局变量和静态变量，其生命周期贯穿整个程序运行期间。静态变量只被初始化一次，在首次加载时分配内存。</p>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">function</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> staticVar = <span class="number">5</span>; <span class="comment">// 静态存储，整个程序运行期间持续存在</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="动态存储（Dynamic-Allocation）"><a href="#动态存储（Dynamic-Allocation）" class="headerlink" title="动态存储（Dynamic Allocation）"></a>动态存储（Dynamic Allocation）</h5><p>动态存储是C++内存管理的核心，允许在运行时分配任意大小的内存。它使用<code>new</code>和<code>delete</code>操作符来手动管理内存。</p>
<p><strong>使用new和delete</strong></p>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = new <span class="type">int</span>; <span class="comment">// 动态分配一个int</span></span><br><span class="line">*ptr = <span class="number">5</span>; <span class="comment">// 给分配的int赋值</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *ptr &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 使用分配的内存</span></span><br><span class="line">delete ptr; <span class="comment">// 释放内存</span></span><br></pre></td></tr></table></figure>
<p><strong>使用new[]和delete[]管理数组</strong></p>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="built_in">array</span> = new <span class="type">int</span>[<span class="number">5</span>]; <span class="comment">// 动态分配一个有5个整数的数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">    <span class="built_in">array</span>[i] = i * i;</span><br><span class="line">&#125;</span><br><span class="line">delete[] <span class="built_in">array</span>; <span class="comment">// 释放数组</span></span><br></pre></td></tr></table></figure>

<p>现在大家已经了解了C++中的内存管理基础，接下来，我们将探讨如何更安全、更有效地管理资源。C++提供了一个强大的编程范式，称为RAII（资源获取即初始化）。</p>
<h4 id="RAII"><a href="#RAII" class="headerlink" title="RAII"></a>RAII</h4><p>“Resource Acquisition Is Initialization” (RAII) 是一种在C++中管理资源（如内存、文件句柄等）的编程模式。在RAII模式下，<strong>资源的分配（获取）发生在构造函数中，资源的释放（归还）发生在析构函数中</strong>。这种方式利用了C++自动调用析构函数的特性，确保了资源总是被正确释放，即使在面对异常情况时也不例外。</p>
<h4 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h4><p>通过<code>RAII</code>的介绍，我们已经认识到构造函数和析构函数在资源管理中的重要性。然而，在现实的编程实践中，尤其是面对复杂的资源管理需求时，单靠构造函数和析构函数可能不足以保证资源的安全和高效管理。这时，智能指针的概念应运而生。</p>
<p><code>智能指针</code>，实质上是一种行为类似于指针的对象，但它们包裹了原始指针，自动管理指向的资源。智能指针的核心理念正是基于<code>RAII模式</code>——通过对象的生命周期来管理资源。当智能指针的实例被创建时，它获取一个资源（比如动态分配的内存）；当智能指针实例销毁时，它释放那个资源。</p>
<p>C++11 标准库中提供了几种智能指针，如std::unique_ptr、std::shared_ptr和std::weak_ptr，但是我这里不讲解C++11 标准库的智能指针，而是重点讲解<code>boost</code>库里的智能指针。这两者的实现原理类似。后续会出一篇专门讲解 <code>C++11</code>新特性的文章。</p>
<p>在C++11之前，C++社区已经有一套成熟的解决方案来处理资源管理问题，那就是boost库提供的智能指针。</p>
<p>boost库是C++标准的实验田，很多在boost中实现的功能后来都被纳入了C++标准库。例如，C++11标准中的智能指针（std::shared_ptr和std::unique_ptr）、基于范围的for循环、无序容器等，都是从Boost库中借鉴或直接采用的。因此，可以说Boost对C++标准的发展有着重要的贡献。</p>
<h5 id="boost库智能指针有哪些？"><a href="#boost库智能指针有哪些？" class="headerlink" title="boost库智能指针有哪些？"></a>boost库智能指针有哪些？</h5><p><strong>1. boost::scoped_ptr</strong></p>
<p><code>boost::scoped_ptr</code>是一种简单的智能指针，用于管理在作用域内分配的对象。它不能传递所有权，即不能从一个<code>scoped_ptr</code>拷贝或赋值给另一个<code>scoped_ptr</code>。当<code>scoped_ptr</code>离开作用域时，它所管理的对象会被自动销毁。</p>
<p>使用示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/scoped_ptr.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    MyClass() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;MyClass constructed\n&quot;</span>; &#125;</span><br><span class="line">    ~MyClass() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;MyClass destroyed\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    boost::scoped_ptr&lt;MyClass&gt; <span class="title function_">ptr</span><span class="params">(new MyClass)</span>;</span><br><span class="line">    <span class="comment">// ptr在这里可用</span></span><br><span class="line">&#125; <span class="comment">// ptr离开作用域，自动销毁MyClass实例</span></span><br></pre></td></tr></table></figure>
<p><strong>2. boost::shared_ptr</strong></p>
<p><code>boost::shared_ptr</code>是一种引用计数的智能指针，也称共享型智能指针，允许多个<code>shared_ptr</code>实例共享同一个对象的所有权。当最后一个引用（shared_ptr实例）被销毁或重新指向另一个对象时，所管理的对象会被自动释放。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/shared_ptr.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    MyClass() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;MyClass constructed\n&quot;</span>; &#125;</span><br><span class="line">    ~MyClass() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;MyClass destroyed\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    boost::<span class="built_in">shared_ptr</span>&lt;MyClass&gt; <span class="title function_">ptr1</span><span class="params">(new MyClass)</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        boost::<span class="built_in">shared_ptr</span>&lt;MyClass&gt; ptr2 = ptr1; <span class="comment">// ptr1和ptr2共享对象</span></span><br><span class="line">    &#125; <span class="comment">// ptr2离开作用域，对象不会被销毁，因为ptr1仍然存在，引用计数不为0</span></span><br><span class="line">&#125; <span class="comment">// ptr1离开作用域，对象被销毁（引用计数为0）</span></span><br></pre></td></tr></table></figure>
<p>对于上面提到的<code>引用计数</code>，大家可以简单理解为一个<code>非负整型数值</code>.</p>
<p><strong>3. boost::weak_ptr</strong></p>
<p><code>boost::weak_ptr</code>专门设计用于与<code>boost::shared_ptr</code>协同工作，解决潜在的循环引用问题。循环引用发生在两个或多个对象通过<code>shared_ptr</code>相互引用时，导致它们的引用计数永远不会归零，进而导致内存泄漏。<code>weak_ptr</code>提供了一种机制，允许对这些对象进行观察，而不增加引用计数。</p>
<p><strong>weak_ptr的几个特性</strong>：</p>
<ul>
<li><strong>观察者</strong>：boost::weak_ptr是对boost::shared_ptr所管理对象的非拥有性引用（观察者）。它允许你访问对象，但不会延长对象的生命周期。</li>
<li><strong>临时升级</strong>：虽然weak_ptr本身不能直接访问对象，但它可以被临时升级为一个shared_ptr（如果对象仍然存在），以安全地访问对象。</li>
<li><strong>解决循环引用</strong>：在使用shared_ptr管理相互引用的对象时，容易产生循环引用，导致对象无法被释放。weak_ptr不参与引用计数，因此可以打破这种循环，避免内存泄漏。</li>
</ul>
<p><strong>weak_ptr基本用法</strong>：</p>
<p><strong>1. 创建weak_ptr</strong></p>
<p>weak_ptr通常通过与一个shared_ptr关联来创建：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">boost::<span class="built_in">shared_ptr</span>&lt;<span class="type">int</span>&gt; <span class="title function_">sp</span><span class="params">(new <span class="type">int</span>(<span class="number">42</span>))</span>; <span class="comment">// 创建shared_ptr</span></span><br><span class="line">boost::weak_ptr&lt;<span class="type">int</span>&gt; <span class="title function_">wp</span><span class="params">(sp)</span>;            <span class="comment">// 通过shared_ptr创建weak_ptr</span></span><br></pre></td></tr></table></figure>
<p><strong>2. 使用weak_ptr</strong></p>
<p>要访问 weak_ptr 所观察的对象，需要将它临时升级为shared_ptr，这可以通过调用weak_ptr的lock方法实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">boost::<span class="built_in">shared_ptr</span>&lt;<span class="type">int</span>&gt; sp = wp.lock(); <span class="comment">// 尝试将weak_ptr升级为shared_ptr</span></span><br><span class="line"><span class="keyword">if</span> (sp) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *sp &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 安全使用</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;对象已被销毁&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3. 解决循环引用示例</strong></p>
<p>考虑两个类ClassA和ClassB，它们通过shared_ptr相互持有对方：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/shared_ptr.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassB</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassA</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    boost::<span class="built_in">shared_ptr</span>&lt;ClassB&gt; bPtr;</span><br><span class="line">    ~ClassA() &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ClassA destroyed\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassB</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    boost::<span class="built_in">shared_ptr</span>&lt;ClassA&gt; aPtr;</span><br><span class="line">    ~ClassB() &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ClassB destroyed\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    boost::<span class="built_in">shared_ptr</span>&lt;ClassA&gt; <span class="title function_">a</span><span class="params">(new ClassA())</span>;</span><br><span class="line">    boost::<span class="built_in">shared_ptr</span>&lt;ClassB&gt; <span class="title function_">b</span><span class="params">(new ClassB())</span>;</span><br><span class="line"></span><br><span class="line">    a-&gt;bPtr = b; <span class="comment">// a持有b的shared_ptr</span></span><br><span class="line">    b-&gt;aPtr = a; <span class="comment">// b持有a的shared_ptr，形成循环引用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，main 函数中创建了两个shared_ptr对象a和b，分别指向 ClassA 和ClassB 的新实例。然后，我们通过 a-&gt;bPtr &#x3D; b;和b-&gt;aPtr &#x3D; a;让这两个实例相互持有对方，从而创建了循环引用。</p>
<p>由于存在循环引用，当 main 函数执行完毕，尽管a和b的作用域结束，它们应该被销毁，但 ClassA 和 ClassB 的实例的引用计数并没有降到零（因为它们相互引用），导致析构函数没有被调用，从而引发内存泄漏。</p>
<p>如何解决？使用<code>weak_ptr</code>可以解决这个问题：</p>
<p>可以将其中一个类的shared_ptr成员改为weak_ptr。这样做可以打破循环引用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassB</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassA</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="comment">// 使用weak_ptr代替shared_ptr</span></span><br><span class="line">    boost::weak_ptr&lt;ClassB&gt; bPtr;</span><br><span class="line">    ~ClassA() &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ClassA destroyed\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassB</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">    boost::<span class="built_in">shared_ptr</span>&lt;ClassA&gt; aPtr;</span><br><span class="line">    ~ClassB() &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ClassB destroyed\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    boost::<span class="built_in">shared_ptr</span>&lt;ClassA&gt; <span class="title function_">a</span><span class="params">(new ClassA())</span>;</span><br><span class="line">    boost::<span class="built_in">shared_ptr</span>&lt;ClassB&gt; <span class="title function_">b</span><span class="params">(new ClassB())</span>;</span><br><span class="line"></span><br><span class="line">    a-&gt;bPtr = b; <span class="comment">// ClassA中持有ClassB的弱引用</span></span><br><span class="line">    b-&gt;aPtr = a; <span class="comment">// ClassB中持有ClassA的强引用，形成非对称的引用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当main结束时，a和b的shared_ptr都会被销毁。</span></span><br><span class="line">    <span class="comment">// b的shared_ptr被销毁时，由于ClassA中持有的是ClassB的weak_ptr，不会阻止ClassB对象的销毁。</span></span><br><span class="line">    <span class="comment">// 因此，ClassB被销毁后，ClassA中的weak_ptr变为悬挂指针，但ClassA对象也会随之被安全销毁。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里大家只需要掌握这几种智能指针的简单使用即可，后面笔者有计划写一篇关于智能指针实现原理的文章，从源码实现的角度来讲解。帮助大家更好的理解智能指针。</p>
<h4 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h4><p>在C++中，内存泄漏是指程序分配的内存没有被正确释放，导致程序不再能够使用那部分内存。内存泄漏在长时间运行的程序中尤为危险，因为它们会逐渐消耗掉所有可用的内存资源，可能导致程序崩溃或系统变得缓慢。</p>
<h5 id="内存泄露的原因："><a href="#内存泄露的原因：" class="headerlink" title="内存泄露的原因："></a>内存泄露的原因：</h5><p>在C++中，内存泄露通常由以下几个原因引起：</p>
<ul>
<li><strong>动态分配内存未释放</strong>：使用new或malloc等分配内存后，未使用delete或free释放。</li>
<li><strong>资源未释放</strong>：除了内存外，文件句柄、数据库连接等资源未被关闭或释放也会造成资源泄露。</li>
<li><strong>循环引用</strong>：使用智能指针（如std::shared_ptr）时，不当的循环引用会导致对象无法被自动销毁。</li>
<li><strong>异常安全性问题</strong>：<br>当函数或方法在执行过程中抛出异常，而这个函数或方法之前进行了资源分配（如动态内存分配），如果没有正确地处理异常（例如通过异常安全的智能指针或try&#x2F;catch块来确保资源被释放），那么原本应该在函数结束时释放的资源可能会因为异常的抛出而遗漏。</li>
</ul>
<h5 id="内存泄露的检测："><a href="#内存泄露的检测：" class="headerlink" title="内存泄露的检测："></a>内存泄露的检测：</h5><p>检测内存泄露通常可以通过以下几种方式：</p>
<p><strong>1. 代码审查</strong>：通过审查代码逻辑，检查每次new的内存分配是否都有对应的delete释放。</p>
<p><strong>2. 运行时工具</strong>：</p>
<ul>
<li><p>Valgrind：Linux下一个强大的内存检测工具，能够检测出内存泄露、内存越界等问题。Valgrind的优点在于它不需要对程序进行重新编译，适用于几乎所有的二进制文件，但缺点是运行速度较慢，通常会让程序的执行速度降低10倍以上。</p>
</li>
<li><p>AddressSanitizer：一个快速的内存错误检测工具，能够检测出包括内存越界访问、使用后释放、堆栈缓冲区溢出等问题。与Valgrind相比，ASan的主要优点是执行速度快（一般只会让程序变慢2倍左右）和提供精确的错误信息，但它需要对程序进行重新编译并链接，并且增加了程序的内存需求。</p>
</li>
</ul>
<h5 id="如何避免内存泄漏？"><a href="#如何避免内存泄漏？" class="headerlink" title="如何避免内存泄漏？"></a>如何避免内存泄漏？</h5><p><strong>1. 限制动态内存的使用</strong></p>
<p>尽量减少动态内存分配的使用。许多情况下，可以通过使用栈分配的变量或标准容器来代替动态分配的内存。这不仅可以减少内存泄漏的风险，还可以提高程序的性能。</p>
<p><strong>2. 使用智能指针</strong>：尽量避免在代码中直接使用裸指针管理动态分配的内存。裸指针很容易导致内存泄漏，因为它们不会自动释放所指向的内存。如果确实需要使用指针，考虑使用<code>智能指针</code>来代替。</p>
<p><strong>3. 使用容器类</strong>：C++标准库提供了多种容器，如std::vector、std::list等，这些容器在内部管理内存，可以减少直接使用动态内存分配的需要。</p>
<p><strong>4. 使用对象池</strong>：<br>对于频繁创建和销毁的小对象，使用对象池可以是一个有效的解决方案。对象池预先分配一定数量的对象，并在需要时重用它们，从而避免了频繁的动态内存分配和释放。</p>
<p><strong>5. 定期检查和测试</strong>：使用内存检测工具定期检查程序，及早发现并修复内存泄漏问题。</p>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>C++中的异常处理是通过<code>try</code>、<code>catch</code>、<code>throw</code>关键字实现的，旨在处理程序运行时可能出现的错误和异常情况。使用异常处理可以使错误处理代码和正常业务逻辑分离，使程序结构更清晰，更易于维护。</p>
<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul>
<li><strong>throw</strong>：当检测到错误条件时，程序可以通过throw关键字抛出一个异常。抛出的异常可以是预定义的数据类型，也可以是自定义类型。</li>
<li><strong>try</strong>：try块包含可能抛出异常的代码。如果在try块中的代码抛出了异常，执行将跳转到相应的catch块。</li>
<li><strong>catch</strong>：catch块用于捕获和处理异常。可以定义多个catch块来捕获不同类型的异常。</li>
</ul>
<h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><p>下面是一个简单的示例，演示了如何使用C++的异常处理机制：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">divide</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">        throw <span class="string">&quot;Division by zero error&quot;</span>; <span class="comment">// 抛出异常</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; divide(<span class="number">10</span>, <span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 正常情况</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; divide(<span class="number">10</span>, <span class="number">0</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 这里将抛出异常</span></span><br><span class="line">    &#125; catch (<span class="type">const</span> <span class="type">char</span>* msg) &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Error: &quot;</span> &lt;&lt; msg &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 捕获并处理异常</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，divide函数在除数为零时抛出一个异常，main函数中的 try 块捕获并处理了这个异常。</p>
<h4 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h4><p>除了使用预定义类型作为异常外，C++还允许定义自定义异常类。通过继承标准的<code>exception</code>类来创建自定义异常更为方便：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义异常类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyException</span> :</span> public exception &#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* <span class="title function_">what</span><span class="params">()</span> <span class="type">const</span> <span class="title function_">throw</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Custom error occurred&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        throw MyException();</span><br><span class="line">    &#125; catch (MyException&amp; e) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;MyException caught&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; e.what() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; catch (exception&amp; e) &#123;</span><br><span class="line">        <span class="comment">// 其他所有的异常</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，我们定义了一个名为MyException的自定义异常类，并在main函数中抛出和捕获了这个异常。自定义异常类通过覆写 what 方法提供了异常的描述信息。</p>
<p>通过合理使用C++的异常处理机制，可以有效地管理程序中的错误情况，提高程序的健壮性和可读性。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章旨在提供一个关于C++语言学习的指南，以帮助初学者系统地掌握C++编程的关键技能和概念。通过深入浅出的方式，我们逐步解析了C++开发的各个方面，从基础的数据类型、函数使用，到高级的面向对象编程技术，如类和对象的操作、封装、继承、以及多态等。</p>
<ul>
<li><p><strong>数据类型和函数</strong>：我们探讨了C++的基本数据类型、枚举、复合以及派生数据类型，这为理解C++提供了坚实的基础。同时，函数的定义、声明、调用以及参数传递等知识点，构建了函数编程的框架。</p>
</li>
<li><p><strong>面向对象编程</strong>：详细讨论了类和对象的定义、成员变量和函数、构造函数和析构函数等概念，强调了封装、继承和多态这三大面向对象编程的核心特性。特别地，通过this指针、友元、运算符重载的讲解，进一步拓展了面向对象的编程思维。</p>
</li>
<li><p><strong>高级特性</strong>：深入到模板编程，介绍了类型参数、非类型参数、函数模板、类模板以及模板的特化，这些内容展现了C++泛型编程的强大能力。同时，对C++中的内存管理、异常处理进行了探讨，了解了怎样编写高效且安全的C++代码。</p>
</li>
</ul>
<p>这篇文章主要是给大家提供一个如何快速学习 C++ 的指南，不知道怎样学习 C++ 的朋友可以 <strong>按照我列的知识点去看书，去实践，掌握 C++ 语言应该会很快的。记住：一定要多敲代码，多实践！！</strong></p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>如果单纯去学习C、C++语言是干不了任何事情的，作为与硬件和操作系统打交道的计算机底层语言，要想掌握 C和C++，你还得学习这几门课程：计算机组成原理、操作系统、数据结构。甚至还得了解汇编语言。除此之外，还需要学习 Linux 系统编程以及网络编程相关知识。</p>
<p>如果你想学习 Linux 编程，包括系统编程和网络编程相关的内容，可以关注我的公众号「<strong>跟着小康学编程</strong>」，微信搜索<strong>跟着小康学编程</strong>或者扫描下方二维码关注 。这里会定时更新 计算机编程 相关的技术文章，感兴趣的读者可以关注一下。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/%E8%81%94%E7%B3%BB%E6%88%91/xkvxgzh.png">   </p>
<p>另外：C&#x2F;C++、Java、Go语言，计算机组成原理、操作系统、数据结构与算法、计算机网络以及Linux 系统编程和网络编程、数据库等经典书籍的电子档 pdf 我已经为大家整理好了，想要获取的同学可以关注我的公众号「<strong>跟着小康学编程</strong>」，然后后台回复：<strong>pdf</strong>，即可获取。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">小康</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/how-to-learn-C++/">http://example.com/how-to-learn-C++/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">跟着小康学编程</a>！</span></div></div><!-- 添加赞赏二维码--><div class="reward-container" style="text-align: center; margin-top: 20px;"><div class="reward-item" style="display: inline-block; margin: 10px;"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/wechat.jpg" alt="请作者喝咖啡" style="width: 150px; height: 150px;"><div>请作者喝咖啡</div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C-%E5%85%A5%E9%97%A8/">C++入门</a><a class="post-meta__tags" href="/tags/C-%E6%95%99%E7%A8%8B/">C++教程</a><a class="post-meta__tags" href="/tags/C-%E5%BF%AB%E9%80%9F%E5%AD%A6%E4%B9%A0/">C++快速学习</a></div><div class="post_share"><div class="social-share" data-image="/img/me.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/SetupLinuxEnv/" title="手把手教你搭建 Linux C/C++ 编程环境"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">手把手教你搭建 Linux C/C++ 编程环境</div></div></a></div><div class="next-post pull-right"><a href="/C++11/" title="深入 C++11：从 auto 到 Lambda，解锁现代 C++ 的强大功能"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">深入 C++11：从 auto 到 Lambda，解锁现代 C++ 的强大功能</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/me.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">小康</div><div class="author-info__description">程序猿一枚，也是一名编程狂热者</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">16</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">51</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">20</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://xiaokang2024.github.io/xiaokangvx/"><i class="fab fa-weixin"></i><span>关注跟着小康学编程</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://xiaokang2024.github.io/images/xiaokanggzh.png" target="_blank" title="&quot;微信公众号&quot;"><i class="iconfont icon-weixingongzhonghao" style="color: #07C160;"></i></a><a class="social-icon" href="https://xiaokang2024.github.io/images/xiaokang-weixin.png" target="_blank" title="&quot;WeChat&quot;"><i class="iconfont icon-weixin" style="color: #1aad19;"></i></a><a class="social-icon" href="https://www.zhihu.com/people/jkhenryer" target="_blank" title="&quot;知乎&quot;"><i class="iconfont icon-zhihu" style="color: #0084ff;"></i></a><a class="social-icon" href="https://github.com/xiaokang2024" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎访问我的编程学习网站！关注我的微信公众号「跟着小康学编程」，不错过任何更新和独家内容！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E8%A8%80%EF%BC%9A"><span class="toc-number">1.</span> <span class="toc-text">引言：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number"></span> <span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.</span> <span class="toc-text">基本数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">枚举类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.</span> <span class="toc-text">复合数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93-struct"><span class="toc-number">3.1.</span> <span class="toc-text">结构体 (struct)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%81%94%E5%90%88%E4%BD%93%EF%BC%88union%EF%BC%89"><span class="toc-number">3.2.</span> <span class="toc-text">联合体（union）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB-class"><span class="toc-number">3.3.</span> <span class="toc-text">类 (class)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B4%BE%E7%94%9F%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.</span> <span class="toc-text">派生数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">4.1.</span> <span class="toc-text">数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88%EF%BC%9A"><span class="toc-number">4.2.</span> <span class="toc-text">指针：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%EF%BC%9A"><span class="toc-number">4.3.</span> <span class="toc-text">引用：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%EF%BC%9A"><span class="toc-number">4.3.1.</span> <span class="toc-text">引用的基本用法：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%9A%84%E7%89%B9%E6%80%A7%EF%BC%9A"><span class="toc-number">4.3.2.</span> <span class="toc-text">引用的特性：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%9A%84%E7%94%A8%E9%80%94%EF%BC%9A"><span class="toc-number">4.3.3.</span> <span class="toc-text">引用的用途：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number"></span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89"><span class="toc-number">1.</span> <span class="toc-text">函数定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%EF%BC%88%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%EF%BC%89"><span class="toc-number">2.</span> <span class="toc-text">函数声明（函数原型）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="toc-number">3.</span> <span class="toc-text">函数调用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">3.1.</span> <span class="toc-text">函数调用方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="toc-number">4.</span> <span class="toc-text">参数传递</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%EF%BC%9A"><span class="toc-number">4.1.</span> <span class="toc-text">代码示例：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-number">5.</span> <span class="toc-text">函数重载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%EF%BC%9A-1"><span class="toc-number">5.1.</span> <span class="toc-text">代码示例：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B0"><span class="toc-number">6.</span> <span class="toc-text">特殊函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">6.1.</span> <span class="toc-text">成员函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">6.2.</span> <span class="toc-text">常量成员函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B"><span class="toc-number"></span> <span class="toc-text">面向对象编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.</span> <span class="toc-text">类和对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89%EF%BC%9A"><span class="toc-number">1.1.</span> <span class="toc-text">类的定义：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%EF%BC%9A"><span class="toc-number">1.2.</span> <span class="toc-text">成员的访问权限：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="toc-number">1.3.</span> <span class="toc-text">成员访问权限有什么用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.</span> <span class="toc-text">成员变量和成员函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.</span> <span class="toc-text">构造函数和析构函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%EF%BC%9A"><span class="toc-number">1.6.</span> <span class="toc-text">对象的创建：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#this%E6%8C%87%E9%92%88"><span class="toc-number">1.7.</span> <span class="toc-text">this指针</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.7.1.</span> <span class="toc-text">底层实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-number">2.</span> <span class="toc-text">封装</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%81%E8%A3%85%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.1.</span> <span class="toc-text">封装的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%81%E8%A3%85%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">2.2.</span> <span class="toc-text">封装的优势</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">3.</span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">3.1.</span> <span class="toc-text">继承的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">3.2.</span> <span class="toc-text">继承的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%95%E4%B8%80%E7%BB%A7%E6%89%BF"><span class="toc-number">3.2.1.</span> <span class="toc-text">单一继承</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="toc-number">3.2.2.</span> <span class="toc-text">多重继承</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8B%E5%85%83"><span class="toc-number">4.</span> <span class="toc-text">友元</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0"><span class="toc-number">4.1.</span> <span class="toc-text">友元函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8B%E5%85%83%E7%B1%BB"><span class="toc-number">4.2.</span> <span class="toc-text">友元类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8B%E5%85%83%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">4.3.</span> <span class="toc-text">友元成员函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">4.4.</span> <span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">5.</span> <span class="toc-text">运算符重载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">5.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">5.2.</span> <span class="toc-text">运算符重载的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">5.2.1.</span> <span class="toc-text">成员函数运算符重载</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">5.2.2.</span> <span class="toc-text">非成员函数运算符重载</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">6.</span> <span class="toc-text">多态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E5%88%86%E7%B1%BB%EF%BC%9A"><span class="toc-number">6.1.</span> <span class="toc-text">多态的分类：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%A4%9A%E6%80%81%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9A"><span class="toc-number">6.2.</span> <span class="toc-text">运行时多态的实现：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">6.3.</span> <span class="toc-text">纯虚函数和抽象类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">6.3.1.</span> <span class="toc-text">纯虚函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">6.3.2.</span> <span class="toc-text">抽象类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E5%92%8C%E9%9A%90%E8%97%8F"><span class="toc-number">7.</span> <span class="toc-text">覆盖和隐藏</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%A6%86%E7%9B%96%EF%BC%88Function-Overriding%EF%BC%89"><span class="toc-number">7.1.</span> <span class="toc-text">函数覆盖（Function Overriding）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%9A%90%E8%97%8F%EF%BC%88Function-Hiding%EF%BC%89"><span class="toc-number">7.2.</span> <span class="toc-text">函数隐藏（Function Hiding）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">8.</span> <span class="toc-text">类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%88static-cast%EF%BC%89"><span class="toc-number">8.1.</span> <span class="toc-text">1. 静态类型转换（static_cast）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%B8%B8%E9%87%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%88const-cast%EF%BC%89"><span class="toc-number">8.2.</span> <span class="toc-text">2. 常量类型转换（const_cast）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%88dynamic-cast%EF%BC%89"><span class="toc-number">8.3.</span> <span class="toc-text">3. 动态类型转换（dynamic_cast）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#dynamic-cast%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">8.3.1.</span> <span class="toc-text">dynamic_cast的工作原理</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E9%87%8D%E6%96%B0%E8%A7%A3%E9%87%8A%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-reinterpret-cast"><span class="toc-number">8.4.</span> <span class="toc-text">4.重新解释类型转换 reinterpret_cast</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">8.4.1.</span> <span class="toc-text">指针类型转换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E4%B8%8E%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">8.4.2.</span> <span class="toc-text">指针与整数类型之间的转换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF"><span class="toc-number">9.</span> <span class="toc-text">模板</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0"><span class="toc-number">9.1.</span> <span class="toc-text">类型参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0"><span class="toc-number">9.2.</span> <span class="toc-text">非类型参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="toc-number">9.3.</span> <span class="toc-text">函数模板</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="toc-number">9.4.</span> <span class="toc-text">类模板</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E7%89%B9%E5%8C%96"><span class="toc-number">9.5.</span> <span class="toc-text">全特化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E5%85%A8%E7%89%B9%E5%8C%96%EF%BC%9A"><span class="toc-number">9.5.1.</span> <span class="toc-text">类模板全特化：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E5%85%A8%E7%89%B9%E5%8C%96%EF%BC%9A"><span class="toc-number">9.5.2.</span> <span class="toc-text">函数模板全特化：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%8F%E7%89%B9%E5%8C%96"><span class="toc-number">9.6.</span> <span class="toc-text">偏特化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">10.</span> <span class="toc-text">内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Linux-C-C-%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E5%9B%BE%E7%A4%BA"><span class="toc-number">10.1.</span> <span class="toc-text">Linux C&#x2F;C++ 程序的内存布局图示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4%EF%BC%88Kernel-Space%EF%BC%89"><span class="toc-number">10.2.</span> <span class="toc-text">内核空间（Kernel Space）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%EF%BC%88User-Space%EF%BC%89"><span class="toc-number">10.3.</span> <span class="toc-text">用户空间（User Space）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">10.4.</span> <span class="toc-text">常见的内存管理方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%AD%98%E5%82%A8%EF%BC%88Stack-Allocation%EF%BC%89"><span class="toc-number">10.4.1.</span> <span class="toc-text">自动存储（Stack Allocation）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%AD%98%E5%82%A8%EF%BC%88Static-Allocation%EF%BC%89"><span class="toc-number">10.4.2.</span> <span class="toc-text">静态存储（Static Allocation）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%AD%98%E5%82%A8%EF%BC%88Dynamic-Allocation%EF%BC%89"><span class="toc-number">10.4.3.</span> <span class="toc-text">动态存储（Dynamic Allocation）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RAII"><span class="toc-number">10.5.</span> <span class="toc-text">RAII</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">10.6.</span> <span class="toc-text">智能指针</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#boost%E5%BA%93%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">10.6.1.</span> <span class="toc-text">boost库智能指针有哪些？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">10.7.</span> <span class="toc-text">内存泄漏</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%9A"><span class="toc-number">10.7.1.</span> <span class="toc-text">内存泄露的原因：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E7%9A%84%E6%A3%80%E6%B5%8B%EF%BC%9A"><span class="toc-number">10.7.2.</span> <span class="toc-text">内存泄露的检测：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%9F"><span class="toc-number">10.7.3.</span> <span class="toc-text">如何避免内存泄漏？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">11.</span> <span class="toc-text">异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">11.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="toc-number">11.2.</span> <span class="toc-text">示例代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8"><span class="toc-number">11.3.</span> <span class="toc-text">自定义异常</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number"></span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%90%8E"><span class="toc-number"></span> <span class="toc-text">最后</span></a></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/httpMethod/" title="HTTP 面试题 —— HTTP有哪些请求方式？">HTTP 面试题 —— HTTP有哪些请求方式？</a><time datetime="2024-07-08T01:51:17.750Z" title="发表于 2024-07-08 09:51:17">2024-07-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/RedisCluster/" title="Redis 架构解析：从主从复制到哨兵和集群模式">Redis 架构解析：从主从复制到哨兵和集群模式</a><time datetime="2024-04-30T06:29:21.248Z" title="发表于 2024-04-30 14:29:21">2024-04-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/RedisPersistence/" title="全面解析 Redis 持久化：RDB、AOF与混合持久化">全面解析 Redis 持久化：RDB、AOF与混合持久化</a><time datetime="2024-04-30T03:34:53.707Z" title="发表于 2024-04-30 11:34:53">2024-04-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/RedisObject/" title="Redis入门指南：掌握常见数据类型">Redis入门指南：掌握常见数据类型</a><time datetime="2024-04-30T01:51:28.581Z" title="发表于 2024-04-30 09:51:28">2024-04-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/LinuxCmd/" title="Linux 命令入门指南：快速掌握基础命令">Linux 命令入门指南：快速掌握基础命令</a><time datetime="2024-04-29T03:16:29.040Z" title="发表于 2024-04-29 11:16:29">2024-04-29</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 小康</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.8.8/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'yNXYnuxkePack1IfO9FTTxA9-gzGzoHsz',
      appKey: 'bs6gdkXWDYvN826BUX5Xl53U',
      avatar: 'monsterid',
      serverURLs: 'https://ynxynuxk.lc-cn-n1-shared.com',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: true
    }, null))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await getScript('https://cdn.jsdelivr.net/npm/valine@1.5.1/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Valine' === 'Valine' || !true) {
    if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script></div><script src="/js/wechat.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>